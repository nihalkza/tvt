{"version":3,"file":"static/js/main.187a5bfd.js","mappings":"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C,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CAAC,MAAO,MACpE,CAAC,MAAO,MAAO,CAAC,MAAO,MAAO,CA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","sources":["../node_modules/react-dom/cjs/react-dom.production.min.js","../node_modules/react-dom/client.js","../node_modules/react-dom/index.js","../node_modules/react/cjs/react-jsx-runtime.production.min.js","../node_modules/react/cjs/react.production.min.js","../node_modules/react/index.js","../node_modules/react/jsx-runtime.js","../node_modules/scheduler/cjs/scheduler.production.min.js","../node_modules/scheduler/index.js","../../node_modules/eme-encryption-scheme-polyfill/index.js","../../node_modules/google-closure-library/closure/goog/base.js","com/google/javascript/jscomp/js/es6/util/arrayiterator.js","com/google/javascript/jscomp/js/util/defineproperty.js","com/google/javascript/jscomp/js/util/global.js","com/google/javascript/jscomp/js/util/polyfill.js","com/google/javascript/jscomp/js/es6/symbol.js","com/google/javascript/jscomp/js/es6/util/makeiterator.js","com/google/javascript/jscomp/js/es6/util/arrayfromiterable.js","com/google/javascript/jscomp/js/es6/util/arrayfromiterator.js","com/google/javascript/jscomp/js/util/objectcreate.js","com/google/javascript/jscomp/js/es6/util/setprototypeof.js","com/google/javascript/jscomp/js/es6/util/inherits.js","com/google/javascript/jscomp/js/es6/generator_engine.js","../node_modules/shaka-player/lib/offline/offline_manifest_parser.js","com/google/javascript/jscomp/js/es6/execute_async_generator.js","com/google/javascript/jscomp/js/es6/util/restarguments.js","com/google/javascript/jscomp/js/util/owns.js","com/google/javascript/jscomp/js/util/findinternal.js","com/google/javascript/jscomp/js/util/checkstringargs.js","com/google/javascript/jscomp/js/es6/util/iteratorfromarray.js","com/google/javascript/jscomp/js/es6/promise/promise.js","com/google/javascript/jscomp/js/es6/weakmap.js","com/google/javascript/jscomp/js/es6/map.js","com/google/javascript/jscomp/js/es6/set.js","com/google/javascript/jscomp/js/es6/array/findindex.js","com/google/javascript/jscomp/js/es6/object/is.js","com/google/javascript/jscomp/js/es6/array/includes.js","com/google/javascript/jscomp/js/es6/string/includes.js","com/google/javascript/jscomp/js/es6/array/find.js","com/google/javascript/jscomp/js/es6/string/startswith.js","com/google/javascript/jscomp/js/es6/array/keys.js","com/google/javascript/jscomp/js/es6/util/assign.js","com/google/javascript/jscomp/js/es6/object/assign.js","com/google/javascript/jscomp/js/es6/array/from.js","com/google/javascript/jscomp/js/es6/array/values.js","com/google/javascript/jscomp/js/es6/promise/finally.js","com/google/javascript/jscomp/js/es6/array/entries.js","com/google/javascript/jscomp/js/es6/string/repeat.js","com/google/javascript/jscomp/js/es6/number/isnan.js","com/google/javascript/jscomp/js/es6/object/values.js","com/google/javascript/jscomp/js/es6/math/log2.js","com/google/javascript/jscomp/js/es6/math/trunc.js","com/google/javascript/jscomp/js/es6/object/entries.js","../node_modules/shaka-player/lib/abr/ewma.js","../node_modules/shaka-player/lib/abr/ewma_bandwidth_estimator.js","../node_modules/shaka-player/lib/debug/log.js","../node_modules/shaka-player/lib/media/media_source_capabilities.js","../node_modules/shaka-player/lib/util/array_utils.js","../node_modules/shaka-player/lib/text/cue.js","../node_modules/shaka-player/lib/util/buffer_utils.js","../node_modules/shaka-player/lib/util/error.js","../node_modules/shaka-player/third_party/closure-uri/utils.js","../node_modules/shaka-player/third_party/closure-uri/uri.js","../node_modules/shaka-player/lib/util/functional.js","../node_modules/shaka-player/lib/util/manifest_parser_utils.js","../node_modules/shaka-player/lib/util/public_promise.js","../node_modules/shaka-player/lib/util/lazy.js","../node_modules/shaka-player/lib/util/delayed_tick.js","../node_modules/shaka-player/lib/util/timer.js","../node_modules/shaka-player/lib/util/platform.js","../node_modules/shaka-player/lib/util/string_utils.js","../node_modules/shaka-player/lib/util/uint8array_utils.js","../node_modules/shaka-player/lib/dependencies/all.js","../node_modules/shaka-player/lib/media/transmuxer.js","../node_modules/shaka-player/lib/util/mime_utils.js","../node_modules/shaka-player/lib/text/text_engine.js","../node_modules/shaka-player/lib/util/language_utils.js","../node_modules/shaka-player/lib/util/multi_map.js","../node_modules/shaka-player/lib/util/stream_utils.js","../node_modules/shaka-player/lib/media/segment_reference.js","../node_modules/shaka-player/lib/abr/simple_abr_manager.js","../node_modules/shaka-player/lib/deprecate/version.js","../node_modules/shaka-player/lib/deprecate/deprecate.js","../node_modules/shaka-player/lib/player.js","../node_modules/shaka-player/lib/deprecate/enforcer.js","../node_modules/shaka-player/lib/media/adaptation_set.js","../node_modules/shaka-player/lib/media/adaptation_set_criteria.js","../node_modules/shaka-player/lib/media/buffering_observer.js","../node_modules/shaka-player/lib/config/auto_show_text.js","../node_modules/shaka-player/lib/net/backoff.js","../node_modules/shaka-player/lib/util/abortable_operation.js","../node_modules/shaka-player/lib/util/fake_event.js","../node_modules/shaka-player/lib/util/fake_event_target.js","../node_modules/shaka-player/lib/util/object_utils.js","../node_modules/shaka-player/lib/util/operation_manager.js","../node_modules/shaka-player/lib/net/networking_engine.js","../node_modules/shaka-player/lib/util/destroyer.js","../node_modules/shaka-player/lib/util/event_manager.js","../node_modules/shaka-player/lib/util/iterables.js","../node_modules/shaka-player/lib/util/map_utils.js","../node_modules/shaka-player/lib/util/data_view_reader.js","../node_modules/shaka-player/lib/util/mp4_parser.js","../node_modules/shaka-player/lib/util/pssh.js","../node_modules/shaka-player/lib/util/xml_utils.js","../node_modules/shaka-player/lib/media/drm_engine.js","../node_modules/shaka-player/lib/media/manifest_parser.js","../node_modules/shaka-player/lib/media/content_workarounds.js","../node_modules/shaka-player/lib/cea/cea_utils.js","../node_modules/shaka-player/lib/cea/cea608_memory.js","../node_modules/shaka-player/lib/cea/cea608_data_channel.js","../node_modules/shaka-player/lib/cea/cea708_window.js","../node_modules/shaka-player/lib/cea/dtvcc_packet_builder.js","../node_modules/shaka-player/lib/cea/cea708_service.js","../node_modules/shaka-player/lib/cea/cea_decoder.js","../node_modules/shaka-player/lib/cea/dummy_cea_parser.js","../node_modules/shaka-player/lib/util/mp4_box_parsers.js","../node_modules/shaka-player/lib/cea/mp4_cea_parser.js","../node_modules/shaka-player/lib/cea/i_cea_parser.js","../node_modules/shaka-player/lib/cea/sei_processor.js","../node_modules/shaka-player/lib/media/closed_caption_parser.js","../node_modules/shaka-player/lib/media/time_ranges_utils.js","../node_modules/shaka-player/lib/util/id3_utils.js","../node_modules/shaka-player/lib/util/ts_parser.js","../node_modules/shaka-player/lib/lcevc/lcevc_dil.js","../node_modules/shaka-player/lib/media/media_source_engine.js","../node_modules/shaka-player/lib/media/presentation_timeline.js","../node_modules/shaka-player/lib/media/stall_detector.js","../node_modules/shaka-player/lib/media/gap_jumping_controller.js","../node_modules/shaka-player/lib/util/media_ready_state_utils.js","../node_modules/shaka-player/lib/media/video_wrapper.js","../node_modules/shaka-player/lib/media/playhead.js","../node_modules/shaka-player/lib/media/segment_index.js","../node_modules/shaka-player/lib/media/play_rate_controller.js","../node_modules/shaka-player/lib/media/playhead_observer.js","../node_modules/shaka-player/lib/media/quality_observer.js","../node_modules/shaka-player/lib/media/region_timeline.js","../node_modules/shaka-player/lib/media/region_observer.js","../node_modules/shaka-player/lib/util/networking.js","../node_modules/shaka-player/lib/media/streaming_engine.js","../node_modules/shaka-player/lib/routing/walker.js","../node_modules/shaka-player/lib/text/text_utils.js","../node_modules/shaka-player/lib/text/simple_text_displayer.js","../node_modules/shaka-player/lib/util/dom_utils.js","../node_modules/shaka-player/lib/text/ui_text_displayer.js","../node_modules/shaka-player/lib/util/cmcd_manager.js","../node_modules/shaka-player/lib/text/web_vtt_generator.js","../node_modules/shaka-player/lib/util/config_utils.js","../node_modules/shaka-player/lib/util/fairplay_utils.js","../node_modules/shaka-player/lib/util/player_configuration.js","../node_modules/shaka-player/lib/util/state_history.js","../node_modules/shaka-player/lib/util/switch_history.js","../node_modules/shaka-player/lib/util/stats.js","../node_modules/shaka-player/lib/ads/ads_stats.js","../node_modules/shaka-player/lib/ads/client_side_ad.js","../node_modules/shaka-player/lib/ads/client_side_ad_manager.js","../node_modules/shaka-player/lib/ads/ad_manager.js","../node_modules/shaka-player/lib/ads/server_side_ad.js","../node_modules/shaka-player/lib/ads/server_side_ad_manager.js","../node_modules/shaka-player/lib/cast/cast_utils.js","../node_modules/shaka-player/lib/cast/cast_sender.js","../node_modules/shaka-player/lib/cast/cast_proxy.js","../node_modules/shaka-player/lib/cast/cast_receiver.js","../node_modules/shaka-player/lib/dash/content_protection.js","../node_modules/shaka-player/lib/dash/mpd_utils.js","../node_modules/shaka-player/lib/media/mp4_segment_index_parser.js","../node_modules/shaka-player/lib/util/ebml_parser.js","../node_modules/shaka-player/lib/media/webm_segment_index_parser.js","../node_modules/shaka-player/lib/dash/segment_base.js","../node_modules/shaka-player/lib/dash/segment_list.js","../node_modules/shaka-player/lib/dash/segment_template.js","../node_modules/shaka-player/lib/util/periods.js","../node_modules/shaka-player/lib/dash/dash_parser.js","../node_modules/shaka-player/lib/hls/hls_classes.js","../node_modules/shaka-player/lib/hls/hls_utils.js","../node_modules/shaka-player/lib/hls/hls_parser.js","../node_modules/shaka-player/lib/util/text_parser.js","../node_modules/shaka-player/lib/hls/manifest_text_parser.js","../node_modules/shaka-player/lib/net/data_uri_plugin.js","../node_modules/shaka-player/lib/net/http_plugin_utils.js","../node_modules/shaka-player/lib/net/http_fetch_plugin.js","../node_modules/shaka-player/lib/net/http_xhr_plugin.js","../node_modules/shaka-player/lib/offline/download_info.js","../node_modules/shaka-player/lib/offline/download_progress_estimator.js","../node_modules/shaka-player/lib/offline/download_manager.js","../node_modules/shaka-player/lib/offline/indexeddb/db_operation.js","../node_modules/shaka-player/lib/offline/indexeddb/db_connection.js","../node_modules/shaka-player/lib/offline/indexeddb/base_storage_cell.js","../node_modules/shaka-player/lib/offline/indexeddb/eme_session_storage_cell.js","../node_modules/shaka-player/lib/offline/storage_muxer.js","../node_modules/shaka-player/lib/offline/indexeddb/storage_mechanism.js","../node_modules/shaka-player/lib/offline/indexeddb/v1_storage_cell.js","../node_modules/shaka-player/lib/offline/indexeddb/v2_storage_cell.js","../node_modules/shaka-player/lib/offline/indexeddb/v5_storage_cell.js","../node_modules/shaka-player/lib/offline/offline_uri.js","../node_modules/shaka-player/lib/offline/manifest_converter.js","../node_modules/shaka-player/lib/offline/offline_scheme.js","../node_modules/shaka-player/lib/offline/session_deleter.js","../node_modules/shaka-player/lib/offline/stored_content_utils.js","../node_modules/shaka-player/lib/offline/stream_bandwidth_estimator.js","../node_modules/shaka-player/lib/offline/storage.js","../node_modules/shaka-player/lib/polyfill/all.js","../node_modules/shaka-player/lib/polyfill/abort_controller.js","../node_modules/shaka-player/lib/polyfill/aria.js","../node_modules/shaka-player/lib/polyfill/encryption_scheme.js","../node_modules/shaka-player/lib/polyfill/fullscreen.js","../node_modules/shaka-player/lib/polyfill/media_capabilities.js","../node_modules/shaka-player/lib/polyfill/patchedmediakeys_apple.js","../node_modules/shaka-player/lib/polyfill/mediasource.js","../node_modules/shaka-player/lib/polyfill/orientation.js","../node_modules/shaka-player/lib/polyfill/patchedmediakeys_nop.js","../node_modules/shaka-player/lib/polyfill/patchedmediakeys_webkit.js","../node_modules/shaka-player/lib/polyfill/pip_webkit.js","../node_modules/shaka-player/lib/polyfill/random_uuid.js","../node_modules/shaka-player/lib/polyfill/storage_estimate.js","../node_modules/shaka-player/lib/polyfill/symbol.js","../node_modules/shaka-player/lib/polyfill/video_play_promise.js","../node_modules/shaka-player/lib/polyfill/videoplaybackquality.js","../node_modules/shaka-player/lib/polyfill/vttcue.js","../node_modules/shaka-player/lib/text/lrc_text_parser.js","../node_modules/shaka-player/lib/text/ttml_text_parser.js","../node_modules/shaka-player/lib/text/mp4_ttml_parser.js","../node_modules/shaka-player/lib/text/vtt_text_parser.js","../node_modules/shaka-player/lib/text/mp4_vtt_parser.js","../node_modules/shaka-player/lib/text/sbv_text_parser.js","../node_modules/shaka-player/lib/text/srt_text_parser.js","../node_modules/shaka-player/lib/text/ssa_text_parser.js","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/load script","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/jsonp chunk loading","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","App.js","reportWebVitals.js","index.js"],"sourcesContent":["/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n'use strict';var aa=require(\"react\"),ca=require(\"scheduler\");function p(a){for(var b=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=1;c<arguments.length;c++)b+=\"&args[]=\"+encodeURIComponent(arguments[c]);return\"Minified React error #\"+a+\"; visit \"+b+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+\"Capture\",b)}\nfunction ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}\nvar ia=!(\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,la=\n{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case \"function\":case \"symbol\":return!0;case \"boolean\":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return\"data-\"!==a&&\"aria-\"!==a;default:return!1}}\nfunction qa(a,b,c,d){if(null===b||\"undefined\"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[[\"acceptCharset\",\"accept-charset\"],[\"className\",\"class\"],[\"htmlFor\",\"for\"],[\"httpEquiv\",\"http-equiv\"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});[\"contentEditable\",\"draggable\",\"spellCheck\",\"value\"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});\n[\"autoReverse\",\"externalResourcesRequired\",\"focusable\",\"preserveAlpha\"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});\"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});\n[\"checked\",\"multiple\",\"muted\",\"selected\"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});[\"capture\",\"download\"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});[\"cols\",\"rows\",\"size\",\"span\"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});[\"rowSpan\",\"start\"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a){var b=a.replace(ra,\nsa);z[b]=new v(b,1,!1,a,null,!1,!1)});\"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/1999/xlink\",!1,!1)});[\"xml:base\",\"xml:lang\",\"xml:space\"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/XML/1998/namespace\",!1,!1)});[\"tabIndex\",\"crossOrigin\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});\nz.xlinkHref=new v(\"xlinkHref\",1,!1,\"xlink:href\",\"http://www.w3.org/1999/xlink\",!0,!1);[\"src\",\"href\",\"action\",\"formAction\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||\"o\"!==b[0]&&\"O\"!==b[0]||\"n\"!==b[1]&&\"N\"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,\"\"+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:\"\":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?\"\":\"\"+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}\nvar ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for(\"react.element\"),wa=Symbol.for(\"react.portal\"),ya=Symbol.for(\"react.fragment\"),za=Symbol.for(\"react.strict_mode\"),Aa=Symbol.for(\"react.profiler\"),Ba=Symbol.for(\"react.provider\"),Ca=Symbol.for(\"react.context\"),Da=Symbol.for(\"react.forward_ref\"),Ea=Symbol.for(\"react.suspense\"),Fa=Symbol.for(\"react.suspense_list\"),Ga=Symbol.for(\"react.memo\"),Ha=Symbol.for(\"react.lazy\");Symbol.for(\"react.scope\");Symbol.for(\"react.debug_trace_mode\");\nvar Ia=Symbol.for(\"react.offscreen\");Symbol.for(\"react.legacy_hidden\");Symbol.for(\"react.cache\");Symbol.for(\"react.tracing_marker\");var Ja=Symbol.iterator;function Ka(a){if(null===a||\"object\"!==typeof a)return null;a=Ja&&a[Ja]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);La=b&&b[1]||\"\"}return\"\\n\"+La+a}var Na=!1;\nfunction Oa(a,b){if(!a||Na)return\"\";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,\"props\",{set:function(){throw Error();}}),\"object\"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&\"string\"===typeof l.stack){for(var e=l.stack.split(\"\\n\"),\nf=d.stack.split(\"\\n\"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k=\"\\n\"+e[g].replace(\" at new \",\" at \");a.displayName&&k.includes(\"<anonymous>\")&&(k=k.replace(\"<anonymous>\",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:\"\")?Ma(a):\"\"}\nfunction Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma(\"Lazy\");case 13:return Ma(\"Suspense\");case 19:return Ma(\"SuspenseList\");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return\"\"}}\nfunction Qa(a){if(null==a)return null;if(\"function\"===typeof a)return a.displayName||a.name||null;if(\"string\"===typeof a)return a;switch(a){case ya:return\"Fragment\";case wa:return\"Portal\";case Aa:return\"Profiler\";case za:return\"StrictMode\";case Ea:return\"Suspense\";case Fa:return\"SuspenseList\"}if(\"object\"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||\"Context\")+\".Consumer\";case Ba:return(a._context.displayName||\"Context\")+\".Provider\";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||\"\",a=\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||\"Memo\";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}\nfunction Ra(a){var b=a.type;switch(a.tag){case 24:return\"Cache\";case 9:return(b.displayName||\"Context\")+\".Consumer\";case 10:return(b._context.displayName||\"Context\")+\".Provider\";case 18:return\"DehydratedFragment\";case 11:return a=b.render,a=a.displayName||a.name||\"\",b.displayName||(\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");case 7:return\"Fragment\";case 5:return b;case 4:return\"Portal\";case 3:return\"Root\";case 6:return\"Text\";case 16:return Qa(b);case 8:return b===za?\"StrictMode\":\"Mode\";case 22:return\"Offscreen\";\ncase 12:return\"Profiler\";case 21:return\"Scope\";case 13:return\"Suspense\";case 19:return\"SuspenseList\";case 25:return\"TracingMarker\";case 1:case 0:case 17:case 2:case 14:case 15:if(\"function\"===typeof b)return b.displayName||b.name||null;if(\"string\"===typeof b)return b}return null}function Sa(a){switch(typeof a){case \"boolean\":case \"number\":case \"string\":case \"undefined\":return a;case \"object\":return a;default:return\"\"}}\nfunction Ta(a){var b=a.type;return(a=a.nodeName)&&\"input\"===a.toLowerCase()&&(\"checkbox\"===b||\"radio\"===b)}\nfunction Ua(a){var b=Ta(a)?\"checked\":\"value\",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=\"\"+a[b];if(!a.hasOwnProperty(b)&&\"undefined\"!==typeof c&&\"function\"===typeof c.get&&\"function\"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=\"\"+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=\"\"+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d=\"\";a&&(d=Ta(a)?a.checked?\"true\":\"false\":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||(\"undefined\"!==typeof document?document:void 0);if(\"undefined\"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?\"\":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:\"checkbox\"===b.type||\"radio\"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,\"checked\",b,!1)}\nfunction bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if(\"number\"===d){if(0===c&&\"\"===a.value||a.value!=c)a.value=\"\"+c}else a.value!==\"\"+c&&(a.value=\"\"+c);else if(\"submit\"===d||\"reset\"===d){a.removeAttribute(\"value\");return}b.hasOwnProperty(\"value\")?cb(a,b.type,c):b.hasOwnProperty(\"defaultValue\")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction db(a,b,c){if(b.hasOwnProperty(\"value\")||b.hasOwnProperty(\"defaultValue\")){var d=b.type;if(!(\"submit\"!==d&&\"reset\"!==d||void 0!==b.value&&null!==b.value))return;b=\"\"+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;\"\"!==c&&(a.name=\"\");a.defaultChecked=!!a._wrapperState.initialChecked;\"\"!==c&&(a.name=c)}\nfunction cb(a,b,c){if(\"number\"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=\"\"+a._wrapperState.initialValue:a.defaultValue!==\"\"+c&&(a.defaultValue=\"\"+c)}var eb=Array.isArray;\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b[\"$\"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty(\"$\"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=\"\"+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:\"\"+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b=\"\");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=\"\"+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=\"\"+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&\"\"!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}\nfunction lb(a,b){return null==a||\"http://www.w3.org/1999/xhtml\"===a?kb(b):\"http://www.w3.org/2000/svg\"===a&&\"foreignObject\"===b?\"http://www.w3.org/1999/xhtml\":a}\nvar mb,nb=function(a){return\"undefined\"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(\"http://www.w3.org/2000/svg\"!==a.namespaceURI||\"innerHTML\"in a)a.innerHTML=b;else{mb=mb||document.createElement(\"div\");mb.innerHTML=\"<svg>\"+b.valueOf().toString()+\"</svg>\";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,\nzoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||\"boolean\"===typeof b||\"\"===b?\"\":c||\"number\"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(\"\"+b).trim():b+\"px\"}\nfunction sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf(\"--\"),e=rb(c,b[c],d);\"float\"===c&&(c=\"cssFloat\");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if(\"object\"!==typeof b.dangerouslySetInnerHTML||!(\"__html\"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&\"object\"!==typeof b.style)throw Error(p(62));}}\nfunction vb(a,b){if(-1===a.indexOf(\"-\"))return\"string\"===typeof b.is;switch(a){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if(\"function\"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}\nfunction Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":case \"onMouseEnter\":(d=!d.disabled)||(a=a.type,d=!(\"button\"===a||\"input\"===a||\"select\"===a||\"textarea\"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&\"function\"!==\ntypeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,\"passive\",{get:function(){Lb=!0}});window.addEventListener(\"test\",Mb,Mb);window.removeEventListener(\"test\",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}\nfunction Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}\nfunction Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}\nvar ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&\"function\"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}\nvar oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;\nfunction tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc=\"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\nfunction Sc(a,b){switch(a){case \"focusin\":case \"focusout\":Lc=null;break;case \"dragenter\":case \"dragleave\":Mc=null;break;case \"mouseover\":case \"mouseout\":Nc=null;break;case \"pointerover\":case \"pointerout\":Oc.delete(b.pointerId);break;case \"gotpointercapture\":case \"lostpointercapture\":Pc.delete(b.pointerId)}}\nfunction Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction Uc(a,b,c,d,e){switch(b){case \"focusin\":return Lc=Tc(Lc,a,b,c,d,e),!0;case \"dragenter\":return Mc=Tc(Mc,a,b,c,d,e),!0;case \"mouseover\":return Nc=Tc(Nc,a,b,c,d,e),!0;case \"pointerover\":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case \"gotpointercapture\":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}\nfunction ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}\nfunction bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;\nfunction ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}\nfunction fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;\nfunction Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}\nfunction jd(a){switch(a){case \"cancel\":case \"click\":case \"close\":case \"contextmenu\":case \"copy\":case \"cut\":case \"auxclick\":case \"dblclick\":case \"dragend\":case \"dragstart\":case \"drop\":case \"focusin\":case \"focusout\":case \"input\":case \"invalid\":case \"keydown\":case \"keypress\":case \"keyup\":case \"mousedown\":case \"mouseup\":case \"paste\":case \"pause\":case \"play\":case \"pointercancel\":case \"pointerdown\":case \"pointerup\":case \"ratechange\":case \"reset\":case \"resize\":case \"seeked\":case \"submit\":case \"touchcancel\":case \"touchend\":case \"touchstart\":case \"volumechange\":case \"change\":case \"selectionchange\":case \"textInput\":case \"compositionstart\":case \"compositionend\":case \"compositionupdate\":case \"beforeblur\":case \"afterblur\":case \"beforeinput\":case \"blur\":case \"fullscreenchange\":case \"focus\":case \"hashchange\":case \"popstate\":case \"select\":case \"selectstart\":return 1;case \"drag\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"mousemove\":case \"mouseout\":case \"mouseover\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"scroll\":case \"toggle\":case \"touchmove\":case \"wheel\":case \"mouseenter\":case \"mouseleave\":case \"pointerenter\":case \"pointerleave\":return 4;\ncase \"message\":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e=\"value\"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}\nfunction od(a){var b=a.keyCode;\"charCode\"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():\"unknown\"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():\"unknown\"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if(\"movementX\"in\na)return a.movementX;a!==yd&&(yd&&\"mousemove\"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return\"movementY\"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return\"clipboardData\"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:\"Escape\",\nSpacebar:\" \",Left:\"ArrowLeft\",Up:\"ArrowUp\",Right:\"ArrowRight\",Down:\"ArrowDown\",Del:\"Delete\",Win:\"OS\",Menu:\"ContextMenu\",Apps:\"ContextMenu\",Scroll:\"ScrollLock\",MozPrintableKey:\"Unidentified\"},Nd={8:\"Backspace\",9:\"Tab\",12:\"Clear\",13:\"Enter\",16:\"Shift\",17:\"Control\",18:\"Alt\",19:\"Pause\",20:\"CapsLock\",27:\"Escape\",32:\" \",33:\"PageUp\",34:\"PageDown\",35:\"End\",36:\"Home\",37:\"ArrowLeft\",38:\"ArrowUp\",39:\"ArrowRight\",40:\"ArrowDown\",45:\"Insert\",46:\"Delete\",112:\"F1\",113:\"F2\",114:\"F3\",115:\"F4\",116:\"F5\",117:\"F6\",118:\"F7\",\n119:\"F8\",120:\"F9\",121:\"F10\",122:\"F11\",123:\"F12\",144:\"NumLock\",145:\"ScrollLock\",224:\"Meta\"},Od={Alt:\"altKey\",Control:\"ctrlKey\",Meta:\"metaKey\",Shift:\"shiftKey\"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if(\"Unidentified\"!==b)return b}return\"keypress\"===a.type?(a=od(a),13===a?\"Enter\":String.fromCharCode(a)):\"keydown\"===a.type||\"keyup\"===a.type?Nd[a.keyCode]||\"Unidentified\":\"\"},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return\"keypress\"===a.type?od(a):0},keyCode:function(a){return\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0},which:function(a){return\"keypress\"===\na.type?od(a):\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return\"deltaX\"in a?a.deltaX:\"wheelDeltaX\"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return\"deltaY\"in a?a.deltaY:\"wheelDeltaY\"in a?-a.wheelDeltaY:\"wheelDelta\"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&\"CompositionEvent\"in window,be=null;ia&&\"documentMode\"in document&&(be=document.documentMode);var ce=ia&&\"TextEvent\"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case \"keyup\":return-1!==$d.indexOf(b.keyCode);case \"keydown\":return 229!==b.keyCode;case \"keypress\":case \"mousedown\":case \"focusout\":return!0;default:return!1}}function he(a){a=a.detail;return\"object\"===typeof a&&\"data\"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case \"compositionend\":return he(b);case \"keypress\":if(32!==b.which)return null;fe=!0;return ee;case \"textInput\":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return\"compositionend\"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case \"paste\":return null;case \"keypress\":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case \"compositionend\":return de&&\"ko\"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,\"datetime-local\":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return\"input\"===b?!!le[a.type]:\"textarea\"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,\"onChange\");0<b.length&&(c=new td(\"onChange\",\"change\",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if(\"change\"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye=\"oninput\"in document;if(!ye){var ze=document.createElement(\"div\");ze.setAttribute(\"oninput\",\"return;\");ye=\"function\"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent(\"onpropertychange\",Be),qe=pe=null)}function Be(a){if(\"value\"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}\nfunction Ce(a,b,c){\"focusin\"===a?(Ae(),pe=b,qe=c,pe.attachEvent(\"onpropertychange\",Be)):\"focusout\"===a&&Ae()}function De(a){if(\"selectionchange\"===a||\"keyup\"===a||\"keydown\"===a)return te(qe)}function Ee(a,b){if(\"click\"===a)return te(b)}function Fe(a,b){if(\"input\"===a||\"change\"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He=\"function\"===typeof Object.is?Object.is:Ge;\nfunction Ie(a,b){if(He(a,b))return!0;if(\"object\"!==typeof a||null===a||\"object\"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):\"contains\"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c=\"string\"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&(\"input\"===b&&(\"text\"===a.type||\"search\"===a.type||\"tel\"===a.type||\"url\"===a.type||\"password\"===a.type)||\"textarea\"===b||\"true\"===a.contentEditable)}\nfunction Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),\"selectionStart\"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,\nd);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});\"function\"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}\nvar Pe=ia&&\"documentMode\"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,\"selectionStart\"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,\"onSelect\"),0<d.length&&(b=new td(\"onSelect\",\"select\",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nfunction Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c[\"Webkit\"+a]=\"webkit\"+b;c[\"Moz\"+a]=\"moz\"+b;return c}var We={animationend:Ve(\"Animation\",\"AnimationEnd\"),animationiteration:Ve(\"Animation\",\"AnimationIteration\"),animationstart:Ve(\"Animation\",\"AnimationStart\"),transitionend:Ve(\"Transition\",\"TransitionEnd\")},Xe={},Ye={};\nia&&(Ye=document.createElement(\"div\").style,\"AnimationEvent\"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),\"TransitionEvent\"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze(\"animationend\"),af=Ze(\"animationiteration\"),bf=Ze(\"animationstart\"),cf=Ze(\"transitionend\"),df=new Map,ef=\"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\" \");\nfunction ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,\"on\"+kf)}ff($e,\"onAnimationEnd\");ff(af,\"onAnimationIteration\");ff(bf,\"onAnimationStart\");ff(\"dblclick\",\"onDoubleClick\");ff(\"focusin\",\"onFocus\");ff(\"focusout\",\"onBlur\");ff(cf,\"onTransitionEnd\");ha(\"onMouseEnter\",[\"mouseout\",\"mouseover\"]);ha(\"onMouseLeave\",[\"mouseout\",\"mouseover\"]);ha(\"onPointerEnter\",[\"pointerout\",\"pointerover\"]);\nha(\"onPointerLeave\",[\"pointerout\",\"pointerover\"]);fa(\"onChange\",\"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));fa(\"onSelect\",\"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));fa(\"onBeforeInput\",[\"compositionend\",\"keypress\",\"textInput\",\"paste\"]);fa(\"onCompositionEnd\",\"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));fa(\"onCompositionStart\",\"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\nfa(\"onCompositionUpdate\",\"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));var lf=\"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"),mf=new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(lf));\nfunction nf(a,b,c){var d=a.type||\"unknown-event\";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}\nfunction D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+\"__bubble\";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf=\"_reactListening\"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){\"selectionchange\"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf(\"selectionchange\",!1,b))}}\nfunction pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||\"touchstart\"!==b&&\"touchmove\"!==b&&\"wheel\"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];\na:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case \"keypress\":if(0===od(c))break a;case \"keydown\":case \"keyup\":k=Rd;break;case \"focusin\":n=\"focus\";k=Fd;break;case \"focusout\":n=\"blur\";k=Fd;break;case \"beforeblur\":case \"afterblur\":k=Fd;break;case \"click\":if(2===c.button)break a;case \"auxclick\":case \"dblclick\":case \"mousedown\":case \"mousemove\":case \"mouseup\":case \"mouseout\":case \"mouseover\":case \"contextmenu\":k=Bd;break;case \"drag\":case \"dragend\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"dragstart\":case \"drop\":k=\nDd;break;case \"touchcancel\":case \"touchend\":case \"touchmove\":case \"touchstart\":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case \"scroll\":k=vd;break;case \"wheel\":k=Zd;break;case \"copy\":case \"cut\":case \"paste\":k=Jd;break;case \"gotpointercapture\":case \"lostpointercapture\":case \"pointercancel\":case \"pointerdown\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"pointerup\":k=Td}var t=0!==(b&4),J=!t&&\"scroll\"===a,x=t?null!==h?h+\"Capture\":null:h;t=[];for(var w=d,u;null!==\nw;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h=\"mouseover\"===a||\"pointerover\"===a;k=\"mouseout\"===a||\"pointerout\"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==\nn&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F=\"onMouseLeave\";x=\"onMouseEnter\";w=\"mouse\";if(\"pointerout\"===a||\"pointerover\"===a)t=Td,F=\"onPointerLeave\",x=\"onPointerEnter\",w=\"pointer\";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+\"leave\",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+\"enter\",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=\nvf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if(\"select\"===k||\"input\"===k&&\"file\"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&\"input\"===k.toLowerCase()&&(\"checkbox\"===h.type||\"radio\"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);\"focusout\"===a&&(xa=h._wrapperState)&&\nxa.controlled&&\"number\"===h.type&&cb(h,\"number\",h.value)}xa=d?ue(d):window;switch(a){case \"focusin\":if(me(xa)||\"true\"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case \"focusout\":Se=Re=Qe=null;break;case \"mousedown\":Te=!0;break;case \"contextmenu\":case \"mouseup\":case \"dragend\":Te=!1;Ue(g,c,e);break;case \"selectionchange\":if(Pe)break;case \"keydown\":case \"keyup\":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case \"compositionstart\":var ba=\"onCompositionStart\";break b;case \"compositionend\":ba=\"onCompositionEnd\";\nbreak b;case \"compositionupdate\":ba=\"onCompositionUpdate\";break b}ba=void 0}else ie?ge(a,c)&&(ba=\"onCompositionEnd\"):\"keydown\"===a&&229===c.keyCode&&(ba=\"onCompositionStart\");ba&&(de&&\"ko\"!==c.locale&&(ie||\"onCompositionStart\"!==ba?\"onCompositionEnd\"===ba&&ie&&($a=nd()):(kd=e,ld=\"value\"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,\"onBeforeInput\"),\n0<d.length&&(e=new Ld(\"onBeforeInput\",\"beforeinput\",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+\"Capture\",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\\r\\n?/g,yf=/\\u0000|\\uFFFD/g;function zf(a){return(\"string\"===typeof a?a:\"\"+a).replace(xf,\"\\n\").replace(yf,\"\")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}\nvar Cf=null,Df=null;function Ef(a,b){return\"textarea\"===a||\"noscript\"===a||\"string\"===typeof b.children||\"number\"===typeof b.children||\"object\"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}\nvar Ff=\"function\"===typeof setTimeout?setTimeout:void 0,Gf=\"function\"===typeof clearTimeout?clearTimeout:void 0,Hf=\"function\"===typeof Promise?Promise:void 0,Jf=\"function\"===typeof queueMicrotask?queueMicrotask:\"undefined\"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}\nfunction Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,\"/$\"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else\"$\"!==c&&\"$?\"!==c&&\"$!\"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if(\"$\"===b||\"$!\"===b||\"$?\"===b)break;if(\"/$\"===b)return null}}return a}\nfunction Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(\"$\"===c||\"$!\"===c||\"$?\"===c){if(0===b)return a;b--}else\"/$\"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of=\"__reactFiber$\"+Nf,Pf=\"__reactProps$\"+Nf,uf=\"__reactContainer$\"+Nf,of=\"__reactEvents$\"+Nf,Qf=\"__reactListeners$\"+Nf,Rf=\"__reactHandles$\"+Nf;\nfunction Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}\nfunction E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if(\"function\"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||\"Unknown\",e));return A({},c,d)}\nfunction cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}\nfunction jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg=\"\";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}\nfunction ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;\nfunction Ag(a,b){var c=Bg(5,null,null,0);c.elementType=\"DELETED\";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=\"\"===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=\nnull,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}\nfunction Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b=\"head\"!==b&&\"body\"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(\"/$\"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else\"$\"!==c&&\"$!\"!==c&&\"$?\"!==c||b++}a=a.nextSibling}yg=\nnull}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var Mg=Uf(null),Ng=null,Og=null,Pg=null;function Qg(){Pg=Og=Ng=null}function Rg(a){var b=Mg.current;E(Mg);a._currentValue=b}\nfunction Sg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Tg(a,b){Ng=a;Pg=Og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(Ug=!0),a.firstContext=null)}\nfunction Vg(a){var b=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:b,next:null},null===Og){if(null===Ng)throw Error(p(308));Og=a;Ng.dependencies={lanes:0,firstContext:a}}else Og=Og.next=a;return b}var Wg=null;function Xg(a){null===Wg?Wg=[a]:Wg.push(a)}function Yg(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,Xg(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Zg(a,d)}\nfunction Zg(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var $g=!1;function ah(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}\nfunction bh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction dh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return Zg(a,c)}e=d.interleaved;null===e?(b.next=b,Xg(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Zg(a,c)}function eh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nfunction fh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction gh(a,b,c,d){var e=a.updateQueue;$g=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if(\"function\"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r=\"function\"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:$g=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;\nh=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);hh|=g;a.lanes=g;a.memoizedState=q}}\nfunction ih(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if(\"function\"!==typeof e)throw Error(p(191,e));e.call(d)}}}var jh=(new aa.Component).refs;function kh(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar nh={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=L(),d=\nlh(a),e=ch(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=dh(a,e,d);null!==b&&(mh(b,a,d,c),eh(b,a,d))}};function oh(a,b,c,d,e,f,g){a=a.stateNode;return\"function\"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}\nfunction ph(a,b,c){var d=!1,e=Vf;var f=b.contextType;\"object\"===typeof f&&null!==f?f=Vg(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=nh;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction qh(a,b,c,d){a=b.state;\"function\"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);\"function\"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&nh.enqueueReplaceState(b,b.state,null)}\nfunction rh(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jh;ah(a);var f=b.contextType;\"object\"===typeof f&&null!==f?e.context=Vg(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;\"function\"===typeof f&&(kh(a,b,f,c),e.state=a.memoizedState);\"function\"===typeof b.getDerivedStateFromProps||\"function\"===typeof e.getSnapshotBeforeUpdate||\"function\"!==typeof e.UNSAFE_componentWillMount&&\"function\"!==typeof e.componentWillMount||(b=e.state,\n\"function\"===typeof e.componentWillMount&&e.componentWillMount(),\"function\"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&nh.enqueueReplaceState(e,e.state,null),gh(a,c,e,d),e.state=a.memoizedState);\"function\"===typeof e.componentDidMount&&(a.flags|=4194308)}\nfunction sh(a,b,c){a=c.ref;if(null!==a&&\"function\"!==typeof a&&\"object\"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=\"\"+a;if(null!==b&&null!==b.ref&&\"function\"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===jh&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if(\"string\"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}\nfunction th(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,\"[object Object]\"===a?\"object with keys {\"+Object.keys(b).join(\", \")+\"}\":a));}function uh(a){var b=a._init;return b(a._payload)}\nfunction vh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=wh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=xh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||\"object\"===typeof f&&null!==f&&f.$$typeof===Ha&&uh(f)===b.type))return d=e(b,c.props),d.ref=sh(a,b,c),d.return=a,d;d=yh(c.type,c.key,c.props,null,a.mode,d);d.ref=sh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=zh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ah(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if(\"string\"===typeof b&&\"\"!==b||\"number\"===typeof b)return b=xh(\"\"+b,a.mode,c),b.return=a,b;if(\"object\"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=yh(b.type,b.key,b.props,null,a.mode,c),\nc.ref=sh(a,null,b),c.return=a,c;case wa:return b=zh(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Ah(b,a.mode,c,null),b.return=a,b;th(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if(\"string\"===typeof c&&\"\"!==c||\"number\"===typeof c)return null!==e?null:h(a,b,\"\"+c,d);if(\"object\"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,\nb,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);th(a,c)}return null}function y(a,b,c,d,e){if(\"string\"===typeof d&&\"\"!==d||\"number\"===typeof d)return a=a.get(c)||null,h(b,a,\"\"+d,e);if(\"object\"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);th(b,d)}return null}\nfunction n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===\nx.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if(\"function\"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,\nm),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){\"object\"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if(\"object\"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=\nf.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||\"object\"===typeof k&&null!==k&&k.$$typeof===Ha&&uh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=sh(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Ah(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=yh(f.type,f.key,f.props,null,a.mode,h),h.ref=sh(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==\nd;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=zh(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);th(a,f)}return\"string\"===typeof f&&\"\"!==f||\"number\"===typeof f?(f=\"\"+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):\n(c(a,d),d=xh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Bh=vh(!0),Ch=vh(!1),Dh={},Eh=Uf(Dh),Fh=Uf(Dh),Gh=Uf(Dh);function Hh(a){if(a===Dh)throw Error(p(174));return a}function Ih(a,b){G(Gh,b);G(Fh,a);G(Eh,Dh);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,\"\");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(Eh);G(Eh,b)}function Jh(){E(Eh);E(Fh);E(Gh)}\nfunction Kh(a){Hh(Gh.current);var b=Hh(Eh.current);var c=lb(b,a.type);b!==c&&(G(Fh,a),G(Eh,c))}function Lh(a){Fh.current===a&&(E(Eh),E(Fh))}var M=Uf(0);\nfunction Mh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||\"$?\"===c.data||\"$!\"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Nh=[];\nfunction Oh(){for(var a=0;a<Nh.length;a++)Nh[a]._workInProgressVersionPrimary=null;Nh.length=0}var Ph=ua.ReactCurrentDispatcher,Qh=ua.ReactCurrentBatchConfig,Rh=0,N=null,O=null,P=null,Sh=!1,Th=!1,Uh=0,Vh=0;function Q(){throw Error(p(321));}function Wh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Xh(a,b,c,d,e,f){Rh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Ph.current=null===a||null===a.memoizedState?Yh:Zh;a=c(d,e);if(Th){f=0;do{Th=!1;Uh=0;if(25<=f)throw Error(p(301));f+=1;P=O=null;b.updateQueue=null;Ph.current=$h;a=c(d,e)}while(Th)}Ph.current=ai;b=null!==O&&null!==O.next;Rh=0;P=O=N=null;Sh=!1;if(b)throw Error(p(300));return a}function bi(){var a=0!==Uh;Uh=0;return a}\nfunction ci(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function di(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(p(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}\nfunction ei(a,b){return\"function\"===typeof b?b(a):b}\nfunction fi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Rh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;N.lanes|=m;hh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(Ug=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,N.lanes|=f,hh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction gi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(Ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function hi(){}\nfunction ii(a,b){var c=N,d=di(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,Ug=!0);d=d.queue;ji(ki.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==P&&P.memoizedState.tag&1){c.flags|=2048;li(9,mi.bind(null,c,d,e,b),void 0,null);if(null===R)throw Error(p(349));0!==(Rh&30)||ni(c,b,e)}return e}function ni(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction mi(a,b,c,d){b.value=c;b.getSnapshot=d;oi(b)&&pi(a)}function ki(a,b,c){return c(function(){oi(b)&&pi(a)})}function oi(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function pi(a){var b=Zg(a,1);null!==b&&mh(b,a,1,-1)}\nfunction qi(a){var b=ci();\"function\"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei,lastRenderedState:a};b.queue=a;a=a.dispatch=ri.bind(null,N,a);return[b.memoizedState,a]}\nfunction li(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function si(){return di().memoizedState}function ti(a,b,c,d){var e=ci();N.flags|=a;e.memoizedState=li(1|b,c,void 0,void 0===d?null:d)}\nfunction ui(a,b,c,d){var e=di();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&Wh(d,g.deps)){e.memoizedState=li(b,c,f,d);return}}N.flags|=a;e.memoizedState=li(1|b,c,f,d)}function vi(a,b){return ti(8390656,8,a,b)}function ji(a,b){return ui(2048,8,a,b)}function wi(a,b){return ui(4,2,a,b)}function xi(a,b){return ui(4,4,a,b)}\nfunction yi(a,b){if(\"function\"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function zi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ui(4,4,yi.bind(null,b,a),c)}function Ai(){}function Bi(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction Ci(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Di(a,b,c){if(0===(Rh&21))return a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=c;He(c,b)||(c=yc(),N.lanes|=c,hh|=c,a.baseState=!0);return b}function Ei(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Qh.transition;Qh.transition={};try{a(!1),b()}finally{C=c,Qh.transition=d}}function Fi(){return di().memoizedState}\nfunction Gi(a,b,c){var d=lh(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,c);else if(c=Yg(a,b,c,d),null!==c){var e=L();mh(c,a,d,e);Ji(c,b,d)}}\nfunction ri(a,b,c){var d=lh(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,Xg(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=Yg(a,b,e,d);null!==c&&(e=L(),mh(c,a,d,e),Ji(c,b,d))}}\nfunction Hi(a){var b=a.alternate;return a===N||null!==b&&b===N}function Ii(a,b){Th=Sh=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Ji(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nvar ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh={readContext:Vg,useCallback:function(a,b){ci().memoizedState=[a,void 0===b?null:b];return a},useContext:Vg,useEffect:vi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ti(4194308,\n4,yi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ti(4194308,4,a,b)},useInsertionEffect:function(a,b){return ti(4,2,a,b)},useMemo:function(a,b){var c=ci();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=ci();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Gi.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=\nci();a={current:a};return b.memoizedState=a},useState:qi,useDebugValue:Ai,useDeferredValue:function(a){return ci().memoizedState=a},useTransition:function(){var a=qi(!1),b=a[0];a=Ei.bind(null,a[1]);ci().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=N,e=ci();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===R)throw Error(p(349));0!==(Rh&30)||ni(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;vi(ki.bind(null,d,\nf,a),[a]);d.flags|=2048;li(9,mi.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=ci(),b=R.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=\":\"+b+\"R\"+c;c=Uh++;0<c&&(b+=\"H\"+c.toString(32));b+=\":\"}else c=Vh++,b=\":\"+b+\"r\"+c.toString(32)+\":\";return a.memoizedState=b},unstable_isNewReconciler:!1},Zh={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:fi,useRef:si,useState:function(){return fi(ei)},\nuseDebugValue:Ai,useDeferredValue:function(a){var b=di();return Di(b,O.memoizedState,a)},useTransition:function(){var a=fi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1},$h={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:gi,useRef:si,useState:function(){return gi(ei)},useDebugValue:Ai,useDeferredValue:function(a){var b=di();return null===\nO?b.memoizedState=a:Di(b,O.memoizedState,a)},useTransition:function(){var a=gi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1};function Ki(a,b){try{var c=\"\",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e=\"\\nError generating stack: \"+f.message+\"\\n\"+f.stack}return{value:a,source:b,stack:e,digest:null}}function Li(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}\nfunction Mi(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Ni=\"function\"===typeof WeakMap?WeakMap:Map;function Oi(a,b,c){c=ch(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Pi||(Pi=!0,Qi=d);Mi(a,b)};return c}\nfunction Ri(a,b,c){c=ch(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if(\"function\"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Mi(a,b)}}var f=a.stateNode;null!==f&&\"function\"===typeof f.componentDidCatch&&(c.callback=function(){Mi(a,b);\"function\"!==typeof d&&(null===Si?Si=new Set([this]):Si.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:\"\"})});return c}\nfunction Ti(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ni;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ui.bind(null,a,b,c),b.then(a,a))}function Vi(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Wi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ch(-1,1),b.tag=2,dh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Xi=ua.ReactCurrentOwner,Ug=!1;function Yi(a,b,c,d){b.child=null===a?Ch(b,null,c,d):Bh(b,a.child,c,d)}\nfunction Zi(a,b,c,d,e){c=c.render;var f=b.ref;Tg(b,e);d=Xh(a,b,c,d,f,e);c=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&c&&vg(b);b.flags|=1;Yi(a,b,d,e);return b.child}\nfunction aj(a,b,c,d,e){if(null===a){var f=c.type;if(\"function\"===typeof f&&!bj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,cj(a,b,f,d,e);a=yh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return $i(a,b,e)}b.flags|=1;a=wh(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction cj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(Ug=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(Ug=!0);else return b.lanes=a.lanes,$i(a,b,e)}return dj(a,b,c,d,e)}\nfunction ej(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if(\"hidden\"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(fj,gj),gj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(fj,gj);gj|=d}else null!==\nf?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(fj,gj),gj|=d;Yi(a,b,e,c);return b.child}function hj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function dj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);Tg(b,e);c=Xh(a,b,c,d,f,e);d=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&d&&vg(b);b.flags|=1;Yi(a,b,c,e);return b.child}\nfunction ij(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;Tg(b,e);if(null===b.stateNode)jj(a,b),ph(b,c,d),rh(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;\"object\"===typeof l&&null!==l?l=Vg(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q=\"function\"===typeof m||\"function\"===typeof g.getSnapshotBeforeUpdate;q||\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||\n(h!==d||k!==l)&&qh(b,g,d,l);$g=!1;var r=b.memoizedState;g.state=r;gh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||$g?(\"function\"===typeof m&&(kh(b,c,m,d),k=b.memoizedState),(h=$g||oh(b,c,h,d,r,k,l))?(q||\"function\"!==typeof g.UNSAFE_componentWillMount&&\"function\"!==typeof g.componentWillMount||(\"function\"===typeof g.componentWillMount&&g.componentWillMount(),\"function\"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),\"function\"===typeof g.componentDidMount&&(b.flags|=4194308)):\n(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;bh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Lg(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;\"object\"===typeof k&&null!==k?k=Vg(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m=\"function\"===typeof y||\"function\"===typeof g.getSnapshotBeforeUpdate)||\n\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&qh(b,g,d,k);$g=!1;r=b.memoizedState;g.state=r;gh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||$g?(\"function\"===typeof y&&(kh(b,c,y,d),n=b.memoizedState),(l=$g||oh(b,c,l,d,r,n,k)||!1)?(m||\"function\"!==typeof g.UNSAFE_componentWillUpdate&&\"function\"!==typeof g.componentWillUpdate||(\"function\"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),\"function\"===typeof g.UNSAFE_componentWillUpdate&&\ng.UNSAFE_componentWillUpdate(d,n,k)),\"function\"===typeof g.componentDidUpdate&&(b.flags|=4),\"function\"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===\na.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return kj(a,b,c,d,f,e)}\nfunction kj(a,b,c,d,e,f){hj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),$i(a,b,f);d=b.stateNode;Xi.current=b;var h=g&&\"function\"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Bh(b,a.child,null,f),b.child=Bh(b,null,h,f)):Yi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function lj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);Ih(a,b.containerInfo)}\nfunction mj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Yi(a,b,c,d);return b.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}\nfunction pj(a,b,c){var d=b.pendingProps,e=M.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(M,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:\"$!\"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:\"hidden\",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=\ng):f=qj(g,d,0,null),a=Ah(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=oj(c),b.memoizedState=nj,a):rj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return sj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:\"hidden\",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=wh(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=wh(h,f):(f=Ah(f,g,c,null),f.flags|=2);f.return=\nb;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?oj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=nj;return d}f=a.child;a=f.sibling;d=wh(f,{mode:\"visible\",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}\nfunction rj(a,b){b=qj({mode:\"visible\",children:b},a.mode,0,null);b.return=a;return a.child=b}function tj(a,b,c,d){null!==d&&Jg(d);Bh(b,a.child,null,c);a=rj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction sj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Li(Error(p(422))),tj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=qj({mode:\"visible\",children:d.children},e,0,null);f=Ah(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Bh(b,a.child,null,g);b.child.memoizedState=oj(g);b.memoizedState=nj;return f}if(0===(b.mode&1))return tj(a,b,g,null);if(\"$!\"===e.data){d=e.nextSibling&&e.nextSibling.dataset;\nif(d)var h=d.dgst;d=h;f=Error(p(419));d=Li(f,d,void 0);return tj(a,b,g,d)}h=0!==(g&a.childLanes);if(Ug||h){d=R;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;\n0!==e&&e!==f.retryLane&&(f.retryLane=e,Zg(a,e),mh(d,a,e,-1))}uj();d=Li(Error(p(421)));return tj(a,b,g,d)}if(\"$?\"===e.data)return b.flags|=128,b.child=a.child,b=vj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=rj(b,d.children);b.flags|=4096;return b}function wj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);Sg(a.return,b,c)}\nfunction xj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction yj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Yi(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&wj(a,c,b);else if(19===a.tag)wj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(M,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case \"forwards\":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Mh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);xj(b,!1,e,c,f);break;case \"backwards\":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Mh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}xj(b,!0,c,null,f);break;case \"together\":xj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction jj(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function $i(a,b,c){null!==a&&(b.dependencies=a.dependencies);hh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=wh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=wh(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction zj(a,b,c){switch(b.tag){case 3:lj(b);Ig();break;case 5:Kh(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:Ih(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Mg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(M,M.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return pj(a,b,c);G(M,M.current&1);a=$i(a,b,c);return null!==a?a.sibling:null}G(M,M.current&1);break;case 19:d=0!==(c&\nb.childLanes);if(0!==(a.flags&128)){if(d)return yj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(M,M.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,ej(a,b,c)}return $i(a,b,c)}var Aj,Bj,Cj,Dj;\nAj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Bj=function(){};\nCj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Hh(Eh.current);var f=null;switch(c){case \"input\":e=Ya(a,e);d=Ya(a,d);f=[];break;case \"select\":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case \"textarea\":e=gb(a,e);d=gb(a,d);f=[];break;default:\"function\"!==typeof e.onClick&&\"function\"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if(\"style\"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&\n(c||(c={}),c[g]=\"\")}else\"dangerouslySetInnerHTML\"!==l&&\"children\"!==l&&\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&\"autoFocus\"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if(\"style\"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]=\"\");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,\nc)),c=k;else\"dangerouslySetInnerHTML\"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):\"children\"===l?\"string\"!==typeof k&&\"number\"!==typeof k||(f=f||[]).push(l,\"\"+k):\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&(ea.hasOwnProperty(l)?(null!=k&&\"onScroll\"===l&&D(\"scroll\",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push(\"style\",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Dj=function(a,b,c,d){c!==d&&(b.flags|=4)};\nfunction Ej(a,b){if(!I)switch(a.tailMode){case \"hidden\":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case \"collapsed\":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Fj(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;Jh();E(Wf);E(H);Oh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Gj(zg),zg=null));Bj(a,b);S(b);return null;case 5:Lh(b);var e=Hh(Gh.current);\nc=b.type;if(null!==a&&null!=b.stateNode)Cj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case \"dialog\":D(\"cancel\",d);D(\"close\",d);break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",d);break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],d);break;case \"source\":D(\"error\",d);break;case \"img\":case \"image\":case \"link\":D(\"error\",\nd);D(\"load\",d);break;case \"details\":D(\"toggle\",d);break;case \"input\":Za(d,f);D(\"invalid\",d);break;case \"select\":d._wrapperState={wasMultiple:!!f.multiple};D(\"invalid\",d);break;case \"textarea\":hb(d,f),D(\"invalid\",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];\"children\"===g?\"string\"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=[\"children\",h]):\"number\"===typeof h&&d.textContent!==\"\"+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,\nh,a),e=[\"children\",\"\"+h]):ea.hasOwnProperty(g)&&null!=h&&\"onScroll\"===g&&D(\"scroll\",d)}switch(c){case \"input\":Va(d);db(d,f,!0);break;case \"textarea\":Va(d);jb(d);break;case \"select\":case \"option\":break;default:\"function\"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;\"http://www.w3.org/1999/xhtml\"===a&&(a=kb(c));\"http://www.w3.org/1999/xhtml\"===a?\"script\"===c?(a=g.createElement(\"div\"),a.innerHTML=\"<script>\\x3c/script>\",a=a.removeChild(a.firstChild)):\n\"string\"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),\"select\"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;Aj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case \"dialog\":D(\"cancel\",a);D(\"close\",a);e=d;break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",a);e=d;break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case \"source\":D(\"error\",a);e=d;break;case \"img\":case \"image\":case \"link\":D(\"error\",\na);D(\"load\",a);e=d;break;case \"details\":D(\"toggle\",a);e=d;break;case \"input\":Za(a,d);e=Ya(a,d);D(\"invalid\",a);break;case \"option\":e=d;break;case \"select\":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D(\"invalid\",a);break;case \"textarea\":hb(a,d);e=gb(a,d);D(\"invalid\",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];\"style\"===f?sb(a,k):\"dangerouslySetInnerHTML\"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):\"children\"===f?\"string\"===typeof k?(\"textarea\"!==\nc||\"\"!==k)&&ob(a,k):\"number\"===typeof k&&ob(a,\"\"+k):\"suppressContentEditableWarning\"!==f&&\"suppressHydrationWarning\"!==f&&\"autoFocus\"!==f&&(ea.hasOwnProperty(f)?null!=k&&\"onScroll\"===f&&D(\"scroll\",a):null!=k&&ta(a,f,k,g))}switch(c){case \"input\":Va(a);db(a,d,!1);break;case \"textarea\":Va(a);jb(a);break;case \"option\":null!=d.value&&a.setAttribute(\"value\",\"\"+Sa(d.value));break;case \"select\":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,\n!0);break;default:\"function\"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case \"button\":case \"input\":case \"select\":case \"textarea\":d=!!d.autoFocus;break a;case \"img\":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Dj(a,b,a.memoizedProps,d);else{if(\"string\"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Hh(Gh.current);Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=\nxg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(M);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===\na){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Gj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(M.current&1)?0===T&&(T=3):uj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return Jh(),\nBj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return Rg(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(M);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Ej(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Mh(a);if(null!==g){b.flags|=128;Ej(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,\ng=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(M,M.current&1|2);return b.child}a=\na.sibling}null!==f.tail&&B()>Hj&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304)}else{if(!d)if(a=Mh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Ej(f,!0),null===f.tail&&\"hidden\"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Hj&&1073741824!==c&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=\nb,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=M.current,G(M,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Ij(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(gj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}\nfunction Jj(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Jh(),E(Wf),E(H),Oh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Lh(b),null;case 13:E(M);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(M),null;case 4:return Jh(),null;case 10:return Rg(b.type._context),null;case 22:case 23:return Ij(),\nnull;case 24:return null;default:return null}}var Kj=!1,U=!1,Lj=\"function\"===typeof WeakSet?WeakSet:Set,V=null;function Mj(a,b){var c=a.ref;if(null!==c)if(\"function\"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Nj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Oj=!1;\nfunction Pj(a,b){Cf=dd;a=Me();if(Ne(a)){if(\"selectionStart\"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=\nq.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;\ncase 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Lg(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent=\"\":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Oj;Oj=!1;return n}\nfunction Qj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Nj(b,c,f)}e=e.next}while(e!==d)}}function Rj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Sj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}\"function\"===typeof b?b(a):b.current=a}}\nfunction Tj(a){var b=a.alternate;null!==b&&(a.alternate=null,Tj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Uj(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Vj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Uj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}\nfunction Xj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Xj(a,b,c),a=a.sibling;null!==a;)Xj(a,b,c),a=a.sibling}var X=null,Yj=!1;function Zj(a,b,c){for(c=c.child;null!==c;)ak(a,b,c),c=c.sibling}\nfunction ak(a,b,c){if(lc&&\"function\"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Mj(c,b);case 6:var d=X,e=Yj;X=null;Zj(a,b,c);X=d;Yj=e;null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Yj;X=c.stateNode.containerInfo;Yj=!0;\nZj(a,b,c);X=d;Yj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Nj(c,b,g):0!==(f&4)&&Nj(c,b,g));e=e.next}while(e!==d)}Zj(a,b,c);break;case 1:if(!U&&(Mj(c,b),d=c.stateNode,\"function\"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Zj(a,b,c);break;case 21:Zj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==\nc.memoizedState,Zj(a,b,c),U=d):Zj(a,b,c);break;default:Zj(a,b,c)}}function bk(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Lj);b.forEach(function(b){var d=ck.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction dk(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Yj=!1;break a;case 3:X=h.stateNode.containerInfo;Yj=!0;break a;case 4:X=h.stateNode.containerInfo;Yj=!0;break a}h=h.return}if(null===X)throw Error(p(160));ak(f,g,e);X=null;Yj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)ek(b,a),b=b.sibling}\nfunction ek(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:dk(b,a);fk(a);if(d&4){try{Qj(3,a,a.return),Rj(3,a)}catch(t){W(a,a.return,t)}try{Qj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);break;case 5:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,\"\")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;\na.updateQueue=null;if(null!==k)try{\"input\"===h&&\"radio\"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];\"style\"===m?sb(e,q):\"dangerouslySetInnerHTML\"===m?nb(e,q):\"children\"===m?ob(e,q):ta(e,m,q,l)}switch(h){case \"input\":bb(e,f);break;case \"textarea\":ib(e,f);break;case \"select\":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,\nf.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:\"\",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:dk(b,a);fk(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:dk(b,a);fk(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:dk(b,a);fk(a);break;case 13:dk(b,a);fk(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||\nnull!==e.alternate&&null!==e.alternate.memoizedState||(gk=B()));d&4&&bk(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,dk(b,a),U=l):dk(b,a);fk(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Qj(4,r,r.return);break;case 1:Mj(r,r.return);var n=r.stateNode;if(\"function\"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=\nb.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Mj(r,r.return);break;case 22:if(null!==r.memoizedState){hk(q);continue}}null!==y?(y.return=r,V=y):hk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,\"function\"===typeof f.setProperty?f.setProperty(\"display\",\"none\",\"important\"):f.display=\"none\"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty(\"display\")?k.display:null,h.style.display=\nrb(\"display\",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?\"\":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:dk(b,a);fk(a);d&4&&bk(a);break;case 21:break;default:dk(b,\na),fk(a)}}function fk(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Uj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,\"\"),d.flags&=-33);var f=Vj(a);Xj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Vj(a);Wj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ik(a,b,c){V=a;jk(a,b,c)}\nfunction jk(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Kj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Kj;var l=U;Kj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?kk(e):null!==k?(k.return=g,V=k):kk(e);for(;null!==f;)V=f,jk(f,b,c),f=f.sibling;V=e;Kj=h;U=l}lk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):lk(a,b,c)}}\nfunction lk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Rj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Lg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&ih(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nb.child.stateNode;break;case 1:c=b.child.stateNode}ih(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case \"button\":case \"input\":case \"select\":case \"textarea\":k.autoFocus&&c.focus();break;case \"img\":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;\ndefault:throw Error(p(163));}U||b.flags&512&&Sj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function hk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}\nfunction kk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Rj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if(\"function\"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Sj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Sj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}\nvar mk=Math.ceil,nk=ua.ReactCurrentDispatcher,ok=ua.ReactCurrentOwner,pk=ua.ReactCurrentBatchConfig,K=0,R=null,Y=null,Z=0,gj=0,fj=Uf(0),T=0,qk=null,hh=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=Infinity,vk=null,Pi=!1,Qi=null,Si=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return 0!==(K&6)?B():-1!==Bk?Bk:Bk=B()}\nfunction lh(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Ck&&(Ck=yc()),Ck;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function mh(a,b,c,d){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==R)a===R&&(0===(K&2)&&(rk|=c),4===T&&Dk(a,Z)),Ek(a,d),1===c&&0===K&&0===(b.mode&1)&&(Hj=B()+500,fg&&jg())}\nfunction Ek(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===R?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Fk.bind(null,a)):hg(Fk.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Gk(c,Hk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Hk(a,b){Bk=-1;Ck=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Ik()&&a.callbackNode!==c)return null;var d=uc(a,a===R?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Jk(a,d);else{b=d;var e=K;K|=2;var f=Kk();if(R!==a||Z!==b)vk=null,Hj=B()+500,Lk(a,b);do try{Mk();break}catch(h){Nk(a,h)}while(1);Qg();nk.current=f;K=e;null!==Y?b=0:(R=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Ok(a,e)));if(1===b)throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;if(6===b)Dk(a,d);\nelse{e=a.current.alternate;if(0===(d&30)&&!Pk(e)&&(b=Jk(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Ok(a,f))),1===b))throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:Dk(a,d);if((d&130023424)===d&&(b=gk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){L();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),b);break}Qk(a,uk,vk);break;case 4:Dk(a,d);if((d&4194240)===\nd)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*mk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),d);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329));}}}Ek(a,B());return a.callbackNode===c?Hk.bind(null,a):null}\nfunction Ok(a,b){var c=tk;a.current.memoizedState.isDehydrated&&(Lk(a,b).flags|=256);a=Jk(a,b);2!==a&&(b=uk,uk=c,null!==b&&Gj(b));return a}function Gj(a){null===uk?uk=a:uk.push.apply(uk,a)}\nfunction Pk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Dk(a,b){b&=~sk;b&=~rk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Fk(a){if(0!==(K&6))throw Error(p(327));Ik();var b=uc(a,0);if(0===(b&1))return Ek(a,B()),null;var c=Jk(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Ok(a,d))}if(1===c)throw c=qk,Lk(a,0),Dk(a,b),Ek(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Qk(a,uk,vk);Ek(a,B());return null}\nfunction Rk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Hj=B()+500,fg&&jg())}}function Sk(a){null!==xk&&0===xk.tag&&0===(K&6)&&Ik();var b=K;K|=1;var c=pk.transition,d=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=d,pk.transition=c,K=b,0===(K&6)&&jg()}}function Ij(){gj=fj.current;E(fj)}\nfunction Lk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:Jh();E(Wf);E(H);Oh();break;case 5:Lh(d);break;case 4:Jh();break;case 13:E(M);break;case 19:E(M);break;case 10:Rg(d.type._context);break;case 22:case 23:Ij()}c=c.return}R=a;Y=a=wh(a.current,null);Z=gj=b;T=0;qk=null;sk=rk=hh=0;uk=tk=null;if(null!==Wg){for(b=\n0;b<Wg.length;b++)if(c=Wg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}Wg=null}return a}\nfunction Nk(a,b){do{var c=Y;try{Qg();Ph.current=ai;if(Sh){for(var d=N.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Sh=!1}Rh=0;P=O=N=null;Th=!1;Uh=0;ok.current=null;if(null===c||null===c.return){T=1;qk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&\"object\"===typeof k&&\"function\"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,\nm.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Vi(g);if(null!==y){y.flags&=-257;Wi(y,g,h,f,b);y.mode&1&&Ti(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Ti(f,l,b);uj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Vi(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Wi(J,g,h,f,b);Jg(Ki(k,h));break a}}f=k=Ki(k,h);4!==T&&(T=2);null===tk?tk=[f]:tk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;\nb&=-b;f.lanes|=b;var x=Oi(f,k,b);fh(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&(\"function\"===typeof w.getDerivedStateFromError||null!==u&&\"function\"===typeof u.componentDidCatch&&(null===Si||!Si.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Ri(f,h,b);fh(f,F);break a}}f=f.return}while(null!==f)}Tk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Kk(){var a=nk.current;nk.current=ai;return null===a?ai:a}\nfunction uj(){if(0===T||3===T||2===T)T=4;null===R||0===(hh&268435455)&&0===(rk&268435455)||Dk(R,Z)}function Jk(a,b){var c=K;K|=2;var d=Kk();if(R!==a||Z!==b)vk=null,Lk(a,b);do try{Uk();break}catch(e){Nk(a,e)}while(1);Qg();K=c;nk.current=d;if(null!==Y)throw Error(p(261));R=null;Z=0;return T}function Uk(){for(;null!==Y;)Vk(Y)}function Mk(){for(;null!==Y&&!cc();)Vk(Y)}function Vk(a){var b=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps;null===b?Tk(a):Y=b;ok.current=null}\nfunction Tk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Fj(c,b,gj),null!==c){Y=c;return}}else{c=Jj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Qk(a,b,c){var d=C,e=pk.transition;try{pk.transition=null,C=1,Xk(a,b,c,d)}finally{pk.transition=e,C=d}return null}\nfunction Xk(a,b,c,d){do Ik();while(null!==xk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===R&&(Y=R=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||wk||(wk=!0,Gk(hc,function(){Ik();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=pk.transition;pk.transition=null;\nvar g=C;C=1;var h=K;K|=4;ok.current=null;Pj(a,c);ek(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;ik(c,a,e);dc();K=h;C=g;pk.transition=f}else a.current=c;wk&&(wk=!1,xk=a,yk=e);f=a.pendingLanes;0===f&&(Si=null);mc(c.stateNode,d);Ek(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Pi)throw Pi=!1,a=Qi,Qi=null,a;0!==(yk&1)&&0!==a.tag&&Ik();f=a.pendingLanes;0!==(f&1)?a===Ak?zk++:(zk=0,Ak=a):zk=0;jg();return null}\nfunction Ik(){if(null!==xk){var a=Dc(yk),b=pk.transition,c=C;try{pk.transition=null;C=16>a?16:a;if(null===xk)var d=!1;else{a=xk;xk=null;yk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Qj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Tj(m);if(m===\nl){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Qj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nu)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Rj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&\"function\"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,pk.transition=b}}return!1}function Yk(a,b,c){b=Ki(c,b);b=Oi(a,b,1);a=dh(a,b,1);b=L();null!==a&&(Ac(a,1,b),Ek(a,b))}\nfunction W(a,b,c){if(3===a.tag)Yk(a,a,c);else for(;null!==b;){if(3===b.tag){Yk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if(\"function\"===typeof b.type.getDerivedStateFromError||\"function\"===typeof d.componentDidCatch&&(null===Si||!Si.has(d))){a=Ki(c,a);a=Ri(b,a,1);b=dh(b,a,1);a=L();null!==b&&(Ac(b,1,a),Ek(b,a));break}}b=b.return}}\nfunction Ui(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=L();a.pingedLanes|=a.suspendedLanes&c;R===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-gk?Lk(a,0):sk|=c);Ek(a,b)}function Zk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=L();a=Zg(a,b);null!==a&&(Ac(a,b,c),Ek(a,c))}function vj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Zk(a,c)}\nfunction ck(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Zk(a,c)}var Wk;\nWk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)Ug=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return Ug=!1,zj(a,b,c);Ug=0!==(a.flags&131072)?!0:!1}else Ug=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;jj(a,b);a=b.pendingProps;var e=Yf(b,H.current);Tg(b,c);e=Xh(null,b,d,a,e,c);var f=bi();b.flags|=1;\"object\"===typeof e&&null!==e&&\"function\"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=\nnull,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ah(b),e.updater=nh,b.stateNode=e,e._reactInternals=b,rh(b,d,a,c),b=kj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Yi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{jj(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=$k(d);a=Lg(d,a);switch(e){case 0:b=dj(null,b,d,a,c);break a;case 1:b=ij(null,b,d,a,c);break a;case 11:b=Zi(null,b,d,a,c);break a;case 14:b=aj(null,b,d,Lg(d.type,a),c);break a}throw Error(p(306,\nd,\"\"));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),dj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),ij(a,b,d,e,c);case 3:a:{lj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;bh(a,b);gh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=\nf,b.memoizedState=f,b.flags&256){e=Ki(Error(p(423)),b);b=mj(a,b,d,c,e);break a}else if(d!==e){e=Ki(Error(p(424)),b);b=mj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Ch(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=$i(a,b,c);break a}Yi(a,b,d,c)}b=b.child}return b;case 5:return Kh(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),\nhj(a,b),Yi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return pj(a,b,c);case 4:return Ih(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Bh(b,null,d,c):Yi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),Zi(a,b,d,e,c);case 7:return Yi(a,b,b.pendingProps,c),b.child;case 8:return Yi(a,b,b.pendingProps.children,c),b.child;case 12:return Yi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;\ng=e.value;G(Mg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=$i(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ch(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);Sg(f.return,\nc,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);Sg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Yi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Tg(b,c),e=Vg(e),d=d(e),b.flags|=1,Yi(a,b,d,c),\nb.child;case 14:return d=b.type,e=Lg(d,b.pendingProps),e=Lg(d.type,e),aj(a,b,d,e,c);case 15:return cj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),jj(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,Tg(b,c),ph(b,d,e),rh(b,d,e,c),kj(null,b,d,!0,a,c);case 19:return yj(a,b,c);case 22:return ej(a,b,c)}throw Error(p(156,b.tag));};function Gk(a,b){return ac(a,b)}\nfunction al(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new al(a,b,c,d)}function bj(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction $k(a){if(\"function\"===typeof a)return bj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}\nfunction wh(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction yh(a,b,c,d,e,f){var g=2;d=a;if(\"function\"===typeof a)bj(a)&&(g=1);else if(\"string\"===typeof a)g=5;else a:switch(a){case ya:return Ah(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return qj(c,e,f,b);default:if(\"object\"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;\nbreak a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,\"\"));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Ah(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function qj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function xh(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}\nfunction zh(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction bl(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=\nnull}function cl(a,b,c,d,e,f,g,h,k){a=new bl(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};ah(f);return a}function dl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:\"\"+d,children:a,containerInfo:b,implementation:c}}\nfunction el(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}\nfunction fl(a,b,c,d,e,f,g,h,k){a=cl(c,d,!0,a,e,f,g,h,k);a.context=el(null);c=a.current;d=L();e=lh(c);f=ch(d,e);f.callback=void 0!==b&&null!==b?b:null;dh(c,f,e);a.current.lanes=e;Ac(a,e,d);Ek(a,d);return a}function gl(a,b,c,d){var e=b.current,f=L(),g=lh(e);c=el(c);null===b.context?b.context=c:b.pendingContext=c;b=ch(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=dh(e,b,g);null!==a&&(mh(a,e,g,f),eh(a,e,g));return g}\nfunction hl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function jl(a,b){il(a,b);(a=a.alternate)&&il(a,b)}function kl(){return null}var ll=\"function\"===typeof reportError?reportError:function(a){console.error(a)};function ml(a){this._internalRoot=a}\nnl.prototype.render=ml.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));gl(a,b,null,null)};nl.prototype.unmount=ml.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Sk(function(){gl(null,a,null,null)});b[uf]=null}};function nl(a){this._internalRoot=a}\nnl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function pl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||\" react-mount-point-unstable \"!==a.nodeValue))}function ql(){}\nfunction rl(a,b,c,d,e){if(e){if(\"function\"===typeof d){var f=d;d=function(){var a=hl(g);f.call(a)}}var g=fl(b,d,a,0,null,!1,!1,\"\",ql);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Sk();return g}for(;e=a.lastChild;)a.removeChild(e);if(\"function\"===typeof d){var h=d;d=function(){var a=hl(k);h.call(a)}}var k=cl(a,0,!1,null,null,!1,!1,\"\",ql);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Sk(function(){gl(b,k,c,d)});return k}\nfunction sl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if(\"function\"===typeof e){var h=e;e=function(){var a=hl(g);h.call(a)}}gl(b,g,a,e)}else g=rl(c,b,a,e,d);return hl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Ek(b,B()),0===(K&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var b=Zg(a,1);if(null!==b){var c=L();mh(b,a,1,c)}}),jl(a,1)}};\nFc=function(a){if(13===a.tag){var b=Zg(a,134217728);if(null!==b){var c=L();mh(b,a,134217728,c)}jl(a,134217728)}};Gc=function(a){if(13===a.tag){var b=lh(a),c=Zg(a,b);if(null!==c){var d=L();mh(c,a,b,d)}jl(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};\nyb=function(a,b,c){switch(b){case \"input\":bb(a,c);b=c.name;if(\"radio\"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll(\"input[name=\"+JSON.stringify(\"\"+b)+'][type=\"radio\"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case \"textarea\":ib(a,c);break;case \"select\":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Rk;Hb=Sk;\nvar tl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Rk]},ul={findFiberByHostInstance:Wc,bundleType:0,version:\"18.2.0\",rendererPackageName:\"react-dom\"};\nvar vl={bundleType:ul.bundleType,version:ul.version,rendererPackageName:ul.rendererPackageName,rendererConfig:ul.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:ul.findFiberByHostInstance||\nkl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:\"18.2.0-next-9e3b772b8-20220608\"};if(\"undefined\"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var wl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl.isDisabled&&wl.supportsFiber)try{kc=wl.inject(vl),lc=wl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl;\nexports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ol(b))throw Error(p(200));return dl(a,b,null,c)};exports.createRoot=function(a,b){if(!ol(a))throw Error(p(299));var c=!1,d=\"\",e=ll;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=cl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ml(b)};\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if(\"function\"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(\",\");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Sk(a)};exports.hydrate=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!0,c)};\nexports.hydrateRoot=function(a,b,c){if(!ol(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f=\"\",g=ll;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=fl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,\ne);return new nl(b)};exports.render=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!pl(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Rk;\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!pl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return sl(a,b,c,!1,d)};exports.version=\"18.2.0-next-9e3b772b8-20220608\";\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","'use strict';\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.min.js');\n} else {\n  module.exports = require('./cjs/react-dom.development.js');\n}\n","/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if(\"object\"===typeof performance&&\"function\"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D=\"function\"===typeof setTimeout?setTimeout:null,E=\"function\"===typeof clearTimeout?clearTimeout:null,F=\"undefined\"!==typeof setImmediate?setImmediate:null;\n\"undefined\"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}\nfunction J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if(\"function\"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();\"function\"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;\nfunction M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if(\"function\"===typeof F)S=function(){F(R)};else if(\"undefined\"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}\nexports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};\nexports.unstable_forceFrameRate=function(a){0>a||125<a?console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};\nexports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();\"object\"===typeof c&&null!==c?(c=c.delay,c=\"number\"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};\nexports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineManifestParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary Creates a new offline manifest parser.\n * @implements {shaka.extern.ManifestParser}\n */\nshaka.offline.OfflineManifestParser = class {\n  /** */\n  constructor() {\n    /** @private {shaka.offline.OfflineUri} */\n    this.uri_ = null;\n  }\n\n  /** @override */\n  configure(config) {\n    // No-op\n  }\n\n  /** @override */\n  async start(uriString, playerInterface) {\n    /** @type {shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.parse(uriString);\n    this.uri_ = uri;\n\n    if (uri == null || !uri.isManifest()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          uriString);\n    }\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      const converter = new shaka.offline.ManifestConverter(\n          uri.mechanism(), uri.cell());\n\n      const finalManifest = converter.fromManifestDB(manifest);\n      playerInterface.makeTextStreamsForClosedCaptions(finalManifest);\n      return finalManifest;\n    } finally {\n      await muxer.destroy();\n    }\n  }\n\n  /** @override */\n  stop() {\n    return Promise.resolve();\n  }\n\n  /** @override */\n  update() {\n    // No-op\n  }\n\n  /** @override */\n  async onExpirationUpdated(sessionId, expiration) {\n    goog.asserts.assert(\n        this.uri_,\n        'Should not get update event before start has been called');\n\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = this.uri_;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      const foundSession = manifest.sessionIds.includes(sessionId);\n      const newExpiration = manifest.expiration == undefined ||\n                        manifest.expiration > expiration;\n\n      if (foundSession && newExpiration) {\n        shaka.log.debug('Updating expiration for stored content');\n        await cell.updateManifestExpiration(uri.key(), expiration);\n      }\n    } catch (e) {\n      // Ignore errors with update.\n      shaka.log.error('There was an error updating', uri, e);\n    } finally {\n      await muxer.destroy();\n    }\n  }\n};\n\n\nshaka.media.ManifestParser.registerParserByMime(\n    'application/x-offline-manifest',\n    () => new shaka.offline.OfflineManifestParser());\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.Ewma');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary\n * This class computes an exponentionally-weighted moving average.\n */\nshaka.abr.Ewma = class {\n  /**\n   * @param {number} halfLife The quantity of prior samples (by weight) used\n   *   when creating a new estimate.  Those prior samples make up half of the\n   *   new estimate.\n   */\n  constructor(halfLife) {\n    goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n\n    /**\n     * Larger values of alpha expire historical data more slowly.\n     * @private {number}\n     */\n    this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n\n    /** @private {number} */\n    this.estimate_ = 0;\n\n    /** @private {number} */\n    this.totalWeight_ = 0;\n  }\n\n\n  /**\n   * Update the alpha with a new halfLife value.\n   *\n   * @param {number} halfLife The quantity of prior samples (by weight) used\n   *   when creating a new estimate.  Those prior samples make up half of the\n   *   new estimate.\n   */\n  updateAlpha(halfLife) {\n    goog.asserts.assert(halfLife > 0, 'expected halfLife to be positive');\n    this.alpha_ = Math.exp(Math.log(0.5) / halfLife);\n  }\n\n\n  /**\n   * Takes a sample.\n   *\n   * @param {number} weight\n   * @param {number} value\n   */\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    const newEstimate = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n\n    if (!isNaN(newEstimate)) {\n      this.estimate_ = newEstimate;\n      this.totalWeight_ += weight;\n    }\n  }\n\n\n  /**\n   * @return {number}\n   */\n  getEstimate() {\n    const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n    return this.estimate_ / zeroFactor;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.EwmaBandwidthEstimator');\n\ngoog.require('shaka.abr.Ewma');\n\n\n/**\n * @summary\n * This class tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n *\n */\nshaka.abr.EwmaBandwidthEstimator = class {\n  /** */\n  constructor() {\n    /**\n     * A fast-moving average.\n     * Half of the estimate is based on the last 2 seconds of sample history.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.fast_ = new shaka.abr.Ewma(2);\n\n    /**\n     * A slow-moving average.\n     * Half of the estimate is based on the last 5 seconds of sample history.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.slow_ = new shaka.abr.Ewma(5);\n\n    /**\n     * Number of bytes sampled.\n     * @private {number}\n     */\n    this.bytesSampled_ = 0;\n\n\n    /**\n     * Minimum number of bytes sampled before we trust the estimate.  If we have\n     * not sampled much data, our estimate may not be accurate enough to trust.\n     * If bytesSampled_ is less than minTotalBytes_, we use defaultEstimate_.\n     * This specific value is based on experimentation.\n     *\n     * @private {number}\n     */\n    this.minTotalBytes_ = 128e3;  // 128kB\n\n    /**\n     * Minimum number of bytes, under which samples are discarded.  Our models\n     * do not include latency information, so connection startup time (time to\n     * first byte) is considered part of the download time.  Because of this, we\n     * should ignore very small downloads which would cause our estimate to be\n     * too low.\n     * This specific value is based on experimentation.\n     *\n     * @private {number}\n     */\n    this.minBytes_ = 16e3;  // 16kB\n  }\n\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes.\n   * Must be called at least once before init().\n   *\n   * @param {shaka.extern.AdvancedAbrConfiguration} config\n   */\n  configure(config) {\n    this.minTotalBytes_ = config.minTotalBytes;\n    this.minBytes_ = config.minBytes;\n    this.fast_.updateAlpha(config.fastHalfLife);\n    this.slow_.updateAlpha(config.slowHalfLife);\n  }\n\n\n  /**\n   * Takes a bandwidth sample.\n   *\n   * @param {number} durationMs The amount of time, in milliseconds, for a\n   *   particular request.\n   * @param {number} numBytes The total number of bytes transferred in that\n   *   request.\n   */\n  sample(\n      durationMs, numBytes) {\n    if (numBytes < this.minBytes_) {\n      return;\n    }\n\n    const bandwidth = 8000 * numBytes / durationMs;\n    const weight = durationMs / 1000;\n\n    this.bytesSampled_ += numBytes;\n    this.fast_.sample(weight, bandwidth);\n    this.slow_.sample(weight, bandwidth);\n  }\n\n\n  /**\n   * Gets the current bandwidth estimate.\n   *\n   * @param {number} defaultEstimate\n   * @return {number} The bandwidth estimate in bits per second.\n   */\n  getBandwidthEstimate(defaultEstimate) {\n    if (this.bytesSampled_ < this.minTotalBytes_) {\n      return defaultEstimate;\n    }\n\n    // Take the minimum of these two estimates.  This should have the effect\n    // of adapting down quickly, but up more slowly.\n    return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n  }\n\n\n  /**\n   * @return {boolean} True if there is enough data to produce a meaningful\n   *   estimate.\n   */\n  hasGoodEstimate() {\n    return this.bytesSampled_ >= this.minTotalBytes_;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.log');\n\ngoog.require('goog.asserts');\n\n/**\n * @summary\n * A console logging framework which is compiled out for deployment.  This is\n * only available when using the uncompiled version.\n * @exportDoc\n */\nshaka.log = class {\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {...*} args\n   */\n  static alwaysError(...args) {}\n\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {...*} args\n   */\n  static alwaysWarn(...args) {}\n\n  /**\n   * This always logs to the console, even in Release mode.  This should only be\n   * used for deprecation messages and things the app should never ignore.\n   *\n   * @param {string} id\n   * @param {...*} args\n   */\n  static warnOnce(id, ...args) {\n    if (shaka.log.oneTimeWarningIssued_.has(id)) {\n      return;\n    }\n\n    shaka.log.oneTimeWarningIssued_.add(id);\n    shaka.log.alwaysWarn(...args);\n  }\n\n  /**\n   * This log is for when an error occurs.  This should always be accompanied\n   * with an error event, thrown exception, or rejected Promise.  Logs are\n   * disabled in Release mode, so there should be other methods of detecting the\n   * error.\n   *\n   * @param {...*} args\n   */\n  static error(...args) {}\n\n  /**\n   * This log is for possible errors or things that may be surprising to a user.\n   * For example, if we work around unusual or bad content, we should warn that\n   * they should fix their content.  Deprecation messages and messages the app\n   * shouldn't ignore should use alwaysWarn instead.\n   *\n   * @param {...*} args\n   */\n  static warning(...args) {}\n\n  /**\n   * This log is for messages to the user about what is happening.  For example,\n   * when we update a manifest or install a polyfill.\n   *\n   * @param {...*} args\n   */\n  static info(...args) {}\n\n  /**\n   * This log is to aid *users* in debugging their content.  This should be for\n   * logs about the content and what we do with it.  For example, when we change\n   * streams or what we are choosing.\n   *\n   * @param {...*} args\n   */\n  static debug(...args) {}\n\n  /**\n   * This log is for debugging Shaka Player itself.  This may be logs about\n   * internal states or events.  This may also be for more verbose logs about\n   * content, such as for segment appends.\n   *\n   * @param {...*} args\n   */\n  static v1(...args) {}\n\n  /**\n   * This log is for tracing and debugging Shaka Player.  These logs will happen\n   * a lot, for example, logging every segment append or every update check.\n   * These are mostly used for tracking which calls happen through the code.\n   *\n   * @param {...*} args\n   */\n  static v2(...args) {}\n};\n\n\n/**\n * Log levels.\n * @enum {number}\n * @exportDoc\n */\nshaka.log.Level = {\n  NONE: 0,\n  ERROR: 1,\n  WARNING: 2,\n  INFO: 3,\n  DEBUG: 4,\n  V1: 5,\n  V2: 6,\n};\n\n\n/**\n * @define {number} the maximum log level.\n */\nshaka.log.MAX_LOG_LEVEL = 3;\n\n\n/**\n * A Set to indicate which one-time warnings have been issued.\n *\n * @private {!Set.<string>}\n */\nshaka.log.oneTimeWarningIssued_ = new Set();\n\n\n// IE8 has no console unless it is opened in advance.\n// IE9 console methods are not Functions and have no bind.\nif (window.console && window.console.log.bind) {\n  /** @private {!Object.<shaka.log.Level, function(...*)>} */\n  shaka.log.logMap_ = {\n    /* eslint-disable no-restricted-syntax */\n    [shaka.log.Level.ERROR]: console.error.bind(console),\n    [shaka.log.Level.WARNING]: console.warn.bind(console),\n    [shaka.log.Level.INFO]: console.info.bind(console),\n    [shaka.log.Level.DEBUG]: console.log.bind(console),\n    [shaka.log.Level.V1]: console.debug.bind(console),\n    [shaka.log.Level.V2]: console.debug.bind(console),\n    /* eslint-enable no-restricted-syntax */\n  };\n\n  shaka.log.alwaysWarn = shaka.log.logMap_[shaka.log.Level.WARNING];\n  shaka.log.alwaysError = shaka.log.logMap_[shaka.log.Level.ERROR];\n\n  if (goog.DEBUG) {\n    // Since we don't want to export shaka.log in production builds, we don't\n    // use the @export annotation.  But the module wrapper (used in debug builds\n    // since v2.5.11) hides anything non-exported.  This is a debug-only,\n    // API-based export to make sure logging is available in debug builds.\n    goog.exportSymbol('shaka.log', shaka.log);\n\n    /** @type {number} */\n    shaka.log.currentLevel;\n\n    /**\n     * Change the log level.  Useful for debugging in uncompiled mode.\n     *\n     * @param {number} level\n     * @exportDoc\n     */\n    shaka.log.setLevel = (level) => {\n      const getLog = (curLevel) => {\n        if (curLevel <= level) {\n          goog.asserts.assert(\n              shaka.log.logMap_[curLevel], 'Unexpected log level');\n          return shaka.log.logMap_[curLevel];\n        } else {\n          return () => {};\n        }\n      };\n\n      shaka.log.currentLevel = level;\n      shaka.log.error = getLog(shaka.log.Level.ERROR);\n      shaka.log.warning = getLog(shaka.log.Level.WARNING);\n      shaka.log.info = getLog(shaka.log.Level.INFO);\n      shaka.log.debug = getLog(shaka.log.Level.DEBUG);\n      shaka.log.v1 = getLog(shaka.log.Level.V1);\n      shaka.log.v2 = getLog(shaka.log.Level.V2);\n    };\n\n    shaka.log.setLevel(shaka.log.MAX_LOG_LEVEL);\n  } else {\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.ERROR) {\n      shaka.log.error = shaka.log.logMap_[shaka.log.Level.ERROR];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.WARNING) {\n      shaka.log.warning = shaka.log.logMap_[shaka.log.Level.WARNING];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.INFO) {\n      shaka.log.info = shaka.log.logMap_[shaka.log.Level.INFO];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.DEBUG) {\n      shaka.log.debug = shaka.log.logMap_[shaka.log.Level.DEBUG];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V1) {\n      shaka.log.v1 = shaka.log.logMap_[shaka.log.Level.V1];\n    }\n    if (shaka.log.MAX_LOG_LEVEL >= shaka.log.Level.V2) {\n      shaka.log.v2 = shaka.log.logMap_[shaka.log.Level.V2];\n    }\n  }\n}\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Capabilities');\n\n/**\n * @summary\n * This is for capturing all media source capabilities on current platform.\n * And this is for static check and can not be constructed.\n */\nshaka.media.Capabilities = class {\n  /**\n   * Cache browser engine call to improve performance on some poor platforms\n   *\n   * @param {string} type\n   * @return {boolean}\n   */\n  static isTypeSupported(type) {\n    const supportMap = shaka.media.Capabilities.MediaSourceTypeSupportMap;\n    if (supportMap.has(type)) {\n      return supportMap.get(type);\n    }\n    const currentSupport = MediaSource.isTypeSupported(type);\n    supportMap.set(type, currentSupport);\n    return currentSupport;\n  }\n};\n\n/**\n * Public it for unit test, and developer could also check the support map.\n * @type {!Map.<string, boolean>}\n */\nshaka.media.Capabilities.MediaSourceTypeSupportMap = new Map();\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ArrayUtils');\n\n\n/**\n * @namespace shaka.util.ArrayUtils\n * @summary Array utility functions.\n */\n\n\nshaka.util.ArrayUtils = class {\n  /**\n   * Returns whether the two values contain the same value.  This correctly\n   * handles comparisons involving NaN.\n   * @param {T} a\n   * @param {T} b\n   * @return {boolean}\n   * @template T\n   */\n  static defaultEquals(a, b) {\n    // NaN !== NaN, so we need to special case it.\n    if (typeof a === 'number' &&\n        typeof b === 'number' && isNaN(a) && isNaN(b)) {\n      return true;\n    }\n    return a === b;\n  }\n\n\n  /**\n   * Remove given element from array (assumes no duplicates).\n   * @param {!Array.<T>} array\n   * @param {T} element\n   * @template T\n   */\n  static remove(array, element) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n      array.splice(index, 1);\n    }\n  }\n\n\n  /**\n   * Count the number of items in the list that pass the check function.\n   * @param {!Array.<T>} array\n   * @param {function(T):boolean} check\n   * @return {number}\n   * @template T\n   */\n  static count(array, check) {\n    let count = 0;\n\n    for (const element of array) {\n      count += check(element) ? 1 : 0;\n    }\n\n    return count;\n  }\n\n\n  /**\n   * Determines if the given arrays contain equal elements in any order.\n   *\n   * @param {!Array.<T>} a\n   * @param {!Array.<T>} b\n   * @param {function(T, T):boolean=} compareFn\n   * @return {boolean}\n   * @template T\n   */\n  static hasSameElements(a, b, compareFn) {\n    if (!compareFn) {\n      compareFn = shaka.util.ArrayUtils.defaultEquals;\n    }\n    if (a.length != b.length) {\n      return false;\n    }\n\n    const copy = b.slice();\n    for (const item of a) {\n      const idx = copy.findIndex((other) => compareFn(item, other));\n      if (idx == -1) {\n        return false;\n      }\n      // Since order doesn't matter, just swap the last element with\n      // this one and then drop the last element.\n      copy[idx] = copy[copy.length - 1];\n      copy.pop();\n    }\n\n    return copy.length == 0;\n  }\n\n\n  /**\n   * Determines if the given arrays contain equal elements in the same order.\n   *\n   * @param {!Array.<T>} a\n   * @param {!Array.<T>} b\n   * @param {function(T, T):boolean=} compareFn\n   * @return {boolean}\n   * @template T\n   */\n  static equal(a, b, compareFn) {\n    if (!compareFn) {\n      compareFn = shaka.util.ArrayUtils.defaultEquals;\n    }\n    if (a.length != b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!compareFn(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Cue');\ngoog.provide('shaka.text.CueRegion');\n\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * @implements {shaka.extern.Cue}\n * @export\n */\nshaka.text.Cue = class {\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} payload\n   */\n  constructor(startTime, endTime, payload) {\n    const Cue = shaka.text.Cue;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.startTime = startTime;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.endTime = endTime;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.payload = payload;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.region = new shaka.text.CueRegion();\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.position = null;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.positionAlign = Cue.positionAlign.AUTO;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.size = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textAlign = Cue.textAlign.CENTER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.writingMode = Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.line = null;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineHeight = '';\n\n    /**\n     * Line Alignment is set to start by default.\n     * @override\n     * @exportInterface\n     */\n    this.lineAlign = Cue.lineAlign.START;\n\n    /**\n     * Set the captions at the bottom of the text container by default.\n     * @override\n     * @exportInterface\n     */\n    this.displayAlign = Cue.displayAlign.AFTER;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.color = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.backgroundColor = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.backgroundImage = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.border = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textShadow = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textStrokeColor = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textStrokeWidth = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontSize = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontWeight = Cue.fontWeight.NORMAL;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontStyle = Cue.fontStyle.NORMAL;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.fontFamily = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.letterSpacing = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.linePadding = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.opacity = 1;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.textDecoration = [];\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.wrapLine = true;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.id = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.nestedCues = [];\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.isContainer = false;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.lineBreak = false;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.cellResolution = {\n      columns: 32,\n      rows: 15,\n    };\n  }\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   * @return {!shaka.text.Cue}\n   */\n  static lineBreak(start, end) {\n    const cue = new shaka.text.Cue(start, end, '');\n    cue.lineBreak = true;\n    return cue;\n  }\n\n  /**\n   * Create a copy of the cue with the same properties.\n   * @return {!shaka.text.Cue}\n   * @suppress {checkTypes} since we must use [] and \"in\" with a struct type.\n   */\n  clone() {\n    const clone = new shaka.text.Cue(0, 0, '');\n\n    for (const k in this) {\n      clone[k] = this[k];\n\n      // Make copies of array fields, but only one level deep.  That way, if we\n      // change, for instance, textDecoration on the clone, we don't affect the\n      // original.\n      if (clone[k] && clone[k].constructor == Array) {\n        clone[k] = /** @type {!Array} */(clone[k]).slice();\n      }\n    }\n\n    return clone;\n  }\n\n  /**\n   * Check if two Cues have all the same values in all properties.\n   * @param {!shaka.text.Cue} cue1\n   * @param {!shaka.text.Cue} cue2\n   * @return {boolean}\n   * @suppress {checkTypes} since we must use [] and \"in\" with a struct type.\n   */\n  static equal(cue1, cue2) {\n    // Compare the start time, end time and payload of the cues first for\n    // performance optimization.  We can avoid the more expensive recursive\n    // checks if the top-level properties don't match.\n    // See: https://github.com/shaka-project/shaka-player/issues/3018\n    if (cue1.startTime != cue2.startTime || cue1.endTime != cue2.endTime ||\n      cue1.payload != cue2.payload) {\n      return false;\n    }\n    for (const k in cue1) {\n      if (k == 'startTime' || k == 'endTime' || k == 'payload') {\n        // Already compared.\n      } else if (k == 'nestedCues') {\n        // This uses shaka.text.Cue.equal rather than just this.equal, since\n        // otherwise recursing here will unbox the method and cause \"this\" to be\n        // undefined in deeper recursion.\n        if (!shaka.util.ArrayUtils.equal(\n            cue1.nestedCues, cue2.nestedCues, shaka.text.Cue.equal)) {\n          return false;\n        }\n      } else if (k == 'region' || k == 'cellResolution') {\n        for (const k2 in cue1[k]) {\n          if (cue1[k][k2] != cue2[k][k2]) {\n            return false;\n          }\n        }\n      } else if (Array.isArray(cue1[k])) {\n        if (!shaka.util.ArrayUtils.equal(cue1[k], cue2[k])) {\n          return false;\n        }\n      } else {\n        if (cue1[k] != cue2[k]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.positionAlign = {\n  'LEFT': 'line-left',\n  'RIGHT': 'line-right',\n  'CENTER': 'center',\n  'AUTO': 'auto',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textAlign = {\n  'LEFT': 'left',\n  'RIGHT': 'right',\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * Vertical alignments of the cues within their extents.\n * 'BEFORE' means displaying at the top of the captions container box, 'CENTER'\n *  means in the middle, 'AFTER' means at the bottom.\n * @enum {string}\n * @export\n */\nshaka.text.Cue.displayAlign = {\n  'BEFORE': 'before',\n  'CENTER': 'center',\n  'AFTER': 'after',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.direction = {\n  'HORIZONTAL_LEFT_TO_RIGHT': 'ltr',\n  'HORIZONTAL_RIGHT_TO_LEFT': 'rtl',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.writingMode = {\n  'HORIZONTAL_TOP_TO_BOTTOM': 'horizontal-tb',\n  'VERTICAL_LEFT_TO_RIGHT': 'vertical-lr',\n  'VERTICAL_RIGHT_TO_LEFT': 'vertical-rl',\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.Cue.lineInterpretation = {\n  'LINE_NUMBER': 0,\n  'PERCENTAGE': 1,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.lineAlign = {\n  'CENTER': 'center',\n  'START': 'start',\n  'END': 'end',\n};\n\n\n/**\n * Default text color according to\n * https://w3c.github.io/webvtt/#default-text-color\n * @enum {string}\n * @export\n */\nshaka.text.Cue.defaultTextColor = {\n  'white': '#FFF',\n  'lime': '#0F0',\n  'cyan': '#0FF',\n  'red': '#F00',\n  'yellow': '#FF0',\n  'magenta': '#F0F',\n  'blue': '#00F',\n  'black': '#000',\n};\n\n\n/**\n * Default text background color according to\n * https://w3c.github.io/webvtt/#default-text-background\n * @enum {string}\n * @export\n */\nshaka.text.Cue.defaultTextBackgroundColor = {\n  'bg_white': '#FFF',\n  'bg_lime': '#0F0',\n  'bg_cyan': '#0FF',\n  'bg_red': '#F00',\n  'bg_yellow': '#FF0',\n  'bg_magenta': '#F0F',\n  'bg_blue': '#00F',\n  'bg_black': '#000',\n};\n\n\n/**\n * In CSS font weight can be a number, where 400 is normal and 700 is bold.\n * Use these values for the enum for consistency.\n * @enum {number}\n * @export\n */\nshaka.text.Cue.fontWeight = {\n  'NORMAL': 400,\n  'BOLD': 700,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.fontStyle = {\n  'NORMAL': 'normal',\n  'ITALIC': 'italic',\n  'OBLIQUE': 'oblique',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.Cue.textDecoration = {\n  'UNDERLINE': 'underline',\n  'LINE_THROUGH': 'lineThrough',\n  'OVERLINE': 'overline',\n};\n\n\n/**\n * @implements {shaka.extern.CueRegion}\n * @struct\n * @export\n */\nshaka.text.CueRegion = class {\n  /** */\n  constructor() {\n    const CueRegion = shaka.text.CueRegion;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.id = '';\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorX = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorY = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.regionAnchorX = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.regionAnchorY = 0;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.width = 100;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.height = 100;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.heightUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.widthUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.viewportAnchorUnits = CueRegion.units.PERCENTAGE;\n\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.scroll = CueRegion.scrollMode.NONE;\n  }\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.text.CueRegion.units = {\n  'PX': 0,\n  'PERCENTAGE': 1,\n  'LINES': 2,\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.text.CueRegion.scrollMode = {\n  'NONE': '',\n  'UP': 'up',\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.BufferUtils');\n\n\n/**\n * @summary A set of BufferSource utility functions.\n * @export\n */\nshaka.util.BufferUtils = class {\n  /**\n   * Compare two buffers for equality.  For buffers of different types, this\n   * compares the underlying buffers as binary data.\n   *\n   * @param {?BufferSource} arr1\n   * @param {?BufferSource} arr2\n   * @return {boolean}\n   * @export\n   * @suppress {strictMissingProperties}\n   */\n  static equal(arr1, arr2) {\n    const BufferUtils = shaka.util.BufferUtils;\n    if (!arr1 && !arr2) {\n      return true;\n    }\n    if (!arr1 || !arr2) {\n      return false;\n    }\n    if (arr1.byteLength != arr2.byteLength) {\n      return false;\n    }\n\n    // Quickly check if these are views of the same buffer.  An ArrayBuffer can\n    // be passed but doesn't have a byteOffset field, so default to 0.\n    if (BufferUtils.unsafeGetArrayBuffer_(arr1) ==\n            BufferUtils.unsafeGetArrayBuffer_(arr2) &&\n        (arr1.byteOffset || 0) == (arr2.byteOffset || 0)) {\n      return true;\n    }\n\n    const uint8A = shaka.util.BufferUtils.toUint8(arr1);\n    const uint8B = shaka.util.BufferUtils.toUint8(arr2);\n    for (let i = 0; i < arr1.byteLength; i++) {\n      if (uint8A[i] != uint8B[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Gets the underlying ArrayBuffer of the given view.  The caller needs to\n   * ensure it uses the \"byteOffset\" and \"byteLength\" fields of the view to\n   * only use the same \"view\" of the data.\n   *\n   * @param {BufferSource} view\n   * @return {!ArrayBuffer}\n   * @private\n   */\n  static unsafeGetArrayBuffer_(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      return view.buffer;\n    }\n  }\n\n  /**\n   * Gets an ArrayBuffer that contains the data from the given TypedArray.  Note\n   * this will allocate a new ArrayBuffer if the object is a partial view of\n   * the data.\n   *\n   * @param {!BufferSource} view\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toArrayBuffer(view) {\n    if (view instanceof ArrayBuffer) {\n      return view;\n    } else {\n      if (view.byteOffset == 0 && view.byteLength == view.buffer.byteLength) {\n        // This is a TypedArray over the whole buffer.\n        return view.buffer;\n      }\n      // This is a \"view\" on the buffer.  Create a new buffer that only contains\n      // the data.  Note that since this isn't an ArrayBuffer, the \"new\" call\n      // will allocate a new buffer to hold the copy.\n      return new Uint8Array(view).buffer;\n    }\n  }\n\n  /**\n   * Creates a new Uint8Array view on the same buffer.  This clamps the values\n   * to be within the same view (i.e. you can't use this to move past the end\n   * of the view, even if the underlying buffer is larger).  However, you can\n   * pass a negative offset to access the data before the view.\n   *\n   * @param {BufferSource} data\n   * @param {number=} offset The offset from the beginning of this data's view\n   *   to start the new view at.\n   * @param {number=} length The byte length of the new view.\n   * @return {!Uint8Array}\n   * @export\n   */\n  static toUint8(data, offset = 0, length = Infinity) {\n    return shaka.util.BufferUtils.view_(data, offset, length, Uint8Array);\n  }\n\n  /**\n   * Creates a DataView over the given buffer.\n   *\n   * @see toUint8\n   * @param {BufferSource} buffer\n   * @param {number=} offset\n   * @param {number=} length\n   * @return {!DataView}\n   * @export\n   */\n  static toDataView(buffer, offset = 0, length = Infinity) {\n    return shaka.util.BufferUtils.view_(buffer, offset, length, DataView);\n  }\n\n  /**\n   * @param {BufferSource} data\n   * @param {number} offset\n   * @param {number} length\n   * @param {function(new:T, ArrayBuffer, number, number)} Type\n   * @return {!T}\n   * @template T\n   * @private\n   */\n  static view_(data, offset, length, Type) {\n    const buffer = shaka.util.BufferUtils.unsafeGetArrayBuffer_(data);\n    // Absolute end of the |data| view within |buffer|.\n    /** @suppress {strictMissingProperties} */\n    const dataEnd = (data.byteOffset || 0) + data.byteLength;\n    // Absolute start of the result within |buffer|.\n    /** @suppress {strictMissingProperties} */\n    const rawStart = (data.byteOffset || 0) + offset;\n    const start = Math.max(0, Math.min(rawStart, dataEnd));\n    // Absolute end of the result within |buffer|.\n    const end = Math.min(start + Math.max(length, 0), dataEnd);\n    return new Type(buffer, start, end - start);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Error');\n\n\n/**\n * @summary\n * Describes an error that happened.\n *\n * @description\n * This uses numerical codes to describe\n * which error happened.\n *\n * Some error are caused by errors from the browser.  In these cases, the error\n * object is provided as part of the <code>data</code> field.  System codes come\n * from the browser and may or may not be documented.  Here are some places\n * where the errors may be documented:\n * <ul>\n *   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaError\">MediaError</a>\n *   <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\">HTTP Codes</a>\n *   <li><a href=\"https://hresult.info\">Edge/PlayReady errors</a>\n * </ul>\n *\n * @export\n * @implements {shaka.extern.Error}\n * @extends {Error}\n */\nshaka.util.Error = class {\n  /**\n   * @param {shaka.util.Error.Severity} severity\n   * @param {shaka.util.Error.Category} category\n   * @param {shaka.util.Error.Code} code\n   * @param {...*} varArgs\n   */\n  constructor(severity, category, code, ...varArgs) {\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.severity = severity;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.category = category;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.code = code;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.data = varArgs;\n    /**\n     * @override\n     * @exportInterface\n     */\n    this.handled = false;\n\n    // This improves the formatting of Errors in failure messages in the tests.\n    if (goog.DEBUG) {\n      let categoryName = 'UNKNOWN';\n      let codeName = 'UNKNOWN';\n\n      for (const k in shaka.util.Error.Category) {\n        if (shaka.util.Error.Category[k] == this.category) {\n          categoryName = k;\n        }\n      }\n      for (const k in shaka.util.Error.Code) {\n        if (shaka.util.Error.Code[k] == this.code) {\n          codeName = k;\n        }\n      }\n\n      /**\n       * A human-readable version of the category and code.\n       * <i>(Only available in uncompiled mode.)</i>\n       *\n       * @const {string}\n       * @exportDoc\n       */\n      this.message = 'Shaka Error ' + categoryName + '.' + codeName +\n                     ' (' + this.data.toString() + ')';\n\n      if (shaka.util.Error.createStack) {\n        try {\n          throw new Error(this.message);\n        } catch (e) {\n          /**\n           * A stack-trace showing where the error occurred.\n           * <i>(Only available in uncompiled mode.)</i>\n           *\n           * @const {string}\n           * @exportDoc\n           */\n          this.stack = e.stack;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @return {string}\n   * @override\n   */\n  toString() {\n    return 'shaka.util.Error ' + JSON.stringify(this, null, '  ');\n  }\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * If true, create a stack trace in Error objects.\n   *\n   * Only available in uncompiled mode, and disabled in tests to avoid issues\n   * with karma-jasmine.  See comments in test/test/boot.js for details.\n   *\n   * @type {boolean}\n   */\n  shaka.util.Error.createStack = true;\n}\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Severity = {\n  /**\n   * An error occurred, but the Player is attempting to recover from the error.\n   *\n   * If the Player cannot ultimately recover, it still may not throw a CRITICAL\n   * error.  For example, retrying for a media segment will never result in\n   * a CRITICAL error (the Player will just retry forever).\n   */\n  'RECOVERABLE': 1,\n\n  /**\n   * A critical error that the library cannot recover from.  These usually cause\n   * the Player to stop loading or updating.  A new manifest must be loaded\n   * to reset the library.\n   */\n  'CRITICAL': 2,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Category = {\n  /** Errors from the network stack. */\n  'NETWORK': 1,\n\n  /** Errors parsing text streams. */\n  'TEXT': 2,\n\n  /** Errors parsing or processing audio or video streams. */\n  'MEDIA': 3,\n\n  /** Errors parsing the Manifest. */\n  'MANIFEST': 4,\n\n  /** Errors related to streaming. */\n  'STREAMING': 5,\n\n  /** Errors related to DRM. */\n  'DRM': 6,\n\n  /** Miscellaneous errors from the player. */\n  'PLAYER': 7,\n\n  /** Errors related to cast. */\n  'CAST': 8,\n\n  /** Errors in the database storage (offline). */\n  'STORAGE': 9,\n\n  /** Errors related to ad insertion. */\n  'ADS': 10,\n};\n\n\n/**\n * @enum {number}\n * @export\n */\nshaka.util.Error.Code = {\n  /**\n   * A network request was made using an unsupported URI scheme.\n   * <br> error.data[0] is the URI.\n   */\n  'UNSUPPORTED_SCHEME': 1000,\n\n  /**\n   * An HTTP network request returned an HTTP status that indicated a failure.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the status code.\n   * <br> error.data[2] is the response text, or null if the response could not\n   *   be interpretted as text.\n   * <br> error.data[3] is the map of response headers.\n   * <br> error.data[4] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'BAD_HTTP_STATUS': 1001,\n\n  /**\n   * An HTTP network request failed with an error, but not from the server.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the original error.\n   * <br> error.data[2] is the NetworkingEngine.RequestType of the request.\n   */\n  'HTTP_ERROR': 1002,\n\n  /**\n   * A network request timed out.\n   * <br> error.data[0] is the URI.\n   * <br> error.data[1] is the NetworkingEngine.RequestType of the request,\n   *   if one was provided.\n   */\n  'TIMEOUT': 1003,\n\n  /**\n   * A network request was made with a malformed data URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_DATA_URI': 1004,\n\n  // RETIRED: 'UNKNOWN_DATA_URI_ENCODING': 1005,\n\n  /**\n   * A request filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'REQUEST_FILTER_ERROR': 1006,\n\n  /**\n   * A response filter threw an error.\n   * <br> error.data[0] is the original error.\n   */\n  'RESPONSE_FILTER_ERROR': 1007,\n\n  /**\n   * A testing network request was made with a malformed URI.\n   * This error is only used by unit and integration tests.\n   */\n  'MALFORMED_TEST_URI': 1008,\n\n  /**\n   * An unexpected network request was made to the FakeNetworkingEngine.\n   * This error is only used by unit and integration tests.\n   */\n  'UNEXPECTED_TEST_REQUEST': 1009,\n\n  /**\n   * The number of retry attempts have run out.\n   * This is an internal error and shouldn't be propagated.\n   */\n  'ATTEMPTS_EXHAUSTED': 1010,\n\n  /**\n   * The segment is missing.\n   * <br> error.data[0] is the URI.\n   */\n  'SEGMENT_MISSING': 1011,\n\n\n  /** The text parser failed to parse a text stream due to an invalid header. */\n  'INVALID_TEXT_HEADER': 2000,\n\n  /**\n   * The text parser failed to parse a text stream due to an invalid cue.\n   * <br> error.data[0] is extra context, if available.\n   */\n  'INVALID_TEXT_CUE': 2001,\n\n  // RETIRED: 'INVALID_TEXT_SETTINGS': 2002,\n\n  /**\n   * Was unable to detect the encoding of the response text.  Suggest adding\n   * byte-order-markings to the response data.\n   */\n  'UNABLE_TO_DETECT_ENCODING': 2003,\n\n  /** The response data contains invalid Unicode character encoding. */\n  'BAD_ENCODING': 2004,\n\n  /**\n   * The XML parser failed to parse an xml stream, or the XML lacks mandatory\n   * elements for TTML.\n   * <br> error.data[0] is extra context, if available.\n   */\n  'INVALID_XML': 2005,\n\n  // RETIRED: 'INVALID_TTML': 2006,\n\n  /**\n   * MP4 segment does not contain TTML.\n   */\n  'INVALID_MP4_TTML': 2007,\n\n  /**\n   * MP4 segment does not contain VTT.\n   */\n  'INVALID_MP4_VTT': 2008,\n\n  /**\n   * When examining media in advance, we were unable to extract the cue time.\n   * This should only be possible with HLS, where we do not have explicit\n   * segment start times.\n   * <br> error.data[0] is the underlying exception or Error object.\n   */\n  'UNABLE_TO_EXTRACT_CUE_START_TIME': 2009,\n\n  /**\n   * MP4 segment for CEA data is invalid.\n   */\n  'INVALID_MP4_CEA': 2010,\n\n  /**\n   * Unable to guess mime type of the text.\n   * <br> error.data[0] is the text file's extension.\n   */\n  'TEXT_COULD_NOT_GUESS_MIME_TYPE': 2011,\n\n  /**\n   * External text tracks cannot be added in src= because native platform\n   * doesn't support it.\n   */\n  'CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS': 2012,\n\n  /**\n   * Only WebVTT is supported when using src=.\n   * <br> error.data[0] is the text MIME type.\n   */\n  'TEXT_ONLY_WEBVTT_SRC_EQUALS': 2013,\n\n  /**\n   * The compilation does not contain a required text plugin for this\n   * operation.\n   * <br> error.data[0] is the text MIME type.\n   */\n  'MISSING_TEXT_PLUGIN': 2014,\n\n  /**\n   * The chapters track failed to load.  The browser does not provide any\n   * information in this case to identify why it failed, but there may be\n   * details in the JavaScript console.\n   */\n  'CHAPTERS_TRACK_FAILED': 2015,\n\n  /**\n   * External thumbnails tracks cannot be added in src= because native platform\n   * doesn't support it.\n   */\n  'CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_SRC_EQUALS': 2016,\n\n  /**\n   * Only external urls of WebVTT type are supported.\n   * <br> error.data[0] is the uri.\n   */\n  'UNSUPPORTED_EXTERNAL_THUMBNAILS_URI': 2017,\n\n  /**\n   * Some component tried to read past the end of a buffer.  The segment index,\n   * init segment, or PSSH may be malformed.\n   */\n  'BUFFER_READ_OUT_OF_BOUNDS': 3000,\n\n  /**\n   * Some component tried to parse an integer that was too large to fit in a\n   * JavaScript number without rounding error.  JavaScript can only natively\n   * represent integers up to 53 bits.\n   */\n  'JS_INTEGER_OVERFLOW': 3001,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered an integer,\n   * ID, or other field larger than the maximum supported by the parser.\n   */\n  'EBML_OVERFLOW': 3002,\n\n  /**\n   * The EBML parser used to parse the WebM container encountered a floating-\n   * point field of a size not supported by the parser.\n   */\n  'EBML_BAD_FLOATING_POINT_SIZE': 3003,\n\n  /**\n   * The MP4 SIDX parser found the wrong box type.\n   * Either the segment index range is incorrect or the data is corrupt.\n   */\n  'MP4_SIDX_WRONG_BOX_TYPE': 3004,\n\n  /**\n   * The MP4 SIDX parser encountered an invalid timescale.\n   * The segment index data may be corrupt.\n   */\n  'MP4_SIDX_INVALID_TIMESCALE': 3005,\n\n  /** The MP4 SIDX parser encountered a type of SIDX that is not supported. */\n  'MP4_SIDX_TYPE_NOT_SUPPORTED': 3006,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cues element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUES_ELEMENT_MISSING': 3007,\n\n  /**\n   * The WebM header parser was unable to locate the Ebml element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_EBML_HEADER_ELEMENT_MISSING': 3008,\n\n  /**\n   * The WebM header parser was unable to locate the Segment element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_SEGMENT_ELEMENT_MISSING': 3009,\n\n  /**\n   * The WebM header parser was unable to locate the Info element.\n   * The init segment data may be corrupt.\n   */\n  'WEBM_INFO_ELEMENT_MISSING': 3010,\n\n  /**\n   * The WebM header parser was unable to locate the Duration element.\n   * The init segment data may be corrupt or may have been incorrectly encoded.\n   * Shaka requires a duration in WebM DASH content.\n   */\n  'WEBM_DURATION_ELEMENT_MISSING': 3011,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Track Positions element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING': 3012,\n\n  /**\n   * The WebM Cues parser was unable to locate the Cue Time element.\n   * The segment index data may be corrupt.\n   */\n  'WEBM_CUE_TIME_ELEMENT_MISSING': 3013,\n\n  /**\n   * A MediaSource operation failed.\n   * <br> error.data[0] is a MediaError code from the video element.\n   */\n  'MEDIA_SOURCE_OPERATION_FAILED': 3014,\n\n  /**\n   * A MediaSource operation threw an exception.\n   * <br> error.data[0] is the exception that was thrown.\n   */\n  'MEDIA_SOURCE_OPERATION_THREW': 3015,\n\n  /**\n   * The video element reported an error.\n   * <br> error.data[0] is a MediaError code from the video element.\n   * <br> On Edge, error.data[1] is a Microsoft extended error code in hex.\n   * <br> On Chrome, error.data[2] is a string with details on the error.\n   * <br> See top of file for links to browser error codes.\n   */\n  'VIDEO_ERROR': 3016,\n\n  /**\n   * A MediaSource operation threw QuotaExceededError and recovery failed. The\n   * content cannot be played correctly because the segments are too large for\n   * the browser/platform. This may occur when attempting to play very high\n   * quality, very high bitrate content on low-end devices.\n   * <br> error.data[0] is the type of content which caused the error.\n   */\n  'QUOTA_EXCEEDED_ERROR': 3017,\n\n  /**\n   * Mux.js did not invoke the callback signifying successful transmuxing.\n   */\n  'TRANSMUXING_FAILED': 3018,\n\n  /**\n   * Content transformations required by the platform could not be performed for\n   * some reason (unsupported container, etc.)\n   *\n   * @see https://github.com/shaka-project/shaka-player/issues/2759\n   */\n  'CONTENT_TRANSFORMATION_FAILED': 3019,\n\n\n  /**\n   * The Player was unable to guess the manifest type based on file extension\n   * or MIME type.  To fix, try one of the following:\n   * <br><ul>\n   *   <li>Rename the manifest so that the URI ends in a well-known extension.\n   *   <li>Configure the server to send a recognizable Content-Type header.\n   *   <li>Configure the server to accept a HEAD request for the manifest.\n   * </ul>\n   * <br> error.data[0] is the manifest URI.\n   */\n  'UNABLE_TO_GUESS_MANIFEST_TYPE': 4000,\n\n  /**\n   * The DASH Manifest contained invalid XML markup.\n   * <br> error.data[0] is the URI associated with the XML.\n   */\n  'DASH_INVALID_XML': 4001,\n\n  /**\n   * The DASH Manifest contained a Representation with insufficient segment\n   * information.\n   */\n  'DASH_NO_SEGMENT_INFO': 4002,\n\n  /** The DASH Manifest contained an AdaptationSet with no Representations. */\n  'DASH_EMPTY_ADAPTATION_SET': 4003,\n\n  /** The DASH Manifest contained an Period with no AdaptationSets. */\n  'DASH_EMPTY_PERIOD': 4004,\n\n  /**\n   * The DASH Manifest does not specify an init segment with a WebM container.\n   */\n  'DASH_WEBM_MISSING_INIT': 4005,\n\n  /** The DASH Manifest contained an unsupported container format. */\n  'DASH_UNSUPPORTED_CONTAINER': 4006,\n\n  /** The embedded PSSH data has invalid encoding. */\n  'DASH_PSSH_BAD_ENCODING': 4007,\n\n  /**\n   * There is an AdaptationSet whose Representations do not have any common\n   * key-systems.\n   */\n  'DASH_NO_COMMON_KEY_SYSTEM': 4008,\n\n  /** Having multiple key IDs per Representation is not supported. */\n  'DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED': 4009,\n\n  /** The DASH Manifest specifies conflicting key IDs. */\n  'DASH_CONFLICTING_KEY_IDS': 4010,\n\n  // RETIRED: 'UNPLAYABLE_PERIOD': 4011,\n\n  /**\n   * There exist some streams that could be decoded, but restrictions imposed\n   * by the application or the key system prevent us from playing.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li>The application has given restrictions to the Player that restrict\n   *       at least one content type completely (e.g. no playable audio).\n   *   <li>The manifest specifies different keys than were given to us from the\n   *       license server.\n   *   <li>The key system has imposed output restrictions that cannot be met\n   *       (such as HDCP) and there are no unrestricted alternatives.\n   * </ul>\n   * <br> error.data[0] is a {@link shaka.extern.RestrictionInfo} object\n   * describing the kinds of restrictions that caused this error.\n   */\n  'RESTRICTIONS_CANNOT_BE_MET': 4012,\n\n  // RETIRED: 'INTERNAL_ERROR_KEY_STATUS': 4013,\n\n  // RETIRED: 'NO_PERIODS': 4014,\n\n  /**\n   * HLS playlist doesn't start with a mandory #EXTM3U tag.\n   */\n  'HLS_PLAYLIST_HEADER_MISSING': 4015,\n\n  /**\n   * HLS tag has an invalid name that doesn't start with '#EXT'\n   * <br> error.data[0] is the invalid tag.\n   */\n  'INVALID_HLS_TAG': 4016,\n\n  /**\n   * HLS playlist has both Master and Media/Segment tags.\n   */\n  'HLS_INVALID_PLAYLIST_HIERARCHY': 4017,\n\n  /**\n   * A Representation has an id that is the same as another Representation in\n   * the same Period.  This makes manifest updates impossible since we cannot\n   * map the updated Representation to the old one.\n   */\n  'DASH_DUPLICATE_REPRESENTATION_ID': 4018,\n\n  // RETIRED: 'HLS_MEDIA_INIT_SECTION_INFO_MISSING': 4019,\n\n  /**\n   * HLS manifest has several #EXT-X-MAP tags. We can only\n   * support one at the moment.\n   */\n  'HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND': 4020,\n\n  // RETIRED: 'HLS_COULD_NOT_GUESS_MIME_TYPE': 4021,\n\n  // RETIRED: 'HLS_MASTER_PLAYLIST_NOT_PROVIDED': 4022,\n\n  /**\n   * One of the required attributes was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing attribute's name.\n   */\n  'HLS_REQUIRED_ATTRIBUTE_MISSING': 4023,\n\n  /**\n   * One of the required tags was not provided, so the\n   * HLS manifest is invalid.\n   * <br> error.data[0] is the missing tag's name.\n   */\n  'HLS_REQUIRED_TAG_MISSING': 4024,\n\n  /**\n   * The HLS parser was unable to guess codecs of a stream.\n   * <br> error.data[0] is the list of all codecs for the variant.\n   */\n  'HLS_COULD_NOT_GUESS_CODECS': 4025,\n\n  /**\n   * The HLS parser has encountered encrypted content with unsupported\n   * KEYFORMAT attributes.\n   */\n  'HLS_KEYFORMATS_NOT_SUPPORTED': 4026,\n\n  /**\n   * The manifest parser only supports xlink links with xlink:actuate=\"onLoad\".\n   */\n  'DASH_UNSUPPORTED_XLINK_ACTUATE': 4027,\n\n  /**\n   * The manifest parser has hit its depth limit on xlink link chains.\n   */\n  'DASH_XLINK_DEPTH_LIMIT': 4028,\n\n  // RETIRED: 'HLS_LIVE_CONTENT_NOT_SUPPORTED': 4029,\n\n  // RETIRED: 'HLS_COULD_NOT_PARSE_SEGMENT_START_TIME': 4030,\n\n  // RETIRED: 'HLS_MEDIA_SEQUENCE_REQUIRED_IN_LIVE_STREAMS': 4031,\n\n  /**\n   * The content container or codecs are not supported by this browser. For\n   * example, this could happen if the content is WebM, but your browser does\n   * not support the WebM container, or if the content uses HEVC, but your\n   * browser does not support the HEVC codec.  This can also occur for\n   * multicodec or multicontainer manifests if none of the codecs or containers\n   * are supported by the browser.\n   *\n   * To see what your browser supports, you can check the JSON data dumped by\n   * http://support.shaka-player-demo.appspot.com/\n   */\n  'CONTENT_UNSUPPORTED_BY_BROWSER': 4032,\n\n  /**\n   * External text tracks cannot be added to live streams.\n   */\n  'CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM': 4033,\n\n  // RETIRED: 'HLS_AES_128_ENCRYPTION_NOT_SUPPORTED': 4034,\n  // RETIRED: 'HLS_INTERNAL_SKIP_STREAM': 4035,\n\n  /** The Manifest contained no Variants. */\n  'NO_VARIANTS': 4036,\n\n  /**\n   * We failed to find matching streams across DASH Periods, and the\n   * period-flattening aglorithm introduced in v3.0 has failed.\n   */\n  'PERIOD_FLATTENING_FAILED': 4037,\n\n  /**\n   * We failed to find matching streams across DASH Periods due to inconsistent\n   * DRM systems across periods.\n   */\n  'INCONSISTENT_DRM_ACROSS_PERIODS': 4038,\n\n  /**\n   * The HLS manifest refers to an undeclared variables.\n   * <br> error.data[0] is the variable undeclared.\n   */\n  'HLS_VARIABLE_NOT_FOUND': 4039,\n\n  /**\n   * We do not support playing encrypted mp2t with MSE\n   */\n  'HLS_MSE_ENCRYPTED_MP2T_NOT_SUPPORTED': 4040,\n\n  /**\n   * We do not support playing encrypted content (different than mp2t) with MSE\n   * and legacy Apple MediaKeys API.\n   */\n  'HLS_MSE_ENCRYPTED_LEGACY_APPLE_MEDIA_KEYS_NOT_SUPPORTED': 4041,\n\n  /**\n   * Web Crypto API is not available (to decrypt AES-128 streams). Web Crypto\n   * only exists in secure origins like https.\n   */\n  'NO_WEB_CRYPTO_API': 4042,\n\n  /**\n   * AES-128 iv length should be 16 bytes.\n   */\n  'HLS_AES_128_INVALID_IV_LENGTH': 4043,\n\n  /**\n   * AES-128 encryption key length should be 16 bytes.\n   */\n  'HLS_AES_128_INVALID_KEY_LENGTH': 4044,\n\n  /**\n   * External thumbnails tracks cannot be added to live streams.\n   */\n  'CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_LIVE_STREAM': 4045,\n\n\n  // RETIRED: 'INCONSISTENT_BUFFER_STATE': 5000,\n  // RETIRED: 'INVALID_SEGMENT_INDEX': 5001,\n  // RETIRED: 'SEGMENT_DOES_NOT_EXIST': 5002,\n  // RETIRED: 'CANNOT_SATISFY_BYTE_LIMIT': 5003,\n  // RETIRED: 'BAD_SEGMENT': 5004,\n  // RETIRED: 'INVALID_STREAMS_CHOSEN': 5005,\n\n  /**\n   * This would only happen if StreamingEngine were not started correctly, and\n   * should not be seen in production.\n   */\n  'STREAMING_ENGINE_STARTUP_INVALID_STATE': 5006,\n\n\n  /**\n   * The manifest indicated protected content, but the manifest parser was\n   * unable to determine what key systems should be used.\n   */\n  'NO_RECOGNIZED_KEY_SYSTEMS': 6000,\n\n  /**\n   * None of the requested key system configurations are available.  This may\n   * happen under the following conditions:\n   * <ul>\n   *   <li> The key system is not supported.\n   *   <li> The key system does not support the features requested (e.g.\n   *        persistent state).\n   *   <li> A user prompt was shown and the user denied access.\n   *   <li> The key system is not available from unsecure contexts. (i.e.\n            requires HTTPS) See https://bit.ly/2K9X1nY\n   * </ul>\n   */\n  'REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE': 6001,\n\n  /**\n   * The browser found one of the requested key systems, but it failed to\n   * create an instance of the CDM for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_CDM': 6002,\n\n  /**\n   * The browser found one of the requested key systems and created an instance\n   * of the CDM, but it failed to attach the CDM to the video for some unknown\n   * reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_ATTACH_TO_VIDEO': 6003,\n\n  /**\n   * The CDM rejected the server certificate supplied by the application.\n   * The certificate may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'INVALID_SERVER_CERTIFICATE': 6004,\n\n  /**\n   * The CDM refused to create a session for some unknown reason.\n   * <br> error.data[0] is an error message string from the browser.\n   */\n  'FAILED_TO_CREATE_SESSION': 6005,\n\n  /**\n   * The CDM was unable to generate a license request for the init data it was\n   * given.  The init data may be malformed or in an unsupported format.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> error.data[1] is the error object from the browser.\n   * <br> error.data[2] is a string with the extended error code, if available.\n   * <br> See top of file for links to browser error codes.\n   */\n  'FAILED_TO_GENERATE_LICENSE_REQUEST': 6006,\n\n  /**\n   * The license request failed.  This could be a timeout, a network failure, or\n   * a rejection by the server.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'LICENSE_REQUEST_FAILED': 6007,\n\n  /**\n   * The license response was rejected by the CDM.  The server's response may be\n   * invalid or malformed for this CDM.\n   * <br> error.data[0] is an error message string from the browser.\n   * <br> See top of file for links to browser error codes.\n   */\n  'LICENSE_RESPONSE_REJECTED': 6008,\n\n  // RETIRED: 'NO_LICENSE_SERVER_SPECIFIED': 6009,\n\n  /**\n   * The manifest does not specify any DRM info, but the content is encrypted.\n   * Either the manifest or the manifest parser are broken.\n   */\n  'ENCRYPTED_CONTENT_WITHOUT_DRM_INFO': 6010,\n\n  // RETIRED: 'WRONG_KEYS': 6011,\n\n  /**\n   * No license server was given for the key system signaled by the manifest.\n   * A license server URI is required for every key system.\n   * <br> error.data[0] is the key system identifier.\n   */\n  'NO_LICENSE_SERVER_GIVEN': 6012,\n\n  /**\n   * A required offline session was removed.  The content is not playable.\n   */\n  'OFFLINE_SESSION_REMOVED': 6013,\n\n  /**\n   * The license has expired.  This is triggered when all keys in the key\n   * status map have a status of 'expired'.\n   */\n  'EXPIRED': 6014,\n\n  /**\n   * A server certificate wasn't given when it is required.  FairPlay requires\n   * setting an explicit server certificate in the configuration.\n   */\n  'SERVER_CERTIFICATE_REQUIRED': 6015,\n\n  /**\n   * An error was thrown while executing the init data transformation.\n   * <br> error.data[0] is the original error.\n   */\n  'INIT_DATA_TRANSFORM_ERROR': 6016,\n\n  /**\n   * The server certificate request failed.\n   * <br> error.data[0] is a shaka.util.Error from the networking engine.\n   */\n  'SERVER_CERTIFICATE_REQUEST_FAILED': 6017,\n\n\n  /**\n   * The call to Player.load() was interrupted by a call to Player.unload()\n   * or another call to Player.load().\n   */\n  'LOAD_INTERRUPTED': 7000,\n\n  /**\n   * An internal error which indicates that an operation was aborted.  This\n   * should not be seen by applications.\n   */\n  'OPERATION_ABORTED': 7001,\n\n  /**\n   * The call to Player.load() failed because the Player does not have a video\n   * element.  The video element must either be provided to the constructor or\n   * to Player.attach() before Player.load() is called.\n   */\n  'NO_VIDEO_ELEMENT': 7002,\n\n  /**\n   * The operation failed because the object has been destroyed.\n   */\n  'OBJECT_DESTROYED': 7003,\n\n  /**\n   * The content has not been loaded in the Player.\n   */\n  'CONTENT_NOT_LOADED': 7004,\n\n  /**\n   * The Cast API is unavailable.  This may be because of one of the following:\n   *  1. The browser may not have Cast support\n   *  2. The browser may be missing a necessary Cast extension\n   *  3. The Cast sender library may not be loaded in your app\n   */\n  'CAST_API_UNAVAILABLE': 8000,\n\n  /**\n   * No cast receivers are available at this time.\n   */\n  'NO_CAST_RECEIVERS': 8001,\n\n  /**\n   * The library is already casting.\n   */\n  'ALREADY_CASTING': 8002,\n\n  /**\n   * A Cast SDK error that we did not explicitly plan for has occurred.\n   * Check data[0] and refer to the Cast SDK documentation for details.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'UNEXPECTED_CAST_ERROR': 8003,\n\n  /**\n   * The cast operation was canceled by the user.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CANCELED_BY_USER': 8004,\n\n  /**\n   * The cast connection timed out.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_CONNECTION_TIMED_OUT': 8005,\n\n  /**\n   * The requested receiver app ID does not exist or is unavailable.\n   * Check the requested app ID for typos.\n   * <br> error.data[0] is an error object from the Cast SDK.\n   */\n  'CAST_RECEIVER_APP_UNAVAILABLE': 8006,\n\n\n  // RETIRED: CAST_RECEIVER_APP_ID_MISSING': 8007,\n\n\n  /**\n   * Offline storage is not supported on this browser; it is required for\n   * offline support.\n   */\n  'STORAGE_NOT_SUPPORTED': 9000,\n\n  /**\n   * An unknown error occurred in the IndexedDB.\n   * <br> On Firefox, one common source for UnknownError calls is reverting\n   * Firefox to an old version. This makes the IndexedDB storage inaccessible\n   * for older versions. The only way to fix this is to delete the storage\n   * data in your profile. See https://mzl.la/2yCGWCm\n   * <br> error.data[0] is the error object.\n   */\n  'INDEXED_DB_ERROR': 9001,\n\n  /**\n   * The storage operation was aborted.  Deprecated in favor of more general\n   * OPERATION_ABORTED.\n   */\n  'DEPRECATED_OPERATION_ABORTED': 9002,\n\n  /**\n   * The specified item was not found in the IndexedDB.\n   * <br> error.data[0] is the offline URI.\n   */\n  'REQUESTED_ITEM_NOT_FOUND': 9003,\n\n  /**\n   * A network request was made with a malformed offline URI.\n   * <br> error.data[0] is the URI.\n   */\n  'MALFORMED_OFFLINE_URI': 9004,\n\n  /**\n   * The specified content is live or in-progress.\n   * Live and in-progress streams cannot be stored offline.\n   * <br> error.data[0] is the URI.\n   */\n  'CANNOT_STORE_LIVE_OFFLINE': 9005,\n\n  // RETIRED: 'STORE_ALREADY_IN_PROGRESS': 9006,\n\n  /**\n   * There was no init data available for offline storage.  This happens when\n   * there is no init data in the manifest nor could we find any in the\n   * segments.  We currently only support searching MP4 init segments for init\n   * data.\n   */\n  'NO_INIT_DATA_FOR_OFFLINE': 9007,\n\n  /**\n   * shaka.offline.Storage was constructed with a Player proxy instead of a\n   * local player instance.  To fix this, use Player directly with Storage\n   * instead of the results of CastProxy.prototype.getPlayer().\n   */\n  'LOCAL_PLAYER_INSTANCE_REQUIRED': 9008,\n\n  // RETIRED/MOVED TO 4000's: 'CONTENT_UNSUPPORTED_BY_BROWSER': 9009,\n\n  // RETIRED: 'UNSUPPORTED_UPGRADE_REQUEST': 9010,\n\n  /**\n   * The storage cell does not allow new operations that require new keys.\n   */\n  'NEW_KEY_OPERATION_NOT_SUPPORTED': 9011,\n\n  /**\n   * A key was not found in a storage cell.\n   */\n  'KEY_NOT_FOUND': 9012,\n\n  /**\n   * A storage cell was not found.\n   */\n  'MISSING_STORAGE_CELL': 9013,\n\n  /**\n   * The storage limit defined in <code>downloadSizeCallback</code> has been\n   * reached.\n   */\n  'STORAGE_LIMIT_REACHED': 9014,\n\n  /**\n   * <code>downloadSizeCallback</code> has produced an unexpected error.\n   */\n  'DOWNLOAD_SIZE_CALLBACK_ERROR': 9015,\n\n  /**\n   * The storage cell does not allow new operations that significantly change\n   * existing data.\n   */\n  'MODIFY_OPERATION_NOT_SUPPORTED': 9016,\n\n  /**\n   * When attempting to open an indexedDB instance, nothing happened for long\n   * enough for us to time out.  This keeps the storage mechanism from hanging\n   * indefinitely, if neither the success nor error callbacks are called.\n   */\n  'INDEXED_DB_INIT_TIMED_OUT': 9017,\n\n  /**\n   * CS IMA SDK, required for ad insertion, has not been included on the page.\n   */\n  'CS_IMA_SDK_MISSING': 10000,\n\n  /**\n   * Client Side Ad Manager needs to be initialized to enable Client Side\n   * Ad Insertion. Call adManager.initClientSide() to do it.\n   */\n  'CS_AD_MANAGER_NOT_INITIALIZED': 10001,\n\n  /**\n   * SS IMA SDK, required for ad insertion, has not been included on the page.\n   */\n  'SS_IMA_SDK_MISSING': 10002,\n\n  /**\n   * Server Side Ad Manager needs to be initialized to enable Server Side\n   * Ad Insertion. Call adManager.initServerSide() to do it.\n   */\n  'SS_AD_MANAGER_NOT_INITIALIZED': 10003,\n\n  /**\n   * A new DAI steam was requested before the previous request had been\n   * resolved. Only one stream request at a time is supported. Please wait\n   * for the previous request to complete before initiating a new one.\n   */\n  'CURRENT_DAI_REQUEST_NOT_FINISHED': 10004,\n};\n","/*! @license\n * Copyright 2008 The Closure Library Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Simple utilities for splitting URI strings.\n *\n * Uses features of RFC 3986 for parsing/formatting URIs:\n *   http://www.ietf.org/rfc/rfc3986.txt\n *\n * @author gboyer@google.com (Garrett Boyer) - The \"lightened\" design.\n * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.\n */\n\ngoog.provide('goog.uri.utils');\ngoog.provide('goog.uri.utils.ComponentIndex');\n\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @type {!RegExp}\n * @private\n */\ngoog.uri.utils.splitRe_ = new RegExp(\n    '^' +\n    '(?:' +\n        '([^:/?#.]+)' +                  // scheme - ignore special characters\n                                         // used by other URL parts such as :,\n                                         // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n        '(?:([^/?#]*)@)?' +              // userInfo\n        '([^/#?]*?)' +                   // domain\n        '(?::([0-9]+))?' +               // port\n        '(?=[/#?]|$)' +                  // authority-terminating character\n    ')?' +\n    '([^?#]+)?' +                        // path\n    '(?:\\\\?([^#]*))?' +                  // query\n    '(?:#(.*))?' +                       // fragment\n    '$');\n\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\ngoog.uri.utils.ComponentIndex = {\n  SCHEME: 1,\n  USER_INFO: 2,\n  DOMAIN: 3,\n  PORT: 4,\n  PATH: 5,\n  QUERY_DATA: 6,\n  FRAGMENT: 7\n};\n\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {string} uri The URI string to examine.\n * @return {!Array.<string|undefined>} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\ngoog.uri.utils.split = function(uri) {\n  // See @return comment -- never null.\n  return /** @type {!Array.<string|undefined>} */ (\n      uri.match(goog.uri.utils.splitRe_));\n};\n","/*! @license\n * Copyright 2006 The Closure Library Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class for parsing and formatting URIs.\n *\n * Use new goog.Uri(string) to parse a URI string.\n *\n * e.g: <code>var myUri = new goog.Uri(window.location);</code>\n *\n * Implements RFC 3986 for parsing/formatting URIs.\n * http://www.ietf.org/rfc/rfc3986.txt\n *\n * Some changes have been made to the interface (more like .NETs), though the\n * internal representation is now of un-encoded parts, this will change the\n * behavior slightly.\n *\n */\n\ngoog.provide('goog.Uri');\ngoog.provide('goog.Uri.QueryData');\n\ngoog.require('goog.asserts');\ngoog.require('goog.uri.utils');\ngoog.require('goog.uri.utils.ComponentIndex');\n\n\n\n/**\n * This class contains setters and getters for the parts of the URI.\n * The <code>getXyz</code>/<code>setXyz</code> methods return the decoded part\n * -- so<code>new goog.Uri('/foo%20bar').getPath()</code> will return the\n * decoded path, <code>/foo bar</code>.\n *\n * Reserved characters (see RFC 3986 section 2.2) can be present in\n * their percent-encoded form in scheme, domain, and path URI components and\n * will not be auto-decoded. For example:\n * <code>new goog.Uri('rel%61tive/path%2fto/resource').getPath()</code> will\n * return <code>relative/path%2fto/resource</code>.\n *\n * The constructor accepts an optional unparsed, raw URI string.  The parser\n * is relaxed, so special characters that aren't escaped but don't cause\n * ambiguities will not cause parse failures.\n *\n * All setters return <code>this</code> and so may be chained, a la\n * <code>new goog.Uri('/foo').setFragment('part').toString()</code>.\n *\n * @param {*=} uri Optional string URI to parse, or if a goog.Uri is\n *        passed, a clone is created.\n *\n * @constructor\n */\ngoog.Uri = function(uri) {\n  // Parse in the uri string\n  var m;\n  if (uri instanceof goog.Uri) {\n    this.setScheme(uri.getScheme());\n    this.setUserInfo(uri.getUserInfo());\n    this.setDomain(uri.getDomain());\n    this.setPort(uri.getPort());\n    this.setPath(uri.getPath());\n    this.setQueryData(uri.getQueryData().clone());\n    this.setFragment(uri.getFragment());\n  } else if (uri && (m = goog.uri.utils.split(String(uri)))) {\n    // Set the parts -- decoding as we do so.\n    // COMPATABILITY NOTE - In IE, unmatched fields may be empty strings,\n    // whereas in other browsers they will be undefined.\n    this.setScheme(m[goog.uri.utils.ComponentIndex.SCHEME] || '', true);\n    this.setUserInfo(m[goog.uri.utils.ComponentIndex.USER_INFO] || '', true);\n    this.setDomain(m[goog.uri.utils.ComponentIndex.DOMAIN] || '', true);\n    this.setPort(m[goog.uri.utils.ComponentIndex.PORT]);\n    this.setPath(m[goog.uri.utils.ComponentIndex.PATH] || '', true);\n    this.setQueryData(m[goog.uri.utils.ComponentIndex.QUERY_DATA] || '', true);\n    this.setFragment(m[goog.uri.utils.ComponentIndex.FRAGMENT] || '', true);\n  } else {\n    this.queryData_ = new goog.Uri.QueryData(null, null);\n  }\n};\n\n\n/**\n * Scheme such as \"http\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.scheme_ = '';\n\n\n/**\n * User credentials in the form \"username:password\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.userInfo_ = '';\n\n\n/**\n * Domain part, e.g. \"www.google.com\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.domain_ = '';\n\n\n/**\n * Port, e.g. 8080.\n * @type {?number}\n * @private\n */\ngoog.Uri.prototype.port_ = null;\n\n\n/**\n * Path, e.g. \"/tests/img.png\".\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.path_ = '';\n\n\n/**\n * Object representing query data.\n * @type {!goog.Uri.QueryData}\n * @private\n */\ngoog.Uri.prototype.queryData_;\n\n\n/**\n * The fragment without the #.\n * @type {string}\n * @private\n */\ngoog.Uri.prototype.fragment_ = '';\n\n\n/**\n * @return {string} The string form of the url.\n * @override\n */\ngoog.Uri.prototype.toString = function() {\n  var out = [];\n\n  var scheme = this.getScheme();\n  if (scheme) {\n    out.push(goog.Uri.encodeSpecialChars_(\n        scheme, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), ':');\n  }\n\n  var domain = this.getDomain();\n  if (domain) {\n    out.push('//');\n\n    var userInfo = this.getUserInfo();\n    if (userInfo) {\n      out.push(goog.Uri.encodeSpecialChars_(\n          userInfo, goog.Uri.reDisallowedInSchemeOrUserInfo_, true), '@');\n    }\n\n    out.push(goog.Uri.removeDoubleEncoding_(encodeURIComponent(domain)));\n\n    var port = this.getPort();\n    if (port != null) {\n      out.push(':', String(port));\n    }\n  }\n\n  var path = this.getPath();\n  if (path) {\n    if (this.hasDomain() && path.charAt(0) != '/') {\n      out.push('/');\n    }\n    out.push(goog.Uri.encodeSpecialChars_(\n        path,\n        path.charAt(0) == '/' ?\n            goog.Uri.reDisallowedInAbsolutePath_ :\n            goog.Uri.reDisallowedInRelativePath_,\n        true));\n  }\n\n  var query = this.getEncodedQuery();\n  if (query) {\n    out.push('?', query);\n  }\n\n  var fragment = this.getFragment();\n  if (fragment) {\n    out.push('#', goog.Uri.encodeSpecialChars_(\n        fragment, goog.Uri.reDisallowedInFragment_));\n  }\n  return out.join('');\n};\n\n\n/**\n * Resolves the given relative URI (a goog.Uri object), using the URI\n * represented by this instance as the base URI.\n *\n * There are several kinds of relative URIs:<br>\n * 1. foo - replaces the last part of the path, the whole query and fragment<br>\n * 2. /foo - replaces the the path, the query and fragment<br>\n * 3. //foo - replaces everything from the domain on.  foo is a domain name<br>\n * 4. ?foo - replace the query and fragment<br>\n * 5. #foo - replace the fragment only\n *\n * Additionally, if relative URI has a non-empty path, all \"..\" and \".\"\n * segments will be resolved, as described in RFC 3986.\n *\n * @param {goog.Uri} relativeUri The relative URI to resolve.\n * @return {!goog.Uri} The resolved URI.\n */\ngoog.Uri.prototype.resolve = function(relativeUri) {\n\n  var absoluteUri = this.clone();\n  if (absoluteUri.scheme_ === 'data') {\n    // Cannot have a relative URI to a data URI.\n    absoluteUri = new goog.Uri();\n  }\n\n  // we satisfy these conditions by looking for the first part of relativeUri\n  // that is not blank and applying defaults to the rest\n\n  var overridden = relativeUri.hasScheme();\n\n  if (overridden) {\n    absoluteUri.setScheme(relativeUri.getScheme());\n  } else {\n    overridden = relativeUri.hasUserInfo();\n  }\n\n  if (overridden) {\n    absoluteUri.setUserInfo(relativeUri.getUserInfo());\n  } else {\n    overridden = relativeUri.hasDomain();\n  }\n\n  if (overridden) {\n    absoluteUri.setDomain(relativeUri.getDomain());\n  } else {\n    overridden = relativeUri.hasPort();\n  }\n\n  var path = relativeUri.getPath();\n  if (overridden) {\n    absoluteUri.setPort(relativeUri.getPort());\n  } else {\n    overridden = relativeUri.hasPath();\n    if (overridden) {\n      // resolve path properly\n      if (path.charAt(0) != '/') {\n        // path is relative\n        if (this.hasDomain() && !this.hasPath()) {\n          // RFC 3986, section 5.2.3, case 1\n          path = '/' + path;\n        } else {\n          // RFC 3986, section 5.2.3, case 2\n          var lastSlashIndex = absoluteUri.getPath().lastIndexOf('/');\n          if (lastSlashIndex != -1) {\n            path = absoluteUri.getPath().substr(0, lastSlashIndex + 1) + path;\n          }\n        }\n      }\n      path = goog.Uri.removeDotSegments(path);\n    }\n  }\n\n  if (overridden) {\n    absoluteUri.setPath(path);\n  } else {\n    overridden = relativeUri.hasQuery();\n  }\n\n  if (overridden) {\n    absoluteUri.setQueryData(relativeUri.getQueryData().clone());\n  } else {\n    overridden = relativeUri.hasFragment();\n  }\n\n  if (overridden) {\n    absoluteUri.setFragment(relativeUri.getFragment());\n  }\n\n  return absoluteUri;\n};\n\n\n/**\n * Clones the URI instance.\n * @return {!goog.Uri} New instance of the URI object.\n */\ngoog.Uri.prototype.clone = function() {\n  return new goog.Uri(this);\n};\n\n\n/**\n * @return {string} The encoded scheme/protocol for the URI.\n */\ngoog.Uri.prototype.getScheme = function() {\n  return this.scheme_;\n};\n\n\n/**\n * Sets the scheme/protocol.\n * @param {string} newScheme New scheme value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setScheme = function(newScheme, decode) {\n  this.scheme_ = decode ? goog.Uri.decodeOrEmpty_(newScheme, true) :\n      newScheme;\n\n  // remove an : at the end of the scheme so somebody can pass in\n  // window.location.protocol\n  if (this.scheme_) {\n    this.scheme_ = this.scheme_.replace(/:$/, '');\n  }\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the scheme has been set.\n */\ngoog.Uri.prototype.hasScheme = function() {\n  return !!this.scheme_;\n};\n\n\n/**\n * @return {string} The decoded user info.\n */\ngoog.Uri.prototype.getUserInfo = function() {\n  return this.userInfo_;\n};\n\n\n/**\n * Sets the userInfo.\n * @param {string} newUserInfo New userInfo value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setUserInfo = function(newUserInfo, decode) {\n  this.userInfo_ = decode ? goog.Uri.decodeOrEmpty_(newUserInfo) :\n                   newUserInfo;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the user info has been set.\n */\ngoog.Uri.prototype.hasUserInfo = function() {\n  return !!this.userInfo_;\n};\n\n\n/**\n * @return {string} The decoded domain.\n */\ngoog.Uri.prototype.getDomain = function() {\n  return this.domain_;\n};\n\n\n/**\n * Sets the domain.\n * @param {string} newDomain New domain value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setDomain = function(newDomain, decode) {\n  this.domain_ = decode ? goog.Uri.decodeOrEmpty_(newDomain, true) :\n      newDomain;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the domain has been set.\n */\ngoog.Uri.prototype.hasDomain = function() {\n  return !!this.domain_;\n};\n\n\n/**\n * @return {?number} The port number.\n */\ngoog.Uri.prototype.getPort = function() {\n  return this.port_;\n};\n\n\n/**\n * Sets the port number.\n * @param {*} newPort Port number. Will be explicitly casted to a number.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPort = function(newPort) {\n  if (newPort) {\n    newPort = Number(newPort);\n    if (isNaN(newPort) || newPort < 0) {\n      throw Error('Bad port number ' + newPort);\n    }\n    this.port_ = newPort;\n  } else {\n    this.port_ = null;\n  }\n\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the port has been set.\n */\ngoog.Uri.prototype.hasPort = function() {\n  return this.port_ != null;\n};\n\n\n/**\n  * @return {string} The decoded path.\n */\ngoog.Uri.prototype.getPath = function() {\n  return this.path_;\n};\n\n\n/**\n * Sets the path.\n * @param {string} newPath New path value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setPath = function(newPath, decode) {\n  this.path_ = decode ? goog.Uri.decodeOrEmpty_(newPath, true) : newPath;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the path has been set.\n */\ngoog.Uri.prototype.hasPath = function() {\n  return !!this.path_;\n};\n\n\n/**\n * @return {boolean} Whether the query string has been set.\n */\ngoog.Uri.prototype.hasQuery = function() {\n  return this.queryData_.toString() !== '';\n};\n\n\n/**\n * Sets the query data.\n * @param {goog.Uri.QueryData|string|undefined} queryData QueryData object.\n * @param {boolean=} decode Optional param for whether to decode new value.\n *     Applies only if queryData is a string.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setQueryData = function(queryData, decode) {\n  if (queryData instanceof goog.Uri.QueryData) {\n    this.queryData_ = queryData;\n  } else {\n    if (!decode) {\n      // QueryData accepts encoded query string, so encode it if\n      // decode flag is not true.\n      queryData = goog.Uri.encodeSpecialChars_(queryData,\n                                               goog.Uri.reDisallowedInQuery_);\n    }\n    this.queryData_ = new goog.Uri.QueryData(queryData, null);\n  }\n\n  return this;\n};\n\n\n/**\n * @return {string} The encoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getEncodedQuery = function() {\n  return this.queryData_.toString();\n};\n\n\n/**\n * @return {string} The decoded URI query, not including the ?.\n */\ngoog.Uri.prototype.getDecodedQuery = function() {\n  return this.queryData_.toDecodedString();\n};\n\n\n/**\n * Returns the query data.\n * @return {!goog.Uri.QueryData} QueryData object.\n */\ngoog.Uri.prototype.getQueryData = function() {\n  return this.queryData_;\n};\n\n\n/**\n * @return {string} The URI fragment, not including the #.\n */\ngoog.Uri.prototype.getFragment = function() {\n  return this.fragment_;\n};\n\n\n/**\n * Sets the URI fragment.\n * @param {string} newFragment New fragment value.\n * @param {boolean=} decode Optional param for whether to decode new value.\n * @return {!goog.Uri} Reference to this URI object.\n */\ngoog.Uri.prototype.setFragment = function(newFragment, decode) {\n  this.fragment_ = decode ? goog.Uri.decodeOrEmpty_(newFragment) :\n                   newFragment;\n  return this;\n};\n\n\n/**\n * @return {boolean} Whether the URI has a fragment set.\n */\ngoog.Uri.prototype.hasFragment = function() {\n  return !!this.fragment_;\n};\n\n\n//==============================================================================\n// Static members\n//==============================================================================\n\n\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {string} path A non-empty path component.\n * @return {string} Path component with removed dot segments.\n */\ngoog.Uri.removeDotSegments = function(path) {\n  if (path == '..' || path == '.') {\n    return '';\n\n  } else if (path.indexOf('./') == -1 &&\n             path.indexOf('/.') == -1) {\n    // This optimization detects uris which do not contain dot-segments,\n    // and as a consequence do not require any processing.\n    return path;\n\n  } else {\n    var leadingSlash = (path.lastIndexOf('/', 0) == 0);\n    var segments = path.split('/');\n    var out = [];\n\n    for (var pos = 0; pos < segments.length; ) {\n      var segment = segments[pos++];\n\n      if (segment == '.') {\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else if (segment == '..') {\n        if (out.length > 1 || out.length == 1 && out[0] != '') {\n          out.pop();\n        }\n        if (leadingSlash && pos == segments.length) {\n          out.push('');\n        }\n      } else {\n        out.push(segment);\n        leadingSlash = true;\n      }\n    }\n\n    return out.join('/');\n  }\n};\n\n\n/**\n * Decodes a value or returns the empty string if it isn't defined or empty.\n * @param {string|undefined} val Value to decode.\n * @param {boolean=} preserveReserved If true, restricted characters will\n *     not be decoded.\n * @return {string} Decoded value.\n * @private\n */\ngoog.Uri.decodeOrEmpty_ = function(val, preserveReserved) {\n  // Don't use UrlDecode() here because val is not a query parameter.\n  if (!val) {\n    return '';\n  }\n\n  return preserveReserved ? decodeURI(val) : decodeURIComponent(val);\n};\n\n\n/**\n * If unescapedPart is non null, then escapes any characters in it that aren't\n * valid characters in a url and also escapes any special characters that\n * appear in extra.\n *\n * @param {(?string|undefined)} unescapedPart The string to encode.\n * @param {RegExp} extra A character set of characters in [\\01-\\177].\n * @param {boolean=} removeDoubleEncoding If true, remove double percent\n *     encoding.\n * @return {?string} null iff unescapedPart == null.\n * @private\n */\ngoog.Uri.encodeSpecialChars_ = function(unescapedPart, extra,\n    removeDoubleEncoding) {\n  if (unescapedPart != null) {\n    var encoded = encodeURI(unescapedPart).\n        replace(extra, goog.Uri.encodeChar_);\n    if (removeDoubleEncoding) {\n      // encodeURI double-escapes %XX sequences used to represent restricted\n      // characters in some URI components, remove the double escaping here.\n      encoded = goog.Uri.removeDoubleEncoding_(encoded);\n    }\n    return encoded;\n  }\n  return null;\n};\n\n\n/**\n * Converts a character in [\\01-\\177] to its unicode character equivalent.\n * @param {string} ch One character string.\n * @return {string} Encoded string.\n * @private\n */\ngoog.Uri.encodeChar_ = function(ch) {\n  var n = ch.charCodeAt(0);\n  return '%' + ((n >> 4) & 0xf).toString(16) + (n & 0xf).toString(16);\n};\n\n\n/**\n * Removes double percent-encoding from a string.\n * @param  {string} doubleEncodedString String\n * @return {string} String with double encoding removed.\n * @private\n */\ngoog.Uri.removeDoubleEncoding_ = function(doubleEncodedString) {\n  return doubleEncodedString.replace(/%25([0-9a-fA-F]{2})/g, '%$1');\n};\n\n\n/**\n * Regular expression for characters that are disallowed in the scheme or\n * userInfo part of the URI.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInSchemeOrUserInfo_ = /[#\\/\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in a relative path.\n * Colon is included due to RFC 3986 3.3.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInRelativePath_ = /[\\#\\?:]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in an absolute path.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInAbsolutePath_ = /[\\#\\?]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the query.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInQuery_ = /[\\#\\?@]/g;\n\n\n/**\n * Regular expression for characters that are disallowed in the fragment.\n * @type {RegExp}\n * @private\n */\ngoog.Uri.reDisallowedInFragment_ = /#/g;\n\n\n\n/**\n * Class used to represent URI query parameters.  It is essentially a hash of\n * name-value pairs, though a name can be present more than once.\n *\n * Has the same interface as the collections in goog.structs.\n *\n * @param {?string=} query Optional encoded query string to parse into\n *     the object.\n * @param {goog.Uri=} uri Optional uri object that should have its\n *     cache invalidated when this object updates. Deprecated -- this\n *     is no longer required.\n * @constructor\n * @final\n */\ngoog.Uri.QueryData = function(query, uri) {\n  /**\n   * Encoded query string, or null if it requires computing from the key map.\n   * @type {?string}\n   * @private\n   */\n  this.encodedQuery_ = query || null;\n};\n\n\n/**\n * If the underlying key map is not yet initialized, it parses the\n * query string and fills the map with parsed data.\n * @private\n */\ngoog.Uri.QueryData.prototype.ensureKeyMapInitialized_ = function() {\n  if (!this.keyMap_) {\n    this.keyMap_ = {};\n    this.count_ = 0;\n\n    if (this.encodedQuery_) {\n      var pairs = this.encodedQuery_.split('&');\n      for (var i = 0; i < pairs.length; i++) {\n        var indexOfEquals = pairs[i].indexOf('=');\n        var name = null;\n        var value = null;\n        if (indexOfEquals >= 0) {\n          name = pairs[i].substring(0, indexOfEquals);\n          value = pairs[i].substring(indexOfEquals + 1);\n        } else {\n          name = pairs[i];\n        }\n        name = decodeURIComponent(name.replace(/\\+/g, ' '));\n        value = value || '';\n        this.add(name, decodeURIComponent(value.replace(/\\+/g, ' ')));\n      }\n    }\n  }\n};\n\n\n/**\n * The map containing name/value or name/array-of-values pairs.\n * May be null if it requires parsing from the query string.\n *\n * We need to use a Map because we cannot guarantee that the key names will\n * not be problematic for IE.\n *\n * @type {Object.<string, !Array.<string>>}\n * @private\n */\ngoog.Uri.QueryData.prototype.keyMap_ = null;\n\n\n/**\n * The number of params, or null if it requires computing.\n * @type {?number}\n * @private\n */\ngoog.Uri.QueryData.prototype.count_ = null;\n\n\n/**\n * @return {?number} The number of parameters.\n */\ngoog.Uri.QueryData.prototype.getCount = function() {\n  this.ensureKeyMapInitialized_();\n  return this.count_;\n};\n\n\n/**\n * Adds a key value pair.\n * @param {string} key Name.\n * @param {string} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\ngoog.Uri.QueryData.prototype.add = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  // Invalidate the cache.\n  this.encodedQuery_ = null;\n\n  var values = this.keyMap_.hasOwnProperty(key) ? this.keyMap_[key] : null;\n  if (!values) {\n    this.keyMap_[key] = (values = []);\n  }\n  values.push(value);\n  goog.asserts.assert(this.count_ != null, 'Should not be null.');\n  this.count_++;\n  return this;\n};\n\n/**\n * Sets a key value pair and removes all other keys with the same value.\n *\n * @param {string} key Name.\n * @param {string} value Value.\n * @return {!goog.Uri.QueryData} Instance of this object.\n */\n goog.Uri.QueryData.prototype.set = function(key, value) {\n  this.ensureKeyMapInitialized_();\n  // Invalidate the cache.\n  this.encodedQuery_ = null;\n\n  if (!this.keyMap_.hasOwnProperty(key)) {\n    this.add(key, value);\n  } else {\n    this.keyMap_[key] = [value];\n  }\n\n  return this;\n};\n\n\n/**\n * @return {string} Encoded query string.\n * @override\n */\ngoog.Uri.QueryData.prototype.toString = function() {\n  if (this.encodedQuery_) {\n    return this.encodedQuery_;\n  }\n\n  if (!this.keyMap_) {\n    return '';\n  }\n\n  var sb = [];\n\n  for (var key in this.keyMap_) {\n    var encodedKey = encodeURIComponent(key);\n    var val = this.keyMap_[key];\n    for (var j = 0; j < val.length; j++) {\n      var param = encodedKey;\n      // Ensure that null and undefined are encoded into the url as\n      // literal strings.\n      if (val[j] !== '') {\n        param += '=' + encodeURIComponent(val[j]);\n      }\n      sb.push(param);\n    }\n  }\n\n  return this.encodedQuery_ = sb.join('&');\n};\n\n\n/**\n * @return {string} Decoded query string.\n */\ngoog.Uri.QueryData.prototype.toDecodedString = function() {\n  return goog.Uri.decodeOrEmpty_(this.toString());\n};\n\n\n/**\n * Clone the query data instance.\n * @return {!goog.Uri.QueryData} New instance of the QueryData object.\n */\ngoog.Uri.QueryData.prototype.clone = function() {\n  var rv = new goog.Uri.QueryData();\n  rv.encodedQuery_ = this.encodedQuery_;\n  if (this.keyMap_) {\n    var cloneMap = {};\n    for (var key in this.keyMap_) {\n      cloneMap[key] = this.keyMap_[key].concat();\n    }\n    rv.keyMap_ = cloneMap;\n    rv.count_ = this.count_;\n  }\n  return rv;\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Functional');\n\n/**\n * @summary A set of functional utility functions.\n */\nshaka.util.Functional = class {\n  /**\n   * Creates a promise chain that calls the given callback for each element in\n   * the array in a catch of a promise.\n   *\n   * e.g.:\n   * Promise.reject().catch(callback(array[0])).catch(callback(array[1]));\n   *\n   * @param {!Array.<ELEM>} array\n   * @param {function(ELEM):!Promise.<RESULT>} callback\n   * @return {!Promise.<RESULT>}\n   * @template ELEM,RESULT\n   */\n  static createFallbackPromiseChain(array, callback) {\n    return array.reduce((promise, elem) => {\n      return promise.catch(() => callback(elem));\n    }, Promise.reject());\n  }\n\n\n  /**\n   * Returns the first array concatenated to the second; used to collapse an\n   * array of arrays into a single array.\n   *\n   * @param {!Array.<T>} all\n   * @param {!Array.<T>} part\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static collapseArrays(all, part) {\n    return all.concat(part);\n  }\n\n  /**\n   * A no-op function that ignores its arguments.  This is used to suppress\n   * unused variable errors.\n   * @param {...*} args\n   */\n  static ignored(...args) {}\n\n\n  /**\n   * A no-op function.  Useful in promise chains.\n   */\n  static noop() {}\n\n\n  /**\n   * Returns if the given value is not null; useful for filtering out null\n   * values.\n   *\n   * @param {T} value\n   * @return {boolean}\n   * @template T\n   */\n  static isNotNull(value) {\n    return value != null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ManifestParserUtils');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\n\n\n/**\n * @summary Utility functions for manifest parsing.\n */\nshaka.util.ManifestParserUtils = class {\n  /**\n   * Resolves an array of relative URIs to the given base URIs. This will result\n   * in M*N number of URIs.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {!Array.<string>} relativeUris\n   * @return {!Array.<string>}\n   */\n  static resolveUris(baseUris, relativeUris) {\n    const Functional = shaka.util.Functional;\n    if (relativeUris.length == 0) {\n      return baseUris;\n    }\n\n    const relativeAsGoog = relativeUris.map((uri) => new goog.Uri(uri));\n    // Resolve each URI relative to each base URI, creating an Array of Arrays.\n    // Then flatten the Arrays into a single Array.\n    return baseUris.map((uri) => new goog.Uri(uri))\n        .map((base) => relativeAsGoog.map((i) => base.resolve(i)))\n        .reduce(Functional.collapseArrays, [])\n        .map((uri) => uri.toString());\n  }\n\n\n  /**\n   * Creates a DrmInfo object from the given info.\n   *\n   * @param {string} keySystem\n   * @param {Array.<shaka.extern.InitDataOverride>} initData\n   * @return {shaka.extern.DrmInfo}\n   */\n  static createDrmInfo(keySystem, initData) {\n    return {\n      keySystem: keySystem,\n      licenseServerUri: '',\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      serverCertificateUri: '',\n      sessionType: '',\n      initData: initData || [],\n      keyIds: new Set(),\n    };\n  }\n\n\n  /**\n   * Attempts to guess which codecs from the codecs list belong to a given\n   * content type.\n   * Assumes that at least one codec is correct, and throws if none are.\n   *\n   * @param {string} contentType\n   * @param {!Array.<string>} codecs\n   * @return {string}\n   */\n  static guessCodecs(contentType, codecs) {\n    if (codecs.length == 1) {\n      return codecs[0];\n    }\n\n    const match = shaka.util.ManifestParserUtils.guessCodecsSafe(\n        contentType, codecs);\n    // A failure is specifically denoted by null; an empty string represents a\n    // valid match of no codec.\n    if (match != null) {\n      return match;\n    }\n\n    // Unable to guess codecs.\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS,\n        codecs);\n  }\n\n\n  /**\n   * Attempts to guess which codecs from the codecs list belong to a given\n   * content type. Does not assume a single codec is anything special, and does\n   * not throw if it fails to match.\n   *\n   * @param {string} contentType\n   * @param {!Array.<string>} codecs\n   * @return {?string} or null if no match is found\n   */\n  static guessCodecsSafe(contentType, codecs) {\n    const formats = shaka.util.ManifestParserUtils\n        .CODEC_REGEXPS_BY_CONTENT_TYPE_[contentType];\n    for (const format of formats) {\n      for (const codec of codecs) {\n        if (format.test(codec.trim())) {\n          return codec.trim();\n        }\n      }\n    }\n\n    // Text does not require a codec string.\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.TEXT) {\n      return '';\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.ContentType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  TEXT: 'text',\n  IMAGE: 'image',\n  APPLICATION: 'application',\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.ManifestParserUtils.TextStreamKind = {\n  SUBTITLE: 'subtitle',\n  CLOSED_CAPTION: 'caption',\n};\n\n\n/**\n * Specifies how tolerant the player is of inaccurate segment start times and\n * end times within a manifest. For example, gaps or overlaps between segments\n * in a SegmentTimeline which are greater than or equal to this value will\n * result in a warning message.\n *\n * @const {number}\n */\nshaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS = 1 / 15;\n\n\n/**\n * A list of regexps to detect well-known video codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.util.ManifestParserUtils.VIDEO_CODEC_REGEXPS_ = [\n  /^avc/,\n  /^hev/,\n  /^hvc/,\n  /^vp0?[89]/,\n  /^av01/,\n  /^dvhe/,\n];\n\n\n/**\n * A list of regexps to detect well-known audio codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.util.ManifestParserUtils.AUDIO_CODEC_REGEXPS_ = [\n  /^vorbis$/,\n  /^opus$/,\n  /^flac$/,\n  /^mp4a/,\n  /^[ae]c-3$/,\n  /^ac-4$/,\n  /^dts[cx]$/, // DTS Surround Sound\n  /^[du]dts$/, // DTS Surround Sound\n];\n\n\n/**\n * A list of regexps to detect well-known text codecs.\n *\n * @const {!Array.<!RegExp>}\n * @private\n */\nshaka.util.ManifestParserUtils.TEXT_CODEC_REGEXPS_ = [\n  /^vtt$/,\n  /^wvtt/,\n  /^stpp/,\n];\n\n\n/**\n * @const {!Object.<string, !Array.<!RegExp>>}\n */\nshaka.util.ManifestParserUtils.CODEC_REGEXPS_BY_CONTENT_TYPE_ = {\n  'audio': shaka.util.ManifestParserUtils.AUDIO_CODEC_REGEXPS_,\n  'video': shaka.util.ManifestParserUtils.VIDEO_CODEC_REGEXPS_,\n  'text': shaka.util.ManifestParserUtils.TEXT_CODEC_REGEXPS_,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * A utility to create Promises with convenient public resolve and reject\n * methods.\n *\n * @extends {Promise.<T>}\n * @template T\n */\nshaka.util.PublicPromise = class {\n  /**\n   * @return {!Promise.<T>}\n   */\n  constructor() {\n    let resolvePromise;\n    let rejectPromise;\n\n    // Promise.call causes an error.  It seems that inheriting from a native\n    // Promise is not permitted by JavaScript interpreters.\n\n    // The work-around is to construct a Promise object, modify it to look like\n    // the compiler's picture of PublicPromise, then return it.  The caller of\n    // new PublicPromise will receive |promise| instead of |this|, and the\n    // compiler will be aware of the additional properties |resolve| and\n    // |reject|.\n\n    const promise = new Promise(((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    }));\n\n    // Now cast the Promise object to our subclass PublicPromise so that the\n    // compiler will permit us to attach resolve() and reject() to it.\n    const publicPromise = /** @type {shaka.util.PublicPromise} */(promise);\n    publicPromise.resolve = resolvePromise;\n    publicPromise.reject = rejectPromise;\n\n    return publicPromise;\n  }\n\n\n  /** @param {T=} value */\n  resolve(value) {}\n\n\n  /** @param {*=} reason */\n  reject(reason) {}\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Lazy');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary\n * This contains a single value that is lazily generated when it is first\n * requested.  This can store any value except \"undefined\".\n *\n * @template T\n */\nshaka.util.Lazy = class {\n  /** @param {function():T} gen */\n  constructor(gen) {\n    /** @private {function():T} */\n    this.gen_ = gen;\n\n    /** @private {T|undefined} */\n    this.value_ = undefined;\n  }\n\n  /** @return {T} */\n  value() {\n    if (this.value_ == undefined) {\n      // Compiler complains about unknown fields without this cast.\n      this.value_ = /** @type {*} */ (this.gen_());\n      goog.asserts.assert(\n          this.value_ != undefined, 'Unable to create lazy value');\n    }\n    return this.value_;\n  }\n\n  /** Resets the value of the lazy function, so it has to be remade. */\n  reset() {\n    this.value_ = undefined;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.DelayedTick');\n\n\n/**\n * @summary\n * This class wraps a function so that we can defer executing the function by X\n * seconds.\n *\n * @final\n */\nshaka.util.DelayedTick = class {\n  /**\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /** @private {function()} */\n    this.onTick_ = onTick;\n\n    /** @private {?function()} */\n    this.cancelPending_ = null;\n  }\n\n  /**\n   * Call |onTick| after |delayInSeconds| has elapsed. If there is already a\n   * pending call to |onTick|, the pending call will be canceled.\n   *\n   * @param {number} delayInSeconds\n   * @return {!shaka.util.DelayedTick}\n   */\n  tickAfter(delayInSeconds) {\n    // We only want one timeout set at a time, so make sure no other timeouts\n    // are running.\n    this.stop();\n\n    // We will wrap these values in a function to allow us to cancel the timeout\n    // we are about to create.\n    let alive = true;\n    let timeoutId = null;\n\n    this.cancelPending_ = () => {\n      window.clearTimeout(timeoutId);\n      alive = false;\n    };\n\n    // For some reason, a timeout may still execute after we have cleared it in\n    // our tests. We will wrap the callback so that we can double-check our\n    // |alive| flag.\n    const onTick = () => {\n      if (alive) {\n        this.onTick_();\n      }\n    };\n\n    timeoutId = window.setTimeout(onTick, delayInSeconds * 1000);\n\n    return this;\n  }\n\n  /**\n   * Cancel any pending calls to |onTick|. If there are no pending calls to\n   * |onTick|, this will be a no-op.\n   */\n  stop() {\n    if (this.cancelPending_) {\n      this.cancelPending_();\n      this.cancelPending_ = null;\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Timer');\n\ngoog.require('shaka.util.DelayedTick');\n\n\n/**\n * A timer allows a single function to be executed at a later time or at\n * regular intervals.\n *\n * @final\n * @export\n */\nshaka.util.Timer = class {\n  /**\n   * Create a new timer. A timer is committed to a single callback function.\n   * While there is no technical reason to do this, it is far easier to\n   * understand and use timers when they are connected to one functional idea.\n   *\n   * @param {function()} onTick\n   */\n  constructor(onTick) {\n    /**\n     * Each time our timer \"does work\", we call that a \"tick\". The name comes\n     * from old analog clocks.\n     *\n     * @private {function()}\n     */\n    this.onTick_ = onTick;\n\n    /** @private {shaka.util.DelayedTick} */\n    this.ticker_ = null;\n  }\n\n  /**\n   * Have the timer call |onTick| now.\n   *\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickNow() {\n    this.stop();\n    this.onTick_();\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| after |seconds| has elapsed unless |stop| is\n   * called first.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickAfter(seconds) {\n    this.stop();\n\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Have the timer call |onTick| every |seconds| until |stop| is called.\n   *\n   * @param {number} seconds\n   * @return {!shaka.util.Timer}\n   * @export\n   */\n  tickEvery(seconds) {\n    this.stop();\n\n    if (goog.DEBUG) {\n      // Capture the stack trace by making a fake error.\n      const stackTrace = Error('Timer created').stack;\n      shaka.util.Timer.activeTimers.set(this, stackTrace);\n    }\n    this.ticker_ = new shaka.util.DelayedTick(() => {\n      // Schedule the timer again first. |onTick_| could cancel the timer and\n      // rescheduling first simplifies the implementation.\n      this.ticker_.tickAfter(seconds);\n      this.onTick_();\n    }).tickAfter(seconds);\n\n    return this;\n  }\n\n  /**\n   * Stop the timer and clear the previous behaviour. The timer is still usable\n   * after calling |stop|.\n   *\n   * @export\n   */\n  stop() {\n    if (this.ticker_) {\n      this.ticker_.stop();\n      this.ticker_ = null;\n    }\n    if (goog.DEBUG) {\n      shaka.util.Timer.activeTimers.delete(this);\n    }\n  }\n};\n\nif (goog.DEBUG) {\n  /**\n   * Tracks all active timer instances, along with the stack trace that created\n   * that timer.\n   * @type {!Map.<!shaka.util.Timer, string>}\n   */\n  shaka.util.Timer.activeTimers = new Map();\n}\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Platform');\n\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A wrapper for platform-specific functions.\n *\n * @final\n */\nshaka.util.Platform = class {\n  /**\n   * Check if the current platform supports media source. We assume that if\n   * the current platform supports media source, then we can use media source\n   * as per its design.\n   *\n   * @return {boolean}\n   */\n  static supportsMediaSource() {\n    // Browsers that lack a media source implementation will have no reference\n    // to |window.MediaSource|. Platforms that we see having problematic media\n    // source implementations will have this reference removed via a polyfill.\n    if (!window.MediaSource) {\n      return false;\n    }\n\n    // Some very old MediaSource implementations didn't have isTypeSupported.\n    if (!MediaSource.isTypeSupported) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if the media type is supported natively by the platform.\n   *\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static supportsMediaType(mimeType) {\n    const video = shaka.util.Platform.anyMediaElement();\n    return video.canPlayType(mimeType) != '';\n  }\n\n  /**\n   * Check if the current platform is MS Edge.\n   *\n   * @return {boolean}\n   */\n  static isEdge() {\n    // Legacy Edge contains \"Edge/version\".\n    // Chromium-based Edge contains \"Edg/version\" (no \"e\").\n    if (navigator.userAgent.match(/Edge?\\//)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the current platform is Legacy Edge.\n   *\n   * @return {boolean}\n   */\n  static isLegacyEdge() {\n    // Legacy Edge contains \"Edge/version\".\n    // Chromium-based Edge contains \"Edg/version\" (no \"e\").\n    if (navigator.userAgent.match(/Edge\\//)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the current platform is MS IE.\n   *\n   * @return {boolean}\n   */\n  static isIE() {\n    return shaka.util.Platform.userAgentContains_('Trident/');\n  }\n\n  /**\n   * Check if the current platform is an Xbox One.\n   *\n   * @return {boolean}\n   */\n  static isXboxOne() {\n    return shaka.util.Platform.userAgentContains_('Xbox One');\n  }\n\n  /**\n   * Check if the current platform is a Tizen TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen() {\n    return shaka.util.Platform.userAgentContains_('Tizen');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 4 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen4() {\n    return shaka.util.Platform.userAgentContains_('Tizen 4');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 3 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen3() {\n    return shaka.util.Platform.userAgentContains_('Tizen 3');\n  }\n\n  /**\n   * Check if the current platform is a Tizen 2 TV.\n   *\n   * @return {boolean}\n   */\n  static isTizen2() {\n    return shaka.util.Platform.userAgentContains_('Tizen 2');\n  }\n\n  /**\n   * Check if the current platform is a WebOS.\n   *\n   * @return {boolean}\n   */\n  static isWebOS() {\n    return shaka.util.Platform.userAgentContains_('Web0S');\n  }\n\n  /**\n   * Check if the current platform is a WebOS 3.\n   *\n   * @return {boolean}\n   */\n  static isWebOS3() {\n    // See: http://webostv.developer.lge.com/discover/specifications/web-engine/\n    return shaka.util.Platform.userAgentContains_('Web0S') &&\n        shaka.util.Platform.userAgentContains_(\n            'Chrome/38.0.2125.122 Safari/537.36');\n  }\n\n  /**\n   * Check if the current platform is a Google Chromecast.\n   *\n   * @return {boolean}\n   */\n  static isChromecast() {\n    return shaka.util.Platform.userAgentContains_('CrKey');\n  }\n\n  /**\n   * Returns a major version number for Chrome, or Chromium-based browsers.\n   *\n   * For example:\n   *   - Chrome 106.0.5249.61 returns 106.\n   *   - Edge 106.0.1370.34 returns 106 (since this is based on Chromium).\n   *   - Safari returns null (since this is independent of Chromium).\n   *\n   * @return {?number} A major version number or null if not Chromium-based.\n   */\n  static chromeVersion() {\n    if (!shaka.util.Platform.isChrome()) {\n      return null;\n    }\n\n    // Looking for something like \"Chrome/106.0.0.0\".\n    const match = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if the current platform is Google Chrome.\n   *\n   * @return {boolean}\n   */\n  static isChrome() {\n    // The Edge user agent will also contain the \"Chrome\" keyword, so we need\n    // to make sure this is not Edge.\n    return shaka.util.Platform.userAgentContains_('Chrome') &&\n           !shaka.util.Platform.isEdge();\n  }\n\n  /**\n   * Check if the current platform is from Apple.\n   *\n   * Returns true on all iOS browsers and on desktop Safari.\n   *\n   * Returns false for non-Safari browsers on macOS, which are independent of\n   * Apple.\n   *\n   * @return {boolean}\n   */\n  static isApple() {\n    return !!navigator.vendor && navigator.vendor.includes('Apple') &&\n        !shaka.util.Platform.isTizen() &&\n        !shaka.util.Platform.isEOS() &&\n        !shaka.util.Platform.isVirginMedia() &&\n        !shaka.util.Platform.isPS4() &&\n        !shaka.util.Platform.isAmazonFireTV();\n  }\n\n  /**\n   * Check if the current platform is Playstation 5.\n   *\n   * Returns true on Playstation 5 browsers.\n   *\n   * Returns false for Playstation 5 browsers\n   *\n   * @return {boolean}\n   */\n  static isPS5() {\n    return shaka.util.Platform.userAgentContains_('PlayStation 5');\n  }\n\n  /**\n   * Check if the current platform is Playstation 4.\n   */\n  static isPS4() {\n    return shaka.util.Platform.userAgentContains_('PlayStation 4');\n  }\n\n  /**\n   * Check if the current platform is Hisense.\n   */\n  static isHisense() {\n    return shaka.util.Platform.userAgentContains_('Hisense') ||\n        shaka.util.Platform.userAgentContains_('VIDAA');\n  }\n\n  /**\n   * Check if the current platform is Virgin Media device.\n   */\n  static isVirginMedia() {\n    return shaka.util.Platform.userAgentContains_('VirginMedia');\n  }\n\n  /**\n   * Check if the current platform is Amazon Fire TV.\n   * https://developer.amazon.com/docs/fire-tv/identify-amazon-fire-tv-devices.html\n   *\n   * @return {boolean}\n   */\n  static isAmazonFireTV() {\n    return shaka.util.Platform.userAgentContains_('AFT');\n  }\n\n  /**\n   * Returns a major version number for Safari, or Safari-based iOS browsers.\n   *\n   * For example:\n   *   - Safari 13.0.4 on macOS returns 13.\n   *   - Safari on iOS 13.3.1 returns 13.\n   *   - Chrome on iOS 13.3.1 returns 13 (since this is based on Safari/WebKit).\n   *   - Chrome on macOS returns null (since this is independent of Apple).\n   *\n   * Returns null on Firefox on iOS, where this version information is not\n   * available.\n   *\n   * @return {?number} A major version number or null if not iOS.\n   */\n  static safariVersion() {\n    // All iOS browsers and desktop Safari will return true for isApple().\n    if (!shaka.util.Platform.isApple()) {\n      return null;\n    }\n\n    // This works for iOS Safari and desktop Safari, which contain something\n    // like \"Version/13.0\" indicating the major Safari or iOS version.\n    let match = navigator.userAgent.match(/Version\\/(\\d+)/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    // This works for all other browsers on iOS, which contain something like\n    // \"OS 13_3\" indicating the major & minor iOS version.\n    match = navigator.userAgent.match(/OS (\\d+)(?:_\\d+)?/);\n    if (match) {\n      return parseInt(match[1], /* base= */ 10);\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if the current platform is Apple Safari\n   * or Safari-based iOS browsers.\n   *\n   * @return {boolean}\n   */\n  static isSafari() {\n    return !!shaka.util.Platform.safariVersion();\n  }\n\n  /**\n   * Check if the current platform is an EOS set-top box.\n   *\n   * @return {boolean}\n   */\n  static isEOS() {\n    return shaka.util.Platform.userAgentContains_('PC=EOS');\n  }\n\n  /**\n   * Guesses if the platform is a mobile one (iOS or Android).\n   *\n   * @return {boolean}\n   */\n  static isMobile() {\n    if (/(?:iPhone|iPad|iPod|Android)/.test(navigator.userAgent)) {\n      // This is Android, iOS, or iPad < 13.\n      return true;\n    }\n\n    // Starting with iOS 13 on iPad, the user agent string no longer has the\n    // word \"iPad\" in it.  It looks very similar to desktop Safari.  This seems\n    // to be intentional on Apple's part.\n    // See: https://forums.developer.apple.com/thread/119186\n    //\n    // So if it's an Apple device with multi-touch support, assume it's a mobile\n    // device.  If some future iOS version starts masking their user agent on\n    // both iPhone & iPad, this clause should still work.  If a future\n    // multi-touch desktop Mac is released, this will need some adjustment.\n    //\n    // As of January 2020, this is mainly used to adjust the default UI config\n    // for mobile devices, so it's low risk if something changes to break this\n    // detection.\n    return shaka.util.Platform.isApple() && navigator.maxTouchPoints > 1;\n  }\n\n  /**\n   * Check if the user agent contains a key. This is the best way we know of\n   * right now to detect platforms. If there is a better way, please send a\n   * PR.\n   *\n   * @param {string} key\n   * @return {boolean}\n   * @private\n   */\n  static userAgentContains_(key) {\n    const userAgent = navigator.userAgent || '';\n    return userAgent.includes(key);\n  }\n\n  /**\n   * For canPlayType queries, we just need any instance.\n   *\n   * First, use a cached element from a previous query.\n   * Second, search the page for one.\n   * Third, create a temporary one.\n   *\n   * Cached elements expire in one second so that they can be GC'd or removed.\n   *\n   * @return {!HTMLMediaElement}\n   */\n  static anyMediaElement() {\n    const Platform = shaka.util.Platform;\n    if (Platform.cachedMediaElement_) {\n      return Platform.cachedMediaElement_;\n    }\n\n    if (!Platform.cacheExpirationTimer_) {\n      Platform.cacheExpirationTimer_ = new shaka.util.Timer(() => {\n        Platform.cachedMediaElement_ = null;\n      });\n    }\n\n    Platform.cachedMediaElement_ = /** @type {HTMLMediaElement} */(\n      document.getElementsByTagName('video')[0] ||\n      document.getElementsByTagName('audio')[0]);\n\n    if (!Platform.cachedMediaElement_) {\n      Platform.cachedMediaElement_ = /** @type {!HTMLMediaElement} */(\n        document.createElement('video'));\n    }\n\n    Platform.cacheExpirationTimer_.tickAfter(/* seconds= */ 1);\n    return Platform.cachedMediaElement_;\n  }\n\n  /**\n   * Returns true if the platform requires encryption information in all init\n   * segments.  For such platforms, MediaSourceEngine will attempt to work\n   * around a lack of such info by inserting fake encryption information into\n   * initialization segments.\n   *\n   * @return {boolean}\n   * @see https://github.com/shaka-project/shaka-player/issues/2759\n   */\n  static requiresEncryptionInfoInAllInitSegments() {\n    const Platform = shaka.util.Platform;\n    return Platform.isTizen() || Platform.isXboxOne();\n  }\n\n  /**\n   * Returns true if MediaKeys is polyfilled\n   *\n   * @return {boolean}\n   */\n  static isMediaKeysPolyfilled() {\n    if (window.shakaMediaKeysPolyfill) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\n/** @private {shaka.util.Timer} */\nshaka.util.Platform.cacheExpirationTimer_ = null;\n\n/** @private {HTMLMediaElement} */\nshaka.util.Platform.cachedMediaElement_ = null;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StringUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @namespace shaka.util.StringUtils\n * @summary A set of string utility functions.\n * @export\n */\nshaka.util.StringUtils = class {\n  /**\n   * Creates a string from the given buffer as UTF-8 encoding.\n   *\n   * @param {?BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static fromUTF8(data) {\n    if (!data) {\n      return '';\n    }\n\n    let uint8 = shaka.util.BufferUtils.toUint8(data);\n    // If present, strip off the UTF-8 BOM.\n    if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n      uint8 = uint8.subarray(3);\n    }\n\n    if (window.TextDecoder && !shaka.util.Platform.isPS4()) {\n      // Use the TextDecoder interface to decode the text.  This has the\n      // advantage compared to the previously-standard decodeUriComponent that\n      // it will continue parsing even if it finds an invalid UTF8 character,\n      // rather than stop and throw an error.\n      const utf8decoder = new TextDecoder();\n      const decoded = utf8decoder.decode(uint8);\n      if (decoded.includes('\\uFFFD')) {\n        shaka.log.alwaysError('Decoded string contains an \"unknown character' +\n                              '\" codepoint.  That probably means the UTF8 ' +\n                              'encoding was incorrect!');\n      }\n      return decoded;\n    } else {\n      // Homebrewed UTF-8 decoder based on\n      // https://en.wikipedia.org/wiki/UTF-8#Encoding\n      // Unlike decodeURIComponent, won't throw on bad encoding.\n      // In this way, it is similar to TextDecoder.\n\n      let decoded = '';\n      for (let i = 0; i < uint8.length; ++i) {\n        // By default, the \"replacement character\" codepoint.\n        let codePoint = 0xFFFD;\n\n        // Top bit is 0, 1-byte encoding.\n        if ((uint8[i] & 0x80) == 0) {\n          codePoint = uint8[i];\n\n        // Top 3 bits of byte 0 are 110, top 2 bits of byte 1 are 10,\n        // 2-byte encoding.\n        } else if (uint8.length >= i + 2 &&\n            (uint8[i] & 0xe0) == 0xc0 &&\n            (uint8[i + 1] & 0xc0) == 0x80) {\n          codePoint = ((uint8[i] & 0x1f) << 6) |\n                      ((uint8[i + 1] & 0x3f));\n          i += 1;  // Consume one extra byte.\n\n        // Top 4 bits of byte 0 are 1110, top 2 bits of byte 1 and 2 are 10,\n        // 3-byte encoding.\n        } else if (uint8.length >= i + 3 &&\n            (uint8[i] & 0xf0) == 0xe0 &&\n            (uint8[i + 1] & 0xc0) == 0x80 &&\n            (uint8[i + 2] & 0xc0) == 0x80) {\n          codePoint = ((uint8[i] & 0x0f) << 12) |\n                      ((uint8[i + 1] & 0x3f) << 6) |\n                      ((uint8[i + 2] & 0x3f));\n          i += 2;  // Consume two extra bytes.\n\n        // Top 5 bits of byte 0 are 11110, top 2 bits of byte 1, 2 and 3 are 10,\n        // 4-byte encoding.\n        } else if (uint8.length >= i + 4 &&\n            (uint8[i] & 0xf1) == 0xf0 &&\n            (uint8[i + 1] & 0xc0) == 0x80 &&\n            (uint8[i + 2] & 0xc0) == 0x80 &&\n            (uint8[i + 3] & 0xc0) == 0x80) {\n          codePoint = ((uint8[i] & 0x07) << 18) |\n                      ((uint8[i + 1] & 0x3f) << 12) |\n                      ((uint8[i + 2] & 0x3f) << 6) |\n                      ((uint8[i + 3] & 0x3f));\n          i += 3;  // Consume three extra bytes.\n        }\n\n        // JavaScript strings are a series of UTF-16 characters.\n        if (codePoint <= 0xffff) {\n          decoded += String.fromCharCode(codePoint);\n        } else {\n          // UTF-16 surrogate-pair encoding, based on\n          // https://en.wikipedia.org/wiki/UTF-16#Description\n          const baseCodePoint = codePoint - 0x10000;\n          const highPart = baseCodePoint >> 10;\n          const lowPart = baseCodePoint & 0x3ff;\n          decoded += String.fromCharCode(0xd800 + highPart);\n          decoded += String.fromCharCode(0xdc00 + lowPart);\n        }\n      }\n\n      return decoded;\n    }\n  }\n\n\n  /**\n   * Creates a string from the given buffer as UTF-16 encoding.\n   *\n   * @param {?BufferSource} data\n   * @param {boolean} littleEndian\n         true to read little endian, false to read big.\n   * @param {boolean=} noThrow true to avoid throwing in cases where we may\n   *     expect invalid input.  If noThrow is true and the data has an odd\n   *     length,it will be truncated.\n   * @return {string}\n   * @export\n   */\n  static fromUTF16(data, littleEndian, noThrow) {\n    if (!data) {\n      return '';\n    }\n\n    if (!noThrow && data.byteLength % 2 != 0) {\n      shaka.log.error('Data has an incorrect length, must be even.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL, shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BAD_ENCODING);\n    }\n\n    // Use a DataView to ensure correct endianness.\n    const length = Math.floor(data.byteLength / 2);\n    const arr = new Uint16Array(length);\n    const dataView = shaka.util.BufferUtils.toDataView(data);\n    for (let i = 0; i < length; i++) {\n      arr[i] = dataView.getUint16(i * 2, littleEndian);\n    }\n    return shaka.util.StringUtils.fromCharCode(arr);\n  }\n\n\n  /**\n   * Creates a string from the given buffer, auto-detecting the encoding that is\n   * being used.  If it cannot detect the encoding, it will throw an exception.\n   *\n   * @param {?BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static fromBytesAutoDetect(data) {\n    const StringUtils = shaka.util.StringUtils;\n    if (!data) {\n      return '';\n    }\n\n    const uint8 = shaka.util.BufferUtils.toUint8(data);\n    if (uint8[0] == 0xef && uint8[1] == 0xbb && uint8[2] == 0xbf) {\n      return StringUtils.fromUTF8(uint8);\n    } else if (uint8[0] == 0xfe && uint8[1] == 0xff) {\n      return StringUtils.fromUTF16(\n          uint8.subarray(2), /* littleEndian= */ false);\n    } else if (uint8[0] == 0xff && uint8[1] == 0xfe) {\n      return StringUtils.fromUTF16(uint8.subarray(2), /* littleEndian= */ true);\n    }\n\n    const isAscii = (i) => {\n      // arr[i] >= ' ' && arr[i] <= '~';\n      return uint8.byteLength <= i || (uint8[i] >= 0x20 && uint8[i] <= 0x7e);\n    };\n\n    shaka.log.debug(\n        'Unable to find byte-order-mark, making an educated guess.');\n    if (uint8[0] == 0 && uint8[2] == 0) {\n      return StringUtils.fromUTF16(data, /* littleEndian= */ false);\n    } else if (uint8[1] == 0 && uint8[3] == 0) {\n      return StringUtils.fromUTF16(data, /* littleEndian= */ true);\n    } else if (isAscii(0) && isAscii(1) && isAscii(2) && isAscii(3)) {\n      return StringUtils.fromUTF8(data);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING);\n  }\n\n\n  /**\n   * Creates a ArrayBuffer from the given string, converting to UTF-8 encoding.\n   *\n   * @param {string} str\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toUTF8(str) {\n    if (window.TextEncoder && !shaka.util.Platform.isPS4()) {\n      const utf8Encoder = new TextEncoder();\n      return shaka.util.BufferUtils.toArrayBuffer(utf8Encoder.encode(str));\n    } else {\n      // http://stackoverflow.com/a/13691499\n      // Converts the given string to a URI encoded string.  If a character\n      // falls in the ASCII range, it is not converted; otherwise it will be\n      // converted to a series of URI escape sequences according to UTF-8.\n      // Example: 'g#' -> 'g#%E3%82%AC'\n      const encoded = encodeURIComponent(str);\n      // Convert each escape sequence individually into a character.  Each\n      // escape sequence is interpreted as a code-point, so if an escape\n      // sequence happens to be part of a multi-byte sequence, each byte will\n      // be converted to a single character.\n      // Example: 'g#%E3%82%AC' -> '\\x67\\x35\\xe3\\x82\\xac'\n      const utf8 = unescape(encoded);\n\n      const result = new Uint8Array(utf8.length);\n      for (let i = 0; i < utf8.length; i++) {\n        const item = utf8[i];\n        result[i] = item.charCodeAt(0);\n      }\n      return shaka.util.BufferUtils.toArrayBuffer(result);\n    }\n  }\n\n\n  /**\n   * Creates a ArrayBuffer from the given string, converting to UTF-16 encoding.\n   *\n   * @param {string} str\n   * @param {boolean} littleEndian\n   * @return {!ArrayBuffer}\n   * @export\n   */\n  static toUTF16(str, littleEndian) {\n    const result = new ArrayBuffer(str.length * 2);\n    const view = new DataView(result);\n    for (let i = 0; i < str.length; ++i) {\n      const value = str.charCodeAt(i);\n      view.setUint16(/* position= */ i * 2, value, littleEndian);\n    }\n    return result;\n  }\n\n\n  /**\n   * Creates a new string from the given array of char codes.\n   *\n   * Using String.fromCharCode.apply is risky because you can trigger stack\n   * errors on very large arrays.  This breaks up the array into several pieces\n   * to avoid this.\n   *\n   * @param {!TypedArray} array\n   * @return {string}\n   */\n  static fromCharCode(array) {\n    return shaka.util.StringUtils.fromCharCodeImpl_.value()(array);\n  }\n\n  /**\n   * Resets the fromCharCode method's implementation.\n   * For debug use.\n   * @export\n   */\n  static resetFromCharCode() {\n    shaka.util.StringUtils.fromCharCodeImpl_.reset();\n  }\n};\n\n\n/** @private {!shaka.util.Lazy.<function(!TypedArray):string>} */\nshaka.util.StringUtils.fromCharCodeImpl_ = new shaka.util.Lazy(() => {\n  /** @param {number} size @return {boolean} */\n  const supportsChunkSize = (size) => {\n    try {\n      // The compiler will complain about suspicious value if this isn't\n      // stored in a variable and used.\n      const buffer = new Uint8Array(size);\n\n      // This can't use the spread operator, or it blows up on Xbox One.\n      // So we use apply() instead, which is normally not allowed.\n      // See issue #2186 for more details.\n      // eslint-disable-next-line no-restricted-syntax\n      const foo = String.fromCharCode.apply(null, buffer);\n      goog.asserts.assert(foo, 'Should get value');\n      return foo.length > 0; // Actually use \"foo\", so it's not compiled out.\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // Different browsers support different chunk sizes; find out the largest\n  // this browser supports so we can use larger chunks on supported browsers\n  // but still support lower-end devices that require small chunks.\n  // 64k is supported on all major desktop browsers.\n  for (let size = 64 * 1024; size > 0; size /= 2) {\n    if (supportsChunkSize(size)) {\n      return (buffer) => {\n        let ret = '';\n        for (let i = 0; i < buffer.length; i += size) {\n          const subArray = buffer.subarray(i, i + size);\n\n          // This can't use the spread operator, or it blows up on Xbox One.\n          // So we use apply() instead, which is normally not allowed.\n          // See issue #2186 for more details.\n          // eslint-disable-next-line no-restricted-syntax\n          ret += String.fromCharCode.apply(null, subArray);  // Issue #2186\n        }\n        return ret;\n      };\n    }\n  }\n  goog.asserts.assert(false, 'Unable to create a fromCharCode method');\n  return null;\n});\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Uint8ArrayUtils');\n\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.StringUtils');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary A set of Uint8Array utility functions.\n * @export\n */\nshaka.util.Uint8ArrayUtils = class {\n  /**\n   * Convert a buffer to a base64 string. The output will be standard\n   * alphabet as opposed to base64url safe alphabet.\n   * @param {BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static toStandardBase64(data) {\n    const bytes = shaka.util.StringUtils.fromCharCode(\n        shaka.util.BufferUtils.toUint8(data));\n    return btoa(bytes);\n  }\n\n  /**\n   * Convert a buffer to a base64 string.  The output will always use the\n   * alternate encoding/alphabet also known as \"base64url\".\n   * @param {BufferSource} data\n   * @param {boolean=} padding If true, pad the output with equals signs.\n   *   Defaults to true.\n   * @return {string}\n   * @export\n   */\n  static toBase64(data, padding) {\n    padding = (padding == undefined) ? true : padding;\n    const base64 = shaka.util.Uint8ArrayUtils.toStandardBase64(data)\n        .replace(/\\+/g, '-').replace(/\\//g, '_');\n    return padding ? base64 : base64.replace(/[=]*$/, '');\n  }\n\n  /**\n   * Convert a base64 string to a Uint8Array.  Accepts either the standard\n   * alphabet or the alternate \"base64url\" alphabet.\n   * @param {string} str\n   * @return {!Uint8Array}\n   * @export\n   */\n  static fromBase64(str) {\n    // atob creates a \"raw string\" where each character is interpreted as a\n    // byte.\n    const bytes = window.atob(str.replace(/-/g, '+').replace(/_/g, '/'));\n    const result = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; ++i) {\n      result[i] = bytes.charCodeAt(i);\n    }\n    return result;\n  }\n\n\n  /**\n   * Convert a hex string to a Uint8Array.\n   * @param {string} str\n   * @return {!Uint8Array}\n   * @export\n   */\n  static fromHex(str) {\n    const size = str.length / 2;\n    const arr = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n      arr[i] = window.parseInt(str.substr(i * 2, 2), 16);\n    }\n    return arr;\n  }\n\n\n  /**\n   * Convert a buffer to a hex string.\n   * @param {BufferSource} data\n   * @return {string}\n   * @export\n   */\n  static toHex(data) {\n    const arr = shaka.util.BufferUtils.toUint8(data);\n    let hex = '';\n    for (let value of arr) {\n      value = value.toString(16);\n      if (value.length == 1) {\n        value = '0' + value;\n      }\n      hex += value;\n    }\n    return hex;\n  }\n\n\n  /**\n   * Concatenate buffers.\n   * @param {...BufferSource} varArgs\n   * @return {!Uint8Array}\n   * @export\n   */\n  static concat(...varArgs) {\n    let totalLength = 0;\n    for (const arr of varArgs) {\n      totalLength += arr.byteLength;\n    }\n\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of varArgs) {\n      result.set(shaka.util.BufferUtils.toUint8(arr), offset);\n      offset += arr.byteLength;\n    }\n    return result;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dependencies');\n\n/**\n * @export\n */\nshaka.dependencies = class {\n  /**\n   * Registers a new dependency.\n   *\n   * @param {shaka.dependencies.Allowed} key which is used for retrieving a\n   *   dependency\n   * @param {?} dep a dependency\n   * @export\n   */\n  static add(key, dep) {\n    if (!shaka.dependencies.Allowed[key]) {\n      throw new Error(`${key} is not supported`);\n    }\n    shaka.dependencies.dependencies_.set(key, () => dep);\n  }\n\n  /**\n   * Check if we have a dependency for the key.\n   *\n   * @param {shaka.dependencies.Allowed} key key\n   * @return {boolean}\n   * @export\n   */\n  static has(key) {\n    return shaka.dependencies.dependencies_.has(key);\n  }\n\n  /** @return {?muxjs} */\n  static muxjs() {\n    return /** @type {?muxjs} */ (shaka.dependencies.dependencies_.get(\n        shaka.dependencies.Allowed.muxjs)());\n  }\n};\n\n/**\n * @export\n * @enum {string}\n */\nshaka.dependencies.Allowed = {\n  muxjs: 'muxjs',\n};\n\n/**\n * Contains accessor functions to shared dependencies that could be used by\n * other components.  The default accessors can be overridden.\n *\n * @private {!Map.<shaka.dependencies.Allowed, function():?>}\n */\nshaka.dependencies.dependencies_ = new Map([\n  [shaka.dependencies.Allowed.muxjs, () => window.muxjs],\n]);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Transmuxer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.Capabilities');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.dependencies');\n\n\n/**\n * Transmuxer provides all operations for transmuxing from Transport\n * Stream or AAC to MP4.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.Transmuxer = class {\n  /**\n   * @param {string} mimeType\n   */\n  constructor(mimeType) {\n    /** @private {string} */\n    this.originalMimeType_ = mimeType;\n\n    /** @private {?muxjs} */\n    this.muxjs_ = shaka.dependencies.muxjs();\n\n    /** @private {muxjs.mp4.Transmuxer} */\n    this.muxTransmuxer_ = new this.muxjs_.mp4.Transmuxer({\n      'keepOriginalTimestamps': true,\n    });\n\n    /** @private {shaka.util.PublicPromise} */\n    this.transmuxPromise_ = null;\n\n    /** @private {!Array.<!Uint8Array>} */\n    this.transmuxedData_ = [];\n\n    /** @private {!Array.<muxjs.mp4.ClosedCaption>} */\n    this.captions_ = [];\n\n    /** @private {boolean} */\n    this.isTransmuxing_ = false;\n\n    this.muxTransmuxer_.on('data', (segment) => this.onTransmuxed_(segment));\n\n    this.muxTransmuxer_.on('done', () => this.onTransmuxDone_());\n  }\n\n  /**\n   * @override\n   */\n  destroy() {\n    this.muxTransmuxer_.dispose();\n    this.muxTransmuxer_ = null;\n    return Promise.resolve();\n  }\n\n\n  /**\n   * Check if the content type is Transport Stream or AAC, and if muxjs is\n   * loaded.\n   * @param {string} mimeType\n   * @param {string=} contentType\n   * @return {boolean}\n   */\n  static isSupported(mimeType, contentType) {\n    const Transmuxer = shaka.media.Transmuxer;\n    const Capabilities = shaka.media.Capabilities;\n\n    const isTs = Transmuxer.isTsContainer_(mimeType);\n    const isAac = Transmuxer.isAacContainer_(mimeType);\n\n    if (!shaka.dependencies.muxjs() || (!isTs && !isAac)) {\n      return false;\n    }\n\n    if (isAac) {\n      return Capabilities.isTypeSupported(Transmuxer.convertAacCodecs_());\n    }\n\n    if (contentType) {\n      return Capabilities.isTypeSupported(\n          Transmuxer.convertTsCodecs_(contentType, mimeType));\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const audioMime = Transmuxer.convertTsCodecs_(ContentType.AUDIO, mimeType);\n    const videoMime = Transmuxer.convertTsCodecs_(ContentType.VIDEO, mimeType);\n    return Capabilities.isTypeSupported(audioMime) ||\n        Capabilities.isTypeSupported(videoMime);\n  }\n\n\n  /**\n   * Check if the mimetype is 'audio/aac'.\n   * @param {string} mimeType\n   * @return {boolean}\n   * @private\n   */\n  static isAacContainer_(mimeType) {\n    return mimeType.toLowerCase().split(';')[0] == 'audio/aac';\n  }\n\n\n  /**\n   * Check if the mimetype contains 'mp2t'.\n   * @param {string} mimeType\n   * @return {boolean}\n   * @private\n   */\n  static isTsContainer_(mimeType) {\n    return mimeType.toLowerCase().split(';')[0].split('/')[1] == 'mp2t';\n  }\n\n\n  /**\n   * For any stream, convert its codecs to MP4 codecs.\n   * @param {string} contentType\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static convertCodecs(contentType, mimeType) {\n    const Transmuxer = shaka.media.Transmuxer;\n    if (Transmuxer.isAacContainer_(mimeType)) {\n      return Transmuxer.convertAacCodecs_();\n    } else if (Transmuxer.isTsContainer_(mimeType)) {\n      return Transmuxer.convertTsCodecs_(contentType, mimeType);\n    }\n    return mimeType;\n  }\n\n\n  /**\n   * For aac stream, convert its codecs to MP4 codecs.\n   * @return {string}\n   * @private\n   */\n  static convertAacCodecs_() {\n    return 'audio/mp4; codecs=\"mp4a.40.2\"';\n  }\n\n\n  /**\n   * For transport stream, convert its codecs to MP4 codecs.\n   * @param {string} contentType\n   * @param {string} tsMimeType\n   * @return {string}\n   * @private\n   */\n  static convertTsCodecs_(contentType, tsMimeType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    let mp4MimeType = tsMimeType.replace(/mp2t/i, 'mp4');\n    if (contentType == ContentType.AUDIO) {\n      mp4MimeType = mp4MimeType.replace('video', 'audio');\n    }\n\n    // Handle legacy AVC1 codec strings (pre-RFC 6381).\n    // Look for \"avc1.<profile>.<level>\", where profile is:\n    //   66 (baseline => 0x42)\n    //   77 (main => 0x4d)\n    //   100 (high => 0x64)\n    // Reference: https://bit.ly/2K9JI3x\n    const match = /avc1\\.(66|77|100)\\.(\\d+)/.exec(mp4MimeType);\n    if (match) {\n      let newCodecString = 'avc1.';\n\n      const profile = match[1];\n      if (profile == '66') {\n        newCodecString += '4200';\n      } else if (profile == '77') {\n        newCodecString += '4d00';\n      } else {\n        goog.asserts.assert(profile == '100',\n            'Legacy avc1 parsing code out of sync with regex!');\n        newCodecString += '6400';\n      }\n\n      // Convert the level to hex and append to the codec string.\n      const level = Number(match[2]);\n      goog.asserts.assert(level < 256,\n          'Invalid legacy avc1 level number!');\n      newCodecString += (level >> 4).toString(16);\n      newCodecString += (level & 0xf).toString(16);\n\n      mp4MimeType = mp4MimeType.replace(match[0], newCodecString);\n    }\n\n    return mp4MimeType;\n  }\n\n\n  /**\n   * Returns the original mimetype of the transmuxer.\n   * @return {string}\n   */\n  getOrginalMimeType() {\n    return this.originalMimeType_;\n  }\n\n\n  /**\n   * Transmux from Transport stream to MP4, using the mux.js library.\n   * @param {BufferSource} data\n   * @return {!Promise.<{data: !Uint8Array,\n   *                     captions: !Array.<!muxjs.mp4.ClosedCaption>}>}\n   */\n  transmux(data) {\n    goog.asserts.assert(!this.isTransmuxing_,\n        'No transmuxing should be in progress.');\n    this.isTransmuxing_ = true;\n    this.transmuxPromise_ = new shaka.util.PublicPromise();\n    this.transmuxedData_ = [];\n    this.captions_ = [];\n\n    const dataArray = shaka.util.BufferUtils.toUint8(data);\n    this.muxTransmuxer_.push(dataArray);\n    this.muxTransmuxer_.flush();\n\n    // Workaround for https://bit.ly/Shaka1449 mux.js not\n    // emitting 'data' and 'done' events.\n    // mux.js code is synchronous, so if onTransmuxDone_ has\n    // not been called by now, it's not going to be.\n    // Treat it as a transmuxing failure and reject the promise.\n    if (this.isTransmuxing_) {\n      this.transmuxPromise_.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.TRANSMUXING_FAILED));\n    }\n    return this.transmuxPromise_;\n  }\n\n  /**\n   * Reset captions from Transport stream to MP4, using the mux.js library.\n  */\n  resetCaptions() {\n    this.muxTransmuxer_.resetCaptions();\n  }\n\n  /**\n   * Handles the 'data' event of the transmuxer.\n   * Extracts the cues from the transmuxed segment, and adds them to an array.\n   * Stores the transmuxed data in another array, to pass it back to\n   * MediaSourceEngine, and append to the source buffer.\n   *\n   * @param {muxjs.mp4.Transmuxer.Segment} segment\n   * @private\n   */\n  onTransmuxed_(segment) {\n    this.captions_ = segment.captions;\n    this.transmuxedData_.push(\n        shaka.util.Uint8ArrayUtils.concat(segment.initSegment, segment.data));\n  }\n\n\n  /**\n   * Handles the 'done' event of the transmuxer.\n   * Resolves the transmux Promise, and returns the transmuxed data.\n   * @private\n   */\n  onTransmuxDone_() {\n    const output = {\n      data: shaka.util.Uint8ArrayUtils.concat(...this.transmuxedData_),\n      captions: this.captions_,\n    };\n\n    this.transmuxPromise_.resolve(output);\n    this.isTransmuxing_ = false;\n  }\n};\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MimeUtils');\n\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.util.ManifestParserUtils');\n\n/**\n * @summary A set of utility functions for dealing with MIME types.\n * @export\n */\nshaka.util.MimeUtils = class {\n  /**\n   * Takes a MIME type and optional codecs string and produces the full MIME\n   * type.\n   *\n   * @param {string} mimeType\n   * @param {string=} codecs\n   * @return {string}\n   * @export\n   */\n  static getFullType(mimeType, codecs) {\n    let fullMimeType = mimeType;\n    if (codecs) {\n      fullMimeType += '; codecs=\"' + codecs + '\"';\n    }\n    return fullMimeType;\n  }\n\n  /**\n   * Takes a MIME type and a codecs string and produces the full MIME\n   * type. If it's a transport stream, convert its codecs to MP4 codecs.\n   * Otherwise for multiplexed content, convert the video MIME types to\n   * their audio equivalents if the content type is audio.\n   *\n   * @param {string} mimeType\n   * @param {string} codecs\n   * @param {string} contentType\n   * @return {string}\n   */\n  static getFullOrConvertedType(mimeType, codecs, contentType) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const Transmuxer = shaka.media.Transmuxer;\n\n    if (Transmuxer.isSupported(fullMimeType, contentType)) {\n      return shaka.media.Transmuxer.convertCodecs(contentType, fullMimeType);\n    } else if (contentType == ContentType.AUDIO) {\n      // video/mp2t is the correct mime type for TS audio, so only replace the\n      // word \"video\" with \"audio\" for non-TS audio content.\n      return fullMimeType.replace('video', 'audio');\n    }\n    return fullMimeType;\n  }\n\n\n  /**\n   * Takes a Stream object and produces an extended MIME type with information\n   * beyond the container and codec type, when available.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   */\n  static getExtendedType(stream) {\n    const components = [stream.mimeType];\n\n    const extendedMimeParams = shaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_;\n    extendedMimeParams.forEach((mimeKey, streamKey) => {\n      const value = stream[streamKey];\n      if (value) {\n        components.push(mimeKey + '=\"' + value + '\"');\n      }\n    });\n    if (stream.hdr == 'PQ') {\n      components.push('eotf=\"smpte2084\"');\n    }\n\n    return components.join(';');\n  }\n\n  /**\n   * Takes a full MIME type (with codecs) or basic MIME type (without codecs)\n   * and returns a container type string (\"mp2t\", \"mp4\", \"webm\", etc.)\n   *\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static getContainerType(mimeType) {\n    return mimeType.split(';')[0].split('/')[1];\n  }\n\n  /**\n   * Split a list of codecs encoded in a string into a list of codecs.\n   * @param {string} codecs\n   * @return {!Array.<string>}\n   */\n  static splitCodecs(codecs) {\n    return codecs.split(',');\n  }\n\n  /**\n   * Get the normalized codec from a codec string,\n   * independently of their container.\n   *\n   * @param {string} codecString\n   * @return {string}\n   */\n  static getNormalizedCodec(codecString) {\n    const parts =\n      shaka.util.MimeUtils.getCodecParts_(codecString);\n    const base = parts[0];\n    const profile = parts[1].toLowerCase();\n    switch (true) {\n      case base === 'mp4a' && profile === '69':\n      case base === 'mp4a' && profile === '6b':\n        return 'mp3';\n      case base === 'mp4a' && profile === '66':\n      case base === 'mp4a' && profile === '67':\n      case base === 'mp4a' && profile === '68':\n      case base === 'mp4a' && profile === '40.2':\n      case base === 'mp4a' && profile === '40.02':\n      case base === 'mp4a' && profile === '40.5':\n      case base === 'mp4a' && profile === '40.05':\n      case base === 'mp4a' && profile === '40.29':\n      case base === 'mp4a' && profile === '40.42': // Extended HE-AAC\n        return 'aac';\n      case base === 'mp4a' && profile === 'a5':\n        return 'ac-3'; // Dolby Digital\n      case base === 'mp4a' && profile === 'a6':\n        return 'ec-3'; // Dolby Digital Plus\n      case base === 'mp4a' && profile === 'b2':\n        return 'dtsx'; // DTS:X\n      case base === 'mp4a' && profile === 'a9':\n        return 'dtsc'; // DTS Digital Surround\n      case base === 'avc1':\n      case base === 'avc3':\n        return 'avc'; // H264\n      case base === 'hvc1':\n      case base === 'hev1':\n        return 'hevc'; // H265\n      case base === 'dvh1':\n      case base === 'dvhe':\n        return 'dovi'; // Dolby Vision\n    }\n    return base;\n  }\n\n  /**\n   * Get the base codec from a codec string.\n   *\n   * @param {string} codecString\n   * @return {string}\n   */\n  static getCodecBase(codecString) {\n    const parts = shaka.util.MimeUtils.getCodecParts_(codecString);\n    return parts[0];\n  }\n\n  /**\n   * Takes a full MIME type (with codecs) or basic MIME type (without codecs)\n   * and returns a basic MIME type (without codecs or other parameters).\n   *\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static getBasicType(mimeType) {\n    return mimeType.split(';')[0];\n  }\n\n  /**\n   * Takes a MIME type and returns the codecs parameter, or an empty string if\n   * there is no codecs parameter.\n   *\n   * @param {string} mimeType\n   * @return {string}\n   */\n  static getCodecs(mimeType) {\n    // Parse the basic MIME type from its parameters.\n    const pieces = mimeType.split(/ *; */);\n    pieces.shift();  // Remove basic MIME type from pieces.\n\n    const codecs = pieces.find((piece) => piece.startsWith('codecs='));\n    if (!codecs) {\n      return '';\n    }\n\n    // The value may be quoted, so remove quotes at the beginning or end.\n    const value = codecs.split('=')[1].replace(/^\"|\"$/g, '');\n    return value;\n  }\n\n  /**\n   * Get the base and profile of a codec string. Where [0] will be the codec\n   * base and [1] will be the profile.\n   * @param {string} codecString\n   * @return {!Array.<string>}\n   * @private\n   */\n  static getCodecParts_(codecString) {\n    const parts = codecString.split('.');\n\n    const base = parts[0];\n\n    parts.shift();\n    const profile = parts.join('.');\n\n    // Make sure that we always return a \"base\" and \"profile\".\n    return [base, profile];\n  }\n};\n\n\n/**\n * A map from Stream object keys to MIME type parameters.  These should be\n * ignored by platforms that do not recognize them.\n *\n * This initial set of parameters are all recognized by Chromecast.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.MimeUtils.EXTENDED_MIME_PARAMETERS_ = new Map()\n    .set('codecs', 'codecs')\n    .set('frameRate', 'framerate')  // Ours is camelCase, theirs is lowercase.\n    .set('bandwidth', 'bitrate')  // They are in the same units: bits/sec.\n    .set('width', 'width')\n    .set('height', 'height')\n    .set('channelsCount', 'channels');\n\n\n/**\n * A mimetype created for CEA-608 closed captions.\n * @const {string}\n */\nshaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE = 'application/cea-608';\n\n/**\n * A mimetype created for CEA-708 closed captions.\n * @const {string}\n */\nshaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE = 'application/cea-708';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.TextEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.MimeUtils');\ngoog.requireType('shaka.cea.ICaptionDecoder');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary Manages text parsers and cues.\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.text.TextEngine = class {\n  /** @param {shaka.extern.TextDisplayer} displayer */\n  constructor(displayer) {\n    /** @private {?shaka.extern.TextParser} */\n    this.parser_ = null;\n\n    /** @private {shaka.extern.TextDisplayer} */\n    this.displayer_ = displayer;\n\n    /** @private {boolean} */\n    this.segmentRelativeVttTiming_ = false;\n\n    /** @private {number} */\n    this.timestampOffset_ = 0;\n\n    /** @private {number} */\n    this.appendWindowStart_ = 0;\n\n    /** @private {number} */\n    this.appendWindowEnd_ = Infinity;\n\n    /** @private {?number} */\n    this.bufferStart_ = null;\n\n    /** @private {?number} */\n    this.bufferEnd_ = null;\n\n    /** @private {string} */\n    this.selectedClosedCaptionId_ = '';\n\n    /**\n     * The closed captions map stores the CEA closed captions by closed captions\n     * id and start and end time.\n     * It's used as the buffer of closed caption text streams, to show captions\n     * when we start displaying captions or switch caption tracks, we need to be\n     * able to get the cues for the other language and display them without\n     * re-fetching the video segments they were embedded in.\n     * Structure of closed caption map:\n     * closed caption id -> {start and end time -> cues}\n     * @private {!Map.<string, !Map.<string, !Array.<shaka.text.Cue>>>} */\n    this.closedCaptionsMap_ = new Map();\n  }\n\n  /**\n   * @param {string} mimeType\n   * @param {!shaka.extern.TextParserPlugin} plugin\n   * @export\n   */\n  static registerParser(mimeType, plugin) {\n    shaka.text.TextEngine.parserMap_[mimeType] = plugin;\n  }\n\n  /**\n   * @param {string} mimeType\n   * @export\n   */\n  static unregisterParser(mimeType) {\n    delete shaka.text.TextEngine.parserMap_[mimeType];\n  }\n\n  /**\n   * @return {?shaka.extern.TextParserPlugin}\n   * @export\n   */\n  static findParser(mimeType) {\n    return shaka.text.TextEngine.parserMap_[mimeType];\n  }\n\n  /**\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isTypeSupported(mimeType) {\n    if (shaka.text.TextEngine.parserMap_[mimeType]) {\n      // An actual parser is available.\n      return true;\n    }\n    if (mimeType == shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE ||\n        mimeType == shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE ) {\n      // Closed captions.\n      return true;\n    }\n    return false;\n  }\n\n  // TODO: revisit this when the compiler supports partially-exported classes.\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    this.parser_ = null;\n    this.displayer_ = null;\n    this.closedCaptionsMap_.clear();\n\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {!shaka.extern.TextDisplayer} displayer\n   */\n  setDisplayer(displayer) {\n    this.displayer_ = displayer;\n  }\n\n  /**\n   * Initialize the parser.  This can be called multiple times, but must be\n   * called at least once before appendBuffer.\n   *\n   * @param {string} mimeType\n   * @param {boolean} sequenceMode\n   * @param {boolean} segmentRelativeVttTiming\n   */\n  initParser(mimeType, sequenceMode, segmentRelativeVttTiming) {\n    // No parser for CEA, which is extracted from video and side-loaded\n    // into TextEngine and TextDisplayer.\n    if (mimeType == shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE ||\n        mimeType == shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE) {\n      return;\n    }\n\n    const factory = shaka.text.TextEngine.parserMap_[mimeType];\n    goog.asserts.assert(\n        factory, 'Text type negotiation should have happened already');\n    this.parser_ = factory();\n    if (this.parser_.setSequenceMode) {\n      this.parser_.setSequenceMode(sequenceMode);\n    } else {\n      shaka.log.alwaysWarn(\n          'Text parsers should have a \"setSequenceMode\" method!');\n    }\n    this.segmentRelativeVttTiming_ = segmentRelativeVttTiming;\n  }\n\n  /**\n   * @param {BufferSource} buffer\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async appendBuffer(buffer, startTime, endTime) {\n    goog.asserts.assert(\n        this.parser_, 'The parser should already be initialized');\n\n    // Start the operation asynchronously to avoid blocking the caller.\n    await Promise.resolve();\n\n    // Check that TextEngine hasn't been destroyed.\n    if (!this.parser_ || !this.displayer_) {\n      return;\n    }\n\n    if (startTime == null || endTime == null) {\n      this.parser_.parseInit(shaka.util.BufferUtils.toUint8(buffer));\n      return;\n    }\n\n    const vttOffset = this.segmentRelativeVttTiming_ ?\n        startTime : this.timestampOffset_;\n\n    /** @type {shaka.extern.TextParser.TimeContext} **/\n    const time = {\n      periodStart: this.timestampOffset_,\n      segmentStart: startTime,\n      segmentEnd: endTime,\n      vttOffset: vttOffset,\n    };\n\n    // Parse the buffer and add the new cues.\n    const allCues = this.parser_.parseMedia(\n        shaka.util.BufferUtils.toUint8(buffer), time);\n    const cuesToAppend = allCues.filter((cue) => {\n      return cue.startTime >= this.appendWindowStart_ &&\n          cue.startTime < this.appendWindowEnd_;\n    });\n\n    this.displayer_.append(cuesToAppend);\n\n    // NOTE: We update the buffered range from the start and end times\n    // passed down from the segment reference, not with the start and end\n    // times of the parsed cues.  This is important because some segments\n    // may contain no cues, but we must still consider those ranges\n    // buffered.\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      // We already had something in buffer, and we assume we are extending\n      // the range from the end.\n      goog.asserts.assert(\n          this.bufferEnd_ != null,\n          'There should already be a buffered range end.');\n      goog.asserts.assert(\n          (startTime - this.bufferEnd_) <= 1,\n          'There should not be a gap in text references >1s');\n    }\n    this.bufferEnd_ = Math.min(endTime, this.appendWindowEnd_);\n  }\n\n  /**\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async remove(startTime, endTime) {\n    // Start the operation asynchronously to avoid blocking the caller.\n    await Promise.resolve();\n\n    if (this.displayer_ && this.displayer_.remove(startTime, endTime)) {\n      if (this.bufferStart_ == null) {\n        goog.asserts.assert(\n            this.bufferEnd_ == null, 'end must be null if startTime is null');\n      } else {\n        goog.asserts.assert(\n            this.bufferEnd_ != null,\n            'end must be non-null if startTime is non-null');\n\n        // Update buffered range.\n        if (endTime <= this.bufferStart_ || startTime >= this.bufferEnd_) {\n          // No intersection.  Nothing was removed.\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We wiped out everything.\n          this.bufferStart_ = this.bufferEnd_ = null;\n        } else if (startTime <= this.bufferStart_ &&\n                   endTime < this.bufferEnd_) {\n          // We removed from the beginning of the range.\n          this.bufferStart_ = endTime;\n        } else if (startTime > this.bufferStart_ &&\n                   endTime >= this.bufferEnd_) {\n          // We removed from the end of the range.\n          this.bufferEnd_ = startTime;\n        } else {\n          // We removed from the middle?  StreamingEngine isn't supposed to.\n          goog.asserts.assert(\n              false, 'removal from the middle is not supported by TextEngine');\n        }\n      }\n    }\n  }\n\n  /** @param {number} timestampOffset */\n  setTimestampOffset(timestampOffset) {\n    this.timestampOffset_ = timestampOffset;\n  }\n\n  /**\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   */\n  setAppendWindow(appendWindowStart, appendWindowEnd) {\n    this.appendWindowStart_ = appendWindowStart;\n    this.appendWindowEnd_ = appendWindowEnd;\n  }\n\n  /**\n   * @return {?number} Time in seconds of the beginning of the buffered range,\n   *   or null if nothing is buffered.\n   */\n  bufferStart() {\n    return this.bufferStart_;\n  }\n\n  /**\n   * @return {?number} Time in seconds of the end of the buffered range,\n   *   or null if nothing is buffered.\n   */\n  bufferEnd() {\n    return this.bufferEnd_;\n  }\n\n  /**\n   * @param {number} t A timestamp\n   * @return {boolean}\n   */\n  isBuffered(t) {\n    if (this.bufferStart_ == null || this.bufferEnd_ == null) {\n      return false;\n    }\n    return t >= this.bufferStart_ && t < this.bufferEnd_;\n  }\n\n  /**\n   * @param {number} t A timestamp\n   * @return {number} Number of seconds ahead of 't' we have buffered\n   */\n  bufferedAheadOf(t) {\n    if (this.bufferEnd_ == null || this.bufferEnd_ < t) {\n      return 0;\n    }\n\n    goog.asserts.assert(\n        this.bufferStart_ != null,\n        'start should not be null if end is not null');\n\n    return this.bufferEnd_ - Math.max(t, this.bufferStart_);\n  }\n\n  /**\n   * Set the selected closed captions id.\n   * Append the cues stored in the closed captions map until buffer end time.\n   * This is to fill the gap between buffered and unbuffered captions, and to\n   * avoid duplicates that would be caused by any future video segments parsed\n   * for captions.\n   *\n   * @param {string} id\n   * @param {number} bufferEndTime Load any stored cues up to this time.\n   */\n  setSelectedClosedCaptionId(id, bufferEndTime) {\n    this.selectedClosedCaptionId_ = id;\n\n    const captionsMap = this.closedCaptionsMap_.get(id);\n    if (captionsMap) {\n      for (const startAndEndTime of captionsMap.keys()) {\n        /** @type {Array.<!shaka.text.Cue>} */\n        const cues = captionsMap.get(startAndEndTime)\n            .filter((c) => c.endTime <= bufferEndTime);\n        if (cues) {\n          this.displayer_.append(cues);\n        }\n      }\n    }\n  }\n\n  /**\n  * @param {!Array<muxjs.mp4.ClosedCaption>} closedCaptions\n  * @return {!Array<!shaka.cea.ICaptionDecoder.ClosedCaption>}\n  */\n  convertMuxjsCaptionsToShakaCaptions(closedCaptions) {\n    const cues = [];\n    for (const caption of closedCaptions) {\n      const cue = new shaka.text.Cue(\n          caption.startTime, caption.endTime, caption.text);\n      cues.push({\n        stream: caption.stream,\n        cue,\n      });\n    }\n    return cues;\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue the cue to apply the timestamp to recursively\n   * @param {number} videoTimestampOffset the timestamp offset of the video\n   * @private\n   */\n  applyVideoTimestampOffsetRecursive_(cue, videoTimestampOffset) {\n    cue.startTime += videoTimestampOffset;\n    cue.endTime += videoTimestampOffset;\n    for (const nested of cue.nestedCues) {\n      this.applyVideoTimestampOffsetRecursive_(nested, videoTimestampOffset);\n    }\n  }\n\n  /**\n   * Store the closed captions in the text engine, and append the cues to the\n   * text displayer.  This is a side-channel used for embedded text only.\n   *\n   * @param {!Array.<!shaka.cea.ICaptionDecoder.ClosedCaption>} closedCaptions\n   * @param {?number} startTime relative to the start of the presentation\n   * @param {?number} endTime relative to the start of the presentation\n   * @param {number} videoTimestampOffset the timestamp offset of the video\n   *   stream in which these captions were embedded\n   */\n  storeAndAppendClosedCaptions(\n      closedCaptions, startTime, endTime, videoTimestampOffset) {\n    const startAndEndTime = startTime + ' ' + endTime;\n    /** @type {!Map.<string, !Map.<string, !Array.<!shaka.text.Cue>>>} */\n    const captionsMap = new Map();\n\n    for (const caption of closedCaptions) {\n      const id = caption.stream;\n      const cue = caption.cue;\n      if (!captionsMap.has(id)) {\n        captionsMap.set(id, new Map());\n      }\n      if (!captionsMap.get(id).has(startAndEndTime)) {\n        captionsMap.get(id).set(startAndEndTime, []);\n      }\n\n      // Adjust CEA captions with respect to the timestamp offset of the video\n      // stream in which they were embedded.\n      this.applyVideoTimestampOffsetRecursive_(cue, videoTimestampOffset);\n\n      const keepThisCue =\n          cue.startTime >= this.appendWindowStart_ &&\n          cue.startTime < this.appendWindowEnd_;\n      if (!keepThisCue) {\n        continue;\n      }\n\n      captionsMap.get(id).get(startAndEndTime).push(cue);\n      if (id == this.selectedClosedCaptionId_) {\n        this.displayer_.append([cue]);\n      }\n    }\n\n    for (const id of captionsMap.keys()) {\n      if (!this.closedCaptionsMap_.has(id)) {\n        this.closedCaptionsMap_.set(id, new Map());\n      }\n      for (const startAndEndTime of captionsMap.get(id).keys()) {\n        const cues = captionsMap.get(id).get(startAndEndTime);\n        this.closedCaptionsMap_.get(id).set(startAndEndTime, cues);\n      }\n    }\n\n    if (this.bufferStart_ == null) {\n      this.bufferStart_ = Math.max(startTime, this.appendWindowStart_);\n    } else {\n      this.bufferStart_ = Math.min(\n          this.bufferStart_, Math.max(startTime, this.appendWindowStart_));\n    }\n\n    this.bufferEnd_ = Math.max(\n        this.bufferEnd_, Math.min(endTime, this.appendWindowEnd_));\n  }\n\n  /**\n   * Get the number of closed caption channels.\n   *\n   * This function is for TESTING ONLY. DO NOT USE in the library.\n   *\n   * @return {number}\n   */\n  getNumberOfClosedCaptionChannels() {\n    return this.closedCaptionsMap_.size;\n  }\n\n  /**\n   * Get the number of closed caption cues for a given channel. If there is\n   * no channel for the given channel id, this will return 0.\n   *\n   * This function is for TESTING ONLY. DO NOT USE in the library.\n   *\n   * @param {string} channelId\n   * @return {number}\n   */\n  getNumberOfClosedCaptionsInChannel(channelId) {\n    const channel = this.closedCaptionsMap_.get(channelId);\n    return channel ? channel.size : 0;\n  }\n};\n\n/** @private {!Object.<string, !shaka.extern.TextParserPlugin>} */\nshaka.text.TextEngine.parserMap_ = {};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.LanguageUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * @summary A set of language utility functions.\n * @final\n * @export\n */\nshaka.util.LanguageUtils = class {\n  /**\n   * Check if |locale1| and |locale2| are locale-compatible.\n   *\n   * Locale-compatible is defined as all components in each locale match. Since\n   * we only respect the language and region components, we only check that\n   * the language and region components match.\n   *\n   * Examples:\n   *  Locale A | Locale B | Locale Compatible\n   *  ---------------------------------------\n   *  en-US    | en-US    | true\n   *  en       | en-US    | false\n   *  en-US    | en-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   * @export\n   */\n  static areLocaleCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    return locale1 == locale2;\n  }\n\n  /**\n   * Check if |locale1| and |locale2| are language-compatible.\n   *\n   * Language compatible is when the language component of each locale matches.\n   * This means that no matter what region they have (or don't have) as long as\n   * the language components match, they are language-compatible.\n   *\n   * Examples:\n   *  Locale A | Locale B | Language-Compatible\n   *  -----------------------------------------\n   *  en-US    | en-US    | true\n   *  en-US    | en       | true\n   *  en-US    | en-CA    | true\n   *  en-CA    | fr-CA    | false\n   *\n   * @param {string} locale1\n   * @param {string} locale2\n   * @return {boolean}\n   * @export\n   */\n  static areLanguageCompatible(locale1, locale2) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    locale1 = LanguageUtils.normalize(locale1);\n    locale2 = LanguageUtils.normalize(locale2);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const locale1Components = LanguageUtils.disassembleLocale_(locale1);\n    /** @type {!Array.<string>} */\n    const locale2Components = LanguageUtils.disassembleLocale_(locale2);\n\n    // We are language compatible if we have the same language.\n    return locale1Components[0] == locale2Components[0];\n  }\n\n  /**\n   * Check if |possibleParent| is the parent locale of |possibleChild|. Because\n   * we do not support dialects, the parent-child relationship is a lot simpler.\n   * In a parent child relationship:\n   *    - The parent and child have the same language-component\n   *    - The parent has no region-component\n   *    - The child has a region-component\n   *\n   * Example:\n   *  Locale A | Locale B | Is A The parent of B?\n   *  --------------------------------------------\n   *  en-US    | en-US    | no\n   *  en-US    | en       | no\n   *  en       | en-US    | yes\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} possibleParent\n   * @param {string} possibleChild\n   * @return {boolean}\n   * @export\n   */\n  static isParentOf(possibleParent, possibleChild) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    possibleParent = LanguageUtils.normalize(possibleParent);\n    possibleChild = LanguageUtils.normalize(possibleChild);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const possibleParentComponents =\n        LanguageUtils.disassembleLocale_(possibleParent);\n    /** @type {!Array.<string>} */\n    const possibleChildComponents =\n        LanguageUtils.disassembleLocale_(possibleChild);\n\n    return possibleParentComponents[0] == possibleChildComponents[0] &&\n           possibleParentComponents.length == 1 &&\n           possibleChildComponents.length == 2;\n  }\n\n  /**\n   * Check if |localeA| shares the same parent with |localeB|. Since we don't\n   * support dialect, we will only look at language and region. For two locales\n   * to be siblings:\n   *    - Both must have language-components\n   *    - Both must have region-components\n   *    - Both must have the same language-component\n   *\n   * Example:\n   *  Locale A | Locale B | Siblings?\n   *  --------------------------------------------\n   *  en-US    | en-US    | yes\n   *  en-US    | en-CA    | yes\n   *  en-US    | en       | no\n   *  en       | en-US    | no\n   *  en       | en       | no\n   *  en       | fr       | no\n   *\n   * @param {string} localeA\n   * @param {string} localeB\n   * @return {boolean}\n   * @export\n   */\n  static isSiblingOf(localeA, localeB) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Even through they SHOULD already be normalized, let's just be safe and\n    // do it again.\n    localeA = LanguageUtils.normalize(localeA);\n    localeB = LanguageUtils.normalize(localeB);\n\n    // Get all components. This should only be language and region\n    // since we do not support dialect.\n    /** @type {!Array.<string>} */\n    const localeAComponents = LanguageUtils.disassembleLocale_(localeA);\n    /** @type {!Array.<string>} */\n    const localeBComponents = LanguageUtils.disassembleLocale_(localeB);\n\n    return localeAComponents.length == 2 &&\n           localeBComponents.length == 2 &&\n           localeAComponents[0] == localeBComponents[0];\n  }\n\n  /**\n   * Normalize a locale. This will take a locale and canonicalize it to a state\n   * that we are prepared to work with.\n   *\n   * We only support with:\n   *   - language\n   *   - language-REGION\n   *\n   * If given a dialect, we will discard it. We will convert any 3-character\n   * codes to 2-character codes. We will force language codes to lowercase and\n   * region codes to uppercase.\n   *\n   * @param {string} locale\n   * @return {string}\n   * @export\n   */\n  static normalize(locale) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const components = locale.split('-');\n\n    // We are only going to use the language and the region. If there was\n    // a dialect or anything else, we are throwing it a way.\n    let language = components[0] || '';\n    let region = components[1] || '';\n\n    // Convert the language to lower case. It is standard for the language code\n    // to be in lower case, but it will also make the map look-up easier.\n    language = language.toLowerCase();\n    language = LanguageUtils.isoMap_.get(language) || language;\n\n    // Convert the region to upper case. It is standard for the region to be in\n    // upper case. If there is no upper code, then it will be an empty string\n    // and this will be a no-op.\n    region = region.toUpperCase();\n\n    return region ?\n           language + '-' + region :\n           language;\n  }\n\n  /**\n   * Check if two language codes are siblings. Language codes are siblings if\n   * they share the same base language while neither one is the base language.\n   *\n   * For example, \"en-US\" and \"en-CA\" are siblings but \"en-US\" and \"en\" are not\n   * siblings.\n   *\n   * @param {string} a\n   * @param {string} b\n   * @return {boolean}\n   * @export\n   */\n  static areSiblings(a, b) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const baseA = LanguageUtils.getBase(a);\n    const baseB = LanguageUtils.getBase(b);\n\n    return a != baseA && b != baseB && baseA == baseB;\n  }\n\n  /**\n   * Compute a numerical relatedness for language codes.  Language codes with a\n   * higher relatedness are a better match.  Unrelated language codes have a\n   * relatedness score of 0.\n   *\n   * @param {string} target\n   * @param {string} candidate\n   * @return {number}\n   * @export\n   */\n  static relatedness(target, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    target = LanguageUtils.normalize(target);\n    candidate = LanguageUtils.normalize(candidate);\n\n    // An exact match is the top score.\n    if (candidate == target) {\n      return 4;\n    }\n\n    // Next is a parent of the target language.\n    if (LanguageUtils.isParentOf(candidate, target)) {\n      return 3;\n    }\n\n    // Next is a sibling of the target language.\n    if (LanguageUtils.isSiblingOf(candidate, target)) {\n      return 2;\n    }\n\n    // Next is a child of the target language.\n    if (LanguageUtils.isParentOf(target, candidate)) {\n      return 1;\n    }\n\n    // Otherwise, they are unrelated.\n    return 0;\n  }\n\n  /**\n   * Get the normalized base language for a language code.\n   *\n   * @param {string} lang\n   * @return {string}\n   * @export\n   */\n  static getBase(lang) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const splitAt = lang.indexOf('-');\n    let major;\n\n    if (splitAt >= 0) {\n      major = lang.substring(0, splitAt);\n    } else {\n      major = lang;\n    }\n\n    // Convert the major code to lower case. It is standard for the major code\n    // to be in lower case, but it will also make the map look-up easier.\n    major = major.toLowerCase();\n    major = LanguageUtils.isoMap_.get(major) || major;\n\n    return major;\n  }\n\n  /**\n   * Get the normalized language of the given text stream. Will return 'und' if\n   * a language is not found on the text stream.\n   *\n   * This should always be used to get the language from a text stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   * @export\n   */\n  static getLocaleForText(stream) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(\n        stream.type == ContentType.TEXT,\n        'Can only get language from text streams');\n\n    const language = stream.language || 'und';\n    return LanguageUtils.normalize(language);\n  }\n\n  /**\n   * Get the normalized locale for the given variant. This will look through\n   * the variant to find the locale that represents the content in the variant.\n   * This will return 'und' if no language can be found.\n   *\n   * This should always be used to get the locale from a variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {string}\n   * @export\n   */\n  static getLocaleForVariant(variant) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // Our preference order is:\n    //  1. Variant\n    //  2. Audio Stream\n    //  3. Video Stream\n    //\n    // We are going to consider all falsy strings to be invalid locales, this\n    // will include empty strings.\n    if (variant.language) {\n      return LanguageUtils.normalize(variant.language);\n    }\n\n    if (variant.audio && variant.audio.language) {\n      return LanguageUtils.normalize(variant.audio.language);\n    }\n\n    if (variant.video && variant.video.language) {\n      return LanguageUtils.normalize(variant.video.language);\n    }\n\n    // No language was found, but we still want to return a valid string.\n    return 'und';\n  }\n\n  /**\n   * Find the locale in |searchSpace| that comes closest to |target|. If no\n   * locale is found to be close to |target|, then |null| will be returned.\n   *\n   * @param {string} target\n   * @param {!Iterable.<string>} searchSpace\n   * @return {?string}\n   * @export\n   */\n  static findClosestLocale(target, searchSpace) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const safeTarget = LanguageUtils.normalize(target);\n    /** @type {!Set.<string>} */\n    const safeSearchSpace = new Set();\n    for (const option of searchSpace) {\n      safeSearchSpace.add(LanguageUtils.normalize(option));\n    }\n\n    // Preference 1 - The option is an exact match. For example, \"en-US\" is an\n    //    exact match of \"en-US\". So if there is an option that is an exact\n    //    match, it would be the best match possible.\n    for (const option of safeSearchSpace) {\n      if (option == safeTarget) {\n        return option;\n      }\n    }\n\n    // Preference 2 - The option is the parent of the target. For example,\n    //    \"en\" is the parent of \"en-US\". So if there is an option with\n    //    \"en\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 3 - The option is a sibling of the target. For example,\n    //    \"en-US\" is a sibling of \"en-CA\". So if there is an option with\n    //    \"en_CA\", it should be good enough when our preference is \"en-US\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isSiblingOf(option, safeTarget)) {\n        return option;\n      }\n    }\n\n    // Preference 4 - The option is a child of the target. For example,\n    //    \"en-US\" is the child of \"en\". SO it there is an option with\n    //    \"en-US\", it should be good enough when our preference is \"en\".\n    for (const option of safeSearchSpace) {\n      if (LanguageUtils.isParentOf(safeTarget, option)) {\n        return option;\n      }\n    }\n\n    // Failed to find anything.\n    return null;\n  }\n\n  /**\n   * Take a locale string and break it into its component. Check that each\n   * component matches what we would expect internally for locales. This\n   * should ONLY be used to verify locales that have been normalized.\n   *\n   * @param {string} locale\n   * @return {!Array.<string>}\n   * @private\n   */\n  static disassembleLocale_(locale) {\n    const components = locale.split('-');\n\n    goog.asserts.assert(\n        components.length <= 2,\n        [\n          'Locales should not have more than 2 components. ',\n          locale,\n          ' has too many components.',\n        ].join());\n\n    return components;\n  }\n};\n\n\n/**\n * A map from 3-letter language codes (ISO 639-2) to 2-letter language codes\n * (ISO 639-1) for all languages which have both in the registry.\n *\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.LanguageUtils.isoMap_ = new Map([\n  ['aar', 'aa'], ['abk', 'ab'], ['afr', 'af'], ['aka', 'ak'], ['alb', 'sq'],\n  ['amh', 'am'], ['ara', 'ar'], ['arg', 'an'], ['arm', 'hy'], ['asm', 'as'],\n  ['ava', 'av'], ['ave', 'ae'], ['aym', 'ay'], ['aze', 'az'], ['bak', 'ba'],\n  ['bam', 'bm'], ['baq', 'eu'], ['bel', 'be'], ['ben', 'bn'], ['bih', 'bh'],\n  ['bis', 'bi'], ['bod', 'bo'], ['bos', 'bs'], ['bre', 'br'], ['bul', 'bg'],\n  ['bur', 'my'], ['cat', 'ca'], ['ces', 'cs'], ['cha', 'ch'], ['che', 'ce'],\n  ['chi', 'zh'], ['chu', 'cu'], ['chv', 'cv'], ['cor', 'kw'], ['cos', 'co'],\n  ['cre', 'cr'], ['cym', 'cy'], ['cze', 'cs'], ['dan', 'da'], ['deu', 'de'],\n  ['div', 'dv'], ['dut', 'nl'], ['dzo', 'dz'], ['ell', 'el'], ['eng', 'en'],\n  ['epo', 'eo'], ['est', 'et'], ['eus', 'eu'], ['ewe', 'ee'], ['fao', 'fo'],\n  ['fas', 'fa'], ['fij', 'fj'], ['fin', 'fi'], ['fra', 'fr'], ['fre', 'fr'],\n  ['fry', 'fy'], ['ful', 'ff'], ['geo', 'ka'], ['ger', 'de'], ['gla', 'gd'],\n  ['gle', 'ga'], ['glg', 'gl'], ['glv', 'gv'], ['gre', 'el'], ['grn', 'gn'],\n  ['guj', 'gu'], ['hat', 'ht'], ['hau', 'ha'], ['heb', 'he'], ['her', 'hz'],\n  ['hin', 'hi'], ['hmo', 'ho'], ['hrv', 'hr'], ['hun', 'hu'], ['hye', 'hy'],\n  ['ibo', 'ig'], ['ice', 'is'], ['ido', 'io'], ['iii', 'ii'], ['iku', 'iu'],\n  ['ile', 'ie'], ['ina', 'ia'], ['ind', 'id'], ['ipk', 'ik'], ['isl', 'is'],\n  ['ita', 'it'], ['jav', 'jv'], ['jpn', 'ja'], ['kal', 'kl'], ['kan', 'kn'],\n  ['kas', 'ks'], ['kat', 'ka'], ['kau', 'kr'], ['kaz', 'kk'], ['khm', 'km'],\n  ['kik', 'ki'], ['kin', 'rw'], ['kir', 'ky'], ['kom', 'kv'], ['kon', 'kg'],\n  ['kor', 'ko'], ['kua', 'kj'], ['kur', 'ku'], ['lao', 'lo'], ['lat', 'la'],\n  ['lav', 'lv'], ['lim', 'li'], ['lin', 'ln'], ['lit', 'lt'], ['ltz', 'lb'],\n  ['lub', 'lu'], ['lug', 'lg'], ['mac', 'mk'], ['mah', 'mh'], ['mal', 'ml'],\n  ['mao', 'mi'], ['mar', 'mr'], ['may', 'ms'], ['mkd', 'mk'], ['mlg', 'mg'],\n  ['mlt', 'mt'], ['mon', 'mn'], ['mri', 'mi'], ['msa', 'ms'], ['mya', 'my'],\n  ['nau', 'na'], ['nav', 'nv'], ['nbl', 'nr'], ['nde', 'nd'], ['ndo', 'ng'],\n  ['nep', 'ne'], ['nld', 'nl'], ['nno', 'nn'], ['nob', 'nb'], ['nor', 'no'],\n  ['nya', 'ny'], ['oci', 'oc'], ['oji', 'oj'], ['ori', 'or'], ['orm', 'om'],\n  ['oss', 'os'], ['pan', 'pa'], ['per', 'fa'], ['pli', 'pi'], ['pol', 'pl'],\n  ['por', 'pt'], ['pus', 'ps'], ['que', 'qu'], ['roh', 'rm'], ['ron', 'ro'],\n  ['rum', 'ro'], ['run', 'rn'], ['rus', 'ru'], ['sag', 'sg'], ['san', 'sa'],\n  ['sin', 'si'], ['slk', 'sk'], ['slo', 'sk'], ['slv', 'sl'], ['sme', 'se'],\n  ['smo', 'sm'], ['sna', 'sn'], ['snd', 'sd'], ['som', 'so'], ['sot', 'st'],\n  ['spa', 'es'], ['sqi', 'sq'], ['srd', 'sc'], ['srp', 'sr'], ['ssw', 'ss'],\n  ['sun', 'su'], ['swa', 'sw'], ['swe', 'sv'], ['tah', 'ty'], ['tam', 'ta'],\n  ['tat', 'tt'], ['tel', 'te'], ['tgk', 'tg'], ['tgl', 'tl'], ['tha', 'th'],\n  ['tib', 'bo'], ['tir', 'ti'], ['ton', 'to'], ['tsn', 'tn'], ['tso', 'ts'],\n  ['tuk', 'tk'], ['tur', 'tr'], ['twi', 'tw'], ['uig', 'ug'], ['ukr', 'uk'],\n  ['urd', 'ur'], ['uzb', 'uz'], ['ven', 've'], ['vie', 'vi'], ['vol', 'vo'],\n  ['wel', 'cy'], ['wln', 'wa'], ['wol', 'wo'], ['xho', 'xh'], ['yid', 'yi'],\n  ['yor', 'yo'], ['zha', 'za'], ['zho', 'zh'], ['zul', 'zu'],\n]);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MultiMap');\n\n\n/**\n * @summary A simple multimap template.\n * @template T\n */\nshaka.util.MultiMap = class {\n  /** */\n  constructor() {\n    /** @private {!Object.<string, !Array.<T>>} */\n    this.map_ = {};\n  }\n\n\n  /**\n   * Add a key, value pair to the map.\n   * @param {string} key\n   * @param {T} value\n   */\n  push(key, value) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (this.map_.hasOwnProperty(key)) {\n      this.map_[key].push(value);\n    } else {\n      this.map_[key] = [value];\n    }\n  }\n\n\n  /**\n   * Get a list of values by key.\n   * @param {string} key\n   * @return {Array.<T>} or null if no such key exists.\n   */\n  get(key) {\n    const list = this.map_[key];\n    // slice() clones the list so that it and the map can each be modified\n    // without affecting the other.\n    return list ? list.slice() : null;\n  }\n\n\n  /**\n   * Get a list of all values.\n   * @return {!Array.<T>}\n   */\n  getAll() {\n    const list = [];\n    for (const key in this.map_) {\n      list.push(...this.map_[key]);\n    }\n    return list;\n  }\n\n\n  /**\n   * Remove a specific value, if it exists.\n   * @param {string} key\n   * @param {T} value\n   */\n  remove(key, value) {\n    if (!(key in this.map_)) {\n      return;\n    }\n    this.map_[key] = this.map_[key].filter((i) => i != value);\n    if (this.map_[key].length == 0) {\n      // Delete the array if it's empty, so that |get| will reliably return null\n      // \"if no such key exists\", instead of sometimes returning an empty array.\n      delete this.map_[key];\n    }\n  }\n\n\n  /**\n   * Clear all keys and values from the multimap.\n   */\n  clear() {\n    this.map_ = {};\n  }\n\n\n  /**\n   * @param {function(string, !Array.<T>)} callback\n   */\n  forEach(callback) {\n    for (const key in this.map_) {\n      callback(key, this.map_[key]);\n    }\n  }\n\n  /**\n   * Returns the number of elements in the multimap.\n   * @return {number}\n   */\n  size() {\n    return Object.keys(this.map_).length;\n  }\n\n  /**\n   * Get a list of all the keys.\n   * @return {!Array.<string>}\n   */\n  keys() {\n    return Object.keys(this.map_);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StreamUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.Capabilities');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.MultiMap');\ngoog.require('shaka.util.Platform');\ngoog.requireType('shaka.media.DrmEngine');\n\n\n/**\n * @summary A set of utility functions for dealing with Streams and Manifests.\n */\nshaka.util.StreamUtils = class {\n  /**\n   * In case of multiple usable codecs, choose one based on lowest average\n   * bandwidth and filter out the rest.\n   * Also filters out variants that have too many audio channels.\n   * @param {!shaka.extern.Manifest} manifest\n   * @param {!Array.<string>} preferredVideoCodecs\n   * @param {!Array.<string>} preferredAudioCodecs\n   * @param {number} preferredAudioChannelCount\n   * @param {!Array.<string>} preferredDecodingAttributes\n   */\n  static chooseCodecsAndFilterManifest(manifest, preferredVideoCodecs,\n      preferredAudioCodecs, preferredAudioChannelCount,\n      preferredDecodingAttributes) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    let variants = manifest.variants;\n    // To start, choose the codecs based on configured preferences if available.\n    if (preferredVideoCodecs.length || preferredAudioCodecs.length) {\n      variants = StreamUtils.choosePreferredCodecs(variants,\n          preferredVideoCodecs, preferredAudioCodecs);\n    }\n\n    // Consider a subset of variants based on audio channel\n    // preferences.\n    // For some content (#1013), surround-sound variants will use a different\n    // codec than stereo variants, so it is important to choose codecs **after**\n    // considering the audio channel config.\n    variants = StreamUtils.filterVariantsByAudioChannelCount(\n        variants, preferredAudioChannelCount);\n\n    // Now organize variants into buckets by codecs.\n    /** @type {!shaka.util.MultiMap.<shaka.extern.Variant>} */\n    let variantsByCodecs = StreamUtils.getVariantsByCodecs_(variants);\n    variantsByCodecs = StreamUtils.filterVariantsByDensity_(variantsByCodecs);\n\n    const bestCodecs = StreamUtils.chooseCodecsByDecodingAttributes_(\n        variantsByCodecs, preferredDecodingAttributes);\n\n    // Filter out any variants that don't match, forcing AbrManager to choose\n    // from a single video codec and a single audio codec possible.\n    manifest.variants = manifest.variants.filter((variant) => {\n      const codecs = StreamUtils.getVariantCodecs_(variant);\n      if (codecs == bestCodecs) {\n        return true;\n      }\n\n      shaka.log.debug('Dropping Variant (better codec available)', variant);\n      return false;\n    });\n  }\n\n  /**\n  * Get variants by codecs.\n  *\n  * @param {!Array<shaka.extern.Variant>} variants\n  * @return {!shaka.util.MultiMap.<shaka.extern.Variant>}\n  * @private\n  */\n  static getVariantsByCodecs_(variants) {\n    const variantsByCodecs = new shaka.util.MultiMap();\n    for (const variant of variants) {\n      const variantCodecs = shaka.util.StreamUtils.getVariantCodecs_(variant);\n      variantsByCodecs.push(variantCodecs, variant);\n    }\n\n    return variantsByCodecs;\n  }\n\n  /**\n  * Filters variants by density.\n  * Get variants by codecs map with the max density where all codecs are\n  * present.\n  *\n  * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n  * @return {!shaka.util.MultiMap.<shaka.extern.Variant>}\n  * @private\n  */\n  static filterVariantsByDensity_(variantsByCodecs) {\n    let maxDensity = 0;\n    const codecGroupsByDensity = new Map();\n    const countCodecs = variantsByCodecs.size();\n\n    variantsByCodecs.forEach((codecs, variants) => {\n      for (const variant of variants) {\n        const video = variant.video;\n        if (!video || !video.width || !video.height) {\n          continue;\n        }\n\n        const density = video.width * video.height * (video.frameRate || 1);\n        if (!codecGroupsByDensity.has(density)) {\n          codecGroupsByDensity.set(density, new shaka.util.MultiMap());\n        }\n\n        /** @type {!shaka.util.MultiMap.<shaka.extern.Variant>} */\n        const group = codecGroupsByDensity.get(density);\n        group.push(codecs, variant);\n\n        // We want to look at the groups in which all codecs are present.\n        // Take the max density from those groups where all codecs are present.\n        // Later, we will compare bandwidth numbers only within this group.\n        // Effectively, only the bandwidth differences in the highest-res and\n        // highest-framerate content will matter in choosing a codec.\n        if (group.size() === countCodecs) {\n          maxDensity = Math.max(maxDensity, density);\n        }\n      }\n    });\n\n    return maxDensity ? codecGroupsByDensity.get(maxDensity) : variantsByCodecs;\n  }\n\n  /**\n   * Choose the codecs by configured preferred audio and video codecs.\n   *\n   * @param {!Array<shaka.extern.Variant>} variants\n   * @param {!Array.<string>} preferredVideoCodecs\n   * @param {!Array.<string>} preferredAudioCodecs\n   * @return {!Array<shaka.extern.Variant>}\n   */\n  static choosePreferredCodecs(variants, preferredVideoCodecs,\n      preferredAudioCodecs) {\n    let subset = variants;\n    for (const videoCodec of preferredVideoCodecs) {\n      const filtered = subset.filter((variant) => {\n        return variant.video && variant.video.codecs.startsWith(videoCodec);\n      });\n      if (filtered.length) {\n        subset = filtered;\n        break;\n      }\n    }\n\n    for (const audioCodec of preferredAudioCodecs) {\n      const filtered = subset.filter((variant) => {\n        return variant.audio && variant.audio.codecs.startsWith(audioCodec);\n      });\n      if (filtered.length) {\n        subset = filtered;\n        break;\n      }\n    }\n    return subset;\n  }\n\n  /**\n   * Choose the codecs by configured preferred decoding attributes.\n   *\n   * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n   * @param {!Array.<string>} attributes\n   * @return {string}\n   * @private\n   */\n  static chooseCodecsByDecodingAttributes_(variantsByCodecs, attributes) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    for (const attribute of attributes) {\n      if (attribute == StreamUtils.DecodingAttributes.SMOOTH ||\n          attribute == StreamUtils.DecodingAttributes.POWER) {\n        variantsByCodecs = StreamUtils.chooseCodecsByMediaCapabilitiesInfo_(\n            variantsByCodecs, attribute);\n        // If we only have one smooth or powerEfficient codecs, choose it as the\n        // best codecs.\n        if (variantsByCodecs.size() == 1) {\n          return variantsByCodecs.keys()[0];\n        }\n      } else if (attribute == StreamUtils.DecodingAttributes.BANDWIDTH) {\n        return StreamUtils.findCodecsByLowestBandwidth_(variantsByCodecs);\n      }\n    }\n    // If there's no configured decoding preferences, or we have multiple codecs\n    // that meets the configured decoding preferences, choose the one with\n    // the lowest bandwidth.\n    return StreamUtils.findCodecsByLowestBandwidth_(variantsByCodecs);\n  }\n\n  /**\n   * Choose the best codecs by configured preferred MediaCapabilitiesInfo\n   * attributes.\n   *\n   * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n   * @param {string} attribute\n   * @return {!shaka.util.MultiMap.<shaka.extern.Variant>}\n   * @private\n   */\n  static chooseCodecsByMediaCapabilitiesInfo_(variantsByCodecs, attribute) {\n    let highestScore = 0;\n    const bestVariantsByCodecs = new shaka.util.MultiMap();\n    variantsByCodecs.forEach((codecs, variants) => {\n      let sum = 0;\n      let num = 0;\n\n      for (const variant of variants) {\n        if (variant.decodingInfos.length) {\n          sum += variant.decodingInfos[0][attribute] ? 1 : 0;\n          num++;\n        }\n      }\n\n      const averageScore = sum / num;\n      shaka.log.debug('codecs', codecs, 'avg', attribute, averageScore);\n\n      if (averageScore > highestScore) {\n        bestVariantsByCodecs.clear();\n        bestVariantsByCodecs.push(codecs, variants);\n        highestScore = averageScore;\n      } else if (averageScore == highestScore) {\n        bestVariantsByCodecs.push(codecs, variants);\n      }\n    });\n    return bestVariantsByCodecs;\n  }\n\n  /**\n   * Find the lowest-bandwidth (best) codecs.\n   * Compute the average bandwidth for each group of variants.\n   *\n   * @param {!shaka.util.MultiMap.<shaka.extern.Variant>} variantsByCodecs\n   * @return {string}\n   * @private\n   */\n  static findCodecsByLowestBandwidth_(variantsByCodecs) {\n    let bestCodecs = '';\n    let lowestAverageBandwidth = Infinity;\n\n    variantsByCodecs.forEach((codecs, variants) => {\n      let sum = 0;\n      let num = 0;\n      for (const variant of variants) {\n        sum += variant.bandwidth || 0;\n        ++num;\n      }\n\n      const averageBandwidth = sum / num;\n      shaka.log.debug('codecs', codecs, 'avg bandwidth', averageBandwidth);\n\n      if (averageBandwidth < lowestAverageBandwidth) {\n        bestCodecs = codecs;\n        lowestAverageBandwidth = averageBandwidth;\n      }\n    });\n\n    goog.asserts.assert(bestCodecs !== '', 'Should have chosen codecs!');\n    goog.asserts.assert(!isNaN(lowestAverageBandwidth),\n        'Bandwidth should be a number!');\n\n    return bestCodecs;\n  }\n\n  /**\n   * Get a string representing all codecs used in a variant.\n   *\n   * @param {!shaka.extern.Variant} variant\n   * @return {string}\n   * @private\n   */\n  static getVariantCodecs_(variant) {\n    // Only consider the base of the codec string.  For example, these should\n    // both be considered the same codec: avc1.42c01e, avc1.4d401f\n    let baseVideoCodec = '';\n    if (variant.video) {\n      baseVideoCodec =\n        shaka.util.MimeUtils.getNormalizedCodec(variant.video.codecs);\n    }\n\n    let baseAudioCodec = '';\n    if (variant.audio) {\n      baseAudioCodec =\n        shaka.util.MimeUtils.getNormalizedCodec(variant.audio.codecs);\n    }\n\n    return baseVideoCodec + '-' + baseAudioCodec;\n  }\n\n  /**\n   * Filter the variants in |manifest| to only include the variants that meet\n   * the given restrictions.\n   *\n   * @param {!shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height:number}} maxHwResolution\n   */\n  static filterByRestrictions(manifest, restrictions, maxHwResolution) {\n    manifest.variants = manifest.variants.filter((variant) => {\n      return shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions, maxHwResolution);\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {shaka.extern.Restrictions} restrictions\n   *   Configured restrictions from the user.\n   * @param {{width: number, height: number}} maxHwRes\n   *   The maximum resolution the hardware can handle.\n   *   This is applied separately from user restrictions because the setting\n   *   should not be easily replaced by the user's configuration.\n   * @return {boolean}\n   */\n  static meetsRestrictions(variant, restrictions, maxHwRes) {\n    /** @type {function(number, number, number):boolean} */\n    const inRange = (x, min, max) => {\n      return x >= min && x <= max;\n    };\n\n    const video = variant.video;\n\n    if (variant.disabledUntilTime != 0) {\n      if (variant.disabledUntilTime > Date.now() / 1000) {\n        return false;\n      }\n      variant.disabledUntilTime = 0;\n    }\n\n    // |video.width| and |video.height| can be undefined, which breaks\n    // the math, so make sure they are there first.\n    if (video && video.width && video.height) {\n      if (!inRange(video.width,\n          restrictions.minWidth,\n          Math.min(restrictions.maxWidth, maxHwRes.width))) {\n        return false;\n      }\n\n      if (!inRange(video.height,\n          restrictions.minHeight,\n          Math.min(restrictions.maxHeight, maxHwRes.height))) {\n        return false;\n      }\n\n      if (!inRange(video.width * video.height,\n          restrictions.minPixels,\n          restrictions.maxPixels)) {\n        return false;\n      }\n    }\n\n    // |variant.frameRate| can be undefined, which breaks\n    // the math, so make sure they are there first.\n    if (variant && variant.video && variant.video.frameRate) {\n      if (!inRange(variant.video.frameRate,\n          restrictions.minFrameRate,\n          restrictions.maxFrameRate)) {\n        return false;\n      }\n    }\n\n    if (!inRange(variant.bandwidth,\n        restrictions.minBandwidth,\n        restrictions.maxBandwidth)) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {shaka.extern.Restrictions} restrictions\n   * @param {{width: number, height: number}} maxHwRes\n   * @return {boolean} Whether the tracks changed.\n   */\n  static applyRestrictions(variants, restrictions, maxHwRes) {\n    let tracksChanged = false;\n\n    for (const variant of variants) {\n      const originalAllowed = variant.allowedByApplication;\n      variant.allowedByApplication = shaka.util.StreamUtils.meetsRestrictions(\n          variant, restrictions, maxHwRes);\n\n      if (originalAllowed != variant.allowedByApplication) {\n        tracksChanged = true;\n      }\n    }\n\n    return tracksChanged;\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any unplayable streams.\n   *\n   * @param {shaka.media.DrmEngine} drmEngine\n   * @param {?shaka.extern.Variant} currentVariant\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static async filterManifest(\n      drmEngine, currentVariant, manifest) {\n    await shaka.util.StreamUtils.filterManifestByMediaCapabilities(manifest,\n        manifest.offlineSessionIds.length > 0);\n    shaka.util.StreamUtils.filterManifestByCurrentVariant(\n        currentVariant, manifest);\n    shaka.util.StreamUtils.filterTextStreams_(manifest);\n    await shaka.util.StreamUtils.filterImageStreams_(manifest);\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any streams unsupported by the\n   * platform via MediaCapabilities.decodingInfo() API.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {boolean} usePersistentLicenses\n   */\n  static async filterManifestByMediaCapabilities(\n      manifest, usePersistentLicenses) {\n    goog.asserts.assert(navigator.mediaCapabilities,\n        'MediaCapabilities should be valid.');\n\n    await shaka.util.StreamUtils.getDecodingInfosForVariants(\n        manifest.variants, usePersistentLicenses, /* srcEquals= */ false);\n    manifest.variants = manifest.variants.filter((variant) => {\n      // See: https://github.com/shaka-project/shaka-player/issues/3860\n      const video = variant.video;\n      const ContentType = shaka.util.ManifestParserUtils.ContentType;\n      const Capabilities = shaka.media.Capabilities;\n      if (video) {\n        let videoCodecs =\n            shaka.util.StreamUtils.getCorrectVideoCodecs_(video.codecs);\n        // For multiplexed streams. Here we must check the audio of the\n        // stream to see if it is compatible.\n        if (video.codecs.includes(',')) {\n          const allCodecs = video.codecs.split(',');\n          videoCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n              ContentType.VIDEO, allCodecs);\n          videoCodecs =\n              shaka.util.StreamUtils.getCorrectVideoCodecs_(videoCodecs);\n          let audioCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n              ContentType.AUDIO, allCodecs);\n          audioCodecs =\n              shaka.util.StreamUtils.getCorrectAudioCodecs_(audioCodecs);\n          const audioFullType = shaka.util.MimeUtils.getFullOrConvertedType(\n              video.mimeType, audioCodecs, ContentType.AUDIO);\n          if (!Capabilities.isTypeSupported(audioFullType)) {\n            return false;\n          }\n          // Update the codec string with the (possibly) converted codecs.\n          videoCodecs = [videoCodecs, audioCodecs].join(',');\n        }\n        const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n            video.mimeType, videoCodecs, ContentType.VIDEO);\n        if (!Capabilities.isTypeSupported(fullType)) {\n          return false;\n        }\n        // Update the codec string with the (possibly) converted codecs.\n        video.codecs = videoCodecs;\n      }\n      const audio = variant.audio;\n      if (audio) {\n        const codecs =\n            shaka.util.StreamUtils.getCorrectAudioCodecs_(audio.codecs);\n        const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n            audio.mimeType, codecs, ContentType.AUDIO);\n        if (!Capabilities.isTypeSupported(fullType)) {\n          return false;\n        }\n        // Update the codec string with the (possibly) converted codecs.\n        audio.codecs = codecs;\n      }\n\n      // See: https://github.com/shaka-project/shaka-player/issues/3380\n      if (shaka.util.Platform.isXboxOne() && video &&\n          ((video.width && video.width > 1920) ||\n          (video.height && video.height > 1080)) &&\n          (video.codecs.includes('avc1.') ||\n          video.codecs.includes('avc3.'))) {\n        shaka.log.debug('Dropping variant - not compatible with platform',\n            shaka.util.StreamUtils.getVariantSummaryString_(variant));\n        return false;\n      }\n\n      const supported = variant.decodingInfos.some((decodingInfo) => {\n        return decodingInfo.supported;\n      });\n      // Filter out all unsupported variants.\n      if (!supported) {\n        shaka.log.debug('Dropping variant - not compatible with platform',\n            shaka.util.StreamUtils.getVariantSummaryString_(variant));\n      }\n      return supported;\n    });\n  }\n\n\n  /**\n   * Get the decodingInfo results of the variants via MediaCapabilities.\n   * This should be called after the DrmEngine is created and configured, and\n   * before DrmEngine sets the mediaKeys.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {boolean} usePersistentLicenses\n   * @param {boolean} srcEquals\n   * @exportDoc\n   */\n  static async getDecodingInfosForVariants(variants, usePersistentLicenses,\n      srcEquals) {\n    const gotDecodingInfo = variants.some((variant) =>\n      variant.decodingInfos.length);\n    if (gotDecodingInfo) {\n      shaka.log.debug('Already got the variants\\' decodingInfo.');\n      return;\n    }\n\n    const mediaCapabilities = navigator.mediaCapabilities;\n\n    const operations = [];\n    const getVariantDecodingInfos = (async (variant, decodingConfig) => {\n      try {\n        const result = await mediaCapabilities.decodingInfo(decodingConfig);\n        variant.decodingInfos.push(result);\n      } catch (e) {\n        shaka.log.info('MediaCapabilities.decodingInfo() failed.',\n            JSON.stringify(decodingConfig), e);\n      }\n    });\n\n    for (const variant of variants) {\n      /** @type {!Array.<!MediaDecodingConfiguration>} */\n      const decodingConfigs = shaka.util.StreamUtils.getDecodingConfigs_(\n          variant, usePersistentLicenses, srcEquals);\n\n      for (const config of decodingConfigs) {\n        operations.push(getVariantDecodingInfos(variant, config));\n      }\n    }\n    await Promise.all(operations);\n  }\n\n\n  /**\n   * Generate a MediaDecodingConfiguration object to get the decodingInfo\n   * results for each variant.\n   * @param {!shaka.extern.Variant} variant\n   * @param {boolean} usePersistentLicenses\n   * @param {boolean} srcEquals\n   * @return {!Array.<!MediaDecodingConfiguration>}\n   * @private\n   */\n  static getDecodingConfigs_(variant, usePersistentLicenses, srcEquals) {\n    const audio = variant.audio;\n    const video = variant.video;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    /** @type {!MediaDecodingConfiguration} */\n    const mediaDecodingConfig = {\n      type: srcEquals ? 'file' : 'media-source',\n    };\n\n    if (video) {\n      let videoCodecs = video.codecs;\n      // For multiplexed streams with audio+video codecs, the config should have\n      // AudioConfiguration and VideoConfiguration.\n      if (video.codecs.includes(',')) {\n        const allCodecs = video.codecs.split(',');\n        videoCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n            ContentType.VIDEO, allCodecs);\n        videoCodecs =\n            shaka.util.StreamUtils.getCorrectVideoCodecs_(videoCodecs);\n        const audioCodecs = shaka.util.ManifestParserUtils.guessCodecs(\n            ContentType.AUDIO, allCodecs);\n\n        const audioFullType = shaka.util.MimeUtils.getFullOrConvertedType(\n            video.mimeType, audioCodecs, ContentType.AUDIO);\n        mediaDecodingConfig.audio = {\n          contentType: audioFullType,\n          channels: 2,\n          bitrate: variant.bandwidth || 1,\n          samplerate: 1,\n          spatialRendering: false,\n        };\n      }\n      videoCodecs = shaka.util.StreamUtils.getCorrectVideoCodecs_(videoCodecs);\n      const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n          video.mimeType, videoCodecs, ContentType.VIDEO);\n      // VideoConfiguration\n      mediaDecodingConfig.video = {\n        contentType: fullType,\n\n        // NOTE: Some decoders strictly check the width and height fields and\n        // won't decode smaller than 64x64.  So if we don't have this info (as\n        // is the case in some of our simpler tests), assume a 64x64 resolution\n        // to fill in this required field for MediaCapabilities.\n        //\n        // This became an issue specifically on Firefox on M1 Macs.\n        width: video.width || 64,\n        height: video.height || 64,\n\n        bitrate: video.bandwidth || variant.bandwidth || 1,\n        // framerate must be greater than 0, otherwise the config is invalid.\n        framerate: video.frameRate || 1,\n      };\n      if (video.hdr) {\n        switch (video.hdr) {\n          case 'SDR':\n            mediaDecodingConfig.video.transferFunction = 'srgb';\n            break;\n          case 'PQ':\n            mediaDecodingConfig.video.transferFunction = 'pq';\n            break;\n          case 'HLG':\n            mediaDecodingConfig.video.transferFunction = 'hlg';\n            break;\n        }\n      }\n    }\n    if (audio) {\n      const codecs =\n          shaka.util.StreamUtils.getCorrectAudioCodecs_(audio.codecs);\n      const fullType = shaka.util.MimeUtils.getFullOrConvertedType(\n          audio.mimeType, codecs, ContentType.AUDIO);\n\n      // AudioConfiguration\n      mediaDecodingConfig.audio = {\n        contentType: fullType,\n        channels: audio.channelsCount || 2,\n        bitrate: audio.bandwidth || variant.bandwidth || 1,\n        samplerate: audio.audioSamplingRate || 1,\n        spatialRendering: audio.spatialAudio,\n      };\n    }\n\n    const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n    const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n    const allDrmInfos = videoDrmInfos.concat(audioDrmInfos);\n\n    // Return a list containing the mediaDecodingConfig for unencrypted variant.\n    if (!allDrmInfos.length) {\n      return [mediaDecodingConfig];\n    }\n\n    // A list of MediaDecodingConfiguration objects created for the variant.\n    const configs = [];\n\n    // Get all the drm info so that we can avoid using nested loops when we\n    // just need the drm info.\n    const drmInfoByKeySystems = new Map();\n    for (const info of allDrmInfos) {\n      if (!drmInfoByKeySystems.get(info.keySystem)) {\n        drmInfoByKeySystems.set(info.keySystem, []);\n      }\n      drmInfoByKeySystems.get(info.keySystem).push(info);\n    }\n\n    const persistentState =\n        usePersistentLicenses ? 'required' : 'optional';\n    const sessionTypes =\n        usePersistentLicenses ? ['persistent-license'] : ['temporary'];\n\n    for (const keySystem of drmInfoByKeySystems.keys()) {\n      // Create a copy of the mediaDecodingConfig.\n      const config = /** @type {!MediaDecodingConfiguration} */\n          (Object.assign({}, mediaDecodingConfig));\n\n      const drmInfos = drmInfoByKeySystems.get(keySystem);\n\n      /** @type {!MediaCapabilitiesKeySystemConfiguration} */\n      const keySystemConfig = {\n        keySystem: keySystem,\n        initDataType: 'cenc',\n        persistentState: persistentState,\n        distinctiveIdentifier: 'optional',\n        sessionTypes: sessionTypes,\n      };\n\n      for (const info of drmInfos) {\n        if (info.initData && info.initData.length) {\n          const initDataTypes = new Set();\n          for (const initData of info.initData) {\n            initDataTypes.add(initData.initDataType);\n          }\n          if (initDataTypes.size > 1) {\n            shaka.log.v2('DrmInfo contains more than one initDataType,',\n                'and we use the initDataType of the first initData.',\n                info);\n          }\n          keySystemConfig.initDataType = info.initData[0].initDataType;\n        }\n\n        if (info.distinctiveIdentifierRequired) {\n          keySystemConfig.distinctiveIdentifier = 'required';\n        }\n        if (info.persistentStateRequired) {\n          keySystemConfig.persistentState = 'required';\n        }\n        if (info.sessionType) {\n          keySystemConfig.sessionTypes = [info.sessionType];\n        }\n\n        if (audio) {\n          if (!keySystemConfig.audio) {\n            // KeySystemTrackConfiguration\n            keySystemConfig.audio = {\n              robustness: info.audioRobustness,\n            };\n          } else {\n            keySystemConfig.audio.robustness =\n                keySystemConfig.audio.robustness || info.audioRobustness;\n          }\n        }\n\n        if (video) {\n          if (!keySystemConfig.video) {\n            // KeySystemTrackConfiguration\n            keySystemConfig.video = {\n              robustness: info.videoRobustness,\n            };\n          } else {\n            keySystemConfig.video.robustness =\n                keySystemConfig.video.robustness || info.videoRobustness;\n          }\n        }\n      }\n      config.keySystemConfiguration = keySystemConfig;\n      configs.push(config);\n    }\n    return configs;\n  }\n\n\n  /**\n   * Generates the correct audio codec for MediaDecodingConfiguration and\n   * for MediaSource.isTypeSupported.\n   * @param {string} codecs\n   * @return {string}\n   * @private\n   */\n  static getCorrectAudioCodecs_(codecs) {\n    // Some Tizen devices seem to misreport AC-3 support, but correctly\n    // report EC-3 support.  So query EC-3 as a fallback for AC-3.\n    // See https://github.com/shaka-project/shaka-player/issues/2989 for\n    // details.\n    if (shaka.util.Platform.isTizen()) {\n      return codecs.toLowerCase() == 'ac-3' ? 'ec-3' : codecs;\n    } else {\n      return codecs;\n    }\n  }\n\n\n  /**\n   * Generates the correct video codec for MediaDecodingConfiguration and\n   * for MediaSource.isTypeSupported.\n   * @param {string} codec\n   * @return {string}\n   * @private\n   */\n  static getCorrectVideoCodecs_(codec) {\n    if (codec.includes('avc1')) {\n      // Convert avc1 codec string from RFC-4281 to RFC-6381 for\n      // MediaSource.isTypeSupported\n      // Example, convert avc1.66.30 to avc1.42001e (0x42 == 66 and 0x1e == 30)\n      const avcdata = codec.split('.');\n      if (avcdata.length == 3) {\n        let result = avcdata.shift() + '.';\n        result += parseInt(avcdata.shift(), 10).toString(16);\n        result +=\n            ('000' + parseInt(avcdata.shift(), 10).toString(16)).slice(-4);\n        return result;\n      }\n    } else if (codec == 'vp9') {\n      // MediaCapabilities supports 'vp09...' codecs, but not 'vp9'. Translate\n      // vp9 codec strings into 'vp09...', to allow such content to play with\n      // mediaCapabilities enabled.\n      // This means profile 0, level 4.1, 8-bit color.  This supports 1080p @\n      // 60Hz.  See https://en.wikipedia.org/wiki/VP9#Levels\n      //\n      // If we don't have more detailed codec info, assume this profile and\n      // level because it's high enough to likely accommodate the parameters we\n      // do have, such as width and height.  If an implementation is checking\n      // the profile and level very strictly, we want older VP9 content to\n      // still work to some degree.  But we don't want to set a level so high\n      // that it is rejected by a hardware decoder that can't handle the\n      // maximum requirements of the level.\n      //\n      // This became an issue specifically on Firefox on M1 Macs.\n      return 'vp09.00.41.08';\n    }\n    return codec;\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any streams uncompatible with the\n   * current variant.\n   *\n   * @param {?shaka.extern.Variant} currentVariant\n   * @param {shaka.extern.Manifest} manifest\n   */\n  static filterManifestByCurrentVariant(currentVariant, manifest) {\n    const StreamUtils = shaka.util.StreamUtils;\n    manifest.variants = manifest.variants.filter((variant) => {\n      const audio = variant.audio;\n      const video = variant.video;\n      if (audio && currentVariant && currentVariant.audio) {\n        if (!StreamUtils.areStreamsCompatible_(audio, currentVariant.audio)) {\n          shaka.log.debug('Droping variant - not compatible with active audio',\n              'active audio',\n              StreamUtils.getStreamSummaryString_(currentVariant.audio),\n              'variant.audio',\n              StreamUtils.getStreamSummaryString_(audio));\n          return false;\n        }\n      }\n\n      if (video && currentVariant && currentVariant.video) {\n        if (!StreamUtils.areStreamsCompatible_(video, currentVariant.video)) {\n          shaka.log.debug('Droping variant - not compatible with active video',\n              'active video',\n              StreamUtils.getStreamSummaryString_(currentVariant.video),\n              'variant.video',\n              StreamUtils.getStreamSummaryString_(video));\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Alters the given Manifest to filter out any unsupported text streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static filterTextStreams_(manifest) {\n    // Filter text streams.\n    manifest.textStreams = manifest.textStreams.filter((stream) => {\n      const fullMimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      const keep = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n\n      if (!keep) {\n        shaka.log.debug('Dropping text stream. Is not supported by the ' +\n                        'platform.', stream);\n      }\n\n      return keep;\n    });\n  }\n\n\n  /**\n   * Alters the given Manifest to filter out any unsupported image streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static async filterImageStreams_(manifest) {\n    const imageStreams = [];\n    for (const stream of manifest.imageStreams) {\n      const mimeType = stream.mimeType;\n      if (!shaka.util.StreamUtils.supportedImageMimeTypes_.has(mimeType)) {\n        const minImage = shaka.util.StreamUtils.minImage_.get(mimeType);\n        if (minImage) {\n          // eslint-disable-next-line no-await-in-loop\n          const res = await shaka.util.StreamUtils.isImageSupported_(minImage);\n          shaka.util.StreamUtils.supportedImageMimeTypes_.set(mimeType, res);\n        } else {\n          shaka.util.StreamUtils.supportedImageMimeTypes_.set(mimeType, false);\n        }\n      }\n\n      const keep =\n          shaka.util.StreamUtils.supportedImageMimeTypes_.get(mimeType);\n\n      if (!keep) {\n        shaka.log.debug('Dropping image stream. Is not supported by the ' +\n                        'platform.', stream);\n      } else {\n        imageStreams.push(stream);\n      }\n    }\n    manifest.imageStreams = imageStreams;\n  }\n\n  /**\n   * @param {string} minImage\n   * @return {!Promise.<boolean>}\n   * @private\n   */\n  static isImageSupported_(minImage) {\n    return new Promise((resolve) => {\n      const imageElement = /** @type {HTMLImageElement} */(new Image());\n      imageElement.src = minImage;\n      if ('decode' in imageElement) {\n        imageElement.decode().then(() => {\n          resolve(true);\n        }).catch(() => {\n          resolve(false);\n        });\n      } else {\n        imageElement.onload = imageElement.onerror = () => {\n          resolve(imageElement.height === 2);\n        };\n      }\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Stream} s0\n   * @param {shaka.extern.Stream} s1\n   * @return {boolean}\n   * @private\n   */\n  static areStreamsCompatible_(s0, s1) {\n    // Basic mime types and basic codecs need to match.\n    // For example, we can't adapt between WebM and MP4,\n    // nor can we adapt between mp4a.* to ec-3.\n    // We can switch between text types on the fly,\n    // so don't run this check on text.\n    if (s0.mimeType != s1.mimeType) {\n      return false;\n    }\n\n    if (s0.codecs.split('.')[0] != s1.codecs.split('.')[0]) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {shaka.extern.Track}\n   */\n  static variantToTrack(variant) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    /** @type {?string} */\n    const audioMimeType = audio ? audio.mimeType : null;\n    /** @type {?string} */\n    const videoMimeType = video ? video.mimeType : null;\n\n    /** @type {?string} */\n    const audioCodec = audio ? audio.codecs : null;\n    /** @type {?string} */\n    const videoCodec = video ? video.codecs : null;\n\n    /** @type {!Array.<string>} */\n    const codecs = [];\n    if (videoCodec) {\n      codecs.push(videoCodec);\n    }\n    if (audioCodec) {\n      codecs.push(audioCodec);\n    }\n\n    /** @type {!Array.<string>} */\n    const mimeTypes = [];\n    if (video) {\n      mimeTypes.push(video.mimeType);\n    }\n    if (audio) {\n      mimeTypes.push(audio.mimeType);\n    }\n    /** @type {?string} */\n    const mimeType = mimeTypes[0] || null;\n\n    /** @type {!Array.<string>} */\n    const kinds = [];\n    if (audio) {\n      kinds.push(audio.kind);\n    }\n    if (video) {\n      kinds.push(video.kind);\n    }\n    /** @type {?string} */\n    const kind = kinds[0] || null;\n\n    /** @type {!Set.<string>} */\n    const roles = new Set();\n    if (audio) {\n      for (const role of audio.roles) {\n        roles.add(role);\n      }\n    }\n    if (video) {\n      for (const role of video.roles) {\n        roles.add(role);\n      }\n    }\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: variant.id,\n      active: false,\n      type: 'variant',\n      bandwidth: variant.bandwidth,\n      language: variant.language,\n      label: null,\n      kind: kind,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: mimeType,\n      audioMimeType: audioMimeType,\n      videoMimeType: videoMimeType,\n      codecs: codecs.join(', '),\n      audioCodec: audioCodec,\n      videoCodec: videoCodec,\n      primary: variant.primary,\n      roles: Array.from(roles),\n      audioRoles: null,\n      forced: false,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n      originalImageId: null,\n    };\n\n    if (video) {\n      track.videoId = video.id;\n      track.originalVideoId = video.originalId;\n      track.width = video.width || null;\n      track.height = video.height || null;\n      track.frameRate = video.frameRate || null;\n      track.pixelAspectRatio = video.pixelAspectRatio || null;\n      track.videoBandwidth = video.bandwidth || null;\n    }\n\n    if (audio) {\n      track.audioId = audio.id;\n      track.originalAudioId = audio.originalId;\n      track.channelsCount = audio.channelsCount;\n      track.audioSamplingRate = audio.audioSamplingRate;\n      track.audioBandwidth = audio.bandwidth || null;\n      track.spatialAudio = audio.spatialAudio;\n      track.label = audio.label;\n      track.audioRoles = audio.roles;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Track}\n   */\n  static textStreamToTrack(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: stream.id,\n      active: false,\n      type: ContentType.TEXT,\n      bandwidth: 0,\n      language: stream.language,\n      label: stream.label,\n      kind: stream.kind || null,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: stream.mimeType,\n      audioMimeType: null,\n      videoMimeType: null,\n      codecs: stream.codecs || null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: stream.primary,\n      roles: stream.roles,\n      audioRoles: null,\n      forced: stream.forced,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: stream.originalId,\n      originalImageId: null,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Track}\n   */\n  static imageStreamToTrack(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    let width = stream.width || null;\n    let height = stream.height || null;\n\n    // The stream width and height represent the size of the entire thumbnail\n    // sheet, so divide by the layout.\n    let reference = null;\n    // Note: segmentIndex is built by default for HLS, but not for DASH, but\n    // in DASH this information comes at the stream level and not at the\n    // segment level.\n    if (stream.segmentIndex) {\n      reference = stream.segmentIndex.get(0);\n    }\n    let layout = stream.tilesLayout;\n    if (reference) {\n      layout = reference.getTilesLayout() || layout;\n    }\n    if (layout && width != null) {\n      width /= Number(layout.split('x')[0]);\n    }\n    if (layout && height != null) {\n      height /= Number(layout.split('x')[1]);\n    }\n    // TODO: What happens if there are multiple grids, with different\n    // layout sizes, inside this image stream?\n\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: stream.id,\n      active: false,\n      type: ContentType.IMAGE,\n      bandwidth: stream.bandwidth || 0,\n      language: '',\n      label: null,\n      kind: null,\n      width,\n      height,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: stream.mimeType,\n      audioMimeType: null,\n      videoMimeType: null,\n      codecs: null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: false,\n      roles: [],\n      audioRoles: null,\n      forced: false,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: layout || null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n      originalImageId: stream.originalId,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * Generate and return an ID for this track, since the ID field is optional.\n   *\n   * @param {TextTrack|AudioTrack} html5Track\n   * @return {number} The generated ID.\n   */\n  static html5TrackId(html5Track) {\n    if (!html5Track['__shaka_id']) {\n      html5Track['__shaka_id'] = shaka.util.StreamUtils.nextTrackId_++;\n    }\n    return html5Track['__shaka_id'];\n  }\n\n\n  /**\n   * @param {TextTrack} textTrack\n   * @return {shaka.extern.Track}\n   */\n  static html5TextTrackToTrack(textTrack) {\n    const CLOSED_CAPTION_MIMETYPE =\n        shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {shaka.extern.Track} */\n    const track = StreamUtils.html5TrackToGenericShakaTrack_(textTrack);\n    track.active = textTrack.mode != 'disabled';\n    track.type = 'text';\n    track.originalTextId = textTrack.id;\n    if (textTrack.kind == 'captions') {\n      track.mimeType = CLOSED_CAPTION_MIMETYPE;\n    }\n    if (textTrack.kind) {\n      track.roles = [textTrack.kind];\n    }\n    if (textTrack.kind == 'forced') {\n      track.forced = true;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * @param {AudioTrack} audioTrack\n   * @return {shaka.extern.Track}\n   */\n  static html5AudioTrackToTrack(audioTrack) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    /** @type {shaka.extern.Track} */\n    const track = StreamUtils.html5TrackToGenericShakaTrack_(audioTrack);\n    track.active = audioTrack.enabled;\n    track.type = 'variant';\n    track.originalAudioId = audioTrack.id;\n\n    if (audioTrack.kind == 'main') {\n      track.primary = true;\n    }\n    if (audioTrack.kind) {\n      track.roles = [audioTrack.kind];\n      track.audioRoles = [audioTrack.kind];\n      track.label = audioTrack.label;\n    }\n\n    return track;\n  }\n\n\n  /**\n   * Creates a Track object with non-type specific fields filled out.  The\n   * caller is responsible for completing the Track object with any\n   * type-specific information (audio or text).\n   *\n   * @param {TextTrack|AudioTrack} html5Track\n   * @return {shaka.extern.Track}\n   * @private\n   */\n  static html5TrackToGenericShakaTrack_(html5Track) {\n    /** @type {shaka.extern.Track} */\n    const track = {\n      id: shaka.util.StreamUtils.html5TrackId(html5Track),\n      active: false,\n      type: '',\n      bandwidth: 0,\n      language: shaka.util.LanguageUtils.normalize(html5Track.language),\n      label: html5Track.label,\n      kind: html5Track.kind,\n      width: null,\n      height: null,\n      frameRate: null,\n      pixelAspectRatio: null,\n      hdr: null,\n      mimeType: null,\n      audioMimeType: null,\n      videoMimeType: null,\n      codecs: null,\n      audioCodec: null,\n      videoCodec: null,\n      primary: false,\n      roles: [],\n      forced: false,\n      audioRoles: null,\n      videoId: null,\n      audioId: null,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      tilesLayout: null,\n      audioBandwidth: null,\n      videoBandwidth: null,\n      originalVideoId: null,\n      originalAudioId: null,\n      originalTextId: null,\n      originalImageId: null,\n    };\n\n    return track;\n  }\n\n\n  /**\n   * Determines if the given variant is playable.\n   * @param {!shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  static isPlayable(variant) {\n    return variant.allowedByApplication && variant.allowedByKeySystem;\n  }\n\n\n  /**\n   * Filters out unplayable variants.\n   * @param {!Array.<!shaka.extern.Variant>} variants\n   * @return {!Array.<!shaka.extern.Variant>}\n   */\n  static getPlayableVariants(variants) {\n    return variants.filter((variant) => {\n      return shaka.util.StreamUtils.isPlayable(variant);\n    });\n  }\n\n\n  /**\n   * Filters variants according to the given audio channel count config.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {number} preferredAudioChannelCount\n   * @return {!Array.<!shaka.extern.Variant>}\n   */\n  static filterVariantsByAudioChannelCount(\n      variants, preferredAudioChannelCount) {\n    // Group variants by their audio channel counts.\n    const variantsWithChannelCounts =\n        variants.filter((v) => v.audio && v.audio.channelsCount);\n\n    /** @type {!Map.<number, !Array.<shaka.extern.Variant>>} */\n    const variantsByChannelCount = new Map();\n    for (const variant of variantsWithChannelCounts) {\n      const count = variant.audio.channelsCount;\n      goog.asserts.assert(count != null, 'Must have count after filtering!');\n      if (!variantsByChannelCount.has(count)) {\n        variantsByChannelCount.set(count, []);\n      }\n      variantsByChannelCount.get(count).push(variant);\n    }\n\n    /** @type {!Array.<number>} */\n    const channelCounts = Array.from(variantsByChannelCount.keys());\n\n    // If no variant has audio channel count info, return the original variants.\n    if (channelCounts.length == 0) {\n      return variants;\n    }\n\n    // Choose the variants with the largest number of audio channels less than\n    // or equal to the configured number of audio channels.\n    const countLessThanOrEqualtoConfig =\n        channelCounts.filter((count) => count <= preferredAudioChannelCount);\n    if (countLessThanOrEqualtoConfig.length) {\n      return variantsByChannelCount.get(\n          Math.max(...countLessThanOrEqualtoConfig));\n    }\n\n    // If all variants have more audio channels than the config, choose the\n    // variants with the fewest audio channels.\n    return variantsByChannelCount.get(Math.min(...channelCounts));\n  }\n\n  /**\n   * Chooses streams according to the given config.\n   *\n   * @param {!Array.<shaka.extern.Stream>} streams\n   * @param {string} preferredLanguage\n   * @param {string} preferredRole\n   * @param {boolean} preferredForced\n   * @return {!Array.<!shaka.extern.Stream>}\n   */\n  static filterStreamsByLanguageAndRole(\n      streams, preferredLanguage, preferredRole, preferredForced) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    let chosen = streams;\n\n    // Start with the set of primary streams.\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    const primary = streams.filter((stream) => {\n      return stream.primary;\n    });\n\n    if (primary.length) {\n      chosen = primary;\n    }\n\n    // Now reduce the set to one language.  This covers both arbitrary language\n    // choice and the reduction of the \"primary\" stream set to one language.\n    const firstLanguage = chosen.length ? chosen[0].language : '';\n    chosen = chosen.filter((stream) => {\n      return stream.language == firstLanguage;\n    });\n\n    // Find the streams that best match our language preference. This will\n    // override previous selections.\n    if (preferredLanguage) {\n      const closestLocale = LanguageUtils.findClosestLocale(\n          LanguageUtils.normalize(preferredLanguage),\n          streams.map((stream) => stream.language));\n\n      // Only replace |chosen| if we found a locale that is close to our\n      // preference.\n      if (closestLocale) {\n        chosen = streams.filter((stream) => {\n          const locale = LanguageUtils.normalize(stream.language);\n          return locale == closestLocale;\n        });\n      }\n    }\n\n    // Filter by forced preference\n    chosen = chosen.filter((stream) => {\n      return stream.forced == preferredForced;\n    });\n\n    // Now refine the choice based on role preference.\n    if (preferredRole) {\n      const roleMatches = shaka.util.StreamUtils.filterTextStreamsByRole_(\n          chosen, preferredRole);\n      if (roleMatches.length) {\n        return roleMatches;\n      } else {\n        shaka.log.warning('No exact match for the text role could be found.');\n      }\n    } else {\n      // Prefer text streams with no roles, if they exist.\n      const noRoleMatches = chosen.filter((stream) => {\n        return stream.roles.length == 0;\n      });\n      if (noRoleMatches.length) {\n        return noRoleMatches;\n      }\n    }\n\n    // Either there was no role preference, or it could not be satisfied.\n    // Choose an arbitrary role, if there are any, and filter out any other\n    // roles. This ensures we never adapt between roles.\n\n    const allRoles = chosen.map((stream) => {\n      return stream.roles;\n    }).reduce(shaka.util.Functional.collapseArrays, []);\n\n    if (!allRoles.length) {\n      return chosen;\n    }\n    return shaka.util.StreamUtils.filterTextStreamsByRole_(chosen, allRoles[0]);\n  }\n\n\n  /**\n   * Filter text Streams by role.\n   *\n   * @param {!Array.<shaka.extern.Stream>} textStreams\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Stream>}\n   * @private\n   */\n  static filterTextStreamsByRole_(textStreams, preferredRole) {\n    return textStreams.filter((stream) => {\n      return stream.roles.includes(preferredRole);\n    });\n  }\n\n\n  /**\n   * Checks if the given stream is an audio stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isAudio(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.type == ContentType.AUDIO;\n  }\n\n\n  /**\n   * Checks if the given stream is a video stream.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isVideo(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return stream.type == ContentType.VIDEO;\n  }\n\n\n  /**\n   * Get all non-null streams in the variant as an array.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {!Array.<shaka.extern.Stream>}\n   */\n  static getVariantStreams(variant) {\n    const streams = [];\n\n    if (variant.audio) {\n      streams.push(variant.audio);\n    }\n    if (variant.video) {\n      streams.push(variant.video);\n    }\n\n    return streams;\n  }\n\n\n  /**\n   * Returns a string of a variant, with the attribute values of its audio\n   * and/or video streams for log printing.\n   * @param {shaka.extern.Variant} variant\n   * @return {string}\n   * @private\n   */\n  static getVariantSummaryString_(variant) {\n    const summaries = [];\n    if (variant.audio) {\n      summaries.push(shaka.util.StreamUtils.getStreamSummaryString_(\n          variant.audio));\n    }\n    if (variant.video) {\n      summaries.push(shaka.util.StreamUtils.getStreamSummaryString_(\n          variant.video));\n    }\n    return summaries.join(', ');\n  }\n\n  /**\n   * Returns a string of an audio or video stream for log printing.\n   * @param {shaka.extern.Stream} stream\n   * @return {string}\n   * @private\n   */\n  static getStreamSummaryString_(stream) {\n    // Accepted parameters for Chromecast can be found (internally) at\n    // go/cast-mime-params\n\n    if (shaka.util.StreamUtils.isAudio(stream)) {\n      return 'type=audio' +\n             ' codecs=' + stream.codecs +\n             ' bandwidth='+ stream.bandwidth +\n             ' channelsCount=' + stream.channelsCount +\n             ' audioSamplingRate=' + stream.audioSamplingRate;\n    }\n\n    if (shaka.util.StreamUtils.isVideo(stream)) {\n      return 'type=video' +\n             ' codecs=' + stream.codecs +\n             ' bandwidth=' + stream.bandwidth +\n             ' frameRate=' + stream.frameRate +\n             ' width=' + stream.width +\n             ' height=' + stream.height;\n    }\n\n    return 'unexpected stream type';\n  }\n};\n\n\n/** @private {number} */\nshaka.util.StreamUtils.nextTrackId_ = 0;\n\n/**\n * @enum {string}\n */\nshaka.util.StreamUtils.DecodingAttributes = {\n  SMOOTH: 'smooth',\n  POWER: 'powerEfficient',\n  BANDWIDTH: 'bandwidth',\n};\n\n/**\n * @private {!Map.<string, boolean>}\n */\nshaka.util.StreamUtils.supportedImageMimeTypes_ = new Map()\n    .set('image/svg+xml', true)\n    .set('image/png', true)\n    .set('image/jpeg', true)\n    .set('image/jpg', true);\n\n/**\n * @const {string}\n * @private\n */\nshaka.util.StreamUtils.minWebPImage_ = 'data:image/webp;base64,UklGRjoAAABXRU' +\n    'JQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwY' +\n    'AAA';\n\n/**\n * @const {string}\n * @private\n */\nshaka.util.StreamUtils.minAvifImage_ = 'data:image/avif;base64,AAAAIGZ0eXBhdm' +\n    'lmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljd' +\n    'AAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEA' +\n    'AAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAA' +\n    'AamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAA' +\n    'xhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAA' +\n    'CVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=';\n\n/**\n * @const {!Map.<string, string>}\n * @private\n */\nshaka.util.StreamUtils.minImage_ = new Map()\n    .set('image/webp', shaka.util.StreamUtils.minWebPImage_)\n    .set('image/avif', shaka.util.StreamUtils.minAvifImage_);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.InitSegmentReference');\ngoog.provide('shaka.media.SegmentReference');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * Creates an InitSegmentReference, which provides the location to an\n * initialization segment.\n *\n * @export\n */\nshaka.media.InitSegmentReference = class {\n  /**\n   * @param {function():!Array.<string>} uris A function that creates the URIs\n   *   of the resource containing the segment.\n   * @param {number} startByte The offset from the start of the resource to the\n   *   start of the segment.\n   * @param {?number} endByte The offset from the start of the resource\n   *   to the end of the segment, inclusive.  A value of null indicates that the\n   *   segment extends to the end of the resource.\n   * @param {null|shaka.extern.MediaQualityInfo=} mediaQuality Information about\n   *   the quality of the media associated with this init segment.\n   * @param {number=} timescale\n   */\n  constructor(uris, startByte, endByte, mediaQuality = null, timescale) {\n    /** @type {function():!Array.<string>} */\n    this.getUris = uris;\n\n    /** @const {number} */\n    this.startByte = startByte;\n\n    /** @const {?number} */\n    this.endByte = endByte;\n\n    /** @const {shaka.extern.MediaQualityInfo|null} */\n    this.mediaQuality = mediaQuality;\n\n    /** @type {number|undefined} */\n    this.timescale = timescale;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the\n   * start of the segment.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartByte() {\n    return this.startByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the end of the\n   * segment, inclusive.  A value of null indicates that the segment extends\n   * to the end of the resource.\n   *\n   * @return {?number}\n   * @export\n   */\n  getEndByte() {\n    return this.endByte;\n  }\n\n  /**\n   * Returns the size of the init segment.\n   * @return {?number}\n   */\n  getSize() {\n    if (this.endByte) {\n      return this.endByte - this.startByte;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns media quality information for the segments associated with\n   * this init segment.\n   *\n   * @return {?shaka.extern.MediaQualityInfo}\n   */\n  getMediaQuality() {\n    return this.mediaQuality;\n  }\n\n  /**\n   * Check if two initSegmentReference have all the same values.\n   * @param {?shaka.media.InitSegmentReference} reference1\n   * @param {?shaka.media.InitSegmentReference} reference2\n   * @return {boolean}\n   */\n  static equal(reference1, reference2) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    if (!reference1 || !reference2) {\n      return reference1 == reference2;\n    } else {\n      return reference1.getStartByte() == reference2.getStartByte() &&\n          reference1.getEndByte() == reference2.getEndByte() &&\n          ArrayUtils.equal(reference1.getUris(), reference2.getUris());\n    }\n  }\n};\n\n\n/**\n * SegmentReference provides the start time, end time, and location to a media\n * segment.\n *\n * @export\n */\nshaka.media.SegmentReference = class {\n  /**\n   * @param {number} startTime The segment's start time in seconds.\n   * @param {number} endTime The segment's end time in seconds.  The segment\n   *   ends the instant before this time, so |endTime| must be strictly greater\n   *   than |startTime|.\n   * @param {function():!Array.<string>} uris\n   *   A function that creates the URIs of the resource containing the segment.\n   * @param {number} startByte The offset from the start of the resource to the\n   *   start of the segment.\n   * @param {?number} endByte The offset from the start of the resource to the\n   *   end of the segment, inclusive.  A value of null indicates that the\n   *   segment extends to the end of the resource.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   *   The segment's initialization segment metadata, or null if the segments\n   *   are self-initializing.\n   * @param {number} timestampOffset\n   *   The amount of time, in seconds, that must be added to the segment's\n   *   internal timestamps to align it to the presentation timeline.\n   *   <br>\n   *   For DASH, this value should equal the Period start time minus the first\n   *   presentation timestamp of the first frame/sample in the Period.  For\n   *   example, for MP4 based streams, this value should equal Period start\n   *   minus the first segment's tfdt box's 'baseMediaDecodeTime' field (after\n   *   it has been converted to seconds).\n   *   <br>\n   *   For HLS, this value should be 0 to keep the presentation time at the most\n   *   recent discontinuity minus the corresponding media time.\n   * @param {number} appendWindowStart\n   *   The start of the append window for this reference, relative to the\n   *   presentation.  Any content from before this time will be removed by\n   *   MediaSource.\n   * @param {number} appendWindowEnd\n   *   The end of the append window for this reference, relative to the\n   *   presentation.  Any content from after this time will be removed by\n   *   MediaSource.\n   * @param {!Array.<!shaka.media.SegmentReference>=} partialReferences\n   *   A list of SegmentReferences for the partial segments.\n   * @param {?string=} tilesLayout\n   *   The value is a grid-item-dimension consisting of two positive decimal\n   *   integers in the format: column-x-row ('4x3'). It describes the\n   *   arrangement of Images in a Grid. The minimum valid LAYOUT is '1x1'.\n   * @param {?number=} tileDuration\n   *  The explicit duration of an individual tile within the tiles grid.\n   *  If not provided, the duration should be automatically calculated based on\n   *  the duration of the reference.\n   * @param {?number=} syncTime\n   *  A time value, expressed in seconds since 1970, which is used to\n   *  synchronize between streams.  Both produced and consumed by the HLS\n   *  parser.  Other components should not need this value.\n   * @param {shaka.media.SegmentReference.Status=} status\n   *  The segment status is used to indicate that a segment does not exist or is\n   *  not available.\n   * @param {?shaka.extern.HlsAes128Key=} hlsAes128Key\n   *  The segment's AES-128-CBC full segment encryption key and iv.\n   */\n  constructor(\n      startTime, endTime, uris, startByte, endByte, initSegmentReference,\n      timestampOffset, appendWindowStart, appendWindowEnd,\n      partialReferences = [], tilesLayout = '', tileDuration = null,\n      syncTime = null, status = shaka.media.SegmentReference.Status.AVAILABLE,\n      hlsAes128Key = null) {\n    // A preload hinted Partial Segment has the same startTime and endTime.\n    goog.asserts.assert(startTime <= endTime,\n        'startTime must be less than or equal to endTime');\n    goog.asserts.assert((endByte == null) || (startByte < endByte),\n        'startByte must be < endByte');\n\n    /** @type {number} */\n    this.startTime = startTime;\n\n    /** @type {number} */\n    this.endTime = endTime;\n\n    /**\n     * The \"true\" end time of the segment, without considering the period end\n     * time.  This is necessary for thumbnail segments, where timing requires us\n     * to know the original segment duration as described in the manifest.\n     * @type {number}\n     */\n    this.trueEndTime = endTime;\n\n    /** @type {function():!Array.<string>} */\n    this.getUrisInner = uris;\n\n    /** @const {number} */\n    this.startByte = startByte;\n\n    /** @const {?number} */\n    this.endByte = endByte;\n\n    /** @type {shaka.media.InitSegmentReference} */\n    this.initSegmentReference = initSegmentReference;\n\n    /** @type {number} */\n    this.timestampOffset = timestampOffset;\n\n    /** @type {number} */\n    this.appendWindowStart = appendWindowStart;\n\n    /** @type {number} */\n    this.appendWindowEnd = appendWindowEnd;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    this.partialReferences = partialReferences;\n\n    /** @type {?string} */\n    this.tilesLayout = tilesLayout;\n\n    /** @type {?number} */\n    this.tileDuration = tileDuration;\n\n    /**\n     * A time value, expressed in seconds since 1970, which is used to\n     * synchronize between streams.  Both produced and consumed by the HLS\n     * parser.  Other components should not need this value.\n     *\n     * @type {?number}\n     */\n    this.syncTime = syncTime;\n\n    /** @type {shaka.media.SegmentReference.Status} */\n    this.status = status;\n\n    /** @type {?shaka.extern.HlsAes128Key} */\n    this.hlsAes128Key = hlsAes128Key;\n\n    /** @type {?shaka.media.SegmentReference.ThumbnailSprite} */\n    this.thumbnailSprite = null;\n\n    /** @type {number} */\n    this.discontinuitySequence = 0;\n  }\n\n  /**\n   * Creates and returns the URIs of the resource containing the segment.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getUris() {\n    return this.getUrisInner();\n  }\n\n  /**\n   * Returns the segment's start time in seconds.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartTime() {\n    return this.startTime;\n  }\n\n  /**\n   * Returns the segment's end time in seconds.\n   *\n   * @return {number}\n   * @export\n   */\n  getEndTime() {\n    return this.endTime;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the\n   * start of the segment.\n   *\n   * @return {number}\n   * @export\n   */\n  getStartByte() {\n    return this.startByte;\n  }\n\n  /**\n   * Returns the offset from the start of the resource to the end of the\n   * segment, inclusive.  A value of null indicates that the segment extends to\n   * the end of the resource.\n   *\n   * @return {?number}\n   * @export\n   */\n  getEndByte() {\n    return this.endByte;\n  }\n\n  /**\n   * Returns the size of the segment.\n   * @return {?number}\n   */\n  getSize() {\n    if (this.endByte) {\n      return this.endByte - this.startByte;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns true if it contains partial SegmentReferences.\n   * @return {boolean}\n   */\n  hasPartialSegments() {\n    return this.partialReferences.length > 0;\n  }\n\n  /**\n   * Returns the segment's tiles layout. Only defined in image segments.\n   *\n   * @return {?string}\n   * @export\n   */\n  getTilesLayout() {\n    return this.tilesLayout;\n  }\n\n  /**\n   * Returns the segment's explicit tile duration.\n   * Only defined in image segments.\n   *\n   * @return {?number}\n   * @export\n   */\n  getTileDuration() {\n    return this.tileDuration;\n  }\n\n  /**\n   * Returns the segment's status.\n   *\n   * @return {shaka.media.SegmentReference.Status}\n   * @export\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Mark the reference as unavailable.\n   *\n   * @export\n   */\n  markAsUnavailable() {\n    this.status = shaka.media.SegmentReference.Status.UNAVAILABLE;\n  }\n\n  /**\n   * Set the segment's thumbnail sprite.\n   *\n   * @param {shaka.media.SegmentReference.ThumbnailSprite} thumbnailSprite\n   * @export\n   */\n  setThumbnailSprite(thumbnailSprite) {\n    this.thumbnailSprite = thumbnailSprite;\n  }\n\n  /**\n   * Returns the segment's thumbnail sprite.\n   *\n   * @return {?shaka.media.SegmentReference.ThumbnailSprite}\n   * @export\n   */\n  getThumbnailSprite() {\n    return this.thumbnailSprite;\n  }\n\n  /**\n   * Offset the segment reference by a fixed amount.\n   *\n   * @param {number} offset The amount to add to the segment's start and end\n   *   times.\n   * @export\n   */\n  offset(offset) {\n    this.startTime += offset;\n    this.endTime += offset;\n    this.trueEndTime += offset;\n\n    for (const partial of this.partialReferences) {\n      partial.startTime += offset;\n      partial.endTime += offset;\n      partial.trueEndTime += offset;\n    }\n  }\n\n  /**\n   * Sync this segment against a particular sync time that will serve as \"0\" in\n   * the presentation timeline.\n   *\n   * @param {number} lowestSyncTime\n   * @export\n   */\n  syncAgainst(lowestSyncTime) {\n    if (this.syncTime == null) {\n      shaka.log.alwaysError('Sync attempted without sync time!');\n      return;\n    }\n    const desiredStart = this.syncTime - lowestSyncTime;\n    const offset = desiredStart - this.startTime;\n    if (Math.abs(offset) >= 0.001) {\n      this.offset(offset);\n    }\n  }\n};\n\n\n/**\n * Rather than using booleans to communicate what the state of the reference,\n * we have this enum.\n *\n * @enum {number}\n * @export\n */\nshaka.media.SegmentReference.Status = {\n  AVAILABLE: 0,\n  UNAVAILABLE: 1,\n  MISSING: 2,\n};\n\n\n/**\n * A convenient typedef for when either type of reference is acceptable.\n *\n * @typedef {shaka.media.InitSegmentReference|shaka.media.SegmentReference}\n */\nshaka.media.AnySegmentReference;\n\n\n/**\n * @typedef {{\n *   height: number,\n *   positionX: number,\n *   positionY: number,\n *   width: number\n * }}\n *\n * @property {number} height\n *    The thumbnail height in px.\n * @property {number} positionX\n *    The thumbnail left position in px.\n * @property {number} positionY\n *    The thumbnail top position in px.\n * @property {number} width\n *    The thumbnail width in px.\n * @export\n */\nshaka.media.SegmentReference.ThumbnailSprite;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.abr.SimpleAbrManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.EwmaBandwidthEstimator');\ngoog.require('shaka.log');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @summary\n * <p>\n * This defines the default ABR manager for the Player.  An instance of this\n * class is used when no ABR manager is given.\n * </p>\n * <p>\n * The behavior of this class is to take throughput samples using\n * segmentDownloaded to estimate the current network bandwidth.  Then it will\n * use that to choose the streams that best fit the current bandwidth.  It will\n * always pick the highest bandwidth variant it thinks can be played.\n * </p>\n * <p>\n * After initial choices are made, this class will call switchCallback() when\n * there is a better choice.  switchCallback() will not be called more than once\n * per ({@link shaka.abr.SimpleAbrManager.SWITCH_INTERVAL_MS}).\n * </p>\n *\n * @implements {shaka.extern.AbrManager}\n * @export\n */\nshaka.abr.SimpleAbrManager = class {\n  /** */\n  constructor() {\n    /** @private {?shaka.extern.AbrManager.SwitchCallback} */\n    this.switch_ = null;\n\n    /** @private {boolean} */\n    this.enabled_ = false;\n\n    /** @private {shaka.abr.EwmaBandwidthEstimator} */\n    this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection. We listen\n    // to the change event to be able to make quick changes in case the type\n    // of connectivity changes.\n    if (navigator.connection) {\n      navigator.connection.addEventListener('change', () => {\n        if (this.config_.useNetworkInformation && this.enabled_) {\n          this.bandwidthEstimator_ = new shaka.abr.EwmaBandwidthEstimator();\n          if (this.config_) {\n            this.bandwidthEstimator_.configure(this.config_.advanced);\n          }\n          const chosenVariant = this.chooseVariant();\n          if (chosenVariant) {\n            this.switch_(chosenVariant);\n          }\n        }\n      });\n    }\n\n    /**\n     * A filtered list of Variants to choose from.\n     * @private {!Array.<!shaka.extern.Variant>}\n     */\n    this.variants_ = [];\n\n    /** @private {number} */\n    this.playbackRate_ = 1;\n\n    /** @private {boolean} */\n    this.startupComplete_ = false;\n\n    /**\n     * The last wall-clock time, in milliseconds, when streams were chosen.\n     *\n     * @private {?number}\n     */\n    this.lastTimeChosenMs_ = null;\n\n    /** @private {?shaka.extern.AbrConfiguration} */\n    this.config_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = null;\n\n    /** @private {ResizeObserver} */\n    this.resizeObserver_ = null;\n\n    /** @private {shaka.util.Timer} */\n    this.resizeObserverTimer_ = new shaka.util.Timer(() => {\n      if (this.config_.restrictToElementSize) {\n        const chosenVariant = this.chooseVariant();\n        if (chosenVariant) {\n          this.switch_(chosenVariant);\n        }\n      }\n    });\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  stop() {\n    this.switch_ = null;\n    this.enabled_ = false;\n    this.variants_ = [];\n    this.playbackRate_ = 1;\n    this.lastTimeChosenMs_ = null;\n    this.mediaElement_ = null;\n\n    if (this.resizeObserver_) {\n      this.resizeObserver_.disconnect();\n      this.resizeObserver_ = null;\n    }\n\n    this.resizeObserverTimer_.stop();\n\n    // Don't reset |startupComplete_|: if we've left the startup interval, we\n    // can start using bandwidth estimates right away after init() is called.\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  init(switchCallback) {\n    this.switch_ = switchCallback;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  chooseVariant() {\n    const SimpleAbrManager = shaka.abr.SimpleAbrManager;\n\n    let maxHeight = Infinity;\n    let maxWidth = Infinity;\n\n    if (this.config_.restrictToScreenSize) {\n      const devicePixelRatio =\n          this.config_.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio;\n      maxHeight = window.screen.height * devicePixelRatio;\n      maxWidth = window.screen.width * devicePixelRatio;\n    }\n\n    if (this.resizeObserver_ && this.config_.restrictToElementSize) {\n      const devicePixelRatio =\n          this.config_.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio;\n      maxHeight = this.mediaElement_.clientWidth * devicePixelRatio;\n      maxWidth = this.mediaElement_.clientHeight * devicePixelRatio;\n    }\n\n    // Get sorted Variants.\n    let sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n        this.config_.restrictions, this.variants_, maxHeight, maxWidth);\n\n    const defaultBandwidthEstimate = this.getDefaultBandwidth_();\n    const currentBandwidth = this.bandwidthEstimator_.getBandwidthEstimate(\n        defaultBandwidthEstimate);\n\n    if (this.variants_.length && !sortedVariants.length) {\n      // If we couldn't meet the ABR restrictions, we should still play\n      // something.\n      // These restrictions are not \"hard\" restrictions in the way that\n      // top-level or DRM-based restrictions are.  Sort the variants without\n      // restrictions and keep just the first (lowest-bandwidth) one.\n      shaka.log.warning('No variants met the ABR restrictions. ' +\n                        'Choosing a variant by lowest bandwidth.');\n      sortedVariants = SimpleAbrManager.filterAndSortVariants_(\n          /* restrictions= */ null, this.variants_,\n          /* maxHeight= */ Infinity, /* maxWidth= */ Infinity);\n      sortedVariants = [sortedVariants[0]];\n    }\n\n    // Start by assuming that we will use the first Stream.\n    let chosen = sortedVariants[0] || null;\n\n    for (let i = 0; i < sortedVariants.length; i++) {\n      const item = sortedVariants[i];\n      const playbackRate =\n          !isNaN(this.playbackRate_) ? Math.abs(this.playbackRate_) : 1;\n      const itemBandwidth = playbackRate * item.bandwidth;\n      const minBandwidth =\n          itemBandwidth / this.config_.bandwidthDowngradeTarget;\n      let next = {bandwidth: Infinity};\n      for (let j = i + 1; j < sortedVariants.length; j++) {\n        if (item.bandwidth != sortedVariants[j].bandwidth) {\n          next = sortedVariants[j];\n          break;\n        }\n      }\n      const nextBandwidth = playbackRate * next.bandwidth;\n      const maxBandwidth = nextBandwidth / this.config_.bandwidthUpgradeTarget;\n      shaka.log.v2('Bandwidth ranges:',\n          (itemBandwidth / 1e6).toFixed(3),\n          (minBandwidth / 1e6).toFixed(3),\n          (maxBandwidth / 1e6).toFixed(3));\n\n      if (currentBandwidth >= minBandwidth &&\n          currentBandwidth <= maxBandwidth &&\n          chosen.bandwidth != item.bandwidth) {\n        chosen = item;\n      }\n    }\n\n    this.lastTimeChosenMs_ = Date.now();\n    return chosen;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  enable() {\n    this.enabled_ = true;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  disable() {\n    this.enabled_ = false;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  segmentDownloaded(deltaTimeMs, numBytes) {\n    shaka.log.v2('Segment downloaded:',\n        'deltaTimeMs=' + deltaTimeMs,\n        'numBytes=' + numBytes,\n        'lastTimeChosenMs=' + this.lastTimeChosenMs_,\n        'enabled=' + this.enabled_);\n    goog.asserts.assert(deltaTimeMs >= 0, 'expected a non-negative duration');\n    this.bandwidthEstimator_.sample(deltaTimeMs, numBytes);\n\n    if ((this.lastTimeChosenMs_ != null) && this.enabled_) {\n      this.suggestStreams_();\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getBandwidthEstimate() {\n    const defaultBandwidthEstimate = this.getDefaultBandwidth_();\n    return this.bandwidthEstimator_.getBandwidthEstimate(\n        defaultBandwidthEstimate);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setVariants(variants) {\n    this.variants_ = variants;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  playbackRateChanged(rate) {\n    this.playbackRate_ = rate;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setMediaElement(mediaElement) {\n    this.mediaElement_ = mediaElement;\n    if (this.resizeObserver_) {\n      this.resizeObserver_.disconnect();\n      this.resizeObserver_ = null;\n    }\n    if (this.mediaElement_ && 'ResizeObserver' in window) {\n      this.resizeObserver_ = new ResizeObserver(() => {\n        const SimpleAbrManager = shaka.abr.SimpleAbrManager;\n        // Batch up resize changes before checking them.\n        this.resizeObserverTimer_.tickAfter(\n            /* seconds= */ SimpleAbrManager.RESIZE_OBSERVER_BATCH_TIME);\n      });\n      this.resizeObserver_.observe(this.mediaElement_);\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  configure(config) {\n    this.config_ = config;\n    if (this.bandwidthEstimator_ && this.config_) {\n      this.bandwidthEstimator_.configure(this.config_.advanced);\n    }\n  }\n\n\n  /**\n   * Calls switch_() with the variant chosen by chooseVariant().\n   *\n   * @private\n   */\n  suggestStreams_() {\n    shaka.log.v2('Suggesting Streams...');\n    goog.asserts.assert(this.lastTimeChosenMs_ != null,\n        'lastTimeChosenMs_ should not be null');\n\n    if (!this.startupComplete_) {\n      // Check if we've got enough data yet.\n      if (!this.bandwidthEstimator_.hasGoodEstimate()) {\n        shaka.log.v2('Still waiting for a good estimate...');\n        return;\n      }\n      this.startupComplete_ = true;\n    } else {\n      // Check if we've left the switch interval.\n      const now = Date.now();\n      const delta = now - this.lastTimeChosenMs_;\n      if (delta < this.config_.switchInterval * 1000) {\n        shaka.log.v2('Still within switch interval...');\n        return;\n      }\n    }\n\n    const chosenVariant = this.chooseVariant();\n    const defaultBandwidthEstimate = this.getDefaultBandwidth_();\n    const bandwidthEstimate = this.bandwidthEstimator_.getBandwidthEstimate(\n        defaultBandwidthEstimate);\n    const currentBandwidthKbps = Math.round(bandwidthEstimate / 1000.0);\n\n    if (chosenVariant) {\n      shaka.log.debug(\n          'Calling switch_(), bandwidth=' + currentBandwidthKbps + ' kbps');\n      // If any of these chosen streams are already chosen, Player will filter\n      // them out before passing the choices on to StreamingEngine.\n      this.switch_(chosenVariant);\n    }\n  }\n\n\n  /**\n   * @private\n   */\n  getDefaultBandwidth_() {\n    let defaultBandwidthEstimate = this.config_.defaultBandwidthEstimate;\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection.  Tizen 3 has\n    // NetworkInformation, but not the downlink attribute.\n    if (navigator.connection && navigator.connection.downlink &&\n        this.config_.useNetworkInformation) {\n      // If it's available, get the bandwidth estimate from the browser (in\n      // megabits per second) and use it as defaultBandwidthEstimate.\n      defaultBandwidthEstimate = navigator.connection.downlink * 1e6;\n    }\n    return defaultBandwidthEstimate;\n  }\n\n\n  /**\n   * @param {?shaka.extern.Restrictions} restrictions\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {!number} maxHeight\n   * @param {!number} maxWidth\n   * @return {!Array.<shaka.extern.Variant>} variants filtered according to\n   *   |restrictions| and sorted in ascending order of bandwidth.\n   * @private\n   */\n  static filterAndSortVariants_(restrictions, variants, maxHeight, maxWidth) {\n    if (restrictions) {\n      variants = variants.filter((variant) => {\n        // This was already checked in another scope, but the compiler doesn't\n        // seem to understand that.\n        goog.asserts.assert(restrictions, 'Restrictions should exist!');\n\n        return shaka.util.StreamUtils.meetsRestrictions(\n            variant, restrictions,\n            /* maxHwRes= */ {width: maxWidth, height: maxHeight});\n      });\n    }\n\n    return variants.sort((v1, v2) => {\n      return v1.bandwidth - v2.bandwidth;\n    });\n  }\n};\n\n\n/**\n * The amount of time, in seconds, we wait to batch up rapid resize changes.\n * This allows us to avoid multiple resize events in most cases.\n * @type {number}\n */\nshaka.abr.SimpleAbrManager.RESIZE_OBSERVER_BATCH_TIME = 1;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.deprecate.Version');\n\n/**\n * A class that defines what a library version is within the deprecation\n * system. Within deprecation we only care about the major and minor versions.\n *\n * @final\n */\nshaka.deprecate.Version = class {\n  /**\n   * @param {number} major\n   * @param {number} minor\n   */\n  constructor(major, minor) {\n    this.major_ = major;\n    this.minor_ = minor;\n  }\n\n  /** @return {number} */\n  major() { return this.major_; }\n\n  /** @return {number} */\n  minor() { return this.minor_; }\n\n  /**\n   * Returns:\n   *  - positive if |this| > |other|\n   *  - zero if |this| == |other|\n   *  - negative if |this| < |other|\n   *\n   * @param {!shaka.deprecate.Version} other\n   * @return {number}\n   */\n  compareTo(other) {\n    const majorCheck = this.major_ - other.major_;\n    const minorCheck = this.minor_ - other.minor_;\n\n    return majorCheck || minorCheck;\n  }\n\n  /** @override */\n  toString() {\n    return 'v' + this.major_ + '.' + this.minor_;\n  }\n\n  /**\n   * Parse the major and minor values out of a version string that is assumed\n   * to follow the grammar: \"vMAJOR.MINOR.\". What comes after the last \".\" we\n   * will ignore.\n   *\n   * @param {string} versionString\n   * @return {!shaka.deprecate.Version}\n   */\n  static parse(versionString) {\n    // Make sure to drop the \"v\" from the front. We limit the number of splits\n    // to two as we don't care what happens after the minor version number.\n    // For example: 'a.b.c.d'.split('.', 2) == ['a', 'b']\n    const components = versionString.substring(1).split('.', /* limit= */ 2);\n\n    return new shaka.deprecate.Version(\n        Number(components[0]),\n        Number(components[1]));\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.Deprecate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.deprecate.Enforcer');\ngoog.require('shaka.deprecate.Version');\ngoog.require('shaka.log');\n\n\n/**\n * |shaka.Deprecate| is the front-end of the deprecation system, allowing for\n * any part of the code to say that \"this block of code should be removed by\n * version X\".\n *\n * @final\n */\nshaka.Deprecate = class {\n  /**\n   * Initialize the system. This must happen before any calls to |enforce|. In\n   * our code base, |shaka.Player| will be the only one to call this (it has the\n   * version string).\n   *\n   * If the |Deprecate| called |Player.version| to initialize itself, it would\n   * mean that |Player| could not use |Deprecate| because it would create a\n   * circular dependency. To work around this, we provide this method so that\n   * |Player| can give us the version without us needing to know about |Player|.\n   *\n   * This will initialize the system to:\n   *  - print warning messages when the feature is scheduled to be removed in a\n   *    later version\n   *  - print errors and fail assertions when the feature should be removed now\n   *\n   * @param {string} versionString\n   */\n  static init(versionString) {\n    goog.asserts.assert(\n        shaka.Deprecate.enforcer_ == null,\n        'Deprecate.init should only be called once.');\n\n    shaka.Deprecate.enforcer_ = new shaka.deprecate.Enforcer(\n        shaka.deprecate.Version.parse(versionString),\n        shaka.Deprecate.onPending_,\n        shaka.Deprecate.onExpired_);\n  }\n\n  /**\n   * Ask the deprecation system to require this feature to be removed by the\n   * given version.\n   *\n   * @param {number} major\n   * @param {string} name\n   * @param {string} description\n   */\n  static deprecateFeature(major, name, description) {\n    const enforcer = shaka.Deprecate.enforcer_;\n    goog.asserts.assert(\n        enforcer,\n        'Missing deprecation enforcer. Was |init| called?');\n\n    const expiresAt = new shaka.deprecate.Version(major, 0);\n    enforcer.enforce(expiresAt, name, description);\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onPending_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    shaka.log.alwaysWarn([\n      name,\n      'has been deprecated and will be removed in',\n      featureVersion,\n      '. We are currently at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join(' '));\n  }\n\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {!shaka.deprecate.Version} featureVersion\n   * @param {string} name\n   * @param {string} description\n   * @private\n   */\n  static onExpired_(libraryVersion, featureVersion, name, description) {\n    // If we were to pass each value to the log call, it would be printed as\n    // a comma-separated list. To make the print state appear more natural to\n    // the reader, create one string for the message.\n    const errorMessage = [\n      name,\n      'has been deprecated and has been removed in',\n      featureVersion,\n      '. We are now at version',\n      libraryVersion,\n      '. Additional information:',\n      description,\n    ].join('');\n\n    shaka.log.alwaysError(errorMessage);\n    goog.asserts.assert(false, errorMessage);\n  }\n};\n\n/**\n * The global deprecation enforcer that will be set by the player (because the\n * player knows the version) when it calls |init|. This may appear a little\n * round-about to you, because it is. Since player uses |Deprecate|, it means\n * that |Deprecate| can't depend on Player directly.\n *\n * @private {shaka.deprecate.Enforcer}\n */\nshaka.Deprecate.enforcer_ = null;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.Player');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Deprecate');\ngoog.require('shaka.config.AutoShowText');\ngoog.require('shaka.log');\ngoog.require('shaka.media.AdaptationSetCriteria');\ngoog.require('shaka.media.BufferingObserver');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ExampleBasedCriteria');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.MediaSourcePlayhead');\ngoog.require('shaka.media.MetaSegmentIndex');\ngoog.require('shaka.media.PlayRateController');\ngoog.require('shaka.media.Playhead');\ngoog.require('shaka.media.PlayheadObserverManager');\ngoog.require('shaka.media.PreferenceBasedCriteria');\ngoog.require('shaka.media.QualityObserver');\ngoog.require('shaka.media.RegionObserver');\ngoog.require('shaka.media.RegionTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.media.SrcEqualsPlayhead');\ngoog.require('shaka.media.StreamingEngine');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.routing.Walker');\ngoog.require('shaka.text.SimpleTextDisplayer');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.UITextDisplayer');\ngoog.require('shaka.text.WebVttGenerator');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.CmcdManager');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Stats');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.lcevc.Dil');\ngoog.requireType('shaka.media.PresentationTimeline');\ngoog.requireType('shaka.routing.Node');\ngoog.requireType('shaka.routing.Payload');\n\n\n/**\n * @event shaka.Player.ErrorEvent\n * @description Fired when a playback error occurs.\n * @property {string} type\n *   'error'\n * @property {!shaka.util.Error} detail\n *   An object which contains details on the error.  The error's\n *   <code>category</code> and <code>code</code> properties will identify the\n *   specific error that occurred.  In an uncompiled build, you can also use the\n *   <code>message</code> and <code>stack</code> properties to debug.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateChangeEvent\n * @description Fired when the player changes load states.\n * @property {string} type\n *    'onstatechange'\n * @property {string} state\n *    The name of the state that the player just entered.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.StateIdleEvent\n * @description Fired when the player has stopped changing states and will\n *    remain idle until a new state change request (e.g. <code>load</code>,\n *    <code>attach</code>, etc.) is made.\n * @property {string} type\n *    'onstateidle'\n * @property {string} state\n *    The name of the state that the player stopped in.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.EmsgEvent\n * @description Fired when a non-typical emsg is found in a segment.\n * @property {string} type\n *   'emsg'\n * @property {shaka.extern.EmsgInfo} detail\n *   An object which contains the content of the emsg box.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DownloadFailed\n * @description Fired when a download has failed, for any reason.\n *   'downloadfailed'\n * @property {!shaka.extern.Request} request\n * @property {?shaka.util.Error} error\n * @param {number} httpResponseCode\n * @param {boolean} aborted\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DownloadHeadersReceived\n * @description Fired when the networking engine has received the headers for\n *    a download, but before the body has been downloaded.\n *    If the HTTP plugin being used does not track this information, this event\n *    will default to being fired when the body is received, instead.\n * @property {!Object.<string, string>} headers\n * @property {!shaka.extern.Request} request\n * @property {!shaka.net.NetworkingEngine.RequestType} type\n *   'downloadheadersreceived'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.DrmSessionUpdateEvent\n * @description Fired when the CDM has accepted the license response.\n * @property {string} type\n *   'drmsessionupdate'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionAddedEvent\n * @description Fired when a media timeline region is added.\n * @property {string} type\n *   'timelineregionadded'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionEnterEvent\n * @description Fired when the playhead enters a timeline region.\n * @property {string} type\n *   'timelineregionenter'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TimelineRegionExitEvent\n * @description Fired when the playhead exits a timeline region.\n * @property {string} type\n *   'timelineregionexit'\n * @property {shaka.extern.TimelineRegionInfo} detail\n *   An object which contains a description of the region.\n * @exportDoc\n */\n\n/**\n * @event shaka.Player.MediaQualityChangedEvent\n * @description Fired when the media quality changes at the playhead.\n * That may be caused by an adaptation change or a DASH period transition.\n * Separate events are emitted for audio and video contentTypes.\n * This is supported for only DASH streams at this time.\n * @property {string} type\n *   'mediaqualitychanged'\n * @property {shaka.extern.MediaQualityInfo} mediaQuality\n *   Information about media quality at the playhead position.\n * @property {number} position\n *   The playhead position.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.BufferingEvent\n * @description Fired when the player's buffering state changes.\n * @property {string} type\n *   'buffering'\n * @property {boolean} buffering\n *   True when the Player enters the buffering state.\n *   False when the Player leaves the buffering state.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadingEvent\n * @description Fired when the player begins loading. The start of loading is\n *   defined as when the user has communicated intent to load content (i.e.\n *   <code>Player.load</code> has been called).\n * @property {string} type\n *   'loading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.LoadedEvent\n * @description Fired when the player ends the load.\n * @property {string} type\n *   'loaded'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.UnloadingEvent\n * @description Fired when the player unloads or fails to load.\n *   Used by the Cast receiver to determine idle state.\n * @property {string} type\n *   'unloading'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextTrackVisibilityEvent\n * @description Fired when text track visibility changes.\n * @property {string} type\n *   'texttrackvisibility'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TracksChangedEvent\n * @description Fired when the list of tracks changes.  For example, this will\n *   happen when new tracks are added/removed or when track restrictions change.\n * @property {string} type\n *   'trackschanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AdaptationEvent\n * @description Fired when an automatic adaptation causes the active tracks\n *   to change.  Does not fire when the application calls\n *   <code>selectVariantTrack()</code>, <code>selectTextTrack()</code>,\n *   <code>selectAudioLanguage()</code>, or <code>selectTextLanguage()</code>.\n * @property {string} type\n *   'adaptation'\n * @property {shaka.extern.Track} oldTrack\n * @property {shaka.extern.Track} newTrack\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.VariantChangedEvent\n * @description Fired when a call from the application caused a variant change.\n *  Can be triggered by calls to <code>selectVariantTrack()</code> or\n *  <code>selectAudioLanguage()</code>. Does not fire when an automatic\n *  adaptation causes a variant change.\n * @property {string} type\n *   'variantchanged'\n * @property {shaka.extern.Track} oldTrack\n * @property {shaka.extern.Track} newTrack\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.TextChangedEvent\n * @description Fired when a call from the application caused a text stream\n *  change. Can be triggered by calls to <code>selectTextTrack()</code> or\n *  <code>selectTextLanguage()</code>.\n * @property {string} type\n *   'textchanged'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ExpirationUpdatedEvent\n * @description Fired when there is a change in the expiration times of an\n *   EME session.\n * @property {string} type\n *   'expirationupdated'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.ManifestParsedEvent\n * @description Fired after the manifest has been parsed, but before anything\n *   else happens. The manifest may contain streams that will be filtered out,\n *   at this stage of the loading process.\n * @property {string} type\n *   'manifestparsed'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.MetadataEvent\n * @description Triggers after metadata associated with the stream is found.\n *   Usually they are metadata of type ID3.\n * @property {string} type\n *   'metadata'\n * @property {number} startTime\n *   The time that describes the beginning of the range of the metadata to\n *   which the cue applies.\n * @property {?number} endTime\n *   The time that describes the end of the range of the metadata to which\n *   the cue applies.\n * @property {string} metadataType\n *   Type of metadata. Eg: org.id3 or org.mp4ra\n * @property {shaka.extern.MetadataFrame} payload\n *   The metadata itself\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.StreamingEvent\n * @description Fired after the manifest has been parsed and track information\n *   is available, but before streams have been chosen and before any segments\n *   have been fetched.  You may use this event to configure the player based on\n *   information found in the manifest.\n * @property {string} type\n *   'streaming'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.AbrStatusChangedEvent\n * @description Fired when the state of abr has been changed.\n *    (Enabled or disabled).\n * @property {string} type\n *   'abrstatuschanged'\n * @property {boolean} newStatus\n *  The new status of the application. True for 'is enabled' and\n *  false otherwise.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.RateChangeEvent\n * @description Fired when the video's playback rate changes.\n *    This allows the PlayRateController to update it's internal rate field,\n *    before the UI updates playback button with the newest playback rate.\n * @property {string} type\n *    'ratechange'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.SegmentAppended\n * @description Fired when a segment is appended to the media element.\n * @property {string} type\n *   'segmentappended'\n * @property {number} start\n *   The start time of the segment.\n * @property {number} end\n *   The end time of the segment.\n * @property {string} contentType\n *   The content type of the segment. E.g. 'video', 'audio', or 'text'.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.SessionDataEvent\n * @description Fired when the manifest parser find info about session data.\n *    Specification: https://tools.ietf.org/html/rfc8216#section-4.3.4.4\n * @property {string} type\n *   'sessiondata'\n * @property {string} id\n *   The id of the session data.\n * @property {string} uri\n *   The uri with the session data info.\n * @property {string} language\n *   The language of the session data.\n * @property {string} value\n *   The value of the session data.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.StallDetectedEvent\n * @description Fired when a stall in playback is detected by the StallDetector.\n *     Not all stalls are caused by gaps in the buffered ranges.\n * @property {string} type\n *   'stalldetected'\n * @exportDoc\n */\n\n\n/**\n * @event shaka.Player.GapJumpedEvent\n * @description Fired when the GapJumpingController jumps over a gap in the\n *     buffered ranges.\n * @property {string} type\n *   'gapjumped'\n * @exportDoc\n */\n\n\n/**\n * @summary The main player object for Shaka Player.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.Player = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {HTMLMediaElement=} mediaElement\n   *    When provided, the player will attach to <code>mediaElement</code>,\n   *    similar to calling <code>attach</code>. When not provided, the player\n   *    will remain detached.\n   * @param {function(shaka.Player)=} dependencyInjector Optional callback\n   *   which is called to inject mocks into the Player.  Used for testing.\n   */\n  constructor(mediaElement, dependencyInjector) {\n    super();\n\n    /** @private {shaka.Player.LoadMode} */\n    this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = null;\n\n    /** @private {HTMLElement} */\n    this.videoContainer_ = null;\n\n    /**\n     * Since we may not always have a text displayer created (e.g. before |load|\n     * is called), we need to track what text visibility SHOULD be so that we\n     * can ensure that when we create the text displayer. When we create our\n     * text displayer, we will use this to show (or not show) text as per the\n     * user's requests.\n     *\n     * @private {boolean}\n     */\n    this.isTextVisible_ = false;\n\n    /**\n     * For listeners scoped to the lifetime of the Player instance.\n     * @private {shaka.util.EventManager}\n     */\n    this.globalEventManager_ = new shaka.util.EventManager();\n\n    /**\n     * For listeners scoped to the lifetime of the media element attachment.\n     * @private {shaka.util.EventManager}\n     */\n    this.attachEventManager_ = new shaka.util.EventManager();\n\n    /**\n     * For listeners scoped to the lifetime of the loaded content.\n     * @private {shaka.util.EventManager}\n     */\n    this.loadEventManager_ = new shaka.util.EventManager();\n\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = null;\n\n    /** @private {shaka.media.DrmEngine} */\n    this.drmEngine_ = null;\n\n    /** @private {shaka.media.MediaSourceEngine} */\n    this.mediaSourceEngine_ = null;\n\n    /** @private {shaka.media.Playhead} */\n    this.playhead_ = null;\n\n    /**\n     * The playhead observers are used to monitor the position of the playhead\n     * and some other source of data (e.g. buffered content), and raise events.\n     *\n     * @private {shaka.media.PlayheadObserverManager}\n     */\n    this.playheadObservers_ = null;\n\n    /**\n     * This is our control over the playback rate of the media element. This\n     * provides the missing functionality that we need to provide trick play,\n     * for example a negative playback rate.\n     *\n     * @private {shaka.media.PlayRateController}\n     */\n    this.playRateController_ = null;\n\n    // We use the buffering observer and timer to track when we move from having\n    // enough buffered content to not enough. They only exist when content has\n    // been loaded and are not re-used between loads.\n    /** @private {shaka.util.Timer} */\n    this.bufferPoller_ = null;\n\n    /** @private {shaka.media.BufferingObserver} */\n    this.bufferObserver_ = null;\n\n    /** @private {shaka.media.RegionTimeline} */\n    this.regionTimeline_ = null;\n\n    /** @private {shaka.util.CmcdManager} */\n    this.cmcdManager_ = null;\n\n    // This is the canvas element that will be used for rendering LCEVC\n    // enhanced frames.\n    /** @private {?HTMLCanvasElement} */\n    this.lcevcCanvas_ = null;\n\n    // This is the LCEVC Dil object to decode LCEVC.\n    /** @private {?shaka.lcevc.Dil} */\n    this.lcevcDil_ = null;\n\n    /** @private {shaka.media.QualityObserver} */\n    this.qualityObserver_ = null;\n\n    /** @private {shaka.media.StreamingEngine} */\n    this.streamingEngine_ = null;\n\n    /** @private {shaka.extern.ManifestParser} */\n    this.parser_ = null;\n\n    /** @private {?shaka.extern.ManifestParser.Factory} */\n    this.parserFactory_ = null;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {?string} */\n    this.assetUri_ = null;\n\n    /** @private {boolean} */\n    this.fullyLoaded_ = false;\n\n    /** @private {shaka.extern.AbrManager} */\n    this.abrManager_ = null;\n\n    /**\n     * The factory that was used to create the abrManager_ instance.\n     * @private {?shaka.extern.AbrManager.Factory}\n     */\n    this.abrManagerFactory_ = null;\n\n    /**\n     * Contains an ID for use with creating streams.  The manifest parser should\n     * start with small IDs, so this starts with a large one.\n     * @private {number}\n     */\n    this.nextExternalStreamId_ = 1e9;\n\n    /** @private {?shaka.extern.PlayerConfiguration} */\n    this.config_ = this.defaultConfig_();\n\n    /**\n     * The TextDisplayerFactory that was last used to make a text displayer.\n     * Stored so that we can tell if a new type of text displayer is desired.\n     * @private {?shaka.extern.TextDisplayer.Factory}\n     */\n    this.lastTextFactory_;\n\n    /** @private {{width: number, height: number}} */\n    this.maxHwRes_ = {width: Infinity, height: Infinity};\n\n    /** @private {shaka.util.Stats} */\n    this.stats_ = null;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(\n            this.config_.preferredAudioLanguage,\n            this.config_.preferredVariantRole,\n            this.config_.preferredAudioChannelCount);\n\n    /** @private {string} */\n    this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n\n    /** @private {string} */\n    this.currentTextRole_ = this.config_.preferredTextRole;\n\n    /** @private {boolean} */\n    this.currentTextForced_ = this.config_.preferForcedSubs;\n\n    /** @private {!Array.<function():(!Promise|undefined)>} */\n    this.cleanupOnUnload_ = [];\n\n    /**\n     * This playback start position will be used when\n     * <code>updateStartTime()</code> has been called to provide an updated\n     * start position during the media loading process.\n     *\n     * @private {?number}\n     */\n    this.updatedStartTime_ = null;\n\n    if (dependencyInjector) {\n      dependencyInjector(this);\n    }\n\n    this.networkingEngine_ = this.createNetworkingEngine();\n    this.networkingEngine_.setForceHTTPS(this.config_.streaming.forceHTTPS);\n\n    /** @private {shaka.extern.IAdManager} */\n    this.adManager_ = null;\n\n    if (shaka.Player.adManagerFactory_) {\n      this.adManager_ = shaka.Player.adManagerFactory_();\n    }\n\n    // If the browser comes back online after being offline, then try to play\n    // again.\n    this.globalEventManager_.listen(window, 'online', () => {\n      this.retryStreaming();\n    });\n\n    /** @private {shaka.routing.Node} */\n    this.detachNode_ = {name: 'detach'};\n    /** @private {shaka.routing.Node} */\n    this.attachNode_ = {name: 'attach'};\n    /** @private {shaka.routing.Node} */\n    this.unloadNode_ = {name: 'unload'};\n    /** @private {shaka.routing.Node} */\n    this.parserNode_ = {name: 'manifest-parser'};\n    /** @private {shaka.routing.Node} */\n    this.manifestNode_ = {name: 'manifest'};\n    /** @private {shaka.routing.Node} */\n    this.mediaSourceNode_ = {name: 'media-source'};\n    /** @private {shaka.routing.Node} */\n    this.drmNode_ = {name: 'drm-engine'};\n    /** @private {shaka.routing.Node} */\n    this.loadNode_ = {name: 'load'};\n    /** @private {shaka.routing.Node} */\n    this.srcEqualsDrmNode_ = {name: 'src-equals-drm-engine'};\n    /** @private {shaka.routing.Node} */\n    this.srcEqualsNode_ = {name: 'src-equals'};\n\n    const AbortableOperation = shaka.util.AbortableOperation;\n\n    const actions = new Map();\n    actions.set(this.attachNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onAttach_(has, wants));\n    });\n    actions.set(this.detachNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onDetach_(has, wants));\n    });\n    actions.set(this.unloadNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onUnload_(has, wants));\n    });\n    actions.set(this.mediaSourceNode_, (has, wants) => {\n      const p = this.onInitializeMediaSourceEngine_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.parserNode_, (has, wants) => {\n      const p = this.onInitializeParser_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.manifestNode_, (has, wants) => {\n      // This action is actually abortable, so unlike the other callbacks, this\n      // one will return an abortable operation.\n      return this.onParseManifest_(has, wants);\n    });\n    actions.set(this.drmNode_, (has, wants) => {\n      const p = this.onInitializeDrm_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.loadNode_, (has, wants) => {\n      return AbortableOperation.notAbortable(this.onLoad_(has, wants));\n    });\n\n    actions.set(this.srcEqualsDrmNode_, (has, wants) => {\n      const p = this.onInitializeSrcEqualsDrm_(has, wants);\n      return AbortableOperation.notAbortable(p);\n    });\n    actions.set(this.srcEqualsNode_, (has, wants) => {\n      return this.onSrcEquals_(has, wants);\n    });\n\n    /** @private {shaka.routing.Walker.Implementation} */\n    const walkerImplementation = {\n      getNext: (at, has, goingTo, wants) => {\n        return this.getNextStep_(at, has, goingTo, wants);\n      },\n      enterNode: (node, has, wants) => {\n        this.dispatchEvent(this.makeEvent_(\n            /* name= */ shaka.util.FakeEvent.EventName.OnStateChange,\n            /* data= */ (new Map()).set('state', node.name)));\n\n        const action = actions.get(node);\n        return action(has, wants);\n      },\n      handleError: async (has, error) => {\n        shaka.log.warning('The walker saw an error:');\n        if (error instanceof shaka.util.Error) {\n          shaka.log.warning('Error Code:', error.code);\n        } else {\n          shaka.log.warning('Error Message:', error.message);\n          shaka.log.warning('Error Stack:', error.stack);\n        }\n\n        // Regardless of what state we were in, if there is an error, we unload.\n        // This ensures that any initialized system will be torn-down and we\n        // will go back to a safe foundation. We assume that the media element\n        // is always safe to use after an error.\n        await this.onUnload_(has, shaka.Player.createEmptyPayload_());\n\n        // There are only two nodes that come before we start loading content,\n        // attach and detach. If we have a media element, it means we were\n        // attached to the element, and we can safely return to the attach state\n        // (we assume that the video element is always re-usable). We favor\n        // returning to the attach node since it means that the app won't need\n        // to re-attach if it saw an error.\n        return has.mediaElement ? this.attachNode_ : this.detachNode_;\n      },\n      onIdle: (node) => {\n        this.dispatchEvent(this.makeEvent_(\n            /* name= */ shaka.util.FakeEvent.EventName.OnStateIdle,\n            /* data= */ (new Map()).set('state', node.name)));\n      },\n    };\n\n    /** @private {shaka.routing.Walker} */\n    this.walker_ = new shaka.routing.Walker(\n        this.detachNode_,\n        shaka.Player.createEmptyPayload_(),\n        walkerImplementation);\n\n    /** @private {shaka.util.Timer} */\n    this.checkVariantsTimer_ =\n        new shaka.util.Timer(() => this.checkVariants_());\n\n    // Even though |attach| will start in later interpreter cycles, it should be\n    // the LAST thing we do in the constructor because conceptually it relies on\n    // player having been initialized.\n    if (mediaElement) {\n      this.attach(mediaElement, /* initializeMediaSource= */ true);\n    }\n  }\n\n  /**\n   * Create a shaka.lcevc.Dil object\n   * @param {shaka.extern.LcevcConfiguration} config\n   * @private\n   */\n  createLcevcDil_(config) {\n    if (this.lcevcDil_ == null) {\n      this.lcevcDil_ = new shaka.lcevc.Dil(\n          /** @type {HTMLVideoElement} */ (this.video_),\n          this.lcevcCanvas_,\n          config,\n      );\n      if (this.mediaSourceEngine_) {\n        this.mediaSourceEngine_.updateLcevcDil(this.lcevcDil_);\n      }\n    }\n  }\n\n  /**\n   * Close a shaka.lcevc.Dil object if present and hide the canvas.\n   * @private\n   */\n  closeLcevcDil_() {\n    if (this.lcevcDil_ != null) {\n      this.lcevcDil_.release();\n      this.lcevcDil_ = null;\n    }\n  }\n\n  /**\n   * Setup shaka.lcevc.Dil object\n   * @param {?shaka.extern.PlayerConfiguration} config\n   * @private\n   */\n  setupLcevc_(config) {\n    if (config.lcevc.enabled) {\n      const tracks = this.getVariantTracks();\n      if (tracks && tracks[0] &&\n        tracks[0].videoMimeType ==\n        shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_['ts']) {\n        const edge = shaka.util.Platform.isEdge() ||\n          shaka.util.Platform.isLegacyEdge();\n        if (edge) {\n          if (!config.streaming.forceTransmux) {\n            // If forceTransmux is disabled for Microsoft Edge, LCEVC data\n            // is stripped out in case of a MPEG-2 TS container.\n            // Hence the warning for Microsoft Edge when playing content with\n            // MPEG-2 TS container.\n            shaka.log.alwaysWarn('LCEVC Warning: For MPEG-2 TS decoding '+\n            'the config.streaming.forceTransmux must be enabled.');\n          }\n        }\n      }\n      this.closeLcevcDil_();\n      this.createLcevcDil_(config.lcevc);\n    } else {\n      this.closeLcevcDil_();\n    }\n  }\n\n  /**\n   * @param {!shaka.util.FakeEvent.EventName} name\n   * @param {Map.<string, Object>=} data\n   * @return {!shaka.util.FakeEvent}\n   * @private\n   */\n  makeEvent_(name, data) {\n    return new shaka.util.FakeEvent(name, data);\n  }\n\n  /**\n   * After destruction, a Player object cannot be used again.\n   *\n   * @override\n   * @export\n   */\n  async destroy() {\n    // Make sure we only execute the destroy logic once.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n\n    // If LCEVC Dil exists close it.\n    this.closeLcevcDil_();\n\n    // Mark as \"dead\". This should stop external-facing calls from changing our\n    // internal state any more. This will stop calls to |attach|, |detach|, etc.\n    // from interrupting our final move to the detached state.\n    this.loadMode_ = shaka.Player.LoadMode.DESTROYED;\n\n    // Because we have set |loadMode_| to |DESTROYED| we can't call |detach|. We\n    // must talk to |this.walker_| directly.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: this.detachNode_,\n        payload: shaka.Player.createEmptyPayload_(),\n        interruptible: false,\n      };\n    });\n\n    // Wait until the detach has finished so that we don't interrupt it by\n    // calling |destroy| on |this.walker_|. To avoid failing here, we always\n    // resolve the promise.\n    await new Promise((resolve) => {\n      events.onStart = () => {\n        shaka.log.info('Preparing to destroy walker...');\n      };\n      events.onEnd = () => {\n        resolve();\n      };\n      events.onCancel = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never be cancelled.');\n        resolve();\n      };\n      events.onError = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never see an error');\n        resolve();\n      };\n      events.onSkip = () => {\n        goog.asserts.assert(false,\n            'Our final detach call should never be skipped');\n        resolve();\n      };\n    });\n    await this.walker_.destroy();\n\n    // Tear-down the event managers to ensure handlers stop firing.\n    if (this.globalEventManager_) {\n      this.globalEventManager_.release();\n      this.globalEventManager_ = null;\n    }\n    if (this.attachEventManager_) {\n      this.attachEventManager_.release();\n      this.attachEventManager_ = null;\n    }\n    if (this.loadEventManager_) {\n      this.loadEventManager_.release();\n      this.loadEventManager_ = null;\n    }\n\n    this.abrManagerFactory_ = null;\n    this.abrManager_ = null;\n    this.config_ = null;\n    this.stats_ = null;\n    this.videoContainer_ = null;\n    this.cmcdManager_ = null;\n\n    if (this.networkingEngine_) {\n      await this.networkingEngine_.destroy();\n      this.networkingEngine_ = null;\n    }\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n  }\n\n  /**\n   * Registers a plugin callback that will be called with\n   * <code>support()</code>.  The callback will return the value that will be\n   * stored in the return value from <code>support()</code>.\n   *\n   * @param {string} name\n   * @param {function():*} callback\n   * @export\n   */\n  static registerSupportPlugin(name, callback) {\n    shaka.Player.supportPlugins_[name] = callback;\n  }\n\n  /**\n   * Set a factory to create an ad manager during player construction time.\n   * This method needs to be called bafore instantiating the Player class.\n   *\n   * @param {!shaka.extern.IAdManager.Factory} factory\n   * @export\n   */\n  static setAdManagerFactory(factory) {\n    shaka.Player.adManagerFactory_ = factory;\n  }\n\n  /**\n   * Return whether the browser provides basic support.  If this returns false,\n   * Shaka Player cannot be used at all.  In this case, do not construct a\n   * Player instance and do not use the library.\n   *\n   * @return {boolean}\n   * @export\n   */\n  static isBrowserSupported() {\n    if (!window.Promise) {\n      shaka.log.alwaysWarn('A Promise implementation or polyfill is required');\n    }\n\n    // Basic features needed for the library to be usable.\n    const basicSupport = !!window.Promise && !!window.Uint8Array &&\n                         // eslint-disable-next-line no-restricted-syntax\n                         !!Array.prototype.forEach;\n    if (!basicSupport) {\n      return false;\n    }\n\n    // We do not support IE\n    if (shaka.util.Platform.isIE()) {\n      return false;\n    }\n\n    // We do not support iOS 9, 10, 11 or 12, nor those same versions of\n    // desktop Safari.\n    const safariVersion = shaka.util.Platform.safariVersion();\n    if (safariVersion && safariVersion < 13) {\n      return false;\n    }\n\n    // DRM support is not strictly necessary, but the APIs at least need to be\n    // there.  Our no-op DRM polyfill should handle that.\n    // TODO(#1017): Consider making even DrmEngine optional.\n    const drmSupport = shaka.media.DrmEngine.isBrowserSupported();\n    if (!drmSupport) {\n      return false;\n    }\n\n    // If we have MediaSource (MSE) support, we should be able to use Shaka.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      return true;\n    }\n\n    // If we don't have MSE, we _may_ be able to use Shaka.  Look for native HLS\n    // support, and call this platform usable if we have it.\n    return shaka.util.Platform.supportsMediaType('application/x-mpegurl');\n  }\n\n  /**\n   * Probes the browser to determine what features are supported.  This makes a\n   * number of requests to EME/MSE/etc which may result in user prompts.  This\n   * should only be used for diagnostics.\n   *\n   * <p>\n   * NOTE: This may show a request to the user for permission.\n   *\n   * @see https://bit.ly/2ywccmH\n   * @param {boolean=} promptsOkay\n   * @return {!Promise.<shaka.extern.SupportType>}\n   * @export\n   */\n  static async probeSupport(promptsOkay=true) {\n    goog.asserts.assert(shaka.Player.isBrowserSupported(),\n        'Must have basic support');\n    let drm = {};\n    if (promptsOkay) {\n      drm = await shaka.media.DrmEngine.probeSupport();\n    }\n    const manifest = shaka.media.ManifestParser.probeSupport();\n    const media = shaka.media.MediaSourceEngine.probeSupport();\n    const ret = {\n      manifest: manifest,\n      media: media,\n      drm: drm,\n    };\n\n    const plugins = shaka.Player.supportPlugins_;\n    for (const name in plugins) {\n      ret[name] = plugins[name]();\n    }\n\n    return ret;\n  }\n\n  /**\n   * Tell the player to use <code>mediaElement</code> for all <code>load</code>\n   * requests until <code>detach</code> or <code>destroy</code> are called.\n   *\n   * <p>\n   * Calling <code>attach</code> with <code>initializedMediaSource=true</code>\n   * will tell the player to take the initial load step and initialize media\n   * source.\n   *\n   * <p>\n   * Calls to <code>attach</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {boolean=} initializeMediaSource\n   * @return {!Promise}\n   * @export\n   */\n  attach(mediaElement, initializeMediaSource = true) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    const payload = shaka.Player.createEmptyPayload_();\n    payload.mediaElement = mediaElement;\n\n    // If the platform does not support media source, we will never want to\n    // initialize media source.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      initializeMediaSource = false;\n    }\n\n    const destination = initializeMediaSource ?\n                        this.mediaSourceNode_ :\n                        this.attachNode_;\n\n    // Do not allow this route to be interrupted because calls after this attach\n    // call will depend on the media element being attached.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: false,\n      };\n    });\n\n    // List to the events that can occur with our request.\n    events.onStart = () => shaka.log.info('Starting attach...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n\n  /**\n   * Calling <code>attachCanvas</code> will tell the player to set canvas\n   * element for LCEVC decoding.\n   *\n   * @param {HTMLCanvasElement} canvas\n   * @export\n   */\n  attachCanvas(canvas) {\n    this.lcevcCanvas_ = canvas;\n  }\n\n  /**\n   * Tell the player to stop using its current media element. If the player is:\n   * <ul>\n   *  <li>detached, this will do nothing,\n   *  <li>attached, this will release the media element,\n   *  <li>loading, this will abort loading, unload, and release the media\n   *      element,\n   *  <li>playing content, this will stop playback, unload, and release the\n   *      media element.\n   * </ul>\n   *\n   * <p>\n   * Calls to <code>detach</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @return {!Promise}\n   * @export\n   */\n  detach() {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // Tell the walker to go \"detached\", but do not allow it to be interrupted.\n    // If it could be interrupted it means that our media element could fall out\n    // of sync.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      return {\n        node: this.detachNode_,\n        payload: shaka.Player.createEmptyPayload_(),\n        interruptible: false,\n      };\n    });\n\n    events.onStart = () => shaka.log.info('Starting detach...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Tell the player to either return to:\n   * <ul>\n   *   <li>detached (when it does not have a media element),\n   *   <li>attached (when it has a media element and\n   *     <code>initializedMediaSource=false</code>)\n   *   <li>media source initialized (when it has a media element and\n   *     <code>initializedMediaSource=true</code>)\n   * </ul>\n   *\n   * <p>\n   * Calls to <code>unload</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {boolean=} initializeMediaSource\n   * @return {!Promise}\n   * @export\n   */\n  unload(initializeMediaSource = true) {\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    this.fullyLoaded_ = false;\n\n    // If the platform does not support media source, we will never want to\n    // initialize media source.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      initializeMediaSource = false;\n    }\n\n    // If LCEVC Dil exists close it.\n    this.closeLcevcDil_();\n\n    // Since we are going either to attached or detached (through unloaded), we\n    // can't allow it to be interrupted or else we could lose track of what\n    // media element we are suppose to use.\n    //\n    // Using the current payload, we can determine which node we want to go to.\n    // If we have a media element, we want to go back to attached. If we have no\n    // media element, we want to go back to detached.\n    const payload = shaka.Player.createEmptyPayload_();\n\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      // When someone calls |unload| we can either be before attached or\n      // detached (there is nothing stopping someone from calling |detach| when\n      // we are already detached).\n      //\n      // If we are attached to the correct element, we can tear down the\n      // previous playback components and go to the attached media source node\n      // depending on whether or not the caller wants to pre-init media source.\n      //\n      // If we don't have a media element, we assume that we are already at the\n      // detached node - but only the walker knows that. To ensure we are\n      // actually there, we tell the walker to go to detach. While this is\n      // technically unnecessary, it ensures that we are in the state we want\n      // to be in and ready for the next request.\n      let destination = null;\n\n      if (currentPayload.mediaElement && initializeMediaSource) {\n        destination = this.mediaSourceNode_;\n      } else if (currentPayload.mediaElement) {\n        destination = this.attachNode_;\n      } else {\n        destination = this.detachNode_;\n      }\n\n      goog.asserts.assert(destination, 'We should have picked a destination.');\n\n      // Copy over the media element because we want to keep using the same\n      // element - the other values don't matter.\n      payload.mediaElement = currentPayload.mediaElement;\n\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: false,\n      };\n    });\n\n    events.onStart = () => shaka.log.info('Starting unload...');\n    return this.wrapWalkerListenersWithPromise_(events);\n  }\n\n  /**\n   * Provides a way to update the stream start position during the media loading\n   * process. Can for example be called from the <code>manifestparsed</code>\n   * event handler to update the start position based on information in the\n   * manifest.\n   *\n   * @param {number} startTime\n   * @export\n   */\n  updateStartTime(startTime) {\n    this.updatedStartTime_ = startTime;\n  }\n\n  /**\n   * Tell the player to load the content at <code>assetUri</code> and start\n   * playback at <code>startTime</code>. Before calling <code>load</code>,\n   * a call to <code>attach</code> must have succeeded.\n   *\n   * <p>\n   * Calls to <code>load</code> will interrupt any in-progress calls to\n   * <code>load</code> but cannot interrupt calls to <code>attach</code>,\n   * <code>detach</code>, or <code>unload</code>.\n   *\n   * @param {string} assetUri\n   * @param {?number=} startTime\n   *    When <code>startTime</code> is <code>null</code> or\n   *    <code>undefined</code>, playback will start at the default start time (0\n   *    for VOD and liveEdge for LIVE).\n   * @param {string=} mimeType\n   * @return {!Promise}\n   * @export\n   */\n  load(assetUri, startTime, mimeType) {\n    this.updatedStartTime_ = null;\n\n    this.fullyLoaded_ = false;\n\n    // Do not allow the player to be used after |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return Promise.reject(this.createAbortLoadError_());\n    }\n\n    // We dispatch the loading event when someone calls |load| because we want\n    // to surface the user intent.\n    this.dispatchEvent(this.makeEvent_(shaka.util.FakeEvent.EventName.Loading));\n\n    // Right away we know what the asset uri and start-of-load time are. We will\n    // fill-in the rest of the information later.\n    const payload = shaka.Player.createEmptyPayload_();\n    payload.uri = assetUri;\n    payload.startTimeOfLoad = Date.now() / 1000;\n    if (mimeType) {\n      payload.mimeType = mimeType;\n    }\n\n    // Because we allow |startTime| to be optional, it means that it will be\n    // |undefined| when not provided. This means that we need to re-map\n    // |undefined| to |null| while preserving |0| as a meaningful value.\n    if (startTime !== undefined) {\n      payload.startTime = startTime;\n    }\n\n    // TODO: Refactor to determine whether it's a manifest or not, and whether\n    // or not we can play it.  Then we could return a better error than\n    // UNABLE_TO_GUESS_MANIFEST_TYPE for WebM in Safari.\n    const useSrcEquals = this.shouldUseSrcEquals_(payload);\n    const destination = useSrcEquals ? this.srcEqualsNode_ : this.loadNode_;\n\n    // Allow this request to be interrupted, this will allow other requests to\n    // cancel a load and quickly start a new load.\n    const events = this.walker_.startNewRoute((currentPayload) => {\n      if (currentPayload.mediaElement == null) {\n        // Because we return null, this \"new route\" will not be used.\n        return null;\n      }\n\n      // Keep using whatever media element we have right now.\n      payload.mediaElement = currentPayload.mediaElement;\n\n      return {\n        node: destination,\n        payload: payload,\n        interruptible: true,\n      };\n    });\n\n    // Stats are for a single playback/load session. Stats must be initialized\n    // before we allow calls to |updateStateHistory|.\n    this.stats_ = new shaka.util.Stats();\n\n    // Create the CMCD manager so client data can be attached to all requests\n    this.cmcdManager_ = this.createCmcd_();\n\n    // Load's request is a little different, so we can't use our normal\n    // listeners-to-promise method. It is the only request where we may skip the\n    // request, so we need to set the on skip callback to reject with a specific\n    // error.\n    events.onStart =\n        () => shaka.log.info('Starting load of ' + assetUri + '...');\n    return new Promise((resolve, reject) => {\n      events.onSkip = () => reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.NO_VIDEO_ELEMENT));\n\n      events.onEnd = () => {\n        resolve();\n        // We dispatch the loaded event when the load promise is resolved\n        this.dispatchEvent(\n            this.makeEvent_(shaka.util.FakeEvent.EventName.Loaded));\n      };\n      events.onCancel = () => reject(this.createAbortLoadError_());\n      events.onError = (e) => reject(e);\n    });\n  }\n\n  /**\n   * Check if src= should be used to load the asset at |uri|. Assume that media\n   * source is the default option, and that src= is for special cases.\n   *\n   * @param {shaka.routing.Payload} payload\n   * @return {boolean}\n   *    |true| if the content should be loaded with src=, |false| if the content\n   *    should be loaded with MediaSource.\n   * @private\n   */\n  shouldUseSrcEquals_(payload) {\n    const Platform = shaka.util.Platform;\n\n    // If we are using a platform that does not support media source, we will\n    // fall back to src= to handle all playback.\n    if (!Platform.supportsMediaSource()) {\n      return true;\n    }\n\n    // The most accurate way to tell the player how to load the content is via\n    // MIME type.  We can fall back to features of the URI if needed.\n    let mimeType = payload.mimeType;\n    const uri = payload.uri || '';\n\n    // If we don't have a MIME type, try to guess based on the file extension.\n    // TODO: Too generic to belong to ManifestParser now.  Refactor.\n    if (!mimeType) {\n      // Try using the uri extension.\n      const extension = shaka.media.ManifestParser.getExtension(uri);\n      mimeType = shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_[extension];\n    }\n\n    // TODO: The load graph system has a design limitation that requires routing\n    // destination to be chosen synchronously.  This means we can only make the\n    // right choice about src= consistently if we have a well-known file\n    // extension or API-provided MIME type.  Detection of MIME type from a HEAD\n    // request (as is done for manifest types) can't be done yet.\n\n    if (mimeType) {\n      // If we have a MIME type, check if the browser can play it natively.\n      // This will cover both single files and native HLS.\n      const mediaElement = payload.mediaElement || Platform.anyMediaElement();\n      const canPlayNatively = mediaElement.canPlayType(mimeType) != '';\n\n      // If we can't play natively, then src= isn't an option.\n      if (!canPlayNatively) {\n        return false;\n      }\n\n      const canPlayMediaSource =\n          shaka.media.ManifestParser.isSupported(uri, mimeType);\n\n      // If MediaSource isn't an option, the native option is our only chance.\n      if (!canPlayMediaSource) {\n        return true;\n      }\n\n      // If we land here, both are feasible.\n      goog.asserts.assert(canPlayNatively && canPlayMediaSource,\n          'Both native and MSE playback should be possible!');\n\n      // We would prefer MediaSource in some cases, and src= in others.  For\n      // example, Android has native HLS, but we'd prefer our own MediaSource\n      // version there.\n\n      // Native HLS can be preferred on any platform via this flag:\n      if (this.config_.streaming.preferNativeHls) {\n        return true;\n      }\n\n      // For Safari, we have an older flag which only applies to this one\n      // browser:\n      if (Platform.isApple()) {\n        return this.config_.streaming.useNativeHlsOnSafari;\n      }\n\n      // In all other cases, we prefer MediaSource.\n      return false;\n    }\n\n    // Unless there are good reasons to use src= (single-file playback or native\n    // HLS), we prefer MediaSource.  So the final return value for choosing src=\n    // is false.\n    return false;\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to attach to\n   * a media element. The only times this may be called are when we are being\n   * asked to re-attach to the current media element, or attach to a new media\n   * element while not attached to a media element.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Attaching to a media element is defined as:\n   *  - Registering error listeners to the media element.\n   *  - Caching the video element for use outside of the load graph.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  onAttach_(has, wants) {\n    // If we don't have a media element yet, it means we are entering\n    // \"attach\" from another node.\n    //\n    // If we have a media element, it should match |wants.mediaElement|\n    // because it means we are going from \"attach\" to \"attach\".\n    //\n    // These constraints should be maintained and guaranteed by the routing\n    // logic in |getNextStep_|.\n    goog.asserts.assert(\n        has.mediaElement == null || has.mediaElement == wants.mediaElement,\n        'The routing logic failed. MediaElement requirement failed.');\n\n    if (has.mediaElement == null) {\n      has.mediaElement = wants.mediaElement;\n\n      const onError = (error) => this.onVideoError_(error);\n      this.attachEventManager_.listen(has.mediaElement, 'error', onError);\n    }\n\n    this.video_ = has.mediaElement;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to detach from\n   * a media element. The only times this may be called are when we are being\n   * asked to detach from the current media element, or detach when we are\n   * already detached.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Detaching from a media element is defined as:\n   *  - Removing error listeners from the media element.\n   *  - Dropping the cached reference to the video element.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  onDetach_(has, wants) {\n    // If we were going from \"detached\" to \"detached\" we wouldn't have\n    // a media element to detach from.\n    if (has.mediaElement) {\n      this.attachEventManager_.removeAll();\n      has.mediaElement = null;\n    }\n\n    if (this.adManager_) {\n      // The ad manager is specific to the video, so detach it too.\n      this.adManager_.release();\n    }\n\n    // Clear our cached copy of the media element.\n    this.video_ = null;\n\n    return Promise.resolve();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to unload all\n   * currently initialized playback components. Unlike the other load actions,\n   * this action is built to be more general. We need to do this because we\n   * don't know what state the player will be in before unloading (including\n   * after an error occurred in the middle of a transition).\n   *\n   * This method assumes that any component could be |null| and should be safe\n   * to call from any point in the load graph.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onUnload_(has, wants) {\n    // Set the load mode to unload right away so that all the public methods\n    // will stop using the internal components. We need to make sure that we\n    // are not overriding the destroyed state because we will unload when we are\n    // destroying the player.\n    if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n      this.loadMode_ = shaka.Player.LoadMode.NOT_LOADED;\n    }\n\n    // Run any general cleanup tasks now.  This should be here at the top, right\n    // after setting loadMode_, so that internal components still exist as they\n    // did when the cleanup tasks were registered in the array.\n    const cleanupTasks = this.cleanupOnUnload_.map((cb) => cb());\n    this.cleanupOnUnload_ = [];\n    await Promise.all(cleanupTasks);\n\n    // Dispatch the unloading event.\n    this.dispatchEvent(\n        this.makeEvent_(shaka.util.FakeEvent.EventName.Unloading));\n\n    // Remove everything that has to do with loading content from our payload\n    // since we are releasing everything that depended on it.\n    has.mimeType = null;\n    has.startTime = null;\n    has.uri = null;\n\n    // Release the region timeline, which is created when parsing the manifest.\n    if (this.regionTimeline_) {\n      this.regionTimeline_.release();\n      this.regionTimeline_ = null;\n    }\n\n    // In most cases we should have a media element. The one exception would\n    // be if there was an error and we, by chance, did not have a media element.\n    if (has.mediaElement) {\n      this.loadEventManager_.removeAll();\n    }\n\n    // Stop the variant checker timer\n    this.checkVariantsTimer_.stop();\n\n    // Some observers use some playback components, shutting down the observers\n    // first ensures that they don't try to use the playback components\n    // mid-destroy.\n    if (this.playheadObservers_) {\n      this.playheadObservers_.release();\n      this.playheadObservers_ = null;\n    }\n\n    if (this.bufferPoller_) {\n      this.bufferPoller_.stop();\n      this.bufferPoller_ = null;\n    }\n\n    // Stop the parser early. Since it is at the start of the pipeline, it\n    // should be start early to avoid is pushing new data downstream.\n    if (this.parser_) {\n      await this.parser_.stop();\n      this.parser_ = null;\n      this.parserFactory_ = null;\n    }\n\n    // Abr Manager will tell streaming engine what to do, so we need to stop\n    // it before we destroy streaming engine. Unlike with the other components,\n    // we do not release the instance, we will reuse it in later loads.\n    if (this.abrManager_) {\n      await this.abrManager_.stop();\n    }\n\n    // Streaming engine will push new data to media source engine, so we need\n    // to shut it down before destroy media source engine.\n    if (this.streamingEngine_) {\n      await this.streamingEngine_.destroy();\n      this.streamingEngine_ = null;\n    }\n\n    if (this.playRateController_) {\n      this.playRateController_.release();\n      this.playRateController_ = null;\n    }\n\n    // Playhead is used by StreamingEngine, so we can't destroy this until after\n    // StreamingEngine has stopped.\n    if (this.playhead_) {\n      this.playhead_.release();\n      this.playhead_ = null;\n    }\n\n    // Media source engine holds onto the media element, and in order to detach\n    // the media keys (with drm engine), we need to break the connection between\n    // media source engine and the media element.\n    if (this.mediaSourceEngine_) {\n      await this.mediaSourceEngine_.destroy();\n      this.mediaSourceEngine_ = null;\n    }\n\n    if (this.adManager_) {\n      this.adManager_.onAssetUnload();\n    }\n\n    // In order to unload a media element, we need to remove the src attribute\n    // and then load again. When we destroy media source engine, this will be\n    // done for us, but for src=, we need to do it here.\n    //\n    // DrmEngine requires this to be done before we destroy DrmEngine itself.\n    if (has.mediaElement && has.mediaElement.src) {\n      // TODO: Investigate this more.  Only reproduces on Firefox 69.\n      // Introduce a delay before detaching the video source.  We are seeing\n      // spurious Promise rejections involving an AbortError in our tests\n      // otherwise.\n      await new Promise(\n          (resolve) => new shaka.util.Timer(resolve).tickAfter(0.1));\n\n      has.mediaElement.removeAttribute('src');\n      has.mediaElement.load();\n      // Remove all track nodes\n      while (has.mediaElement.lastChild) {\n        has.mediaElement.removeChild(has.mediaElement.firstChild);\n      }\n    }\n\n    if (this.drmEngine_) {\n      await this.drmEngine_.destroy();\n      this.drmEngine_ = null;\n    }\n\n    this.assetUri_ = null;\n    this.bufferObserver_ = null;\n\n    if (this.manifest_) {\n      for (const variant of this.manifest_.variants) {\n        for (const stream of [variant.audio, variant.video]) {\n          if (stream && stream.segmentIndex) {\n            stream.segmentIndex.release();\n          }\n        }\n      }\n      for (const stream of this.manifest_.textStreams) {\n        if (stream.segmentIndex) {\n          stream.segmentIndex.release();\n        }\n      }\n    }\n\n    this.manifest_ = null;\n    this.stats_ = new shaka.util.Stats(); // Replace with a clean stats object.\n    this.lastTextFactory_ = null;\n\n    // Make sure that the app knows of the new buffering state.\n    this.updateBufferState_();\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * media source engine. The only time this may be called is when we are\n   * attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute. The load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeMediaSourceEngine_(has, wants) {\n    goog.asserts.assert(\n        shaka.util.Platform.supportsMediaSource(),\n        'We should not be initializing media source on a platform that does ' +\n            'not support media source.');\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing media source.');\n    goog.asserts.assert(\n        has.mediaElement == wants.mediaElement,\n        '|has| and |wants| should have the same media element when ' +\n            'initializing media source.');\n\n    goog.asserts.assert(\n        this.mediaSourceEngine_ == null,\n        'We should not have a media source engine yet.');\n\n    // When changing text visibility we need to update both the text displayer\n    // and streaming engine because we don't always stream text. To ensure that\n    // text displayer and streaming engine are always in sync, wait until they\n    // are both initialized before setting the initial value.\n    const textDisplayerFactory = this.config_.textDisplayFactory;\n    const textDisplayer = textDisplayerFactory();\n    this.lastTextFactory_ = textDisplayerFactory;\n\n    const mediaSourceEngine = this.createMediaSourceEngine(\n        has.mediaElement,\n        textDisplayer,\n        (metadata, offset, endTime) => {\n          this.processTimedMetadataMediaSrc_(metadata, offset, endTime);\n        },\n        this.lcevcDil_);\n    mediaSourceEngine.configure(this.config_.mediaSource);\n    const {segmentRelativeVttTiming} = this.config_.manifest;\n    mediaSourceEngine.setSegmentRelativeVttTiming(segmentRelativeVttTiming);\n\n    // Wait for media source engine to finish opening. This promise should\n    // NEVER be rejected as per the media source engine implementation.\n    await mediaSourceEngine.open();\n\n    // Wait until it is ready to actually store the reference.\n    this.mediaSourceEngine_ = mediaSourceEngine;\n  }\n\n  /**\n   * Create the parser for the asset located at |wants.uri|. This should only be\n   * called as part of the load graph.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeParser_(has, wants) {\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing the parser.');\n    goog.asserts.assert(\n        has.mediaElement == wants.mediaElement,\n        '|has| and |wants| should have the same media element when ' +\n            'initializing the parser.');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Need networking engine when initializing the parser.');\n    goog.asserts.assert(\n        this.config_,\n        'Need player config when initializing the parser.');\n\n    // We are going to \"lock-in\" the mime type and uri since they are\n    // what we are going to use to create our parser and parse the manifest.\n    has.mimeType = wants.mimeType;\n    has.uri = wants.uri;\n\n    goog.asserts.assert(\n        has.uri,\n        'We should have an asset uri when initializing the parsing.');\n\n    // Store references to things we asserted so that we don't need to reassert\n    // them again later.\n    const assetUri = has.uri;\n    const networkingEngine = this.networkingEngine_;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = assetUri;\n\n    // Create the parser that we will use to parse the manifest.\n    this.parserFactory_ = await shaka.media.ManifestParser.getFactory(\n        assetUri,\n        networkingEngine,\n        this.config_.manifest.retryParameters,\n        has.mimeType);\n    goog.asserts.assert(this.parserFactory_, 'Must have manifest parser');\n    this.parser_ = this.parserFactory_();\n\n    const manifestConfig =\n        shaka.util.ObjectUtils.cloneObject(this.config_.manifest);\n    // Don't read video segments if the player is attached to an audio element\n    if (wants.mediaElement && wants.mediaElement.nodeName === 'AUDIO') {\n      manifestConfig.disableVideo = true;\n    }\n\n    this.parser_.configure(manifestConfig);\n  }\n\n  /**\n   * Parse the manifest at |has.uri| using the parser that should have already\n   * been created. This should only be called as part of the load graph.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!shaka.util.AbortableOperation}\n   * @private\n   */\n  onParseManifest_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        '|has| and |wants| should have the same mime type when parsing.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        '|has| and |wants| should have the same uri when parsing.');\n\n    goog.asserts.assert(\n        has.uri,\n        '|has| should have a valid uri when parsing.');\n    goog.asserts.assert(\n        has.uri == this.assetUri_,\n        '|has.uri| should match the cached asset uri.');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Need networking engine to parse manifest.');\n    goog.asserts.assert(\n        this.cmcdManager_,\n        'Need CMCD manager to populate manifest request data.');\n    goog.asserts.assert(\n        this.config_,\n        'Need player config to parse manifest.');\n\n    goog.asserts.assert(\n        this.parser_,\n        '|this.parser_| should have been set in an earlier step.');\n\n    // Store references to things we asserted so that we don't need to reassert\n    // them again later.\n    const assetUri = has.uri;\n    const networkingEngine = this.networkingEngine_;\n\n    // This will be needed by the parser once it starts parsing, so we will\n    // initialize it now even through it appears a little out-of-place.\n    this.regionTimeline_ =\n        new shaka.media.RegionTimeline(() => this.seekRange());\n    this.regionTimeline_.addEventListener('regionadd', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.onRegionEvent_(\n          shaka.util.FakeEvent.EventName.TimelineRegionAdded, region);\n\n      if (this.adManager_) {\n        this.adManager_.onDashTimedMetadata(region);\n      }\n    });\n\n    this.qualityObserver_ = null;\n    if (this.config_.streaming.observeQualityChanges) {\n      this.qualityObserver_ = new shaka.media.QualityObserver(\n          () => this.getBufferedInfo());\n\n      this.qualityObserver_.addEventListener('qualitychange', (event) => {\n        /** @type {shaka.extern.MediaQualityInfo} */\n        const mediaQualityInfo = event['quality'];\n        /** @type {number} */\n        const position = event['position'];\n        this.onMediaQualityChange_(mediaQualityInfo, position);\n      });\n    }\n\n    const playerInterface = {\n      networkingEngine: networkingEngine,\n      modifyManifestRequest: (request, manifestInfo) => {\n        this.cmcdManager_.applyManifestData(request, manifestInfo);\n      },\n      modifySegmentRequest: (request, segmentInfo) => {\n        this.cmcdManager_.applySegmentData(request, segmentInfo);\n      },\n      filter: (manifest) => this.filterManifest_(manifest),\n      makeTextStreamsForClosedCaptions: (manifest) => {\n        return this.makeTextStreamsForClosedCaptions_(manifest);\n      },\n\n      // Called when the parser finds a timeline region. This can be called\n      // before we start playback or during playback (live/in-progress\n      // manifest).\n      onTimelineRegionAdded: (region) => this.regionTimeline_.addRegion(region),\n\n      onEvent: (event) => this.dispatchEvent(event),\n      onError: (error) => this.onError_(error),\n      isLowLatencyMode: () => this.isLowLatencyMode_(),\n      isAutoLowLatencyMode: () => this.isAutoLowLatencyMode_(),\n      enableLowLatencyMode: () => {\n        this.configure('streaming.lowLatencyMode', true);\n      },\n      updateDuration: () => {\n        if (this.streamingEngine_) {\n          this.streamingEngine_.updateDuration();\n        }\n      },\n      newDrmInfo: (stream) => {\n        // We may need to create new sessions for any new init data.\n        const currentDrmInfo =\n            this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n        // DrmEngine.newInitData() requires mediaKeys to be available.\n        if (currentDrmInfo && this.drmEngine_.getMediaKeys()) {\n          this.processDrmInfos_(currentDrmInfo.keySystem, stream);\n        }\n      },\n    };\n\n    const startTime = Date.now() / 1000;\n\n    return new shaka.util.AbortableOperation(/* promise= */ (async () => {\n      this.manifest_ = await this.parser_.start(assetUri, playerInterface);\n\n      // This event is fired after the manifest is parsed, but before any\n      // filtering takes place.\n      const event =\n          this.makeEvent_(shaka.util.FakeEvent.EventName.ManifestParsed);\n      this.dispatchEvent(event);\n\n      // We require all manifests to have at least one variant.\n      if (this.manifest_.variants.length == 0) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.NO_VARIANTS);\n      }\n\n      // Make sure that all variants are either: audio-only, video-only, or\n      // audio-video.\n      shaka.Player.filterForAVVariants_(this.manifest_);\n\n      const now = Date.now() / 1000;\n      const delta = now - startTime;\n      this.stats_.setManifestTime(delta);\n    })(), /* onAbort= */ () => {\n      shaka.log.info('Aborting parser step...');\n      return this.parser_.stop();\n    });\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * drmEngine. The only time this may be called is when we are attached a\n   * media element and have parsed a manifest.\n   *\n   * The load-graph is responsible for ensuring all assumptions made by this\n   * method are valid before executing it.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeDrm_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        'The load graph should have ensured the mime types matched.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        'The load graph should have ensured the uris matched');\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        '|onInitializeDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.config_,\n        '|onInitializeDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.manifest_,\n        '|this.manifest_| should have been set in an earlier step.');\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when initializing the DRM Engine.');\n\n    const startTime = Date.now() / 1000;\n    let firstEvent = true;\n\n    this.drmEngine_ = this.createDrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: (e) => {\n        this.onError_(e);\n      },\n      onKeyStatus: (map) => {\n        this.onKeyStatus_(map);\n      },\n      onExpirationUpdated: (id, expiration) => {\n        this.onExpirationUpdated_(id, expiration);\n      },\n      onEvent: (e) => {\n        this.dispatchEvent(e);\n        if (e.type == shaka.util.FakeEvent.EventName.DrmSessionUpdate &&\n            firstEvent) {\n          firstEvent = false;\n          const now = Date.now() / 1000;\n          const delta = now - startTime;\n          this.stats_.setDrmTime(delta);\n          // LCEVC data by itself is not encrypted in DRM protected streams and\n          // can therefore be accessed and decoded as normal. However, the LCEVC\n          // decoder needs access to the VideoElement output in order to apply\n          // the enhancement. In DRM contexts where the browser CDM restricts\n          // access from our decoder, the enhancement cannot be applied and\n          // therefore the LCEVC output canvas is hidden accordingly.\n          if (this.lcevcDil_) {\n            this.lcevcDil_.hideCanvas();\n          }\n        }\n      },\n    });\n\n    this.drmEngine_.configure(this.config_.drm);\n\n    await this.drmEngine_.initForPlayback(\n        this.manifest_.variants,\n        this.manifest_.offlineSessionIds);\n\n    await this.drmEngine_.attach(has.mediaElement);\n\n    // Now that we have drm information, filter the manifest (again) so that we\n    // can ensure we only use variants with the selected key system.\n    await this.filterManifest_(this.manifest_);\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to load all\n   * playback components needed for playback. The only times this may be called\n   * is when we are attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * Loading is defined as:\n   *  - Attaching all playback-related listeners to the media element\n   *  - Initializing playback and observers\n   *  - Initializing ABR Manager\n   *  - Initializing Streaming Engine\n   *  - Starting playback at |wants.startTime|\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @private\n   */\n  async onLoad_(has, wants) {\n    goog.asserts.assert(\n        has.mimeType == wants.mimeType,\n        '|has| and |wants| should have the same mime type when loading.');\n    goog.asserts.assert(\n        has.uri == wants.uri,\n        '|has| and |wants| should have the same uri when loading.');\n\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when loading.');\n    goog.asserts.assert(\n        !isNaN(wants.startTimeOfLoad),\n        '|wants| should tell us when the load was originally requested');\n\n    // Since we are about to start playback, we will lock in the start time as\n    // something we are now depending on.\n    has.startTime = wants.startTime;\n\n    // If updateStartTime() has been called since load() was invoked use the\n    // requested startTime\n    if (this.updatedStartTime_ != null) {\n      has.startTime = this.updatedStartTime_;\n      this.updatedStartTime_ = null;\n    }\n\n    // Store a reference to values in |has| after asserting so that closure will\n    // know that they will still be non-null between calls to await.\n    const mediaElement = has.mediaElement;\n    const assetUri = has.uri;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = assetUri;\n\n    this.playRateController_ = new shaka.media.PlayRateController({\n      getRate: () => mediaElement.playbackRate,\n      getDefaultRate: () => mediaElement.defaultPlaybackRate,\n      setRate: (rate) => { mediaElement.playbackRate = rate; },\n      movePlayhead: (delta) => { mediaElement.currentTime += delta; },\n    });\n\n    const updateStateHistory = () => this.updateStateHistory_();\n    const onRateChange = () => this.onRateChange_();\n    this.loadEventManager_.listen(mediaElement, 'playing', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'pause', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ended', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ratechange', onRateChange);\n\n    // Check status of the LCEVC DIL Object and reset or\n    // create or close based on config\n    this.setupLcevc_(this.config_);\n\n    const abrFactory = this.config_.abrFactory;\n    if (!this.abrManager_ || this.abrManagerFactory_ != abrFactory) {\n      this.abrManagerFactory_ = abrFactory;\n      this.abrManager_ = abrFactory();\n      if (typeof this.abrManager_.setMediaElement != 'function') {\n        shaka.Deprecate.deprecateFeature(5,\n            'AbrManager',\n            'Please use an AbrManager with setMediaElement function.');\n        this.abrManager_.setMediaElement = () => {};\n      }\n      this.abrManager_.configure(this.config_.abr);\n    }\n\n    // Copy preferred languages from the config again, in case the config was\n    // changed between construction and playback.\n    this.currentAdaptationSetCriteria_ =\n        new shaka.media.PreferenceBasedCriteria(\n            this.config_.preferredAudioLanguage,\n            this.config_.preferredVariantRole,\n            this.config_.preferredAudioChannelCount);\n\n    this.currentTextLanguage_ = this.config_.preferredTextLanguage;\n    this.currentTextRole_ = this.config_.preferredTextRole;\n    this.currentTextForced_ = this.config_.preferForcedSubs;\n\n    shaka.Player.applyPlayRange_(this.manifest_.presentationTimeline,\n        this.config_.playRangeStart,\n        this.config_.playRangeEnd);\n\n    this.abrManager_.init((variant, clearBuffer, safeMargin) => {\n      return this.switch_(variant, clearBuffer, safeMargin);\n    });\n    this.abrManager_.setMediaElement(mediaElement);\n\n    // If the content is multi-codec and the browser can play more than one of\n    // them, choose codecs now before we initialize streaming.\n    shaka.util.StreamUtils.chooseCodecsAndFilterManifest(\n        this.manifest_,\n        this.config_.preferredVideoCodecs,\n        this.config_.preferredAudioCodecs,\n        this.config_.preferredAudioChannelCount,\n        this.config_.preferredDecodingAttributes);\n\n    this.streamingEngine_ = this.createStreamingEngine();\n    this.streamingEngine_.configure(this.config_.streaming);\n\n    // Set the load mode to \"loaded with media source\" as late as possible so\n    // that public methods won't try to access internal components until\n    // they're all initialized. We MUST switch to loaded before calling\n    // \"streaming\" so that they can access internal information.\n    this.loadMode_ = shaka.Player.LoadMode.MEDIA_SOURCE;\n\n    if (mediaElement.textTracks) {\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'addtrack', (e) => {\n            const trackEvent = /** @type {!TrackEvent} */(e);\n            if (trackEvent.track) {\n              const track = trackEvent.track;\n              goog.asserts.assert(\n                  track instanceof TextTrack, 'Wrong track type!');\n\n              switch (track.kind) {\n                case 'chapters':\n                  this.activateChaptersTrack_(track);\n                  break;\n              }\n            }\n          });\n    }\n\n    // The event must be fired after we filter by restrictions but before the\n    // active stream is picked to allow those listening for the \"streaming\"\n    // event to make changes before streaming starts.\n    this.dispatchEvent(\n        this.makeEvent_(shaka.util.FakeEvent.EventName.Streaming));\n\n    // Pick the initial streams to play.\n    // Unless the user has already picked a variant, anyway, by calling\n    // selectVariantTrack before this loading stage.\n    let initialVariant = null;\n    const activeVariant = this.streamingEngine_.getCurrentVariant();\n    if (!activeVariant) {\n      initialVariant = this.chooseVariant_();\n      goog.asserts.assert(initialVariant, 'Must choose an initial variant!');\n    }\n\n    // Lazy-load the stream, so we will have enough info to make the playhead.\n    const createSegmentIndexPromises = [];\n    const toLazyLoad = activeVariant || initialVariant;\n    for (const stream of [toLazyLoad.video, toLazyLoad.audio]) {\n      if (stream && !stream.segmentIndex) {\n        createSegmentIndexPromises.push(stream.createSegmentIndex());\n      }\n    }\n    if (createSegmentIndexPromises.length > 0) {\n      await Promise.all(createSegmentIndexPromises);\n    }\n\n    this.playhead_ = this.createPlayhead(has.startTime);\n    this.playheadObservers_ = this.createPlayheadObserversForMSE_();\n\n    // We need to start the buffer management code near the end because it will\n    // set the initial buffering state and that depends on other components\n    // being initialized.\n    const rebufferThreshold = Math.max(\n        this.manifest_.minBufferTime, this.config_.streaming.rebufferingGoal);\n    this.startBufferManagement_(rebufferThreshold);\n\n    // Now we can switch to the initial variant.\n    if (!activeVariant) {\n      goog.asserts.assert(initialVariant,\n          'Must have choosen an initial variant!');\n\n      this.switchVariant_(initialVariant, /* fromAdaptation= */ true,\n          /* clearBuffer= */ false, /* safeMargin= */ 0);\n\n      // Now that we have initial streams, we may adjust the start time to align\n      // to a segment boundary.\n      if (this.config_.streaming.startAtSegmentBoundary) {\n        const startTime = this.playhead_.getTime();\n        const adjustedTime =\n            await this.adjustStartTime_(initialVariant, startTime);\n\n        this.playhead_.setStartTime(adjustedTime);\n      }\n\n      // Since the first streams just became active, send an adaptation event.\n      this.onAdaptation_(null,\n          shaka.util.StreamUtils.variantToTrack(initialVariant));\n    }\n\n    this.playhead_.ready();\n\n    // Decide if text should be shown automatically.\n    // similar to video/audio track, we would skip switch initial text track\n    // if user already pick text track (via selectTextTrack api)\n    const activeTextTrack = this.getTextTracks().find((t) => t.active);\n\n    if (!activeTextTrack) {\n      const initialTextStream = this.chooseTextStream_();\n\n      if (initialTextStream) {\n        this.addTextStreamToSwitchHistory_(\n            initialTextStream, /* fromAdaptation= */ true);\n      }\n\n      if (initialVariant) {\n        this.setInitialTextState_(initialVariant, initialTextStream);\n      }\n\n      // Don't initialize with a text stream unless we should be streaming text.\n      if (initialTextStream && this.shouldStreamText_()) {\n        this.streamingEngine_.switchTextStream(initialTextStream);\n      }\n    }\n\n\n    // Start streaming content. This will start the flow of content down to\n    // media source.\n    await this.streamingEngine_.start();\n\n    if (this.config_.abr.enabled) {\n      this.abrManager_.enable();\n      this.onAbrStatusChanged_();\n    }\n\n    // Re-filter the manifest after streams have been chosen.\n    this.filterManifestByCurrentVariant_();\n    // Dispatch a 'trackschanged' event now that all initial filtering is done.\n    this.onTracksChanged_();\n\n    // Now that we've filtered out variants that aren't compatible with the\n    // active one, update abr manager with filtered variants.\n    // NOTE: This may be unnecessary.  We've already chosen one codec in\n    // chooseCodecsAndFilterManifest_ before we started streaming.  But it\n    // doesn't hurt, and this will all change when we start using\n    // MediaCapabilities and codec switching.\n    // TODO(#1391): Re-evaluate with MediaCapabilities and codec switching.\n    this.updateAbrManagerVariants_();\n\n    const hasPrimary = this.manifest_.variants.some((v) => v.primary);\n    if (!this.config_.preferredAudioLanguage && !hasPrimary) {\n      shaka.log.warning('No preferred audio language set.  We have chosen an ' +\n                        'arbitrary language initially');\n    }\n\n    this.fullyLoaded_ = true;\n\n    // Wait for the 'loadedmetadata' event to measure load() latency.\n    this.loadEventManager_.listenOnce(mediaElement, 'loadedmetadata', () => {\n      const now = Date.now() / 1000;\n      const delta = now - wants.startTimeOfLoad;\n      this.stats_.setLoadLatency(delta);\n    });\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to initialize\n   * drmEngine for src= playbacks.\n   *\n   * The load-graph is responsible for ensuring all assumptions made by this\n   * method are valid before executing it.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!Promise}\n   * @private\n   */\n  async onInitializeSrcEqualsDrm_(has, wants) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(\n        this.networkingEngine_,\n        '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n    goog.asserts.assert(\n        this.config_,\n        '|onInitializeSrcEqualsDrm_| should never be called after |destroy|');\n\n    const startTime = Date.now() / 1000;\n    let firstEvent = true;\n\n    this.drmEngine_ = this.createDrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: (e) => {\n        this.onError_(e);\n      },\n      onKeyStatus: (map) => {\n        this.onKeyStatus_(map);\n      },\n      onExpirationUpdated: (id, expiration) => {\n        this.onExpirationUpdated_(id, expiration);\n      },\n      onEvent: (e) => {\n        this.dispatchEvent(e);\n        if (e.type == shaka.util.FakeEvent.EventName.DrmSessionUpdate &&\n            firstEvent) {\n          firstEvent = false;\n          const now = Date.now() / 1000;\n          const delta = now - startTime;\n          this.stats_.setDrmTime(delta);\n        }\n      },\n    });\n\n    this.drmEngine_.configure(this.config_.drm);\n\n    const uri = wants.uri || '';\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    let mimeType = shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_[extension];\n    if (mimeType == 'application/x-mpegurl' && shaka.util.Platform.isApple()) {\n      mimeType = 'application/vnd.apple.mpegurl';\n    }\n    if (!mimeType) {\n      mimeType = 'video/mp4';\n    }\n\n    // TODO: Instead of feeding DrmEngine with Variants, we should refactor\n    // DrmEngine so that it takes a minimal config derived from Variants.  In\n    // cases like this one or in removal of stored content, the details are\n    // largely unimportant.  We should have a saner way to initialize DrmEngine.\n    // That would also insulate DrmEngine from manifest changes in the future.\n    // For now, that is time-consuming and this synthetic Variant is easy, so\n    // I'm putting it off.  Since this is only expected to be used for native\n    // HLS in Safari, this should be safe. -JCP\n    /** @type {shaka.extern.Variant} */\n    const variant = {\n      id: 0,\n      language: 'und',\n      disabledUntilTime: 0,\n      primary: false,\n      audio: null,\n      video: {\n        id: 0,\n        originalId: null,\n        createSegmentIndex: () => Promise.resolve(),\n        segmentIndex: null,\n        mimeType: wants.mimeType ?\n            shaka.util.MimeUtils.getBasicType(wants.mimeType) : mimeType,\n        codecs: wants.mimeType ?\n            shaka.util.MimeUtils.getCodecs(wants.mimeType) : '',\n        encrypted: true,\n        drmInfos: [],  // Filled in by DrmEngine config.\n        keyIds: new Set(),\n        language: 'und',\n        label: null,\n        type: ContentType.VIDEO,\n        primary: false,\n        trickModeVideo: null,\n        emsgSchemeIdUris: null,\n        roles: [],\n        forced: false,\n        channelsCount: null,\n        audioSamplingRate: null,\n        spatialAudio: false,\n        closedCaptions: null,\n      },\n      bandwidth: 100,\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n      decodingInfos: [],\n    };\n\n    this.drmEngine_.setSrcEquals(/* srcEquals= */ true);\n    await this.drmEngine_.initForPlayback(\n        [variant], /* offlineSessionIds= */ []);\n    await this.drmEngine_.attach(has.mediaElement);\n  }\n\n  /**\n   * This should only be called by the load graph when it is time to set-up the\n   * media element to play content using src=. The only times this may be called\n   * is when we are attached to the same media element as in the request.\n   *\n   * This method assumes that it is safe for it to execute, the load-graph is\n   * responsible for ensuring all assumptions are true.\n   *\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {!shaka.util.AbortableOperation}\n   *\n   * @private\n   */\n  onSrcEquals_(has, wants) {\n    goog.asserts.assert(\n        has.mediaElement,\n        'We should have a media element when loading.');\n    goog.asserts.assert(\n        wants.uri,\n        '|has| should have a valid uri when loading.');\n    goog.asserts.assert(\n        !isNaN(wants.startTimeOfLoad),\n        '|wants| should tell us when the load was originally requested');\n    goog.asserts.assert(\n        this.video_ == has.mediaElement,\n        'The video element should match our media element');\n\n    // Lock-in the values that we are using so that the routing logic knows what\n    // we have.\n    has.uri = wants.uri;\n    has.startTime = wants.startTime;\n\n    // Save the uri so that it can be used outside of the load-graph.\n    this.assetUri_ = has.uri;\n\n    const mediaElement = has.mediaElement;\n\n    this.playhead_ = new shaka.media.SrcEqualsPlayhead(mediaElement);\n\n    // This flag is used below in the language preference setup to check if\n    // this load was canceled before the necessary awaits completed.\n    let unloaded = false;\n    this.cleanupOnUnload_.push(() => {\n      unloaded = true;\n    });\n\n    if (has.startTime != null) {\n      this.playhead_.setStartTime(has.startTime);\n    }\n\n    this.playRateController_ = new shaka.media.PlayRateController({\n      getRate: () => mediaElement.playbackRate,\n      getDefaultRate: () => mediaElement.defaultPlaybackRate,\n      setRate: (rate) => { mediaElement.playbackRate = rate; },\n      movePlayhead: (delta) => { mediaElement.currentTime += delta; },\n    });\n\n    // We need to start the buffer management code near the end because it will\n    // set the initial buffering state and that depends on other components\n    // being initialized.\n    const rebufferThreshold = this.config_.streaming.rebufferingGoal;\n    this.startBufferManagement_(rebufferThreshold);\n\n    // Add all media element listeners.\n    const updateStateHistory = () => this.updateStateHistory_();\n    const onRateChange = () => this.onRateChange_();\n    this.loadEventManager_.listen(mediaElement, 'playing', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'pause', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ended', updateStateHistory);\n    this.loadEventManager_.listen(mediaElement, 'ratechange', onRateChange);\n\n    // Wait for the 'loadedmetadata' event to measure load() latency, but only\n    // if preload is set in a way that would result in this event firing\n    // automatically.\n    // See https://github.com/shaka-project/shaka-player/issues/2483\n    if (mediaElement.preload != 'none') {\n      this.loadEventManager_.listenOnce(mediaElement, 'loadedmetadata', () => {\n        const now = Date.now() / 1000;\n        const delta = now - wants.startTimeOfLoad;\n        this.stats_.setLoadLatency(delta);\n      });\n    }\n\n    // The audio tracks are only available on Safari at the moment, but this\n    // drives the tracks API for Safari's native HLS. So when they change,\n    // fire the corresponding Shaka Player event.\n    if (mediaElement.audioTracks) {\n      this.loadEventManager_.listen(\n          mediaElement.audioTracks, 'addtrack', () => this.onTracksChanged_());\n      this.loadEventManager_.listen(\n          mediaElement.audioTracks, 'removetrack',\n          () => this.onTracksChanged_());\n      this.loadEventManager_.listen(\n          mediaElement.audioTracks, 'change', () => this.onTracksChanged_());\n    }\n\n    if (mediaElement.textTracks) {\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'addtrack', (e) => {\n            const trackEvent = /** @type {!TrackEvent} */(e);\n            if (trackEvent.track) {\n              const track = trackEvent.track;\n              goog.asserts.assert(\n                  track instanceof TextTrack, 'Wrong track type!');\n\n              switch (track.kind) {\n                case 'metadata':\n                  this.processTimedMetadataSrcEqls_(track);\n                  break;\n\n                case 'chapters':\n                  this.activateChaptersTrack_(track);\n                  break;\n\n                default:\n                  this.onTracksChanged_();\n                  break;\n              }\n            }\n          });\n\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'removetrack',\n          () => this.onTracksChanged_());\n      this.loadEventManager_.listen(\n          mediaElement.textTracks, 'change',\n          () => this.onTracksChanged_());\n    }\n\n    const extension = shaka.media.ManifestParser.getExtension(has.uri);\n    const mimeType =\n      shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_[extension];\n\n    // By setting |src| we are done \"loading\" with src=. We don't need to set\n    // the current time because |playhead| will do that for us.\n    mediaElement.src = this.cmcdManager_.appendSrcData(has.uri, mimeType);\n\n    // Tizen 3 / WebOS won't load anything unless you call load() explicitly,\n    // no matter the value of the preload attribute.  This is harmful on some\n    // other platforms by triggering unbounded loading of media data, but is\n    // necessary here.\n    if (shaka.util.Platform.isTizen() || shaka.util.Platform.isWebOS()) {\n      mediaElement.load();\n    }\n\n    // Set the load mode last so that we know that all our components are\n    // initialized.\n    this.loadMode_ = shaka.Player.LoadMode.SRC_EQUALS;\n\n    // The event doesn't mean as much for src= playback, since we don't control\n    // streaming.  But we should fire it in this path anyway since some\n    // applications may be expecting it as a life-cycle event.\n    this.dispatchEvent(\n        this.makeEvent_(shaka.util.FakeEvent.EventName.Streaming));\n\n    // The \"load\" Promise is resolved when we have loaded the metadata.  If we\n    // wait for the full data, that won't happen on Safari until the play button\n    // is hit.\n    const fullyLoaded = new shaka.util.PublicPromise();\n    shaka.util.MediaReadyState.waitForReadyState(mediaElement,\n        HTMLMediaElement.HAVE_METADATA,\n        this.loadEventManager_,\n        () => {\n          this.playhead_.ready();\n          fullyLoaded.resolve();\n        });\n\n    // We can't switch to preferred languages, though, until the data is loaded.\n    shaka.util.MediaReadyState.waitForReadyState(mediaElement,\n        HTMLMediaElement.HAVE_CURRENT_DATA,\n        this.loadEventManager_,\n        async () => {\n          this.setupPreferredAudioOnSrc_();\n\n          // Applying the text preference too soon can result in it being\n          // reverted.  Wait for native HLS to pick something first.\n          const textTracks = this.getFilteredTextTracks_();\n          if (!textTracks.find((t) => t.mode != 'disabled')) {\n            await new Promise((resolve) => {\n              this.loadEventManager_.listenOnce(\n                  mediaElement.textTracks, 'change', resolve);\n\n              // We expect the event to fire because it does on Safari.\n              // But in case it doesn't on some other platform or future\n              // version, move on in 1 second no matter what.  This keeps the\n              // language settings from being completely ignored if something\n              // goes wrong.\n              new shaka.util.Timer(resolve).tickAfter(1);\n            });\n          }\n\n          // If we have moved on to another piece of content while waiting for\n          // the above event/timer, we should not change tracks here.\n          if (unloaded) {\n            return;\n          }\n\n          this.setupPreferredTextOnSrc_();\n        });\n\n    if (mediaElement.error) {\n      // Already failed!\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    } else if (mediaElement.preload == 'none') {\n      shaka.log.alwaysWarn(\n          'With <video preload=\"none\">, the browser will not load anything ' +\n          'until play() is called. We are unable to measure load latency in ' +\n          'a meaningful way, and we cannot provide track info yet. Please do ' +\n          'not use preload=\"none\" with Shaka Player.');\n      // We can't wait for an event load loadedmetadata, since that will be\n      // blocked until a user interaction.  So resolve the Promise now.\n      fullyLoaded.resolve();\n    }\n\n    this.loadEventManager_.listenOnce(mediaElement, 'error', () => {\n      fullyLoaded.reject(this.videoErrorToShakaError_());\n    });\n\n    return new shaka.util.AbortableOperation(fullyLoaded, /* onAbort= */ () => {\n      const abortedError = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n      fullyLoaded.reject(abortedError);\n      return Promise.resolve();  // Abort complete.\n    }).chain(() => {\n      this.fullyLoaded_ = true;\n    });\n  }\n\n  /**\n   * This method setup the preferred audio using src=..\n   *\n   * @private\n   */\n  setupPreferredAudioOnSrc_() {\n    const preferredAudioLanguage = this.config_.preferredAudioLanguage;\n\n    // If the user has not selected a preference, the browser preference is\n    // left.\n    if (preferredAudioLanguage == '') {\n      return;\n    }\n\n    this.selectAudioLanguage(preferredAudioLanguage);\n\n    const preferredVariantRole = this.config_.preferredVariantRole;\n\n    // If the user has not selected a role preference, the previous match is\n    // selected.\n    if (preferredVariantRole == '') {\n      return;\n    }\n\n    this.selectAudioLanguage(preferredAudioLanguage, preferredVariantRole);\n  }\n\n  /**\n   * This method setup the preferred text using src=.\n   *\n   * @private\n   */\n  setupPreferredTextOnSrc_() {\n    const preferredTextLanguage = this.config_.preferredTextLanguage;\n    const preferForcedSubs = this.config_.preferForcedSubs;\n\n    // If the user has not selected a preference, the browser preference is\n    // left.\n    if (preferredTextLanguage == '') {\n      return;\n    }\n\n    this.selectTextLanguage(preferredTextLanguage, '', preferForcedSubs);\n\n    const preferredTextRole = this.config_.preferredTextRole;\n\n    // If the user has not selected a role preference, the previous match is\n    // selected.\n    if (preferredTextRole == '') {\n      return;\n    }\n\n    this.selectTextLanguage(preferredTextLanguage, preferredTextRole,\n        preferForcedSubs);\n  }\n\n  /**\n   * We're looking for metadata tracks to process id3 tags. One of the uses is\n   * for ad info on LIVE streams\n   *\n   * @param {!TextTrack} track\n   * @private\n   */\n  processTimedMetadataSrcEqls_(track) {\n    if (track.kind != 'metadata') {\n      return;\n    }\n\n    // Hidden mode is required for the cuechange event to launch correctly\n    track.mode = 'hidden';\n    this.loadEventManager_.listen(track, 'cuechange', () => {\n      if (!track.activeCues) {\n        return;\n      }\n\n      for (const cue of track.activeCues) {\n        this.dispatchMetadataEvent_(cue.startTime, cue.endTime,\n            cue.type, cue.value);\n\n        if (this.adManager_) {\n          this.adManager_.onCueMetadataChange(cue.value);\n        }\n      }\n    });\n\n    // In Safari the initial assignment does not always work, so we schedule\n    // this process to be repeated several times to ensure that it has been put\n    // in the correct mode.\n    const timer = new shaka.util.Timer(() => {\n      const textTracks = this.getMetadataTracks_();\n      for (const textTrack of textTracks) {\n        textTrack.mode = 'hidden';\n      }\n    }).tickNow().tickAfter(0.5);\n\n    this.cleanupOnUnload_.push(() => {\n      timer.stop();\n    });\n  }\n\n\n  /**\n   * @param {!Array.<shaka.extern.ID3Metadata>} metadata\n   * @param {number} offset\n   * @param {?number} segmentEndTime\n   * @private\n   */\n  processTimedMetadataMediaSrc_(metadata, offset, segmentEndTime) {\n    for (const sample of metadata) {\n      if (sample.data && sample.cueTime && sample.frames) {\n        const start = sample.cueTime + offset;\n        let end = segmentEndTime;\n        // This can happen when the ID3 info arrives in a previous segment.\n        if (end && start > end) {\n          end = start;\n        }\n        const metadataType = 'org.id3';\n        for (const frame of sample.frames) {\n          const payload = frame;\n          this.dispatchMetadataEvent_(start, end, metadataType, payload);\n        }\n\n        if (this.adManager_) {\n          this.adManager_.onHlsTimedMetadata(sample, start);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Construct and fire a Player.Metadata event\n   *\n   * @param {number} startTime\n   * @param {?number} endTime\n   * @param {string} metadataType\n   * @param {shaka.extern.MetadataFrame} payload\n   * @private\n   */\n  dispatchMetadataEvent_(startTime, endTime, metadataType, payload) {\n    goog.asserts.assert(!endTime || startTime <= endTime,\n        'Metadata start time should be less or equal to the end time!');\n    const eventName = shaka.util.FakeEvent.EventName.Metadata;\n    const data = new Map()\n        .set('startTime', startTime)\n        .set('endTime', endTime)\n        .set('metadataType', metadataType)\n        .set('payload', payload);\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * Set the mode on a chapters track so that it loads.\n   *\n   * @param {?TextTrack} track\n   * @private\n   */\n  activateChaptersTrack_(track) {\n    if (!track || track.kind != 'chapters') {\n      return;\n    }\n\n    // Hidden mode is required for the cuechange event to launch correctly and\n    // get the cues and the activeCues\n    track.mode = 'hidden';\n\n    // In Safari the initial assignment does not always work, so we schedule\n    // this process to be repeated several times to ensure that it has been put\n    // in the correct mode.\n    const timer = new shaka.util.Timer(() => {\n      track.mode = 'hidden';\n    }).tickNow().tickAfter(0.5);\n\n    this.cleanupOnUnload_.push(() => {\n      timer.stop();\n    });\n  }\n\n  /**\n   * Take a series of variants and ensure that they only contain one type of\n   * variant. The different options are:\n   *  1. Audio-Video\n   *  2. Audio-Only\n   *  3. Video-Only\n   *\n   * A manifest can only contain a single type because once we initialize media\n   * source to expect specific streams, it must always have content for those\n   * streams. If we were to start with audio+video and switch to an audio-only\n   * variant, media source would block waiting for video content.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static filterForAVVariants_(manifest) {\n    const isAVVariant = (variant) => {\n      // Audio-video variants may include both streams separately or may be\n      // single multiplexed streams with multiple codecs.\n      return (variant.video && variant.audio) ||\n             (variant.video && variant.video.codecs.includes(','));\n    };\n    if (manifest.variants.some(isAVVariant)) {\n      shaka.log.debug('Found variant with audio and video content, ' +\n          'so filtering out audio-only content.');\n      manifest.variants = manifest.variants.filter(isAVVariant);\n    }\n  }\n\n  /**\n   * Create a new DrmEngine instance. This may be replaced by tests to create\n   * fake instances. Configuration and initialization will be handled after\n   * |createDrmEngine|.\n   *\n   * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n   * @return {!shaka.media.DrmEngine}\n   */\n  createDrmEngine(playerInterface) {\n    const updateExpirationTime = this.config_.drm.updateExpirationTime;\n    return new shaka.media.DrmEngine(playerInterface, updateExpirationTime);\n  }\n\n  /**\n   * Creates a new instance of NetworkingEngine.  This can be replaced by tests\n   * to create fake instances instead.\n   *\n   * @return {!shaka.net.NetworkingEngine}\n   */\n  createNetworkingEngine() {\n    /** @type {function(number, number)} */\n    const onProgressUpdated_ = (deltaTimeMs, bytesDownloaded) => {\n      // In some situations, such as during offline storage, the abr manager\n      // might not yet exist. Therefore, we need to check if abr manager has\n      // been initialized before using it.\n      if (this.abrManager_) {\n        this.abrManager_.segmentDownloaded(deltaTimeMs, bytesDownloaded);\n      }\n    };\n    /** @type {shaka.net.NetworkingEngine.OnHeadersReceived} */\n    const onHeadersReceived_ = (headers, request, requestType) => {\n      // Release a 'downloadheadersreceived' event.\n      const name = shaka.util.FakeEvent.EventName.DownloadHeadersReceived;\n      const data = new Map()\n          .set('headers', headers)\n          .set('request', request)\n          .set('requestType', requestType);\n      this.dispatchEvent(this.makeEvent_(name, data));\n    };\n    /** @type {shaka.net.NetworkingEngine.OnDownloadFailed} */\n    const onDownloadFailed_ = (request, error, httpResponseCode, aborted) => {\n      // Release a 'downloadfailed' event.\n      const name = shaka.util.FakeEvent.EventName.DownloadFailed;\n      const data = new Map()\n          .set('request', request)\n          .set('error', error)\n          .set('httpResponseCode', httpResponseCode)\n          .set('aborted', aborted);\n      this.dispatchEvent(this.makeEvent_(name, data));\n    };\n\n    return new shaka.net.NetworkingEngine(\n        onProgressUpdated_, onHeadersReceived_, onDownloadFailed_);\n  }\n\n  /**\n   * Creates a new instance of Playhead.  This can be replaced by tests to\n   * create fake instances instead.\n   *\n   * @param {?number} startTime\n   * @return {!shaka.media.Playhead}\n   */\n  createPlayhead(startTime) {\n    goog.asserts.assert(this.manifest_, 'Must have manifest');\n    goog.asserts.assert(this.video_, 'Must have video');\n    return new shaka.media.MediaSourcePlayhead(\n        this.video_,\n        this.manifest_,\n        this.config_.streaming,\n        startTime,\n        () => this.onSeek_(),\n        (event) => this.dispatchEvent(event));\n  }\n\n  /**\n   * Create the observers for MSE playback. These observers are responsible for\n   * notifying the app and player of specific events during MSE playback.\n   *\n   * @return {!shaka.media.PlayheadObserverManager}\n   * @private\n   */\n  createPlayheadObserversForMSE_() {\n    goog.asserts.assert(this.manifest_, 'Must have manifest');\n    goog.asserts.assert(this.regionTimeline_, 'Must have region timeline');\n    goog.asserts.assert(this.video_, 'Must have video element');\n\n    // Create the region observer. This will allow us to notify the app when we\n    // move in and out of timeline regions.\n    const regionObserver = new shaka.media.RegionObserver(this.regionTimeline_);\n\n    regionObserver.addEventListener('enter', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.onRegionEvent_(\n          shaka.util.FakeEvent.EventName.TimelineRegionEnter, region);\n    });\n\n    regionObserver.addEventListener('exit', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.onRegionEvent_(\n          shaka.util.FakeEvent.EventName.TimelineRegionExit, region);\n    });\n\n    regionObserver.addEventListener('skip', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      /** @type {boolean} */\n      const seeking = event['seeking'];\n      // If we are seeking, we don't want to surface the enter/exit events since\n      // they didn't play through them.\n      if (!seeking) {\n        this.onRegionEvent_(\n            shaka.util.FakeEvent.EventName.TimelineRegionEnter, region);\n        this.onRegionEvent_(\n            shaka.util.FakeEvent.EventName.TimelineRegionExit, region);\n      }\n    });\n\n    // Now that we have all our observers, create a manager for them.\n    const manager = new shaka.media.PlayheadObserverManager(this.video_);\n    manager.manage(regionObserver);\n    if (this.qualityObserver_) {\n      manager.manage(this.qualityObserver_);\n    }\n    return manager;\n  }\n\n  /**\n   * Initialize and start the buffering system (observer and timer) so that we\n   * can monitor our buffer lead during playback.\n   *\n   * @param {number} rebufferingGoal\n   * @private\n   */\n  startBufferManagement_(rebufferingGoal) {\n    goog.asserts.assert(\n        !this.bufferObserver_,\n        'No buffering observer should exist before initialization.');\n\n    goog.asserts.assert(\n        !this.bufferPoller_,\n        'No buffer timer should exist before initialization.');\n\n    // Give dummy values, will be updated below.\n    this.bufferObserver_ = new shaka.media.BufferingObserver(1, 2);\n\n    // Force us back to a buffering state. This ensure everything is starting in\n    // the same state.\n    this.bufferObserver_.setState(shaka.media.BufferingObserver.State.STARVING);\n    this.updateBufferingSettings_(rebufferingGoal);\n    this.updateBufferState_();\n\n    // TODO: We should take some time to look into the effects of our\n    //       quarter-second refresh practice. We often use a quarter-second\n    //       but we have no documentation about why.\n    this.bufferPoller_ = new shaka.util.Timer(() => {\n      this.pollBufferState_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /**\n   * Updates the buffering thresholds based on the new rebuffering goal.\n   *\n   * @param {number} rebufferingGoal\n   * @private\n   */\n  updateBufferingSettings_(rebufferingGoal) {\n    // The threshold to transition back to satisfied when starving.\n    const starvingThreshold = rebufferingGoal;\n    // The threshold to transition into starving when satisfied.\n    // We use a \"typical\" threshold, unless the rebufferingGoal is unusually\n    // low.\n    // Then we force the value down to half the rebufferingGoal, since\n    // starvingThreshold must be strictly larger than satisfiedThreshold for the\n    // logic in BufferingObserver to work correctly.\n    const satisfiedThreshold = Math.min(\n        shaka.Player.TYPICAL_BUFFERING_THRESHOLD_, rebufferingGoal / 2);\n\n    this.bufferObserver_.setThresholds(starvingThreshold, satisfiedThreshold);\n  }\n\n  /**\n   * This method is called periodically to check what the buffering observer\n   * says so that we can update the rest of the buffering behaviours.\n   *\n   * @private\n   */\n  pollBufferState_() {\n    goog.asserts.assert(\n        this.video_,\n        'Need a media element to update the buffering observer');\n\n    goog.asserts.assert(\n        this.bufferObserver_,\n        'Need a buffering observer to update');\n\n    let bufferedToEnd;\n    switch (this.loadMode_) {\n      case shaka.Player.LoadMode.SRC_EQUALS:\n        bufferedToEnd = this.isBufferedToEndSrc_();\n        break;\n      case shaka.Player.LoadMode.MEDIA_SOURCE:\n        bufferedToEnd = this.isBufferedToEndMS_();\n        break;\n      default:\n        bufferedToEnd = false;\n        break;\n    }\n\n    const bufferLead = shaka.media.TimeRangesUtils.bufferedAheadOf(\n        this.video_.buffered,\n        this.video_.currentTime);\n\n    const stateChanged = this.bufferObserver_.update(bufferLead, bufferedToEnd);\n\n    // If the state changed, we need to surface the event.\n    if (stateChanged) {\n      this.updateBufferState_();\n    }\n  }\n\n  /**\n   * Create a new media source engine. This will ONLY be replaced by tests as a\n   * way to inject fake media source engine instances.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   * @param {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)}\n   *  onMetadata\n   * @param {shaka.lcevc.Dil} lcevcDil\n   *\n   * @return {!shaka.media.MediaSourceEngine}\n   */\n  createMediaSourceEngine(mediaElement, textDisplayer, onMetadata, lcevcDil) {\n    return new shaka.media.MediaSourceEngine(\n        mediaElement,\n        textDisplayer,\n        onMetadata,\n        lcevcDil);\n  }\n\n  /**\n   * Create a new CMCD manager.\n   *\n   * @private\n   */\n  createCmcd_() {\n    /** @type {shaka.util.CmcdManager.PlayerInterface} */\n    const playerInterface = {\n      getBandwidthEstimate: () => this.abrManager_ ?\n        this.abrManager_.getBandwidthEstimate() : NaN,\n      getBufferedInfo: () => this.getBufferedInfo(),\n      getCurrentTime: () => this.video_ ? this.video_.currentTime : 0,\n      getVariantTracks: () => this.getVariantTracks(),\n      getPlaybackRate: () => this.getPlaybackRate(),\n      isLive: () => this.isLive(),\n    };\n\n    return new shaka.util.CmcdManager(playerInterface, this.config_.cmcd);\n  }\n\n  /**\n   * Creates a new instance of StreamingEngine.  This can be replaced by tests\n   * to create fake instances instead.\n   *\n   * @return {!shaka.media.StreamingEngine}\n   */\n  createStreamingEngine() {\n    goog.asserts.assert(\n        this.abrManager_ && this.mediaSourceEngine_ &&\n        this.cmcdManager_ && this.manifest_,\n        'Must not be destroyed');\n\n    /** @type {shaka.media.StreamingEngine.PlayerInterface} */\n    const playerInterface = {\n      getPresentationTime: () => this.playhead_ ? this.playhead_.getTime() : 0,\n      getBandwidthEstimate: () => this.abrManager_.getBandwidthEstimate(),\n      modifySegmentRequest: (request, segmentInfo) => {\n        this.cmcdManager_.applySegmentData(request, segmentInfo);\n      },\n      mediaSourceEngine: this.mediaSourceEngine_,\n      netEngine: this.networkingEngine_,\n      onError: (error) => this.onError_(error),\n      onEvent: (event) => this.dispatchEvent(event),\n      onManifestUpdate: () => this.onManifestUpdate_(),\n      onSegmentAppended: (start, end, contentType) => {\n        this.onSegmentAppended_(start, end, contentType);\n      },\n      onInitSegmentAppended: (position, initSegment) => {\n        const mediaQuality = initSegment.getMediaQuality();\n        if (mediaQuality && this.qualityObserver_) {\n          this.qualityObserver_.addMediaQualityChange(mediaQuality, position);\n        }\n      },\n      beforeAppendSegment: (contentType, segment) => {\n        return this.drmEngine_.parseInbandPssh(contentType, segment);\n      },\n      onMetadata: (metadata, offset, endTime) => {\n        this.processTimedMetadataMediaSrc_(metadata, offset, endTime);\n      },\n    };\n\n    return new shaka.media.StreamingEngine(this.manifest_, playerInterface);\n  }\n\n  /**\n   * Changes configuration settings on the Player.  This checks the names of\n   * keys and the types of values to avoid coding errors.  If there are errors,\n   * this logs them to the console and returns false.  Correct fields are still\n   * applied even if there are other errors.  You can pass an explicit\n   * <code>undefined</code> value to restore the default value.  This has two\n   * modes of operation:\n   *\n   * <p>\n   * First, this can be passed a single \"plain\" object.  This object should\n   * follow the {@link shaka.extern.PlayerConfiguration} object.  Not all fields\n   * need to be set; unset fields retain their old values.\n   *\n   * <p>\n   * Second, this can be passed two arguments.  The first is the name of the key\n   * to set.  This should be a '.' separated path to the key.  For example,\n   * <code>'streaming.alwaysStreamText'</code>.  The second argument is the\n   * value to set.\n   *\n   * @param {string|!Object} config This should either be a field name or an\n   *   object.\n   * @param {*=} value In the second mode, this is the value to set.\n   * @return {boolean} True if the passed config object was valid, false if\n   *   there were invalid entries.\n   * @export\n   */\n  configure(config, value) {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n    goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n        'String configs should have values!');\n\n    // ('fieldName', value) format\n    if (arguments.length == 2 && typeof(config) == 'string') {\n      config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n    }\n\n    goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n    // Deprecate 'streaming.forceTransmuxTS' configuration.\n    if (config['streaming'] && 'forceTransmuxTS' in config['streaming']) {\n      shaka.Deprecate.deprecateFeature(5,\n          'streaming.forceTransmuxTS configuration',\n          'Please Use streaming.forceTransmux instead.');\n      config['streaming']['forceTransmux'] =\n          config['streaming']['forceTransmuxTS'];\n      delete config['streaming']['forceTransmuxTS'];\n    }\n\n    // If lowLatencyMode is enabled, and inaccurateManifestTolerance and\n    // rebufferingGoal are not specified, set inaccurateManifestTolerance to 0\n    // and rebufferingGoal to 0.01 by default for low latency streaming.\n    if (config['streaming'] && config['streaming']['lowLatencyMode']) {\n      if (config['streaming']['inaccurateManifestTolerance'] == undefined) {\n        config['streaming']['inaccurateManifestTolerance'] = 0;\n      }\n      if (config['streaming']['rebufferingGoal'] == undefined) {\n        config['streaming']['rebufferingGoal'] = 0.01;\n      }\n    }\n    const ret = shaka.util.PlayerConfiguration.mergeConfigObjects(\n        this.config_, config, this.defaultConfig_());\n\n    this.applyConfig_();\n    return ret;\n  }\n\n  /**\n   * Apply config changes.\n   * @private\n   */\n  applyConfig_() {\n    if (this.parser_) {\n      const manifestConfig =\n          shaka.util.ObjectUtils.cloneObject(this.config_.manifest);\n      // Don't read video segments if the player is attached to an audio element\n      if (this.video_ && this.video_.nodeName === 'AUDIO') {\n        manifestConfig.disableVideo = true;\n      }\n      this.parser_.configure(manifestConfig);\n    }\n    if (this.drmEngine_) {\n      this.drmEngine_.configure(this.config_.drm);\n    }\n    if (this.streamingEngine_) {\n      this.streamingEngine_.configure(this.config_.streaming);\n\n      // Need to apply the restrictions.\n      try {\n        // this.filterManifestWithRestrictions_() may throw.\n        this.filterManifestWithRestrictions_(this.manifest_);\n      } catch (error) {\n        this.onError_(error);\n      }\n\n      if (this.abrManager_) {\n        // Update AbrManager variants to match these new settings.\n        this.updateAbrManagerVariants_();\n      }\n\n      // If the streams we are playing are restricted, we need to switch.\n      const activeVariant = this.streamingEngine_.getCurrentVariant();\n      if (activeVariant) {\n        if (!activeVariant.allowedByApplication ||\n            !activeVariant.allowedByKeySystem) {\n          shaka.log.debug('Choosing new variant after changing configuration');\n          this.chooseVariantAndSwitch_();\n        }\n      }\n    }\n    if (this.networkingEngine_) {\n      this.networkingEngine_.setForceHTTPS(this.config_.streaming.forceHTTPS);\n    }\n\n    if (this.mediaSourceEngine_) {\n      this.mediaSourceEngine_.configure(this.config_.mediaSource);\n      const {segmentRelativeVttTiming} = this.config_.manifest;\n      this.mediaSourceEngine_.setSegmentRelativeVttTiming(\n          segmentRelativeVttTiming);\n\n      const textDisplayerFactory = this.config_.textDisplayFactory;\n      if (this.lastTextFactory_ != textDisplayerFactory) {\n        const displayer = textDisplayerFactory();\n        this.mediaSourceEngine_.setTextDisplayer(displayer);\n        this.lastTextFactory_ = textDisplayerFactory;\n\n        if (this.streamingEngine_) {\n          // Reload the text stream, so the cues will load again.\n          this.streamingEngine_.reloadTextStream();\n        }\n      }\n    }\n    if (this.abrManager_) {\n      this.abrManager_.configure(this.config_.abr);\n      // Simply enable/disable ABR with each call, since multiple calls to these\n      // methods have no effect.\n      if (this.config_.abr.enabled) {\n        this.abrManager_.enable();\n      } else {\n        this.abrManager_.disable();\n      }\n\n      this.onAbrStatusChanged_();\n    }\n    if (this.bufferObserver_) {\n      let rebufferThreshold = this.config_.streaming.rebufferingGoal;\n      if (this.manifest_) {\n        rebufferThreshold =\n            Math.max(rebufferThreshold, this.manifest_.minBufferTime);\n      }\n      this.updateBufferingSettings_(rebufferThreshold);\n    }\n\n    if (this.manifest_) {\n      shaka.Player.applyPlayRange_(this.manifest_.presentationTimeline,\n          this.config_.playRangeStart,\n          this.config_.playRangeEnd);\n    }\n  }\n\n  /**\n   * Return a copy of the current configuration.  Modifications of the returned\n   * value will not affect the Player's active configuration.  You must call\n   * <code>player.configure()</code> to make changes.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  getConfiguration() {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n\n    const ret = this.defaultConfig_();\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        ret, this.config_, this.defaultConfig_());\n    return ret;\n  }\n\n  /**\n   * Return a reference to the current configuration. Modifications to the\n   * returned value will affect the Player's active configuration. This method\n   * is not exported as sharing configuration with external objects is not\n   * supported.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   */\n  getSharedConfiguration() {\n    goog.asserts.assert(\n        this.config_, 'Cannot call getSharedConfiguration after call destroy!');\n    return this.config_;\n  }\n\n  /**\n   * Returns the ratio of video length buffered compared to buffering Goal\n   * @return {number}\n   * @export\n   */\n  getBufferFullness() {\n    if (this.video_) {\n      const bufferedLength = this.video_.buffered.length;\n      const bufferedEnd =\n          bufferedLength ? this.video_.buffered.end(bufferedLength - 1) : 0;\n      const bufferingGoal = this.getConfiguration().streaming.bufferingGoal;\n      const lengthToBeBuffered = Math.min(this.video_.currentTime +\n          bufferingGoal, this.seekRange().end);\n\n      if (bufferedEnd >= lengthToBeBuffered) {\n        return 1;\n      } else if (bufferedEnd <= this.video_.currentTime) {\n        return 0;\n      } else if (bufferedEnd < lengthToBeBuffered) {\n        return ((bufferedEnd - this.video_.currentTime) /\n            (lengthToBeBuffered - this.video_.currentTime));\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Reset configuration to default.\n   * @export\n   */\n  resetConfiguration() {\n    goog.asserts.assert(this.config_, 'Cannot be destroyed');\n    // Remove the old keys so we remove open-ended dictionaries like drm.servers\n    // but keeps the same object reference.\n    for (const key in this.config_) {\n      delete this.config_[key];\n    }\n\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        this.config_, this.defaultConfig_(), this.defaultConfig_());\n    this.applyConfig_();\n  }\n\n  /**\n   * Get the current load mode.\n   *\n   * @return {shaka.Player.LoadMode}\n   * @export\n   */\n  getLoadMode() {\n    return this.loadMode_;\n  }\n\n  /**\n   * Get the media element that the player is currently using to play loaded\n   * content. If the player has not loaded content, this will return\n   * <code>null</code>.\n   *\n   * @return {HTMLMediaElement}\n   * @export\n   */\n  getMediaElement() {\n    return this.video_;\n  }\n\n  /**\n   * @return {shaka.net.NetworkingEngine} A reference to the Player's networking\n   *     engine.  Applications may use this to make requests through Shaka's\n   *     networking plugins.\n   * @export\n   */\n  getNetworkingEngine() {\n    return this.networkingEngine_;\n  }\n\n  /**\n   * Get the uri to the asset that the player has loaded. If the player has not\n   * loaded content, this will return <code>null</code>.\n   *\n   * @return {?string}\n   * @export\n   */\n  getAssetUri() {\n    return this.assetUri_;\n  }\n\n  /**\n   * Returns a shaka.ads.AdManager instance, responsible for Dynamic\n   * Ad Insertion functionality.\n   *\n   * @return {shaka.extern.IAdManager}\n   * @export\n   */\n  getAdManager() {\n    // NOTE: this clause is redundant, but it keeps the compiler from\n    // inlining this function. Inlining leads to setting the adManager\n    // not taking effect in the compiled build.\n    // Closure has a @noinline flag, but apparently not all cases are\n    // supported by it, and ours isn't.\n    // If they expand support, we might be able to get rid of this\n    // clause.\n    if (!this.adManager_) {\n      return null;\n    }\n\n    return this.adManager_;\n  }\n\n  /**\n   * Get if the player is playing live content. If the player has not loaded\n   * content, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isLive() {\n    if (this.manifest_) {\n      return this.manifest_.presentationTimeline.isLive();\n    }\n\n    // For native HLS, the duration for live streams seems to be Infinity.\n    if (this.video_ && this.video_.src) {\n      return this.video_.duration == Infinity;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get if the player is playing in-progress content. If the player has not\n   * loaded content, this will return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isInProgress() {\n    return this.manifest_ ?\n           this.manifest_.presentationTimeline.isInProgress() :\n           false;\n  }\n\n  /**\n   * Check if the manifest contains only audio-only content. If the player has\n   * not loaded content, this will return <code>false</code>.\n   *\n   * <p>\n   * The player does not support content that contain more than one type of\n   * variants (i.e. mixing audio-only, video-only, audio-video). Content will be\n   * filtered to only contain one type of variant.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isAudioOnly() {\n    if (this.manifest_) {\n      const variants = this.manifest_.variants;\n      if (!variants.length) {\n        return false;\n      }\n\n      // Note that if there are some audio-only variants and some audio-video\n      // variants, the audio-only variants are removed during filtering.\n      // Therefore if the first variant has no video, that's sufficient to say\n      // it is audio-only content.\n      return !variants[0].video;\n    } else if (this.video_ && this.video_.src) {\n      // If we have video track info, use that.  It will be the least\n      // error-prone way with native HLS.  In contrast, videoHeight might be\n      // unset until the first frame is loaded.  Since isAudioOnly is queried\n      // by the UI on the 'trackschanged' event, the videoTracks info should be\n      // up-to-date.\n      if (this.video_.videoTracks) {\n        return this.video_.videoTracks.length == 0;\n      }\n\n      // We cast to the more specific HTMLVideoElement to access videoHeight.\n      // This might be an audio element, though, in which case videoHeight will\n      // be undefined at runtime.  For audio elements, this will always return\n      // true.\n      const video = /** @type {HTMLVideoElement} */(this.video_);\n      return video.videoHeight == 0;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Return the value of lowLatencyMode configuration.\n   * @return {boolean}\n   * @private\n   */\n  isLowLatencyMode_() {\n    return this.config_.streaming.lowLatencyMode;\n  }\n\n  /**\n   * Return the value of autoLowLatencyMode configuration.\n   * @return {boolean}\n   * @private\n   */\n  isAutoLowLatencyMode_() {\n    return this.config_.streaming.autoLowLatencyMode;\n  }\n\n  /**\n   * Get the range of time (in seconds) that seeking is allowed. If the player\n   * has not loaded content, this will return a range from 0 to 0.\n   *\n   * @return {{start: number, end: number}}\n   * @export\n   */\n  seekRange() {\n    if (!this.fullyLoaded_) {\n      return {'start': 0, 'end': 0};\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n\n      return {\n        'start': timeline.getSeekRangeStart(),\n        'end': timeline.getSeekRangeEnd(),\n      };\n    }\n\n    // If we have loaded content with src=, we ask the video element for its\n    // seekable range.  This covers both plain mp4s and native HLS playbacks.\n    if (this.video_ && this.video_.src) {\n      const seekable = this.video_.seekable;\n      if (seekable.length) {\n        return {\n          'start': seekable.start(0),\n          'end': seekable.end(seekable.length - 1),\n        };\n      }\n    }\n\n    return {'start': 0, 'end': 0};\n  }\n\n  /**\n   * Go to live in a live stream.\n   *\n   * @export\n   */\n  goToLive() {\n    if (this.isLive()) {\n      this.video_.currentTime = this.seekRange().end;\n    } else {\n      shaka.log.warning('goToLive is for live streams!');\n    }\n  }\n\n  /**\n   * Get the key system currently used by EME. If EME is not being used, this\n   * will return an empty string. If the player has not loaded content, this\n   * will return an empty string.\n   *\n   * @return {string}\n   * @export\n   */\n  keySystem() {\n    return shaka.media.DrmEngine.keySystem(this.drmInfo());\n  }\n\n  /**\n   * Get the drm info used to initialize EME. If EME is not being used, this\n   * will return <code>null</code>. If the player is idle or has not initialized\n   * EME yet, this will return <code>null</code>.\n   *\n   * @return {?shaka.extern.DrmInfo}\n   * @export\n   */\n  drmInfo() {\n    return this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n  }\n\n\n  /**\n   * Get the drm engine.\n   * This method should only be used for testing. Applications SHOULD NOT\n   * use this in production.\n   *\n   * @return {?shaka.media.DrmEngine}\n   */\n  getDrmEngine() {\n    return this.drmEngine_;\n  }\n\n\n  /**\n   * Get the next known expiration time for any EME session. If the session\n   * never expires, this will return <code>Infinity</code>. If there are no EME\n   * sessions, this will return <code>Infinity</code>. If the player has not\n   * loaded content, this will return <code>Infinity</code>.\n   *\n   * @return {number}\n   * @export\n   */\n  getExpiration() {\n    return this.drmEngine_ ? this.drmEngine_.getExpiration() : Infinity;\n  }\n\n  /**\n   * Gets a map of EME key ID to the current key status.\n   *\n   * @return {!Object<string, string>}\n   * @export\n   */\n  getKeyStatuses() {\n    return this.drmEngine_ ? this.drmEngine_.getKeyStatuses() : {};\n  }\n\n  /**\n   * Check if the player is currently in a buffering state (has too little\n   * content to play smoothly). If the player has not loaded content, this will\n   * return <code>false</code>.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isBuffering() {\n    const State = shaka.media.BufferingObserver.State;\n    return this.bufferObserver_ ?\n           this.bufferObserver_.getState() == State.STARVING :\n           false;\n  }\n\n  /**\n   * Get the playback rate of what is playing right now. If we are using trick\n   * play, this will return the trick play rate.\n   * If no content is playing, this will return 0.\n   * If content is buffering, this will return the expected playback rate once\n   * the video starts playing.\n   *\n   * <p>\n   * If the player has not loaded content, this will return a playback rate of\n   * 0.\n   *\n   * @return {number}\n   * @export\n   */\n  getPlaybackRate() {\n    if (!this.video_) {\n      return 0;\n    }\n    return this.playRateController_ ?\n           this.playRateController_.getRealRate() :\n           1;\n  }\n\n  /**\n   * Enable trick play to skip through content without playing by repeatedly\n   * seeking. For example, a rate of 2.5 would result in 2.5 seconds of content\n   * being skipped every second. A negative rate will result in moving\n   * backwards.\n   *\n   * <p>\n   * If the player has not loaded content or is still loading content this will\n   * be a no-op. Wait until <code>load</code> has completed before calling.\n   *\n   * <p>\n   * Trick play will be canceled automatically if the playhead hits the\n   * beginning or end of the seekable range for the content.\n   *\n   * @param {number} rate\n   * @export\n   */\n  trickPlay(rate) {\n    // A playbackRate of 0 is used internally when we are in a buffering state,\n    // and doesn't make sense for trick play.  If you set a rate of 0 for trick\n    // play, we will reject it and issue a warning.  If it happens during a\n    // test, we will fail the test through this assertion.\n    goog.asserts.assert(rate != 0, 'Should never set a trick play rate of 0!');\n    if (rate == 0) {\n      shaka.log.alwaysWarn('A trick play rate of 0 is unsupported!');\n      return;\n    }\n\n    if (this.video_.paused) {\n      // Our fast forward is implemented with playbackRate and needs the video\n      // to be playing (to not be paused) to take immediate effect.\n      // If the video is paused, \"unpause\" it.\n      this.video_.play();\n    }\n    this.playRateController_.set(rate);\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.abrManager_.playbackRateChanged(rate);\n      this.streamingEngine_.setTrickPlay(Math.abs(rate) > 1);\n    }\n  }\n\n  /**\n   * Cancel trick-play. If the player has not loaded content or is still loading\n   * content this will be a no-op.\n   *\n   * @export\n   */\n  cancelTrickPlay() {\n    const defaultPlaybackRate = this.playRateController_.getDefaultRate();\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      this.playRateController_.set(defaultPlaybackRate);\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.playRateController_.set(defaultPlaybackRate);\n      this.abrManager_.playbackRateChanged(defaultPlaybackRate);\n      this.streamingEngine_.setTrickPlay(false);\n    }\n  }\n\n  /**\n   * Return a list of variant tracks that can be switched to.\n   *\n   * <p>\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getVariantTracks() {\n    if (this.manifest_) {\n      const currentVariant = this.streamingEngine_ ?\n          this.streamingEngine_.getCurrentVariant() : null;\n\n      const tracks = [];\n\n      let activeTracks = 0;\n\n      // Convert each variant to a track.\n      for (const variant of this.manifest_.variants) {\n        if (!shaka.util.StreamUtils.isPlayable(variant)) {\n          continue;\n        }\n\n        const track = shaka.util.StreamUtils.variantToTrack(variant);\n        track.active = variant == currentVariant;\n        if (!track.active && activeTracks != 1 && currentVariant != null &&\n          variant.video == currentVariant.video &&\n          variant.audio == currentVariant.audio) {\n          track.active = true;\n        }\n\n        if (track.active) {\n          activeTracks++;\n        }\n\n        tracks.push(track);\n      }\n\n      goog.asserts.assert(activeTracks <= 1,\n          'It should only have one active track');\n\n      return tracks;\n    } else if (this.video_ && this.video_.audioTracks) {\n      // Safari's native HLS always shows a single element in videoTracks.\n      // You can't use that API to change resolutions.  But we can use\n      // audioTracks to generate a variant list that is usable for changing\n      // languages.\n      const audioTracks = Array.from(this.video_.audioTracks);\n      return audioTracks.map((audio) =>\n        shaka.util.StreamUtils.html5AudioTrackToTrack(audio));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a list of text tracks that can be switched to.\n   *\n   * <p>\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getTextTracks() {\n    if (this.manifest_) {\n      const currentTextStream = this.streamingEngine_ ?\n          this.streamingEngine_.getCurrentTextStream() : null;\n      const tracks = [];\n\n      // Convert all selectable text streams to tracks.\n      for (const text of this.manifest_.textStreams) {\n        const track = shaka.util.StreamUtils.textStreamToTrack(text);\n        track.active = text == currentTextStream;\n\n        tracks.push(track);\n      }\n\n      return tracks;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      const StreamUtils = shaka.util.StreamUtils;\n      return textTracks.map((text) => StreamUtils.html5TextTrackToTrack(text));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a list of image tracks that can be switched to.\n   *\n   * If the player has not loaded content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getImageTracks() {\n    if (this.manifest_) {\n      const imageStreams = this.manifest_.imageStreams;\n      const StreamUtils = shaka.util.StreamUtils;\n      return imageStreams.map((image) => StreamUtils.imageStreamToTrack(image));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Return a Thumbnail object from a image track Id and time.\n   *\n   * If the player has not loaded content, this will return a null.\n   *\n   * @param {number} trackId\n   * @param {number} time\n   * @return {!Promise.<?shaka.extern.Thumbnail>}\n   * @export\n   */\n  async getThumbnails(trackId, time) {\n    if (this.manifest_) {\n      const imageStream = this.manifest_.imageStreams.find(\n          (stream) => stream.id == trackId);\n      if (!imageStream) {\n        return null;\n      }\n      if (!imageStream.segmentIndex) {\n        await imageStream.createSegmentIndex();\n      }\n      const referencePosition = imageStream.segmentIndex.find(time);\n      if (referencePosition == null) {\n        return null;\n      }\n      const reference = imageStream.segmentIndex.get(referencePosition);\n      const tilesLayout =\n          reference.getTilesLayout() || imageStream.tilesLayout;\n      // This expression is used to detect one or more numbers (0-9) followed\n      // by an x and after one or more numbers (0-9)\n      const match = /(\\d+)x(\\d+)/.exec(tilesLayout);\n      if (!match) {\n        shaka.log.warning('Tiles layout does not contain a valid format ' +\n            ' (columns x rows)');\n        return null;\n      }\n      const fullImageWidth = imageStream.width || 0;\n      const fullImageHeight = imageStream.height || 0;\n      const columns = parseInt(match[1], 10);\n      const rows = parseInt(match[2], 10);\n      let width = fullImageWidth / columns;\n      let height = fullImageHeight / rows;\n      const totalImages = columns * rows;\n      const segmentDuration = reference.trueEndTime - reference.startTime;\n      const thumbnailDuration =\n          reference.getTileDuration() || (segmentDuration / totalImages);\n      let thumbnailTime = reference.startTime;\n      let positionX = 0;\n      let positionY = 0;\n      // If the number of images in the segment is greater than 1, we have to\n      // find the correct image. For that we will return to the app the\n      // coordinates of the position of the correct image.\n      // Image search is always from left to right and top to bottom.\n      // Note: The time between images within the segment is always\n      // equidistant.\n      //\n      // Eg: Total images 5, tileLayout 5x1, segmentDuration 5, thumbnailTime 2\n      // positionX = 0.4 * fullImageWidth\n      // positionY = 0\n      if (totalImages > 1) {\n        const thumbnailPosition =\n            Math.floor((time - reference.startTime) / thumbnailDuration);\n        thumbnailTime = reference.startTime +\n            (thumbnailPosition * thumbnailDuration);\n        positionX = (thumbnailPosition % columns) * width;\n        positionY = Math.floor(thumbnailPosition / columns) * height;\n      }\n      let sprite = false;\n      const thumbnailSprite = reference.getThumbnailSprite();\n      if (thumbnailSprite) {\n        sprite = true;\n        height = thumbnailSprite.height;\n        positionX = thumbnailSprite.positionX;\n        positionY = thumbnailSprite.positionY;\n        width = thumbnailSprite.width;\n      }\n      return {\n        imageHeight: fullImageHeight,\n        imageWidth: fullImageWidth,\n        height: height,\n        positionX: positionX,\n        positionY: positionY,\n        startTime: thumbnailTime,\n        duration: thumbnailDuration,\n        uris: reference.getUris(),\n        width: width,\n        sprite: sprite,\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Select a specific text track. <code>track</code> should come from a call to\n   * <code>getTextTracks</code>. If the track is not found, this will be a\n   * no-op. If the player has not loaded content, this will be a no-op.\n   *\n   * <p>\n   * Note that <code>AdaptationEvents</code> are not fired for manual track\n   * selections.\n   *\n   * @param {shaka.extern.Track} track\n   * @export\n   */\n  selectTextTrack(track) {\n    if (this.manifest_ && this.streamingEngine_) {\n      const stream = this.manifest_.textStreams.find(\n          (stream) => stream.id == track.id);\n\n      if (!stream) {\n        shaka.log.error('No stream with id', track.id);\n        return;\n      }\n\n      if (stream == this.streamingEngine_.getCurrentTextStream()) {\n        shaka.log.debug('Text track already selected.');\n        return;\n      }\n\n      // Add entries to the history.\n      this.addTextStreamToSwitchHistory_(stream, /* fromAdaptation= */ false);\n      this.streamingEngine_.switchTextStream(stream);\n      this.onTextChanged_();\n\n      // Workaround for\n      // https://github.com/shaka-project/shaka-player/issues/1299\n      // When track is selected, back-propagate the language to\n      // currentTextLanguage_.\n      this.currentTextLanguage_ = stream.language;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      for (const textTrack of textTracks) {\n        if (shaka.util.StreamUtils.html5TrackId(textTrack) == track.id) {\n          // Leave the track in 'hidden' if it's selected but not showing.\n          textTrack.mode = this.isTextVisible_ ? 'showing' : 'hidden';\n        } else {\n          // Safari allows multiple text tracks to have mode == 'showing', so be\n          // explicit in resetting the others.\n          textTrack.mode = 'disabled';\n        }\n      }\n      this.onTextChanged_();\n    }\n  }\n\n  /**\n   * Select a specific variant track to play.  <code>track</code> should come\n   * from a call to <code>getVariantTracks</code>. If <code>track</code> cannot\n   * be found, this will be a no-op. If the player has not loaded content, this\n   * will be a no-op.\n   *\n   * <p>\n   * Changing variants will take effect once the currently buffered content has\n   * been played. To force the change to happen sooner, use\n   * <code>clearBuffer</code> with <code>safeMargin</code>. Setting\n   * <code>clearBuffer</code> to <code>true</code> will clear all buffered\n   * content after <code>safeMargin</code>, allowing the new variant to start\n   * playing sooner.\n   *\n   * <p>\n   * Note that <code>AdaptationEvents</code> are not fired for manual track\n   * selections.\n   *\n   * @param {shaka.extern.Track} track\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin Optional amount of buffer (in seconds) to\n   *   retain when clearing the buffer. Useful for switching variant quickly\n   *   without causing a buffering event. Defaults to 0 if not provided. Ignored\n   *   if clearBuffer is false. Can cause hiccups on some browsers if chosen too\n   *   small, e.g. The amount of two segments is a fair minimum to consider as\n   *   safeMargin value.\n   * @export\n   */\n  selectVariantTrack(track, clearBuffer = false, safeMargin = 0) {\n    if (this.manifest_ && this.streamingEngine_) {\n      if (this.config_.abr.enabled) {\n        shaka.log.alwaysWarn('Changing tracks while abr manager is enabled ' +\n                             'will likely result in the selected track ' +\n                             'being overriden. Consider disabling abr before ' +\n                             'calling selectVariantTrack().');\n      }\n\n      const variant = this.manifest_.variants.find(\n          (variant) => variant.id == track.id);\n      if (!variant) {\n        shaka.log.error('No variant with id', track.id);\n        return;\n      }\n\n      // Double check that the track is allowed to be played. The track list\n      // should only contain playable variants, but if restrictions change and\n      // |selectVariantTrack| is called before the track list is updated, we\n      // could get a now-restricted variant.\n      if (!shaka.util.StreamUtils.isPlayable(variant)) {\n        shaka.log.error('Unable to switch to restricted track', track.id);\n        return;\n      }\n\n      this.switchVariant_(\n          variant, /* fromAdaptation= */ false, clearBuffer, safeMargin);\n\n      // Workaround for\n      // https://github.com/shaka-project/shaka-player/issues/1299\n      // When track is selected, back-propagate the language to\n      // currentAudioLanguage_.\n      this.currentAdaptationSetCriteria_ = new shaka.media.ExampleBasedCriteria(\n          variant);\n\n      // Update AbrManager variants to match these new settings.\n      this.updateAbrManagerVariants_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      // Safari's native HLS won't let you choose an explicit variant, though\n      // you can choose audio languages this way.\n      const audioTracks = Array.from(this.video_.audioTracks);\n      for (const audioTrack of audioTracks) {\n        if (shaka.util.StreamUtils.html5TrackId(audioTrack) == track.id) {\n          // This will reset the \"enabled\" of other tracks to false.\n          this.switchHtml5Track_(audioTrack);\n          return;\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a list of audio language-role combinations available.  If the\n   * player has not loaded any content, this will return an empty list.\n   *\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @export\n   */\n  getAudioLanguagesAndRoles() {\n    return shaka.Player.getLanguageAndRolesFrom_(this.getVariantTracks());\n  }\n\n  /**\n   * Return a list of text language-role combinations available.  If the player\n   * has not loaded any content, this will be return an empty list.\n   *\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @export\n   */\n  getTextLanguagesAndRoles() {\n    return shaka.Player.getLanguageAndRolesFrom_(this.getTextTracks());\n  }\n\n  /**\n   * Return a list of audio languages available. If the player has not loaded\n   * any content, this will return an empty list.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getAudioLanguages() {\n    return Array.from(shaka.Player.getLanguagesFrom_(this.getVariantTracks()));\n  }\n\n  /**\n   * Return a list of text languages available. If the player has not loaded\n   * any content, this will return an empty list.\n   *\n   * @return {!Array.<string>}\n   * @export\n   */\n  getTextLanguages() {\n    return Array.from(shaka.Player.getLanguagesFrom_(this.getTextTracks()));\n  }\n\n  /**\n   * Sets the current audio language and current variant role to the selected\n   * language, role and channel count, and chooses a new variant if need be.\n   * If the player has not loaded any content, this will be a no-op.\n   *\n   * @param {string} language\n   * @param {string=} role\n   * @param {number=} channelsCount\n   * @export\n   */\n  selectAudioLanguage(language, role, channelsCount = 0) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    if (this.manifest_ && this.playhead_) {\n      this.currentAdaptationSetCriteria_ =\n          new shaka.media.PreferenceBasedCriteria(language, role || '',\n              channelsCount, /* label= */ '');\n\n      const diff = (a, b) => {\n        if (!a.video && !b.video) {\n          return 0;\n        } else if (!a.video || !b.video) {\n          return Infinity;\n        } else {\n          return Math.abs((a.video.height || 0) - (b.video.height || 0)) +\n                Math.abs((a.video.width || 0) - (b.video.width || 0));\n        }\n      };\n        // Find the variant whose size is closest to the active variant.  This\n        // ensures we stay at about the same resolution when just changing the\n        // language/role.\n      const active = this.streamingEngine_.getCurrentVariant();\n      const set =\n            this.currentAdaptationSetCriteria_.create(this.manifest_.variants);\n      let bestVariant = null;\n      for (const curVariant of set.values()) {\n        if (!bestVariant ||\n              diff(bestVariant, active) > diff(curVariant, active)) {\n          bestVariant = curVariant;\n        }\n      }\n      if (bestVariant) {\n        const track = shaka.util.StreamUtils.variantToTrack(bestVariant);\n        this.selectVariantTrack(track, /* clearBuffer= */ true);\n        return;\n      }\n\n      // If we haven't switched yet, just use ABR to find a new track.\n      this.chooseVariantAndSwitch_();\n    } else if (this.video_ && this.video_.audioTracks) {\n      const audioTracks = Array.from(this.video_.audioTracks);\n      const selectedLanguage = LanguageUtils.normalize(language);\n\n      let languageMatch = null;\n      let languageAndRoleMatch = null;\n\n      for (const audioTrack of audioTracks) {\n        const track = shaka.util.StreamUtils.html5AudioTrackToTrack(audioTrack);\n\n        if (LanguageUtils.normalize(track.language) == selectedLanguage) {\n          languageMatch = audioTrack;\n\n          if (role) {\n            if (track.roles.includes(role)) {\n              languageAndRoleMatch = audioTrack;\n            }\n          } else {  // no role\n            if (track.roles.length == 0) {\n              languageAndRoleMatch = audioTrack;\n            }\n          }\n        }\n      }\n      if (languageAndRoleMatch) {\n        this.switchHtml5Track_(languageAndRoleMatch);\n      } else if (languageMatch) {\n        this.switchHtml5Track_(languageMatch);\n      }\n    }\n  }\n\n  /**\n   * Sets the current text language and current text role to the selected\n   * language and role, and chooses a new variant if need be. If the player has\n   * not loaded any content, this will be a no-op.\n   *\n   * @param {string} language\n   * @param {string=} role\n   * @param {boolean=} forced\n   * @export\n   */\n  selectTextLanguage(language, role, forced = false) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    if (this.manifest_ && this.playhead_) {\n      this.currentTextLanguage_ = language;\n      this.currentTextRole_ = role || '';\n      this.currentTextForced_ = forced;\n\n      const chosenText = this.chooseTextStream_();\n      if (chosenText) {\n        if (chosenText == this.streamingEngine_.getCurrentTextStream()) {\n          shaka.log.debug('Text track already selected.');\n          return;\n        }\n\n        this.addTextStreamToSwitchHistory_(\n            chosenText, /* fromAdaptation= */ false);\n        if (this.shouldStreamText_()) {\n          this.streamingEngine_.switchTextStream(chosenText);\n          this.onTextChanged_();\n        }\n      }\n    } else {\n      const selectedLanguage = LanguageUtils.normalize(language);\n\n      const track = this.getTextTracks().find((t) => {\n        return LanguageUtils.normalize(t.language) == selectedLanguage &&\n          (!role || t.roles.includes(role)) && t.forced == forced;\n      });\n\n      if (track) {\n        this.selectTextTrack(track);\n      }\n    }\n  }\n\n  /**\n   * Select variant tracks that have a given label. This assumes the\n   * label uniquely identifies an audio stream, so all the variants\n   * are expected to have the same variant.audio.\n   *\n   * @param {string} label\n   * @export\n   */\n  selectVariantsByLabel(label) {\n    if (this.manifest_ && this.playhead_) {\n      let firstVariantWithLabel = null;\n      for (const variant of this.manifest_.variants) {\n        if (variant.audio.label == label) {\n          firstVariantWithLabel = variant;\n          break;\n        }\n      }\n\n      if (firstVariantWithLabel == null) {\n        shaka.log.warning('No variants were found with label: ' +\n            label + '. Ignoring the request to switch.');\n\n        return;\n      }\n\n      // Label is a unique identifier of a variant's audio stream.\n      // Because of that we assume that all the variants with the same\n      // label have the same language.\n      this.currentAdaptationSetCriteria_ =\n          new shaka.media.PreferenceBasedCriteria(\n              firstVariantWithLabel.language, '', 0, label);\n\n      this.chooseVariantAndSwitch_();\n    }\n  }\n\n  /**\n   * Check if the text displayer is enabled.\n   *\n   * @return {boolean}\n   * @export\n   */\n  isTextTrackVisible() {\n    const expected = this.isTextVisible_;\n\n    if (this.mediaSourceEngine_) {\n      // Make sure our values are still in-sync.\n      const actual = this.mediaSourceEngine_.getTextDisplayer().isTextVisible();\n      goog.asserts.assert(\n          actual == expected, 'text visibility has fallen out of sync');\n\n      // Always return the actual value so that the app has the most accurate\n      // information (in the case that the values come out of sync in prod).\n      return actual;\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      return textTracks.some((t) => t.mode == 'showing');\n    }\n\n    return expected;\n  }\n\n  /**\n   * Return a list of chapters tracks.\n   *\n   * @return {!Array.<shaka.extern.Track>}\n   * @export\n   */\n  getChaptersTracks() {\n    if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getChaptersTracks_();\n      const StreamUtils = shaka.util.StreamUtils;\n      return textTracks.map((text) => StreamUtils.html5TextTrackToTrack(text));\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * This returns the list of chapters.\n   *\n   * @param {string} language\n   * @return {!Array.<shaka.extern.Chapter>}\n   * @export\n   */\n  getChapters(language) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const inputlanguage = LanguageUtils.normalize(language);\n    const chaptersTracks = this.getChaptersTracks_();\n    const chaptersTracksWithLanguage = chaptersTracks\n        .filter((t) => LanguageUtils.normalize(t.language) == inputlanguage);\n    if (!chaptersTracksWithLanguage || !chaptersTracksWithLanguage.length) {\n      return [];\n    }\n    const chapters = [];\n    const uniqueChapters = new Set();\n    for (const chaptersTrack of chaptersTracksWithLanguage) {\n      if (chaptersTrack && chaptersTrack.cues) {\n        for (const cue of chaptersTrack.cues) {\n          let id = cue.id;\n          if (!id || id == '') {\n            id = cue.startTime + '-' + cue.endTime + '-' + cue.text;\n          }\n          /** @type {shaka.extern.Chapter} */\n          const chapter = {\n            id: id,\n            title: cue.text,\n            startTime: cue.startTime,\n            endTime: cue.endTime,\n          };\n          if (!uniqueChapters.has(id)) {\n            chapters.push(chapter);\n            uniqueChapters.add(id);\n          }\n        }\n      }\n    }\n    return chapters;\n  }\n\n  /**\n   * Ignore the TextTracks with the 'metadata' or 'chapters' kind, or the one\n   * generated by the SimpleTextDisplayer.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getFilteredTextTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind != 'metadata' && t.kind != 'chapters' &&\n                       t.label != shaka.Player.TextTrackLabel);\n  }\n\n  /**\n   * Get the TextTracks with the 'metadata' kind.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getMetadataTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind == 'metadata');\n  }\n\n  /**\n   * Get the TextTracks with the 'chapters' kind.\n   *\n   * @return {!Array.<TextTrack>}\n   * @private\n   */\n  getChaptersTracks_() {\n    goog.asserts.assert(this.video_.textTracks,\n        'TextTracks should be valid.');\n    return Array.from(this.video_.textTracks)\n        .filter((t) => t.kind == 'chapters');\n  }\n\n  /**\n   * Enable or disable the text displayer.  If the player is in an unloaded\n   * state, the request will be applied next time content is loaded.\n   *\n   * @param {boolean} isVisible\n   * @export\n   */\n  setTextTrackVisibility(isVisible) {\n    const oldVisibilty = this.isTextVisible_;\n    // Convert to boolean in case apps pass 0/1 instead false/true.\n    const newVisibility = !!isVisible;\n\n    if (oldVisibilty == newVisibility) {\n      return;\n    }\n\n    this.isTextVisible_ = newVisibility;\n\n    // Hold of on setting the text visibility until we have all the components\n    // we need. This ensures that they stay in-sync.\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      this.mediaSourceEngine_.getTextDisplayer()\n          .setTextVisibility(newVisibility);\n\n      // When the user wants to see captions, we stream captions. When the user\n      // doesn't want to see captions, we don't stream captions. This is to\n      // avoid bandwidth consumption by an unused resource. The app developer\n      // can override this and configure us to always stream captions.\n      if (!this.config_.streaming.alwaysStreamText) {\n        if (newVisibility) {\n          if (this.streamingEngine_.getCurrentTextStream()) {\n            // We already have a selected text stream.\n          } else {\n            // Find the text stream that best matches the user's preferences.\n            const streams =\n                shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n                    this.manifest_.textStreams,\n                    this.currentTextLanguage_,\n                    this.currentTextRole_,\n                    this.currentTextForced_);\n\n            // It is possible that there are no streams to play.\n            if (streams.length > 0) {\n              this.streamingEngine_.switchTextStream(streams[0]);\n              this.onTextChanged_();\n            }\n          }\n        } else {\n          this.streamingEngine_.unloadTextStream();\n        }\n      }\n    } else if (this.video_ && this.video_.src && this.video_.textTracks) {\n      const textTracks = this.getFilteredTextTracks_();\n      // Find the active track by looking for one which is not disabled.  This\n      // is the only way to identify the track which is currently displayed.\n      // Set it to 'showing' or 'hidden' based on newVisibility.\n      for (const textTrack of textTracks) {\n        if (textTrack.mode != 'disabled') {\n          textTrack.mode = newVisibility ? 'showing' : 'hidden';\n        }\n      }\n    }\n\n    // We need to fire the event after we have updated everything so that\n    // everything will be in a stable state when the app responds to the\n    // event.\n    this.onTextTrackVisibility_();\n  }\n\n  /**\n   * Get the current playhead position as a date. This should only be called\n   * when the player has loaded a live stream. If the player has not loaded a\n   * live stream, this will return <code>null</code>.\n   *\n   * @return {Date}\n   * @export\n   */\n  getPlayheadTimeAsDate() {\n    if (!this.isLive()) {\n      shaka.log.warning('getPlayheadTimeAsDate is for live streams!');\n      return null;\n    }\n\n    const walkerPayload = this.walker_.getCurrentPayload();\n\n    let presentationTime = 0;\n    if (this.playhead_) {\n      presentationTime = this.playhead_.getTime();\n    } else if (walkerPayload) {\n      if (walkerPayload.startTime == null) {\n        // A live stream with no requested start time and no playhead yet.  We\n        // would start at the live edge, but we don't have that yet, so return\n        // the current date & time.\n        return new Date();\n      } else {\n        // A specific start time has been requested.  This is what Playhead will\n        // use once it is created.\n        presentationTime = walkerPayload.startTime;\n      }\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n      const startTime = timeline.getPresentationStartTime();\n      return new Date(/* ms= */ (startTime + presentationTime) * 1000);\n    } else if (this.video_ && this.video_.getStartDate) {\n      // Apple's native HLS gives us getStartDate(), which is only available if\n      // EXT-X-PROGRAM-DATETIME is in the playlist.\n      const startDate = this.video_.getStartDate();\n      if (isNaN(startDate.getTime())) {\n        shaka.log.warning(\n            'EXT-X-PROGRAM-DATETIME required to get playhead time as Date!');\n        return null;\n      }\n      return new Date(startDate.getTime() + (presentationTime * 1000));\n    } else {\n      shaka.log.warning('No way to get playhead time as Date!');\n      return null;\n    }\n  }\n\n  /**\n   * Get the presentation start time as a date. This should only be called when\n   * the player has loaded a live stream. If the player has not loaded a live\n   * stream, this will return <code>null</code>.\n   *\n   * @return {Date}\n   * @export\n   */\n  getPresentationStartTimeAsDate() {\n    if (!this.isLive()) {\n      shaka.log.warning('getPresentationStartTimeAsDate is for live streams!');\n      return null;\n    }\n\n    if (this.manifest_) {\n      const timeline = this.manifest_.presentationTimeline;\n      const startTime = timeline.getPresentationStartTime();\n      goog.asserts.assert(startTime != null,\n          'Presentation start time should not be null!');\n      return new Date(/* ms= */ startTime * 1000);\n    } else if (this.video_ && this.video_.getStartDate) {\n      // Apple's native HLS gives us getStartDate(), which is only available if\n      // EXT-X-PROGRAM-DATETIME is in the playlist.\n      const startDate = this.video_.getStartDate();\n      if (isNaN(startDate.getTime())) {\n        shaka.log.warning(\n            'EXT-X-PROGRAM-DATETIME required to get presentation start time ' +\n            'as Date!');\n        return null;\n      }\n      return startDate;\n    } else {\n      shaka.log.warning('No way to get presentation start time as Date!');\n      return null;\n    }\n  }\n\n  /**\n   * Get information about what the player has buffered. If the player has not\n   * loaded content or is currently loading content, the buffered content will\n   * be empty.\n   *\n   * @return {shaka.extern.BufferedInfo}\n   * @export\n   */\n  getBufferedInfo() {\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      return this.mediaSourceEngine_.getBufferedInfo();\n    }\n\n    const info = {\n      total: [],\n      audio: [],\n      video: [],\n      text: [],\n    };\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      const TimeRangesUtils = shaka.media.TimeRangesUtils;\n      info.total = TimeRangesUtils.getBufferedInfo(this.video_.buffered);\n    }\n\n    return info;\n  }\n\n  /**\n   * Get statistics for the current playback session. If the player is not\n   * playing content, this will return an empty stats object.\n   *\n   * @return {shaka.extern.Stats}\n   * @export\n   */\n  getStats() {\n    // If the Player is not in a fully-loaded state, then return an empty stats\n    // blob so that this call will never fail.\n    const loaded = this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ||\n                   this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS;\n    if (!loaded) {\n      return shaka.util.Stats.getEmptyBlob();\n    }\n\n    this.updateStateHistory_();\n\n    goog.asserts.assert(this.video_, 'If we have stats, we should have video_');\n    const element = /** @type {!HTMLVideoElement} */ (this.video_);\n\n    const completionRatio = element.currentTime / element.duration;\n    if (!isNaN(completionRatio)) {\n      this.stats_.setCompletionPercent(Math.round(100 * completionRatio));\n    }\n\n    if (this.playhead_) {\n      this.stats_.setGapsJumped(this.playhead_.getGapsJumped());\n      this.stats_.setStallsDetected(this.playhead_.getStallsDetected());\n    }\n\n    if (element.getVideoPlaybackQuality) {\n      const info = element.getVideoPlaybackQuality();\n\n      this.stats_.setDroppedFrames(\n          Number(info.droppedVideoFrames),\n          Number(info.totalVideoFrames));\n      this.stats_.setCorruptedFrames(Number(info.corruptedVideoFrames));\n    }\n\n    const licenseSeconds =\n        this.drmEngine_ ? this.drmEngine_.getLicenseTime() : NaN;\n    this.stats_.setLicenseTime(licenseSeconds);\n\n    if (this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE) {\n      // Event through we are loaded, it is still possible that we don't have a\n      // variant yet because we set the load mode before we select the first\n      // variant to stream.\n      const variant = this.streamingEngine_.getCurrentVariant();\n\n      if (variant) {\n        const rate = this.playRateController_ ?\n           this.playRateController_.getRealRate() : 1;\n        const variantBandwidth = rate * variant.bandwidth;\n        // TODO: Should include text bandwidth if it enabled.\n        const currentStreamBandwidth = variantBandwidth;\n        this.stats_.setCurrentStreamBandwidth(currentStreamBandwidth);\n      }\n\n      if (variant && variant.video) {\n        this.stats_.setResolution(\n            /* width= */ variant.video.width || NaN,\n            /* height= */ variant.video.height || NaN);\n      }\n\n      if (this.isLive()) {\n        const now = this.getPresentationStartTimeAsDate().valueOf() +\n            this.seekRange().end * 1000;\n        const latency = (Date.now() - now) / 1000;\n        this.stats_.setLiveLatency(latency);\n      }\n\n      if (this.manifest_ && this.manifest_.presentationTimeline) {\n        const maxSegmentDuration =\n            this.manifest_.presentationTimeline.getMaxSegmentDuration();\n        this.stats_.setMaxSegmentDuration(maxSegmentDuration);\n      }\n\n      const estimate = this.abrManager_.getBandwidthEstimate();\n      this.stats_.setBandwidthEstimate(estimate);\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      this.stats_.setResolution(\n          /* width= */ element.videoWidth || NaN,\n          /* height= */ element.videoHeight || NaN);\n    }\n\n    return this.stats_.getBlob();\n  }\n\n  /**\n   * Adds the given text track to the loaded manifest.  <code>load()</code> must\n   * resolve before calling.  The presentation must have a duration.\n   *\n   * This returns the created track, which can immediately be selected by the\n   * application.  The track will not be automatically selected.\n   *\n   * @param {string} uri\n   * @param {string} language\n   * @param {string} kind\n   * @param {string=} mimeType\n   * @param {string=} codec\n   * @param {string=} label\n   * @param {boolean=} forced\n   * @return {!Promise.<shaka.extern.Track>}\n   * @export\n   */\n  async addTextTrackAsync(uri, language, kind, mimeType, codec, label,\n      forced = false) {\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE &&\n        this.loadMode_ != shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding text ' +\n          'tracks.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.CONTENT_NOT_LOADED);\n    }\n\n    if (!mimeType) {\n      mimeType = await this.getTextMimetype_(uri);\n    }\n\n    let adCuePoints = [];\n    if (this.adManager_) {\n      try {\n        adCuePoints = this.adManager_.getServerSideCuePoints();\n      } catch (error) {}\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      if (forced) {\n        // See: https://github.com/whatwg/html/issues/4472\n        kind = 'forced';\n      }\n      await this.addSrcTrackElement_(uri, language, kind, mimeType, label || '',\n          adCuePoints);\n      const textTracks = this.getTextTracks();\n      const srcTrack = textTracks.find((t) => {\n        return t.language == language &&\n            t.label == (label || '') &&\n            t.kind == kind;\n      });\n      if (srcTrack) {\n        this.onTracksChanged_();\n        return srcTrack;\n      }\n      // This should not happen, but there are browser implementations that may\n      // not support the Track element.\n      shaka.log.error('Cannot add this text when loaded with src=');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS);\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration == Infinity) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM);\n    }\n\n    if (adCuePoints.length) {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Need networking engine.');\n      const data = await this.getTextData_(uri,\n          this.networkingEngine_,\n          this.config_.streaming.retryParameters);\n      const vvtText = this.convertToWebVTT_(data, mimeType, adCuePoints);\n      const blob = new Blob([vvtText], {type: 'text/vtt'});\n      uri = shaka.media.MediaSourceEngine.createObjectURL(blob);\n      mimeType = 'text/vtt';\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.nextExternalStreamId_++,\n      originalId: null,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: shaka.media.SegmentIndex.forSingleSegment(\n          /* startTime= */ 0,\n          /* duration= */ duration,\n          /* uris= */ [uri]),\n      mimeType: mimeType || '',\n      codecs: codec || '',\n      kind: kind,\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: language,\n      label: label || null,\n      type: ContentType.TEXT,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      forced: !!forced,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n\n    const fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    const supported = shaka.text.TextEngine.isTypeSupported(fullMimeType);\n    if (!supported) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.MISSING_TEXT_PLUGIN,\n          mimeType);\n    }\n\n    this.manifest_.textStreams.push(stream);\n    this.onTracksChanged_();\n    return shaka.util.StreamUtils.textStreamToTrack(stream);\n  }\n\n  /**\n   * Adds the given thumbnails track to the loaded manifest.\n   * <code>load()</code> must resolve before calling.  The presentation must\n   * have a duration.\n   *\n   * This returns the created track, which can immediately be used by the\n   * application.\n   *\n   * @param {string} uri\n   * @param {string=} mimeType\n   * @return {!Promise.<shaka.extern.Track>}\n   * @export\n   */\n  async addThumbnailsTrack(uri, mimeType) {\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE &&\n        this.loadMode_ != shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding image ' +\n          'tracks.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.CONTENT_NOT_LOADED);\n    }\n\n    if (this.loadMode_ == shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error('Cannot add this thumbnail track when loaded with src=');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_SRC_EQUALS);\n    }\n\n    if (!mimeType) {\n      mimeType = await this.getTextMimetype_(uri);\n    }\n\n    if (mimeType != 'text/vtt') {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.UNSUPPORTED_EXTERNAL_THUMBNAILS_URI,\n          uri);\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration == Infinity) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_LIVE_STREAM);\n    }\n\n    goog.asserts.assert(\n        this.networkingEngine_, 'Need networking engine.');\n    const buffer = await this.getTextData_(uri,\n        this.networkingEngine_,\n        this.config_.streaming.retryParameters);\n\n    const factory = shaka.text.TextEngine.findParser(mimeType);\n    if (!factory) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.MISSING_TEXT_PLUGIN,\n          mimeType);\n    }\n    const TextParser = factory();\n    const time = {\n      periodStart: 0,\n      segmentStart: 0,\n      segmentEnd: duration,\n      vttOffset: 0,\n    };\n    const data = shaka.util.BufferUtils.toUint8(buffer);\n    const cues = TextParser.parseMedia(data, time);\n\n    const references = [];\n    for (const cue of cues) {\n      const imageUri = shaka.util.ManifestParserUtils.resolveUris(\n          [uri], [cue.payload])[0];\n      const reference = new shaka.media.SegmentReference(\n          cue.startTime,\n          cue.endTime,\n          () => [imageUri],\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          /* initSegmentReference= */ null,\n          /* timestampOffset= */ 0,\n          /* appendWindowStart= */ 0,\n          /* appendWindowEnd= */ Infinity,\n      );\n      if (imageUri.includes('#xywh')) {\n        const spriteInfo = imageUri.split('#xywh=')[1].split(',');\n        if (spriteInfo.length === 4) {\n          reference.setThumbnailSprite({\n            height: parseInt(spriteInfo[3], 10),\n            positionX: parseInt(spriteInfo[0], 10),\n            positionY: parseInt(spriteInfo[1], 10),\n            width: parseInt(spriteInfo[2], 10),\n          });\n        }\n      }\n      references.push(reference);\n    }\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.nextExternalStreamId_++,\n      originalId: null,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: new shaka.media.SegmentIndex(references),\n      mimeType: mimeType || '',\n      codecs: '',\n      kind: '',\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: 'und',\n      label: null,\n      type: ContentType.IMAGE,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      forced: false,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n      tilesLayout: '1x1',\n    };\n\n    this.manifest_.imageStreams.push(stream);\n    this.onTracksChanged_();\n    return shaka.util.StreamUtils.imageStreamToTrack(stream);\n  }\n\n  /**\n   * Adds the given chapters track to the loaded manifest.  <code>load()</code>\n   * must resolve before calling.  The presentation must have a duration.\n   *\n   * This returns the created track.\n   *\n   * @param {string} uri\n   * @param {string} language\n   * @param {string=} mimeType\n   * @return {!Promise.<shaka.extern.Track>}\n   * @export\n   */\n  async addChaptersTrack(uri, language, mimeType) {\n    if (this.loadMode_ != shaka.Player.LoadMode.MEDIA_SOURCE &&\n        this.loadMode_ != shaka.Player.LoadMode.SRC_EQUALS) {\n      shaka.log.error(\n          'Must call load() and wait for it to resolve before adding ' +\n          'chapters tracks.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.CONTENT_NOT_LOADED);\n    }\n\n    if (!mimeType) {\n      mimeType = await this.getTextMimetype_(uri);\n    }\n\n    let adCuePoints = [];\n    if (this.adManager_) {\n      try {\n        adCuePoints = this.adManager_.getServerSideCuePoints();\n      } catch (error) {}\n    }\n\n    /** @type {!HTMLTrackElement} */\n    const trackElement = await this.addSrcTrackElement_(\n        uri, language, /* kind= */ 'chapters', mimeType, /* label= */ '',\n        adCuePoints);\n\n    const chaptersTracks = this.getChaptersTracks();\n    const chaptersTrack = chaptersTracks.find((t) => {\n      return t.language == language;\n    });\n\n    if (chaptersTrack) {\n      await new Promise((resolve, reject) => {\n        // The chapter data isn't available until the 'load' event fires, and\n        // that won't happen until the chapters track is activated by the\n        // activateChaptersTrack_ method.\n        this.loadEventManager_.listenOnce(trackElement, 'load', resolve);\n        this.loadEventManager_.listenOnce(trackElement, 'error', (event) => {\n          reject(new shaka.util.Error(\n              shaka.util.Error.Severity.RECOVERABLE,\n              shaka.util.Error.Category.TEXT,\n              shaka.util.Error.Code.CHAPTERS_TRACK_FAILED));\n        });\n      });\n\n      return chaptersTrack;\n    }\n\n    // This should not happen, but there are browser implementations that may\n    // not support the Track element.\n    shaka.log.error('Cannot add this text when loaded with src=');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS);\n  }\n\n  /**\n   * @param {string} uri\n   * @return {!Promise.<string>}\n   * @private\n   */\n  async getTextMimetype_(uri) {\n    // Try using the uri extension.\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    let mimeType = shaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_[extension];\n\n    if (mimeType) {\n      return mimeType;\n    }\n\n    try {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Need networking engine.');\n      // eslint-disable-next-line require-atomic-updates\n      mimeType = await shaka.media.ManifestParser.getMimeType(uri,\n          this.networkingEngine_,\n          this.config_.streaming.retryParameters);\n    } catch (error) {}\n\n    if (mimeType) {\n      return mimeType;\n    }\n\n    shaka.log.error(\n        'The mimeType has not been provided and it could not be deduced ' +\n        'from its extension.');\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.RECOVERABLE,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.TEXT_COULD_NOT_GUESS_MIME_TYPE,\n        extension);\n  }\n\n  /**\n   * @param {string} uri\n   * @param {string} language\n   * @param {string} kind\n   * @param {string} mimeType\n   * @param {string} label\n   * @param {!Array.<!shaka.extern.AdCuePoint>} adCuePoints\n   * @return {!Promise.<!HTMLTrackElement>}\n   * @private\n   */\n  async addSrcTrackElement_(uri, language, kind, mimeType, label,\n      adCuePoints) {\n    if (mimeType != 'text/vtt' || adCuePoints.length) {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Need networking engine.');\n      const data = await this.getTextData_(uri,\n          this.networkingEngine_,\n          this.config_.streaming.retryParameters);\n      const vvtText = this.convertToWebVTT_(data, mimeType, adCuePoints);\n      const blob = new Blob([vvtText], {type: 'text/vtt'});\n      uri = shaka.media.MediaSourceEngine.createObjectURL(blob);\n      mimeType = 'text/vtt';\n    }\n\n    const trackElement =\n      /** @type {!HTMLTrackElement} */(document.createElement('track'));\n    trackElement.src = this.cmcdManager_.appendTextTrackData(uri);\n    trackElement.label = label;\n    trackElement.kind = kind;\n    trackElement.srclang = language;\n\n    // Because we're pulling in the text track file via Javascript, the\n    // same-origin policy applies. If you'd like to have a player served\n    // from one domain, but the text track served from another, you'll\n    // need to enable CORS in order to do so. In addition to enabling CORS\n    // on the server serving the text tracks, you will need to add the\n    // crossorigin attribute to the video element itself.\n    if (!this.video_.getAttribute('crossorigin')) {\n      this.video_.setAttribute('crossorigin', 'anonymous');\n    }\n\n    this.video_.appendChild(trackElement);\n    return trackElement;\n  }\n\n  /**\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async getTextData_(uri, netEngine, retryParams) {\n    const type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.net.NetworkingEngine.makeRequest([uri], retryParams);\n    request.method = 'GET';\n\n    this.cmcdManager_.applyTextData(request);\n\n    const response = await netEngine.request(type, request).promise;\n\n    return response.data;\n  }\n\n\n  /**\n   * Converts an input string to a WebVTT format string.\n   *\n   * @param {BufferSource} buffer\n   * @param {string} mimeType\n   * @param {!Array.<!shaka.extern.AdCuePoint>} adCuePoints\n   * @return {string}\n   * @private\n   */\n  convertToWebVTT_(buffer, mimeType, adCuePoints) {\n    const factory = shaka.text.TextEngine.findParser(mimeType);\n    if (factory) {\n      const obj = factory();\n      const time = {\n        periodStart: 0,\n        segmentStart: 0,\n        segmentEnd: this.video_.duration,\n        vttOffset: 0,\n      };\n      const data = shaka.util.BufferUtils.toUint8(buffer);\n      const cues = obj.parseMedia(data, time);\n      return shaka.text.WebVttGenerator.convert(cues, adCuePoints);\n    }\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.TEXT,\n        shaka.util.Error.Code.MISSING_TEXT_PLUGIN,\n        mimeType);\n  }\n\n  /**\n   * Set the maximum resolution that the platform's hardware can handle.\n   * This will be called automatically by <code>shaka.cast.CastReceiver</code>\n   * to enforce limitations of the Chromecast hardware.\n   *\n   * @param {number} width\n   * @param {number} height\n   * @export\n   */\n  setMaxHardwareResolution(width, height) {\n    this.maxHwRes_.width = width;\n    this.maxHwRes_.height = height;\n  }\n\n  /**\n   * Retry streaming after a streaming failure has occurred. When the player has\n   * not loaded content or is loading content, this will be a no-op and will\n   * return <code>false</code>.\n   *\n   * <p>\n   * If the player has loaded content, and streaming has not seen an error, this\n   * will return <code>false</code>.\n   *\n   * <p>\n   * If the player has loaded content, and streaming seen an error, but the\n   * could not resume streaming, this will return <code>false</code>.\n   *\n   * @param {number=} retryDelaySeconds\n   * @return {boolean}\n   * @export\n   */\n  retryStreaming(retryDelaySeconds = 0.1) {\n    return this.loadMode_ == shaka.Player.LoadMode.MEDIA_SOURCE ?\n           this.streamingEngine_.retry(retryDelaySeconds) :\n           false;\n  }\n\n  /**\n   * Get the manifest that the player has loaded. If the player has not loaded\n   * any content, this will return <code>null</code>.\n   *\n   * NOTE: This structure is NOT covered by semantic versioning compatibility\n   * guarantees.  It may change at any time!\n   *\n   * This is marked as deprecated to warn Closure Compiler users at compile-time\n   * to avoid using this method.\n   *\n   * @return {?shaka.extern.Manifest}\n   * @export\n   * @deprecated\n   */\n  getManifest() {\n    shaka.log.alwaysWarn(\n        'Shaka Player\\'s internal Manifest structure is NOT covered by ' +\n        'semantic versioning compatibility guarantees.  It may change at any ' +\n        'time!  Please consider filing a feature request for whatever you ' +\n        'use getManifest() for.');\n    return this.manifest_;\n  }\n\n  /**\n   * Get the type of manifest parser that the player is using. If the player has\n   * not loaded any content, this will return <code>null</code>.\n   *\n   * @return {?shaka.extern.ManifestParser.Factory}\n   * @export\n   */\n  getManifestParserFactory() {\n    return this.parserFactory_;\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean} fromAdaptation\n   * @private\n   */\n  addVariantToSwitchHistory_(variant, fromAdaptation) {\n    const switchHistory = this.stats_.getSwitchHistory();\n    switchHistory.updateCurrentVariant(variant, fromAdaptation);\n  }\n\n  /**\n   * @param {shaka.extern.Stream} textStream\n   * @param {boolean} fromAdaptation\n   * @private\n   */\n  addTextStreamToSwitchHistory_(textStream, fromAdaptation) {\n    const switchHistory = this.stats_.getSwitchHistory();\n    switchHistory.updateCurrentText(textStream, fromAdaptation);\n  }\n\n  /**\n   * @return {shaka.extern.PlayerConfiguration}\n   * @private\n   */\n  defaultConfig_() {\n    const config = shaka.util.PlayerConfiguration.createDefault();\n\n    config.streaming.failureCallback = (error) => {\n      this.defaultStreamingFailureCallback_(error);\n    };\n\n    // Because this.video_ may not be set when the config is built, the default\n    // TextDisplay factory must capture a reference to \"this\".\n    config.textDisplayFactory = () => {\n      if (this.videoContainer_) {\n        return new shaka.text.UITextDisplayer(\n            this.video_, this.videoContainer_);\n      } else {\n        return new shaka.text.SimpleTextDisplayer(this.video_);\n      }\n    };\n    return config;\n  }\n\n  /**\n   * Set the videoContainer to construct UITextDisplayer.\n   * @param {HTMLElement} videoContainer\n   * @export\n   */\n  setVideoContainer(videoContainer) {\n    this.videoContainer_ = videoContainer;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  defaultStreamingFailureCallback_(error) {\n    // For live streams, we retry streaming automatically for certain errors.\n    // For VOD streams, all streaming failures are fatal.\n    if (!this.isLive()) {\n      return;\n    }\n\n    let retryDelaySeconds = null;\n    if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS ||\n        error.code == shaka.util.Error.Code.HTTP_ERROR) {\n      // These errors can be near-instant, so delay a bit before retrying.\n      retryDelaySeconds = 1;\n    } else if (error.code == shaka.util.Error.Code.TIMEOUT) {\n      // We already waited for a timeout, so retry quickly.\n      retryDelaySeconds = 0.1;\n    }\n\n    if (retryDelaySeconds != null) {\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n      shaka.log.warning('Live streaming error.  Retrying automatically...');\n      this.retryStreaming(retryDelaySeconds);\n    }\n  }\n\n  /**\n   * For CEA closed captions embedded in the video streams, create dummy text\n   * stream.  This can be safely called again on existing manifests, for\n   * manifest updates.\n   * @param {!shaka.extern.Manifest} manifest\n   * @private\n   */\n  makeTextStreamsForClosedCaptions_(manifest) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const TextStreamKind = shaka.util.ManifestParserUtils.TextStreamKind;\n    const CEA608_MIME = shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE;\n    const CEA708_MIME = shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE;\n\n    // A set, to make sure we don't create two text streams for the same video.\n    const closedCaptionsSet = new Set();\n    for (const textStream of manifest.textStreams) {\n      if (textStream.mimeType == CEA608_MIME ||\n          textStream.mimeType == CEA708_MIME) {\n        // This function might be called on a manifest update, so don't make a\n        // new text stream for closed caption streams we have seen before.\n        closedCaptionsSet.add(textStream.originalId);\n      }\n    }\n    for (const variant of manifest.variants) {\n      const video = variant.video;\n      if (video && video.closedCaptions) {\n        for (const id of video.closedCaptions.keys()) {\n          if (!closedCaptionsSet.has(id)) {\n            const mimeType = id.startsWith('CC') ? CEA608_MIME : CEA708_MIME;\n\n            // Add an empty segmentIndex, for the benefit of the period combiner\n            // in our builtin DASH parser.\n            const segmentIndex = new shaka.media.MetaSegmentIndex();\n            const textStream = {\n              id: this.nextExternalStreamId_++,  // A globally unique ID.\n              originalId: id, // The CC ID string, like 'CC1', 'CC3', etc.\n              createSegmentIndex: () => Promise.resolve(),\n              segmentIndex,\n              mimeType,\n              codecs: '',\n              kind: TextStreamKind.CLOSED_CAPTION,\n              encrypted: false,\n              drmInfos: [],\n              keyIds: new Set(),\n              language: video.closedCaptions.get(id),\n              label: null,\n              type: ContentType.TEXT,\n              primary: false,\n              trickModeVideo: null,\n              emsgSchemeIdUris: null,\n              roles: video.roles,\n              forced: false,\n              channelsCount: null,\n              audioSamplingRate: null,\n              spatialAudio: false,\n              closedCaptions: null,\n            };\n            manifest.textStreams.push(textStream);\n            closedCaptionsSet.add(id);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Filters a manifest, removing unplayable streams/variants.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  async filterManifest_(manifest) {\n    await this.filterManifestWithStreamUtils_(manifest);\n    this.filterManifestWithRestrictions_(manifest);\n  }\n\n  /**\n   * Filters a manifest, removing unplayable streams/variants.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  async filterManifestWithStreamUtils_(manifest) {\n    goog.asserts.assert(manifest, 'Manifest should exist!');\n    goog.asserts.assert(this.video_, 'Must not be destroyed');\n\n    /** @type {?shaka.extern.Variant} */\n    const currentVariant = this.streamingEngine_ ?\n        this.streamingEngine_.getCurrentVariant() : null;\n\n    await shaka.util.StreamUtils.filterManifest(\n        this.drmEngine_, currentVariant, manifest);\n    this.checkPlayableVariants_(manifest);\n  }\n\n\n  /**\n   * Apply the restrictions configuration to the manifest, and check if there's\n   * a variant that meets the restrictions.\n   *\n   * @param {?shaka.extern.Manifest} manifest\n   * @private\n   */\n  filterManifestWithRestrictions_(manifest) {\n    // Return if |destroy| is called.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n    const tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n        manifest.variants, this.config_.restrictions, this.maxHwRes_);\n    if (tracksChanged && this.streamingEngine_) {\n      this.onTracksChanged_();\n    }\n\n    // We may need to create new sessions for any new init data.\n    const currentDrmInfo =\n        this.drmEngine_ ? this.drmEngine_.getDrmInfo() : null;\n    // DrmEngine.newInitData() requires mediaKeys to be available.\n    if (currentDrmInfo && this.drmEngine_.getMediaKeys()) {\n      for (const variant of manifest.variants) {\n        this.processDrmInfos_(currentDrmInfo.keySystem, variant.video);\n        this.processDrmInfos_(currentDrmInfo.keySystem, variant.audio);\n      }\n    }\n    this.checkRestrictedVariants_(manifest);\n  }\n\n  /**\n   * @param {string} keySystem\n   * @param {?shaka.extern.Stream} stream\n   * @private\n   */\n  processDrmInfos_(keySystem, stream) {\n    if (!stream) {\n      return;\n    }\n\n    for (const drmInfo of stream.drmInfos) {\n      // Ignore any data for different key systems.\n      if (drmInfo.keySystem == keySystem) {\n        for (const initData of (drmInfo.initData || [])) {\n          this.drmEngine_.newInitData(\n              initData.initDataType, initData.initData);\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  filterManifestByCurrentVariant_() {\n    goog.asserts.assert(this.manifest_, 'Manifest should be valid');\n    goog.asserts.assert(this.streamingEngine_,\n        'StreamingEngine should be valid');\n\n    const currentVariant = this.streamingEngine_ ?\n        this.streamingEngine_.getCurrentVariant() : null;\n    shaka.util.StreamUtils.filterManifestByCurrentVariant(currentVariant,\n        this.manifest_);\n    this.checkPlayableVariants_(this.manifest_);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} initialVariant\n   * @param {number} time\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async adjustStartTime_(initialVariant, time) {\n    /** @type {?shaka.extern.Stream} */\n    const activeAudio = initialVariant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const activeVideo = initialVariant.video;\n\n    /**\n     * @param {?shaka.extern.Stream} stream\n     * @param {number} time\n     * @return {!Promise.<?number>}\n     */\n    const getAdjustedTime = async (stream, time) => {\n      if (!stream) {\n        return null;\n      }\n\n      await stream.createSegmentIndex();\n      const iter = stream.segmentIndex.getIteratorForTime(time);\n      const ref = iter ? iter.next().value : null;\n      if (!ref) {\n        return null;\n      }\n\n      const refTime = ref.startTime;\n      goog.asserts.assert(refTime <= time,\n          'Segment should start before target time!');\n      return refTime;\n    };\n\n    const audioStartTime = await getAdjustedTime(activeAudio, time);\n    const videoStartTime = await getAdjustedTime(activeVideo, time);\n\n    // If we have both video and audio times, pick the larger one.  If we picked\n    // the smaller one, that one will download an entire segment to buffer the\n    // difference.\n    if (videoStartTime != null && audioStartTime != null) {\n      return Math.max(videoStartTime, audioStartTime);\n    } else if (videoStartTime != null) {\n      return videoStartTime;\n    } else if (audioStartTime != null) {\n      return audioStartTime;\n    } else {\n      return time;\n    }\n  }\n\n  /**\n   * Update the buffering state to be either \"we are buffering\" or \"we are not\n   * buffering\", firing events to the app as needed.\n   *\n   * @private\n   */\n  updateBufferState_() {\n    const isBuffering = this.isBuffering();\n    shaka.log.v2('Player changing buffering state to', isBuffering);\n\n    // Make sure we have all the components we need before we consider ourselves\n    // as being loaded.\n    // TODO: Make the check for \"loaded\" simpler.\n    const loaded = this.stats_ && this.bufferObserver_ && this.playhead_;\n\n    if (loaded) {\n      this.playRateController_.setBuffering(isBuffering);\n      if (this.cmcdManager_) {\n        this.cmcdManager_.setBuffering(isBuffering);\n      }\n      this.updateStateHistory_();\n    }\n\n    // Surface the buffering event so that the app knows if/when we are\n    // buffering.\n    const eventName = shaka.util.FakeEvent.EventName.Buffering;\n    const data = (new Map()).set('buffering', isBuffering);\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * A callback for when the playback rate changes. We need to watch the\n   * playback rate so that if the playback rate on the media element changes\n   * (that was not caused by our play rate controller) we can notify the\n   * controller so that it can stay in-sync with the change.\n   *\n   * @private\n   */\n  onRateChange_() {\n    /** @type {number} */\n    const newRate = this.video_.playbackRate;\n\n    // On Edge, when someone seeks using the native controls, it will set the\n    // playback rate to zero until they finish seeking, after which it will\n    // return the playback rate.\n    //\n    // If the playback rate changes while seeking, Edge will cache the playback\n    // rate and use it after seeking.\n    //\n    // https://github.com/shaka-project/shaka-player/issues/951\n    if (newRate == 0) {\n      return;\n    }\n\n    if (this.playRateController_) {\n      // The playback rate has changed. This could be us or someone else.\n      // If this was us, setting the rate again will be a no-op.\n      this.playRateController_.set(newRate);\n    }\n\n    const event = this.makeEvent_(shaka.util.FakeEvent.EventName.RateChange);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Try updating the state history. If the player has not finished\n   * initializing, this will be a no-op.\n   *\n   * @private\n   */\n  updateStateHistory_() {\n    // If we have not finish initializing, this will be a no-op.\n    if (!this.stats_) {\n      return;\n    }\n    if (!this.bufferObserver_) {\n      return;\n    }\n\n    const State = shaka.media.BufferingObserver.State;\n\n    const history = this.stats_.getStateHistory();\n\n    if (this.bufferObserver_.getState() == State.STARVING) {\n      history.update('buffering');\n    } else if (this.video_.paused) {\n      history.update('paused');\n    } else if (this.video_.ended) {\n      history.update('ended');\n    } else {\n      history.update('playing');\n    }\n  }\n\n  /**\n   * Callback from Playhead.\n   *\n   * @private\n   */\n  onSeek_() {\n    if (this.playheadObservers_) {\n      this.playheadObservers_.notifyOfSeek();\n    }\n    if (this.streamingEngine_) {\n      this.streamingEngine_.seeked();\n    }\n    if (this.bufferObserver_) {\n      // If we seek into an unbuffered range, we should fire a 'buffering' event\n      // immediately.  If StreamingEngine can buffer fast enough, we may not\n      // update our buffering tracking otherwise.\n      this.pollBufferState_();\n    }\n  }\n\n  /**\n   * Update AbrManager with variants while taking into account restrictions,\n   * preferences, and ABR.\n   *\n   * On error, this dispatches an error event and returns false.\n   *\n   * @return {boolean} True if successful.\n   * @private\n   */\n  updateAbrManagerVariants_() {\n    try {\n      goog.asserts.assert(this.manifest_, 'Manifest should exist by now!');\n      this.checkRestrictedVariants_(this.manifest_);\n    } catch (e) {\n      this.onError_(e);\n      return false;\n    }\n\n    const playableVariants = this.manifest_.variants.filter((variant) => {\n      return shaka.util.StreamUtils.isPlayable(variant);\n    });\n\n    // Update the abr manager with newly filtered variants.\n    const adaptationSet = this.currentAdaptationSetCriteria_.create(\n        playableVariants);\n    this.abrManager_.setVariants(Array.from(adaptationSet.values()));\n    return true;\n  }\n\n  /**\n   * Chooses a variant from all possible variants while taking into account\n   * restrictions, preferences, and ABR.\n   *\n   * On error, this dispatches an error event and returns null.\n   *\n   * @return {?shaka.extern.Variant}\n   * @private\n   */\n  chooseVariant_() {\n    if (this.updateAbrManagerVariants_()) {\n      return this.abrManager_.chooseVariant();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Re-apply restrictions to the variants, to re-enable variants that were\n   * temporarily disabled due to network errors.\n   * If any variants are enabled this way, a new variant might be chosen for\n   * playback.\n   * @private\n   */\n  checkVariants_() {\n    const tracksChanged = shaka.util.StreamUtils.applyRestrictions(\n        this.manifest_.variants, this.config_.restrictions, this.maxHwRes_);\n    if (tracksChanged) {\n      this.chooseVariant_();\n    }\n  }\n\n  /**\n   * Choose a text stream from all possible text streams while taking into\n   * account user preference.\n   *\n   * @return {?shaka.extern.Stream}\n   * @private\n   */\n  chooseTextStream_() {\n    const subset = shaka.util.StreamUtils.filterStreamsByLanguageAndRole(\n        this.manifest_.textStreams,\n        this.currentTextLanguage_,\n        this.currentTextRole_,\n        this.currentTextForced_);\n    return subset[0] || null;\n  }\n\n  /**\n   * Chooses a new Variant.  If the new variant differs from the old one, it\n   * adds the new one to the switch history and switches to it.\n   *\n   * Called after a config change, a key status event, or an explicit language\n   * change.\n   *\n   * @private\n   */\n  chooseVariantAndSwitch_() {\n    goog.asserts.assert(this.config_, 'Must not be destroyed');\n\n    // Because we're running this after a config change (manual language\n    // change) or a key status event, it is always okay to clear the buffer\n    // here.\n    const chosenVariant = this.chooseVariant_();\n    if (chosenVariant) {\n      this.switchVariant_(chosenVariant, /* fromAdaptation= */ true,\n          /* clearBuffers= */ true, /* safeMargin= */ 0);\n    }\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean} fromAdaptation\n   * @param {boolean} clearBuffer\n   * @param {number} safeMargin\n   * @private\n   */\n  switchVariant_(variant, fromAdaptation, clearBuffer, safeMargin) {\n    const currentVariant = this.streamingEngine_.getCurrentVariant();\n    if (variant == currentVariant) {\n      shaka.log.debug('Variant already selected.');\n      // If you want to clear the buffer, we force to reselect the same variant.\n      // We don't need to reset the timestampOffset since it's the same variant,\n      // so 'adaptation' isn't passed here.\n      if (clearBuffer) {\n        this.streamingEngine_.switchVariant(variant, clearBuffer, safeMargin,\n            /* force= */ true);\n      }\n      return;\n    }\n\n    // Add entries to the history.\n    this.addVariantToSwitchHistory_(variant, fromAdaptation);\n    this.streamingEngine_.switchVariant(\n        variant, clearBuffer, safeMargin, /* force= */ undefined,\n        /* adaptation= */ fromAdaptation);\n    let oldTrack = null;\n    if (currentVariant) {\n      oldTrack = shaka.util.StreamUtils.variantToTrack(currentVariant);\n    }\n    const newTrack = shaka.util.StreamUtils.variantToTrack(variant);\n\n    if (fromAdaptation) {\n      // Dispatch an 'adaptation' event\n      this.onAdaptation_(oldTrack, newTrack);\n    } else {\n      // Dispatch a 'variantchanged' event\n      this.onVariantChanged_(oldTrack, newTrack);\n    }\n  }\n\n  /**\n   * @param {AudioTrack} track\n   * @private\n   */\n  switchHtml5Track_(track) {\n    goog.asserts.assert(this.video_ && this.video_.audioTracks,\n        'Video and video.audioTracks should not be null!');\n    const audioTracks = Array.from(this.video_.audioTracks);\n    const currentTrack = audioTracks.find((t) => t.enabled);\n\n    // This will reset the \"enabled\" of other tracks to false.\n    track.enabled = true;\n\n    // AirPlay does not reset the \"enabled\" of other tracks to false, so\n    // it must be changed by hand.\n    if (track.id !== currentTrack.id) {\n      currentTrack.enabled = false;\n    }\n\n    const oldTrack =\n      shaka.util.StreamUtils.html5AudioTrackToTrack(currentTrack);\n    const newTrack =\n      shaka.util.StreamUtils.html5AudioTrackToTrack(track);\n    this.onVariantChanged_(oldTrack, newTrack);\n  }\n\n  /**\n   * Decide during startup if text should be streamed/shown.\n   * @private\n   */\n  setInitialTextState_(initialVariant, initialTextStream) {\n    // Check if we should show text (based on difference between audio and text\n    // languages).\n    if (initialTextStream) {\n      if (initialVariant.audio && this.shouldInitiallyShowText_(\n          initialVariant.audio, initialTextStream)) {\n        this.isTextVisible_ = true;\n      }\n      if (this.isTextVisible_) {\n        // If the cached value says to show text, then update the text displayer\n        // since it defaults to not shown.\n        this.mediaSourceEngine_.getTextDisplayer().setTextVisibility(true);\n        goog.asserts.assert(this.shouldStreamText_(),\n            'Should be streaming text');\n      }\n      this.onTextTrackVisibility_();\n    } else {\n      this.isTextVisible_ = false;\n    }\n  }\n\n  /**\n   * Check if we should show text on screen automatically.\n   *\n   * @param {shaka.extern.Stream} audioStream\n   * @param {shaka.extern.Stream} textStream\n   * @return {boolean}\n   * @private\n   */\n  shouldInitiallyShowText_(audioStream, textStream) {\n    const AutoShowText = shaka.config.AutoShowText;\n\n    if (this.config_.autoShowText == AutoShowText.NEVER) {\n      return false;\n    }\n    if (this.config_.autoShowText == AutoShowText.ALWAYS) {\n      return true;\n    }\n\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredTextLocale =\n        LanguageUtils.normalize(this.config_.preferredTextLanguage);\n    /** @type {string} */\n    const textLocale = LanguageUtils.normalize(textStream.language);\n\n    if (this.config_.autoShowText == AutoShowText.IF_PREFERRED_TEXT_LANGUAGE) {\n      // Only the text language match matters.\n      return LanguageUtils.areLanguageCompatible(\n          textLocale,\n          preferredTextLocale);\n    }\n\n    if (this.config_.autoShowText == AutoShowText.IF_SUBTITLES_MAY_BE_NEEDED) {\n      /* The text should automatically be shown if the text is\n       * language-compatible with the user's text language preference, but not\n       * compatible with the audio.  These are cases where we deduce that\n       * subtitles may be needed.\n       *\n       * For example:\n       *   preferred | chosen | chosen |\n       *   text      | text   | audio  | show\n       *   -----------------------------------\n       *   en-CA     | en     | jp     | true\n       *   en        | en-US  | fr     | true\n       *   fr-CA     | en-US  | jp     | false\n       *   en-CA     | en-US  | en-US  | false\n       *\n       */\n      /** @type {string} */\n      const audioLocale = LanguageUtils.normalize(audioStream.language);\n\n      return (\n        LanguageUtils.areLanguageCompatible(textLocale, preferredTextLocale) &&\n        !LanguageUtils.areLanguageCompatible(audioLocale, textLocale));\n    }\n\n    shaka.log.alwaysWarn('Invalid autoShowText setting!');\n    return false;\n  }\n\n  /**\n   * Callback from StreamingEngine.\n   *\n   * @private\n   */\n  onManifestUpdate_() {\n    if (this.parser_ && this.parser_.update) {\n      this.parser_.update();\n    }\n  }\n\n  /**\n   * Callback from StreamingEngine.\n   *\n   * @private\n   */\n  onSegmentAppended_(start, end, contentType) {\n    // When we append a segment to media source (via streaming engine) we are\n    // changing what data we have buffered, so notify the playhead of the\n    // change.\n    if (this.playhead_) {\n      this.playhead_.notifyOfBufferingChange();\n    }\n    this.pollBufferState_();\n\n    // Dispatch an event for users to consume, too.\n    const data = new Map()\n        .set('start', start)\n        .set('end', end)\n        .set('contentType', contentType);\n    this.dispatchEvent(this.makeEvent_(\n        shaka.util.FakeEvent.EventName.SegmentAppended, data));\n  }\n\n  /**\n   * Callback from AbrManager.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin Optional amount of buffer (in seconds) to\n   *   retain when clearing the buffer.\n   *   Defaults to 0 if not provided. Ignored if clearBuffer is false.\n   * @private\n   */\n  switch_(variant, clearBuffer = false, safeMargin = 0) {\n    shaka.log.debug('switch_');\n    goog.asserts.assert(this.config_.abr.enabled,\n        'AbrManager should not call switch while disabled!');\n    goog.asserts.assert(this.manifest_, 'We need a manifest to switch ' +\n                                        'variants.');\n\n    if (!this.streamingEngine_) {\n      // There's no way to change it.\n      return;\n    }\n\n    if (variant == this.streamingEngine_.getCurrentVariant()) {\n      // This isn't a change.\n      return;\n    }\n\n    this.switchVariant_(variant, /* fromAdaptation= */ true,\n        clearBuffer, safeMargin);\n  }\n\n  /**\n   * Dispatches an 'adaptation' event.\n   * @param {?shaka.extern.Track} from\n   * @param {shaka.extern.Track} to\n   * @private\n   */\n  onAdaptation_(from, to) {\n    // Delay the 'adaptation' event so that StreamingEngine has time to absorb\n    // the changes before the user tries to query it.\n    const data = new Map()\n        .set('oldTrack', from)\n        .set('newTrack', to);\n    if (this.lcevcDil_) {\n      this.lcevcDil_.updateVariant(to);\n    }\n    const event =\n        this.makeEvent_(shaka.util.FakeEvent.EventName.Adaptation, data);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'trackschanged' event.\n   * @private\n   */\n  onTracksChanged_() {\n    // Delay the 'trackschanged' event so StreamingEngine has time to absorb the\n    // changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.util.FakeEvent.EventName.TracksChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'variantchanged' event.\n   * @param {?shaka.extern.Track} from\n   * @param {shaka.extern.Track} to\n   * @private\n   */\n  onVariantChanged_(from, to) {\n    // Delay the 'variantchanged' event so StreamingEngine has time to absorb\n    // the changes before the user tries to query it.\n    const data = new Map()\n        .set('oldTrack', from)\n        .set('newTrack', to);\n    if (this.lcevcDil_) {\n      this.lcevcDil_.updateVariant(to);\n    }\n\n    const event =\n        this.makeEvent_(shaka.util.FakeEvent.EventName.VariantChanged, data);\n    this.delayDispatchEvent_(event);\n  }\n\n  /**\n   * Dispatches a 'textchanged' event.\n   * @private\n   */\n  onTextChanged_() {\n    // Delay the 'textchanged' event so StreamingEngine time to absorb the\n    // changes before the user tries to query it.\n    const event = this.makeEvent_(shaka.util.FakeEvent.EventName.TextChanged);\n    this.delayDispatchEvent_(event);\n  }\n\n  /** @private */\n  onTextTrackVisibility_() {\n    const event =\n        this.makeEvent_(shaka.util.FakeEvent.EventName.TextTrackVisibility);\n    this.delayDispatchEvent_(event);\n  }\n\n  /** @private */\n  onAbrStatusChanged_() {\n    const data = (new Map()).set('newStatus', this.config_.abr.enabled);\n    this.delayDispatchEvent_(this.makeEvent_(\n        shaka.util.FakeEvent.EventName.AbrStatusChanged, data));\n  }\n\n  /**\n   * Tries to recover from NETWORK HTTP_ERROR, temporary disabling the current\n   * problematic variant.\n   * @param {!shaka.util.Error} error\n   * @return {boolean}\n   * @private\n   */\n  tryToRecoverFromError_(error) {\n    if ((error.code != shaka.util.Error.Code.HTTP_ERROR &&\n      error.code != shaka.util.Error.Code.SEGMENT_MISSING) ||\n      error.category != shaka.util.Error.Category.NETWORK) {\n      return false;\n    }\n\n    if (!navigator.onLine) {\n      // Don't restrict variants if we're completely offline, or else we end up\n      // rapidly restricting all of them.\n      return false;\n    }\n\n    let maxDisabledTime = this.config_.streaming.maxDisabledTime;\n    if (maxDisabledTime == 0) {\n      if (error.code == shaka.util.Error.Code.SEGMENT_MISSING) {\n        // Spec: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.3\n        // The client SHOULD NOT attempt to load Media Segments that have been\n        // marked with an EXT-X-GAP tag, or to load Partial Segments with a\n        // GAP=YES attribute. Instead, clients are encouraged to look for\n        // another Variant Stream of the same Rendition which does not have the\n        // same gap, and play that instead.\n        maxDisabledTime = 1;\n      } else {\n        return false;\n      }\n    }\n\n    if (error.code == shaka.util.Error.Code.HTTP_ERROR) {\n      shaka.log.debug('Recoverable NETWORK HTTP_ERROR, trying to recover...');\n    }\n\n    // Obtain the active variant and disable it from manifest variants\n    const activeVariantTrack = this.getVariantTracks().find((t) => t.active);\n    goog.asserts.assert(activeVariantTrack, 'Active variant should be found');\n    const manifest = this.manifest_;\n    for (const variant of manifest.variants) {\n      if (variant.id === activeVariantTrack.id) {\n        variant.disabledUntilTime = (Date.now() / 1000) + maxDisabledTime;\n      }\n    }\n\n    // Apply restrictions in order to disable variants\n    shaka.util.StreamUtils.applyRestrictions(\n        manifest.variants, this.config_.restrictions, this.maxHwRes_);\n\n    // Select for a new variant\n    const chosenVariant = this.chooseVariant_();\n    if (!chosenVariant) {\n      shaka.log.warning('Not enough variants to recover from error');\n      return false;\n    }\n\n    // Get the safeMargin to ensure a seamless playback\n    const {video} = this.getBufferedInfo();\n    const safeMargin =\n        video.reduce((size, {start, end}) => size + end - start, 0);\n\n    this.switchVariant_(chosenVariant, /* fromAdaptation= */ false,\n        /* clearBuffers= */ true, /* safeMargin= */ safeMargin);\n\n    this.checkVariantsTimer_.tickAfter(maxDisabledTime);\n    return true;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  onError_(error) {\n    goog.asserts.assert(error instanceof shaka.util.Error, 'Wrong error type!');\n\n    // Errors dispatched after |destroy| is called are not meaningful and should\n    // be safe to ignore.\n    if (this.loadMode_ == shaka.Player.LoadMode.DESTROYED) {\n      return;\n    }\n\n\n    if (this.tryToRecoverFromError_(error)) {\n      error.handled = true;\n      return;\n    }\n\n    const eventName = shaka.util.FakeEvent.EventName.Error;\n    const event = this.makeEvent_(eventName, (new Map()).set('detail', error));\n    this.dispatchEvent(event);\n    if (event.defaultPrevented) {\n      error.handled = true;\n    }\n  }\n\n  /**\n   * When we fire region events, we need to copy the information out of the\n   * region to break the connection with the player's internal data. We do the\n   * copy here because this is the transition point between the player and the\n   * app.\n   *\n   * @param {!shaka.util.FakeEvent.EventName} eventName\n   * @param {shaka.extern.TimelineRegionInfo} region\n   *\n   * @private\n   */\n  onRegionEvent_(eventName, region) {\n    // Always make a copy to avoid exposing our internal data to the app.\n    const clone = {\n      schemeIdUri: region.schemeIdUri,\n      value: region.value,\n      startTime: region.startTime,\n      endTime: region.endTime,\n      id: region.id,\n      eventElement: region.eventElement,\n    };\n\n    const data = (new Map()).set('detail', clone);\n    this.dispatchEvent(this.makeEvent_(eventName, data));\n  }\n\n  /**\n   * When notified of a media quality change we need to emit a\n   * MediaQualityChange event to the app.\n   *\n   * @param {shaka.extern.MediaQualityInfo} mediaQuality\n   * @param {number} position\n   *\n   * @private\n   */\n  onMediaQualityChange_(mediaQuality, position) {\n    // Always make a copy to avoid exposing our internal data to the app.\n    const clone = {\n      bandwidth: mediaQuality.bandwidth,\n      audioSamplingRate: mediaQuality.audioSamplingRate,\n      codecs: mediaQuality.codecs,\n      contentType: mediaQuality.contentType,\n      frameRate: mediaQuality.frameRate,\n      height: mediaQuality.height,\n      mimeType: mediaQuality.mimeType,\n      channelsCount: mediaQuality.channelsCount,\n      pixelAspectRatio: mediaQuality.pixelAspectRatio,\n      width: mediaQuality.width,\n    };\n\n    const data = new Map()\n        .set('mediaQuality', clone)\n        .set('position', position);\n\n    this.dispatchEvent(this.makeEvent_(\n        shaka.util.FakeEvent.EventName.MediaQualityChanged, data));\n  }\n\n  /**\n   * Turn the media element's error object into a Shaka Player error object.\n   *\n   * @return {shaka.util.Error}\n   * @private\n   */\n  videoErrorToShakaError_() {\n    goog.asserts.assert(this.video_.error,\n        'Video error expected, but missing!');\n    if (!this.video_.error) {\n      return null;\n    }\n\n    const code = this.video_.error.code;\n    if (code == 1 /* MEDIA_ERR_ABORTED */) {\n      // Ignore this error code, which should only occur when navigating away or\n      // deliberately stopping playback of HTTP content.\n      return null;\n    }\n\n    // Extra error information from MS Edge:\n    let extended = this.video_.error.msExtendedCode;\n    if (extended) {\n      // Convert to unsigned:\n      if (extended < 0) {\n        extended += Math.pow(2, 32);\n      }\n      // Format as hex:\n      extended = extended.toString(16);\n    }\n\n    // Extra error information from Chrome:\n    const message = this.video_.error.message;\n\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.VIDEO_ERROR,\n        code, extended, message);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  onVideoError_(event) {\n    const error = this.videoErrorToShakaError_();\n    if (!error) {\n      return;\n    }\n    this.onError_(error);\n  }\n\n  /**\n   * @param {!Object.<string, string>} keyStatusMap A map of hex key IDs to\n   *   statuses.\n   * @private\n   */\n  onKeyStatus_(keyStatusMap) {\n    if (!this.streamingEngine_) {\n      // We can't use this info to manage restrictions in src= mode, so ignore\n      // it.\n      return;\n    }\n\n    const keyIds = Object.keys(keyStatusMap);\n    if (keyIds.length == 0) {\n      shaka.log.warning(\n          'Got a key status event without any key statuses, so we don\\'t ' +\n          'know the real key statuses. If we don\\'t have all the keys, ' +\n          'you\\'ll need to set restrictions so we don\\'t select those tracks.');\n    }\n\n    // If EME is using a synthetic key ID, the only key ID is '00' (a single 0\n    // byte).  In this case, it is only used to report global success/failure.\n    // See note about old platforms in: https://bit.ly/2tpez5Z\n    const isGlobalStatus = keyIds.length == 1 && keyIds[0] == '00';\n    if (isGlobalStatus) {\n      shaka.log.warning(\n          'Got a synthetic key status event, so we don\\'t know the real key ' +\n          'statuses. If we don\\'t have all the keys, you\\'ll need to set ' +\n          'restrictions so we don\\'t select those tracks.');\n    }\n\n    const restrictedStatuses = shaka.Player.restrictedStatuses_;\n    let tracksChanged = false;\n\n    // Only filter tracks for keys if we have some key statuses to look at.\n    if (keyIds.length) {\n      for (const variant of this.manifest_.variants) {\n        const streams = shaka.util.StreamUtils.getVariantStreams(variant);\n\n        for (const stream of streams) {\n          const originalAllowed = variant.allowedByKeySystem;\n\n          // Only update if we have key IDs for the stream.  If the keys aren't\n          // all present, then the track should be restricted.\n          if (stream.keyIds.size) {\n            variant.allowedByKeySystem = true;\n\n            for (const keyId of stream.keyIds) {\n              const keyStatus = keyStatusMap[isGlobalStatus ? '00' : keyId];\n              variant.allowedByKeySystem = variant.allowedByKeySystem &&\n                  !!keyStatus && !restrictedStatuses.includes(keyStatus);\n            }\n          }\n\n          if (originalAllowed != variant.allowedByKeySystem) {\n            tracksChanged = true;\n          }\n        }  // for (const stream of streams)\n      }  // for (const variant of this.manifest_.variants)\n    }  // if (keyIds.size)\n\n    if (tracksChanged) {\n      const variantsUpdated = this.updateAbrManagerVariants_();\n      if (!variantsUpdated) {\n        return;\n      }\n    }\n\n    const currentVariant = this.streamingEngine_.getCurrentVariant();\n    if (currentVariant && !currentVariant.allowedByKeySystem) {\n      shaka.log.debug('Choosing new streams after key status changed');\n      this.chooseVariantAndSwitch_();\n    }\n\n    if (tracksChanged) {\n      this.onTracksChanged_();\n    }\n  }\n\n  /**\n   * Callback from DrmEngine\n   * @param {string} keyId\n   * @param {number} expiration\n   * @private\n   */\n  onExpirationUpdated_(keyId, expiration) {\n    if (this.parser_ && this.parser_.onExpirationUpdated) {\n      this.parser_.onExpirationUpdated(keyId, expiration);\n    }\n\n    const event =\n        this.makeEvent_(shaka.util.FakeEvent.EventName.ExpirationUpdated);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * @return {boolean} true if we should stream text right now.\n   * @private\n   */\n  shouldStreamText_() {\n    return this.config_.streaming.alwaysStreamText || this.isTextTrackVisible();\n  }\n\n  /**\n   * Applies playRangeStart and playRangeEnd to the given timeline. This will\n   * only affect non-live content.\n   *\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @param {number} playRangeStart\n   * @param {number} playRangeEnd\n   *\n   * @private\n   */\n  static applyPlayRange_(timeline, playRangeStart, playRangeEnd) {\n    if (playRangeStart > 0) {\n      if (timeline.isLive()) {\n        shaka.log.warning(\n            '|playRangeStart| has been configured for live content. ' +\n            'Ignoring the setting.');\n      } else {\n        timeline.setUserSeekStart(playRangeStart);\n      }\n    }\n\n    // If the playback has been configured to end before the end of the\n    // presentation, update the duration unless it's live content.\n    const fullDuration = timeline.getDuration();\n    if (playRangeEnd < fullDuration) {\n      if (timeline.isLive()) {\n        shaka.log.warning(\n            '|playRangeEnd| has been configured for live content. ' +\n            'Ignoring the setting.');\n      } else {\n        timeline.setDuration(playRangeEnd);\n      }\n    }\n  }\n\n  /**\n   * Checks if the variants are all restricted, and throw an appropriate\n   * exception if so.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   *\n   * @private\n   */\n  checkRestrictedVariants_(manifest) {\n    const restrictedStatuses = shaka.Player.restrictedStatuses_;\n    const keyStatusMap =\n        this.drmEngine_ ? this.drmEngine_.getKeyStatuses() : {};\n    const keyIds = Object.keys(keyStatusMap);\n    const isGlobalStatus = keyIds.length && keyIds[0] == '00';\n\n    let hasPlayable = false;\n    let hasAppRestrictions = false;\n\n    /** @type {!Set.<string>} */\n    const missingKeys = new Set();\n\n    /** @type {!Set.<string>} */\n    const badKeyStatuses = new Set();\n\n    for (const variant of manifest.variants) {\n      // TODO: Combine with onKeyStatus_.\n      const streams = [];\n      if (variant.audio) {\n        streams.push(variant.audio);\n      }\n      if (variant.video) {\n        streams.push(variant.video);\n      }\n\n      for (const stream of streams) {\n        if (stream.keyIds.size) {\n          for (const keyId of stream.keyIds) {\n            const keyStatus = keyStatusMap[isGlobalStatus ? '00' : keyId];\n            if (!keyStatus) {\n              missingKeys.add(keyId);\n            } else if (restrictedStatuses.includes(keyStatus)) {\n              badKeyStatuses.add(keyStatus);\n            }\n          }\n        }  // if (stream.keyIds.size)\n      }\n\n      if (!variant.allowedByApplication) {\n        hasAppRestrictions = true;\n      } else if (variant.allowedByKeySystem) {\n        hasPlayable = true;\n      }\n    }\n\n    if (!hasPlayable) {\n      /** @type {shaka.extern.RestrictionInfo} */\n      const data = {\n        hasAppRestrictions,\n        missingKeys: Array.from(missingKeys),\n        restrictedKeyStatuses: Array.from(badKeyStatuses),\n      };\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET,\n          data);\n    }\n  }\n\n  /**\n   * Confirm some variants are playable. Otherwise, throw an exception.\n   * @param {!shaka.extern.Manifest} manifest\n   * @private\n   */\n  checkPlayableVariants_(manifest) {\n    const valid = manifest.variants.some(shaka.util.StreamUtils.isPlayable);\n\n    // If none of the variants are playable, throw\n    // CONTENT_UNSUPPORTED_BY_BROWSER.\n    if (!valid) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER);\n    }\n  }\n\n  /**\n   * Fire an event, but wait a little bit so that the immediate execution can\n   * complete before the event is handled.\n   *\n   * @param {!shaka.util.FakeEvent} event\n   * @private\n   */\n  async delayDispatchEvent_(event) {\n    // Wait until the next interpreter cycle.\n    await Promise.resolve();\n\n    // Only dispatch the event if we are still alive.\n    if (this.loadMode_ != shaka.Player.LoadMode.DESTROYED) {\n      this.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Get the normalized languages for a group of tracks.\n   *\n   * @param {!Array.<?shaka.extern.Track>} tracks\n   * @return {!Set.<string>}\n   * @private\n   */\n  static getLanguagesFrom_(tracks) {\n    const languages = new Set();\n\n    for (const track of tracks) {\n      if (track.language) {\n        languages.add(shaka.util.LanguageUtils.normalize(track.language));\n      } else {\n        languages.add('und');\n      }\n    }\n\n    return languages;\n  }\n\n  /**\n   * Get all permutations of normalized languages and role for a group of\n   * tracks.\n   *\n   * @param {!Array.<?shaka.extern.Track>} tracks\n   * @return {!Array.<shaka.extern.LanguageRole>}\n   * @private\n   */\n  static getLanguageAndRolesFrom_(tracks) {\n    /** @type {!Map.<string, !Set>} */\n    const languageToRoles = new Map();\n    /** @type {!Map.<string, !Map.<string, string>>} */\n    const languageRoleToLabel = new Map();\n\n    for (const track of tracks) {\n      let language = 'und';\n      let roles = [];\n\n      if (track.language) {\n        language = shaka.util.LanguageUtils.normalize(track.language);\n      }\n\n      if (track.type == 'variant') {\n        roles = track.audioRoles;\n      } else {\n        roles = track.roles;\n      }\n\n      if (!roles || !roles.length) {\n        // We must have an empty role so that we will still get a language-role\n        // entry from our Map.\n        roles = [''];\n      }\n\n      if (!languageToRoles.has(language)) {\n        languageToRoles.set(language, new Set());\n      }\n\n      for (const role of roles) {\n        languageToRoles.get(language).add(role);\n        if (track.label) {\n          if (!languageRoleToLabel.has(language)) {\n            languageRoleToLabel.set(language, new Map());\n          }\n          languageRoleToLabel.get(language).set(role, track.label);\n        }\n      }\n    }\n\n    // Flatten our map to an array of language-role pairs.\n    const pairings = [];\n    languageToRoles.forEach((roles, language) => {\n      for (const role of roles) {\n        let label = null;\n        if (languageRoleToLabel.has(language) &&\n            languageRoleToLabel.get(language).has(role)) {\n          label = languageRoleToLabel.get(language).get(role);\n        }\n        pairings.push({language, role, label});\n      }\n    });\n    return pairings;\n  }\n\n  /**\n   * Assuming the player is playing content with media source, check if the\n   * player has buffered enough content to make it to the end of the\n   * presentation.\n   *\n   * @return {boolean}\n   * @private\n   */\n  isBufferedToEndMS_() {\n    goog.asserts.assert(\n        this.video_,\n        'We need a video element to get buffering information');\n    goog.asserts.assert(\n        this.mediaSourceEngine_,\n        'We need a media source engine to get buffering information');\n    goog.asserts.assert(\n        this.manifest_,\n        'We need a manifest to get buffering information');\n\n    // This is a strong guarantee that we are buffered to the end, because it\n    // means the playhead is already at that end.\n    if (this.video_.ended) {\n      return true;\n    }\n\n    // This means that MediaSource has buffered the final segment in all\n    // SourceBuffers and is no longer accepting additional segments.\n    if (this.mediaSourceEngine_.ended()) {\n      return true;\n    }\n\n    // Live streams are \"buffered to the end\" when they have buffered to the\n    // live edge or beyond (into the region covered by the presentation delay).\n    if (this.manifest_.presentationTimeline.isLive()) {\n      const liveEdge =\n          this.manifest_.presentationTimeline.getSegmentAvailabilityEnd();\n      const bufferEnd =\n          shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n      if (bufferEnd != null && bufferEnd >= liveEdge) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Assuming the player is playing content with src=, check if the player has\n   * buffered enough content to make it to the end of the presentation.\n   *\n   * @return {boolean}\n   * @private\n   */\n  isBufferedToEndSrc_() {\n    goog.asserts.assert(\n        this.video_,\n        'We need a video element to get buffering information');\n\n    // This is a strong guarantee that we are buffered to the end, because it\n    // means the playhead is already at that end.\n    if (this.video_.ended) {\n      return true;\n    }\n\n    // If we have buffered to the duration of the content, it means we will have\n    // enough content to buffer to the end of the presentation.\n    const bufferEnd =\n        shaka.media.TimeRangesUtils.bufferEnd(this.video_.buffered);\n\n    // Because Safari's native HLS reports slightly inaccurate values for\n    // bufferEnd here, we use a fudge factor.  Without this, we can end up in a\n    // buffering state at the end of the stream.  See issue #2117.\n    // TODO: Try to remove the fudge here once we no longer manage buffering\n    // state above the browser with playbackRate=0.\n    const fudge = 1;  // 1000 ms\n    return bufferEnd != null && bufferEnd >= this.video_.duration - fudge;\n  }\n\n  /**\n   * Create an error for when we purposely interrupt a load operation.\n   *\n   * @return {!shaka.util.Error}\n   * @private\n   */\n  createAbortLoadError_() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.LOAD_INTERRUPTED);\n  }\n\n  /**\n   * Key\n   * ----------------------\n   * D   : Detach Node\n   * A   : Attach Node\n   * MS  : Media Source Node\n   * P   : Manifest Parser Node\n   * M   : Manifest Node\n   * DRM : Drm Engine Node\n   * L   : Load Node\n   * U   : Unloading Node\n   * SRC : Src Equals Node\n   *\n   * Graph Topology\n   * ----------------------\n   *\n   *        [SRC]-----+\n   *         ^        |\n   *         |        v\n   * [D]<-->[A]<-----[U]\n   *         |        ^\n   *         v        |\n   *        [MS]------+\n   *         |        |\n   *         v        |\n   *        [P]-------+\n   *         |        |\n   *         v        |\n   *        [M]-------+\n   *         |        |\n   *         v        |\n   *        [DRM]-----+\n   *         |        |\n   *         v        |\n   *        [L]-------+\n   *\n   * @param {!shaka.routing.Node} currentlyAt\n   * @param {shaka.routing.Payload} currentlyWith\n   * @param {!shaka.routing.Node} wantsToBeAt\n   * @param {shaka.routing.Payload} wantsToHave\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextStep_(currentlyAt, currentlyWith, wantsToBeAt, wantsToHave) {\n    let next = null;\n\n    // Detach is very simple, either stay in detach (because |detach| was called\n    // while in detached) or go somewhere that requires us to attach to an\n    // element.\n    if (currentlyAt == this.detachNode_) {\n      next = wantsToBeAt == this.detachNode_ ?\n             this.detachNode_ :\n             this.attachNode_;\n    }\n\n    if (currentlyAt == this.attachNode_) {\n      next = this.getNextAfterAttach_(wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    if (currentlyAt == this.mediaSourceNode_) {\n      next = this.getNextAfterMediaSource_(\n          wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    if (currentlyAt == this.parserNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.manifestNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    if (currentlyAt == this.manifestNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.drmNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    // For DRM, we have two options \"load\" or \"unload\". If all our constraints\n    // are met, we can go to \"load\". If anything is off, we must go back to\n    // \"unload\" to reset.\n    if (currentlyAt == this.drmNode_) {\n      next = this.getNextMatchingAllDependencies_(\n          /* destination= */ this.loadNode_,\n          /* next= */ this.loadNode_,\n          /* reset= */ this.unloadNode_,\n          /* goingTo= */ wantsToBeAt,\n          /* has= */ currentlyWith,\n          /* wants= */ wantsToHave);\n    }\n\n    // For DRM w/ src= playback, we only care about destination and media\n    // element.\n    if (currentlyAt == this.srcEqualsDrmNode_) {\n      if (wantsToBeAt == this.srcEqualsNode_ &&\n          currentlyWith.mediaElement == wantsToHave.mediaElement) {\n        next = this.srcEqualsNode_;\n      } else {\n        next = this.unloadNode_;\n      }\n    }\n\n    // After we load content, always go through unload because we can't safely\n    // use components after we have started playback.\n    if (currentlyAt == this.loadNode_ || currentlyAt == this.srcEqualsNode_) {\n      next = this.unloadNode_;\n    }\n\n    if (currentlyAt == this.unloadNode_) {\n      next = this.getNextAfterUnload_(wantsToBeAt, currentlyWith, wantsToHave);\n    }\n\n    goog.asserts.assert(next, 'Missing next step!');\n    return next;\n  }\n\n  /**\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterAttach_(goingTo, has, wants) {\n    // Attach and detach are the only two nodes that we can directly go\n    // back-and-forth between.\n    if (goingTo == this.detachNode_) {\n      return this.detachNode_;\n    }\n\n    // If we are going anywhere other than detach, then we need the media\n    // element to match, if they don't match, we need to go through detach\n    // first.\n    if (has.mediaElement != wants.mediaElement) {\n      return this.detachNode_;\n    }\n\n    // If we are already in attached, and someone calls |attach| again (to the\n    // same video element), we can handle the redundant request by re-entering\n    // our current state.\n    if (goingTo == this.attachNode_) {\n      return this.attachNode_;\n    }\n\n    // The next step from attached to loaded is through media source.\n    if (goingTo == this.mediaSourceNode_ || goingTo == this.loadNode_) {\n      return this.mediaSourceNode_;\n    }\n\n    // If we are going to src=, then we should set up DRM first.  This will\n    // support cases like FairPlay HLS on Safari.\n    if (goingTo == this.srcEqualsNode_) {\n      return this.srcEqualsDrmNode_;\n    }\n\n    // We are missing a rule, the null will get caught by a common check in\n    // the routing system.\n    return null;\n  }\n\n  /**\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterMediaSource_(goingTo, has, wants) {\n    // We can only go to parse manifest or unload. If we want to go to load and\n    // we have the right media element, we can go to parse manifest. If we\n    // don't, no matter where we want to go, we must go through unload.\n    if (goingTo == this.loadNode_ && has.mediaElement == wants.mediaElement) {\n      return this.parserNode_;\n    }\n\n    // Right now the unload node is responsible for tearing down all playback\n    // components (including media source). So since we have created media\n    // source, we need to unload since our dependencies are not compatible.\n    //\n    // TODO: We are structured this way to maintain a historic structure. Going\n    //       forward, there is no reason to restrict ourselves to this. Going\n    //       forward we should explore breaking apart |onUnload| and develop\n    //       more meaningful terminology around tearing down playback resources.\n    return this.unloadNode_;\n  }\n\n  /**\n   * After unload there are only two options, attached or detached. This choice\n   * is based on whether or not we have a media element. If we have a media\n   * element, then we go to attach. If we don't have a media element, we go to\n   * detach.\n   *\n   * @param {!shaka.routing.Node} goingTo\n   * @param {shaka.routing.Payload} has\n   * @param {shaka.routing.Payload} wants\n   * @return {?shaka.routing.Node}\n   * @private\n   */\n  getNextAfterUnload_(goingTo, has, wants) {\n    // If we don't want a media element, detach.\n    // If we have the wrong media element, detach.\n    // Otherwise it means we want to attach to a media element and it is safe to\n    // do so.\n    return !wants.mediaElement || has.mediaElement != wants.mediaElement ?\n           this.detachNode_ :\n           this.attachNode_;\n  }\n\n  /**\n   * A general method used to handle routing when we can either than one step\n   * toward our destination (while all our dependencies match) or go to a node\n   * that will reset us so we can try again.\n   *\n   * @param {!shaka.routing.Node} destinationNode\n   *   What |goingTo| must be for us to step toward |nextNode|. Otherwise we\n   *   will go to |resetNode|.\n   * @param {!shaka.routing.Node} nextNode\n   *   The node we will go to next if |goingTo == destinationNode| and all\n   *   dependencies match.\n   * @param {!shaka.routing.Node} resetNode\n   *   The node we will go to next if |goingTo != destinationNode| or any\n   *   dependency does not match.\n   * @param {!shaka.routing.Node} goingTo\n   *   The node that the walker is trying to go to.\n   * @param {shaka.routing.Payload} has\n   *   The payload that the walker currently has.\n   * @param {shaka.routing.Payload} wants\n   *   The payload that the walker wants to have when iy gets to |goingTo|.\n   * @return {shaka.routing.Node}\n   * @private\n   */\n  getNextMatchingAllDependencies_(destinationNode, nextNode, resetNode, goingTo,\n      has, wants) {\n    if (goingTo == destinationNode &&\n        has.mediaElement == wants.mediaElement &&\n        has.uri == wants.uri &&\n        has.mimeType == wants.mimeType) {\n      return nextNode;\n    }\n\n    return resetNode;\n  }\n\n  /**\n   * @return {shaka.routing.Payload}\n   * @private\n   */\n  static createEmptyPayload_() {\n    return {\n      mediaElement: null,\n      mimeType: null,\n      startTime: null,\n      startTimeOfLoad: NaN,\n      uri: null,\n    };\n  }\n\n  /**\n   * Using a promise, wrap the listeners returned by |Walker.startNewRoute|.\n   * This will work for most usages in |Player| but should not be used for\n   * special cases.\n   *\n   * This will connect |onCancel|, |onEnd|, |onError|, and |onSkip| with\n   * |resolve| and |reject| but will leave |onStart| unset.\n   *\n   * @param {shaka.routing.Walker.Listeners} listeners\n   * @return {!Promise}\n   * @private\n   */\n  wrapWalkerListenersWithPromise_(listeners) {\n    return new Promise((resolve, reject) => {\n      listeners.onCancel = () => reject(this.createAbortLoadError_());\n      listeners.onEnd = () => resolve();\n      listeners.onError = (e) => reject(e);\n      listeners.onSkip = () => reject(this.createAbortLoadError_());\n    });\n  }\n};\n\n/**\n * In order to know what method of loading the player used for some content, we\n * have this enum. It lets us know if content has not been loaded, loaded with\n * media source, or loaded with src equals.\n *\n * This enum has a low resolution, because it is only meant to express the\n * outer limits of the various states that the player is in. For example, when\n * someone calls a public method on player, it should not matter if they have\n * initialized drm engine, it should only matter if they finished loading\n * content.\n *\n * @enum {number}\n * @export\n */\nshaka.Player.LoadMode = {\n  'DESTROYED': 0,\n  'NOT_LOADED': 1,\n  'MEDIA_SOURCE': 2,\n  'SRC_EQUALS': 3,\n};\n\n/**\n * The typical buffering threshold.  When we have less than this buffered (in\n * seconds), we enter a buffering state.  This specific value is based on manual\n * testing and evaluation across a variety of platforms.\n *\n * To make the buffering logic work in all cases, this \"typical\" threshold will\n * be overridden if the rebufferingGoal configuration is too low.\n *\n * @const {number}\n * @private\n */\nshaka.Player.TYPICAL_BUFFERING_THRESHOLD_ = 0.5;\n\n/**\n * @define {string} A version number taken from git at compile time.\n * @export\n */\nshaka.Player.version = 'v4.3.4-uncompiled';\n\n// Initialize the deprecation system using the version string we just set\n// on the player.\nshaka.Deprecate.init(shaka.Player.version);\n\n\n/**\n * These are the EME key statuses that represent restricted playback.\n * 'usable', 'released', 'output-downscaled', 'status-pending' are statuses\n * of the usable keys.  'expired' status is being handled separately in\n * DrmEngine.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.Player.restrictedStatuses_ = ['output-restricted', 'internal-error'];\n\n\n/** @private {!Object.<string, function():*>} */\nshaka.Player.supportPlugins_ = {};\n\n\n/** @private {?shaka.extern.IAdManager.Factory} */\nshaka.Player.adManagerFactory_ = null;\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'video/mp4',\n  'm4v': 'video/mp4',\n  'm4a': 'audio/mp4',\n  'webm': 'video/webm',\n  'weba': 'audio/webm',\n  'mkv': 'video/webm', // Chromium browsers supports it.\n  'ts': 'video/mp2t',\n  'ogv': 'video/ogg',\n  'ogg': 'audio/ogg',\n  'mpg': 'video/mpeg',\n  'mpeg': 'video/mpeg',\n  'm3u8': 'application/x-mpegurl',\n  'mpd': 'application/dash+xml',\n  'mp3': 'audio/mpeg',\n  'aac': 'audio/aac',\n  'flac': 'audio/flac',\n  'wav': 'audio/wav',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_ = {\n  'sbv': 'text/x-subviewer',\n  'srt': 'text/srt',\n  'vtt': 'text/vtt',\n  'webvtt': 'text/vtt',\n  'ttml': 'application/ttml+xml',\n  'lrc': 'application/x-subtitle-lrc',\n  'ssa': 'text/x-ssa',\n  'ass': 'text/x-ssa',\n};\n\n\n/**\n * @const {string}\n */\nshaka.Player.TextTrackLabel = 'Shaka Player TextTrack';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.deprecate.Enforcer');\n\ngoog.require('shaka.deprecate.Version');\n\n\n/**\n * The enforcer's job is to call the correct callback when a feature will need\n * to be removed later or removed now.\n *\n * The \"what should be done\" is not part of the enforcer, that must be provided\n * to the enforcer when it is created. This separation was created so that\n * testing and production could be equal users of the enforcer.\n *\n * @final\n */\nshaka.deprecate.Enforcer = class {\n  /**\n   * @param {!shaka.deprecate.Version} libraryVersion\n   * @param {shaka.deprecate.Listener} onPending\n   * @param {shaka.deprecate.Listener} onExpired\n   */\n  constructor(libraryVersion, onPending, onExpired) {\n    /** @private {!shaka.deprecate.Version} */\n    this.libraryVersion_ = libraryVersion;\n\n    /** @private {shaka.deprecate.Listener} */\n    this.onPending_ = onPending;\n    /** @private {shaka.deprecate.Listener} */\n    this.onExpired_ = onExpired;\n  }\n\n  /**\n   * Tell the enforcer that a feature will expire on |expiredOn| and that it\n   * should notify the listeners if it is pending or expired.\n   *\n   * @param {!shaka.deprecate.Version} expiresOn\n   * @param {string} name\n   * @param {string} description\n   */\n  enforce(expiresOn, name, description) {\n    // If the expiration version is larger than the library version\n    // (compareTo > 0), it means the expiration is in the future, and is still\n    // pending.\n    const isPending = expiresOn.compareTo(this.libraryVersion_) > 0;\n\n    // Find the right callback (pending or expired) for this enforcement request\n    // call it to handle this features pending/expired removal.\n    const callback = isPending ? this.onPending_ : this.onExpired_;\n    callback(this.libraryVersion_, expiresOn, name, description);\n  }\n};\n\n/**\n * A callback for listening to deprecation events.\n *\n * Parameters:\n *  libraryVersion: !shaka.deprecate.Version\n *  featureVersion: !shaka.deprecate.Version\n *  name: string\n *  description: string\n *\n * libraryVersion: The current version of the library.\n * featureVersion: The version of the library when the feature should be\n *                 removed.\n * name: The name of the feature that will/should be removed.\n * description: A description of what is changing.\n *\n * @typedef {function(\n *    !shaka.deprecate.Version,\n *    !shaka.deprecate.Version,\n *    string,\n *    string)}\n */\nshaka.deprecate.Listener;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.AdaptationSet');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.MimeUtils');\n\n\n/**\n * A set of variants that we want to adapt between.\n *\n * @final\n */\nshaka.media.AdaptationSet = class {\n  /**\n   * @param {shaka.extern.Variant} root\n   *    The variant that all other variants will be tested against when being\n   *    added to the adaptation set. If a variant is not compatible with the\n   *    root, it will not be added.\n   * @param {!Iterable.<shaka.extern.Variant>=} candidates\n   *    Variants that may be compatible with the root and should be added if\n   *    compatible. If a candidate is not compatible, it will not end up in the\n   *    adaptation set.\n   */\n  constructor(root, candidates) {\n    /** @private {shaka.extern.Variant} */\n    this.root_ = root;\n    /** @private {!Set.<shaka.extern.Variant>} */\n    this.variants_ = new Set([root]);\n\n    // Try to add all the candidates. If they cannot be added (because they\n    // are not compatible with the root, they will be rejected by |add|.\n    candidates = candidates || [];\n    for (const candidate of candidates) {\n      this.add(candidate);\n    }\n  }\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  add(variant) {\n    if (this.canInclude(variant)) {\n      this.variants_.add(variant);\n      return true;\n    }\n\n    // To be nice, issue a warning if someone is trying to add something that\n    // they shouldn't.\n    shaka.log.warning('Rejecting variant - not compatible with root.');\n    return false;\n  }\n\n  /**\n   * Check if |variant| can be included with the set. If |canInclude| returns\n   * |false|, calling |add| will result in it being ignored.\n   *\n   * @param {shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  canInclude(variant) {\n    return shaka.media.AdaptationSet.areAdaptable(this.root_, variant);\n  }\n\n  /**\n   * @param {shaka.extern.Variant} a\n   * @param {shaka.extern.Variant} b\n   * @return {boolean}\n   */\n  static areAdaptable(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // All variants should have audio or should all not have audio.\n    if (!!a.audio != !!b.audio) {\n      return false;\n    }\n\n    // All variants should have video or should all not have video.\n    if (!!a.video != !!b.video) {\n      return false;\n    }\n\n    // If the languages don't match, we should not adapt between them.\n    if (a.language != b.language) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.audio == !!b.audio,\n        'Both should either have audio or not have audio.');\n    if (a.audio && b.audio &&\n        !AdaptationSet.areAudiosCompatible_(a.audio, b.audio)) {\n      return false;\n    }\n\n    goog.asserts.assert(\n        !!a.video == !!b.video,\n        'Both should either have video or not have video.');\n    if (a.video && b.video &&\n        !AdaptationSet.areVideosCompatible_(a.video, b.video)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @return {!Iterable.<shaka.extern.Variant>}\n   */\n  values() {\n    return this.variants_.values();\n  }\n\n  /**\n   * Check if we can switch between two audio streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areAudiosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // Don't adapt between channel counts, which could annoy the user\n    // due to volume changes on downmixing.  An exception is made for\n    // stereo and mono, which should be fine to adapt between.\n    if (!a.channelsCount || !b.channelsCount ||\n        a.channelsCount > 2 || b.channelsCount > 2) {\n      if (a.channelsCount != b.channelsCount) {\n        return false;\n      }\n    }\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Audio roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two video streams.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static areVideosCompatible_(a, b) {\n    const AdaptationSet = shaka.media.AdaptationSet;\n\n    // We can only adapt between base-codecs.\n    if (!AdaptationSet.canTransitionBetween_(a, b)) {\n      return false;\n    }\n\n    // Video roles must not change between adaptations.\n    if (!AdaptationSet.areRolesEqual_(a.roles, b.roles)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if we can switch between two streams based on their codec and mime\n   * type.\n   *\n   * @param {shaka.extern.Stream} a\n   * @param {shaka.extern.Stream} b\n   * @return {boolean}\n   * @private\n   */\n  static canTransitionBetween_(a, b) {\n    if (a.mimeType != b.mimeType) {\n      return false;\n    }\n\n\n    // Get the base codec of each codec in each stream.\n    const codecsA = shaka.util.MimeUtils.splitCodecs(a.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n    const codecsB = shaka.util.MimeUtils.splitCodecs(b.codecs).map((codec) => {\n      return shaka.util.MimeUtils.getCodecBase(codec);\n    });\n\n    // We don't want to allow switching between transmuxed and non-transmuxed\n    // content so the number of codecs should be the same.\n    //\n    // To avoid the case where an codec is used for audio and video we will\n    // codecs using arrays (not sets). While at this time, there are no codecs\n    // that work for audio and video, it is possible for \"raw\" codecs to be\n    // which would share the same name.\n    if (codecsA.length != codecsB.length) {\n      return false;\n    }\n\n    // Sort them so that we can walk through them and compare them\n    // element-by-element.\n    codecsA.sort();\n    codecsB.sort();\n\n    for (let i = 0; i < codecsA.length; i++) {\n      if (codecsA[i] != codecsB[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if two role lists are the equal. This will take into account all\n   * unique behaviours when comparing roles.\n   *\n   * @param {!Iterable.<string>} a\n   * @param {!Iterable.<string>} b\n   * @return {boolean}\n   * @private\n   */\n  static areRolesEqual_(a, b) {\n    const aSet = new Set(a);\n    const bSet = new Set(b);\n\n    // Remove the main role from the role lists (we expect to see them only\n    // in dash manifests).\n    const mainRole = 'main';\n    aSet.delete(mainRole);\n    bSet.delete(mainRole);\n\n    // Make sure that we have the same number roles in each list. Make sure to\n    // do it after correcting for 'main'.\n    if (aSet.size != bSet.size) {\n      return false;\n    }\n\n    // Because we know the two sets are the same size, if any item is missing\n    // if means that they are not the same.\n    for (const x of aSet) {\n      if (!bSet.has(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.AdaptationSetCriteria');\ngoog.provide('shaka.media.ExampleBasedCriteria');\ngoog.provide('shaka.media.PreferenceBasedCriteria');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.AdaptationSet');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * An adaptation set criteria is a unit of logic that can take a set of\n * variants and return a subset of variants that should (and can) be\n * adapted between.\n *\n * @interface\n */\nshaka.media.AdaptationSetCriteria = class {\n  /**\n   * Take a set of variants, and return a subset of variants that can be\n   * adapted between.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!shaka.media.AdaptationSet}\n   */\n  create(variants) {}\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.ExampleBasedCriteria = class {\n  /**\n   * @param {shaka.extern.Variant} example\n   */\n  constructor(example) {\n    /** @private {shaka.extern.Variant} */\n    this.example_ = example;\n\n    // We can't know if role and label are really important, so we don't use\n    // role and label for this.\n    const role = '';\n    const label = '';\n    const channelCount = example.audio && example.audio.channelsCount ?\n                         example.audio.channelsCount :\n                         0;\n\n    /** @private {!shaka.media.AdaptationSetCriteria} */\n    this.fallback_ = new shaka.media.PreferenceBasedCriteria(\n        example.language, role, channelCount, label);\n  }\n\n  /** @override */\n  create(variants) {\n    // We can't assume that the example is in |variants| because it could\n    // actually be from another period.\n    const shortList = variants.filter((variant) => {\n      return shaka.media.AdaptationSet.areAdaptable(this.example_, variant);\n    });\n\n    if (shortList.length) {\n      // Use the first item in the short list as the root. It should not matter\n      // which element we use as all items in the short list should already be\n      // compatible.\n      return new shaka.media.AdaptationSet(shortList[0], shortList);\n    } else {\n      return this.fallback_.create(variants);\n    }\n  }\n};\n\n\n/**\n * @implements {shaka.media.AdaptationSetCriteria}\n * @final\n */\nshaka.media.PreferenceBasedCriteria = class {\n  /**\n   * @param {string} language\n   * @param {string} role\n   * @param {number} channelCount\n   * @param {string=} label\n   */\n  constructor(language, role, channelCount, label = '') {\n    /** @private {string} */\n    this.language_ = language;\n    /** @private {string} */\n    this.role_ = role;\n    /** @private {number} */\n    this.channelCount_ = channelCount;\n    /** @private {string} */\n    this.label_ = label;\n  }\n\n  /** @override */\n  create(variants) {\n    const Class = shaka.media.PreferenceBasedCriteria;\n    const StreamUtils = shaka.util.StreamUtils;\n\n    let current = [];\n\n    const byLanguage = Class.filterByLanguage_(variants, this.language_);\n    const byPrimary = variants.filter((variant) => variant.primary);\n\n    if (byLanguage.length) {\n      current = byLanguage;\n    } else if (byPrimary.length) {\n      current = byPrimary;\n    } else {\n      current = variants;\n    }\n\n    // Now refine the choice based on role preference.  Even the empty string\n    // works here, and will match variants without any roles.\n    const byRole = Class.filterVariantsByRole_(current, this.role_);\n    if (byRole.length) {\n      current = byRole;\n    } else {\n      shaka.log.warning('No exact match for variant role could be found.');\n    }\n\n    if (this.channelCount_) {\n      const byChannel = StreamUtils.filterVariantsByAudioChannelCount(\n          current, this.channelCount_);\n      if (byChannel.length) {\n        current = byChannel;\n      } else {\n        shaka.log.warning(\n            'No exact match for the channel count could be found.');\n      }\n    }\n\n    if (this.label_) {\n      const byLabel = Class.filterVariantsByLabel_(current, this.label_);\n      if (byLabel.length) {\n        current = byLabel;\n      } else {\n        shaka.log.warning('No exact match for variant label could be found.');\n      }\n    }\n\n    // Make sure we only return a valid adaptation set.\n    const set = new shaka.media.AdaptationSet(current[0]);\n    for (const variant of current) {\n      if (set.canInclude(variant)) {\n        set.add(variant);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLanguage\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterByLanguage_(variants, preferredLanguage) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {string} */\n    const preferredLocale = LanguageUtils.normalize(preferredLanguage);\n\n    /** @type {?string} */\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredLocale,\n        variants.map((variant) => LanguageUtils.getLocaleForVariant(variant)));\n\n    // There were no locales close to what we preferred.\n    if (!closestLocale) {\n      return [];\n    }\n\n    // Find the variants that use the closest variant.\n    return variants.filter((variant) => {\n      return closestLocale == LanguageUtils.getLocaleForVariant(variant);\n    });\n  }\n\n  /**\n   * Filter Variants by role.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredRole\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByRole_(variants, preferredRole) {\n    return variants.filter((variant) => {\n      if (!variant.audio) {\n        return false;\n      }\n\n      if (preferredRole) {\n        return variant.audio.roles.includes(preferredRole);\n      } else {\n        return variant.audio.roles.length == 0;\n      }\n    });\n  }\n\n  /**\n   * Filter Variants by label.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {string} preferredLabel\n   * @return {!Array.<shaka.extern.Variant>}\n   * @private\n   */\n  static filterVariantsByLabel_(variants, preferredLabel) {\n    return variants.filter((variant) => {\n      if (!variant.audio) {\n        return false;\n      }\n\n      const label1 = variant.audio.label.toLowerCase();\n      const label2 = preferredLabel.toLowerCase();\n      return label1 == label2;\n    });\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.BufferingObserver');\n\n\n/**\n * The buffering observer watches how much content has been buffered and raises\n * events when the state changes (enough => not enough or vice versa).\n *\n * @final\n */\nshaka.media.BufferingObserver = class {\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  constructor(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /** @private {shaka.media.BufferingObserver.State} */\n    this.previousState_ = State.SATISFIED;\n\n    /** @private {!Map.<shaka.media.BufferingObserver.State, number>} */\n    this.thresholds_ = new Map()\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * @param {number} thresholdWhenStarving\n   * @param {number} thresholdWhenSatisfied\n   */\n  setThresholds(thresholdWhenStarving, thresholdWhenSatisfied) {\n    const State = shaka.media.BufferingObserver.State;\n    this.thresholds_\n        .set(State.SATISFIED, thresholdWhenSatisfied)\n        .set(State.STARVING, thresholdWhenStarving);\n  }\n\n  /**\n   * Update the observer by telling it how much content has been buffered (in\n   * seconds) and if we are buffered to the end of the presentation. If the\n   * controller believes the state has changed, it will return |true|.\n   *\n   * @param {number} bufferLead\n   * @param {boolean} bufferedToEnd\n   * @return {boolean}\n   */\n  update(bufferLead, bufferedToEnd) {\n    const State = shaka.media.BufferingObserver.State;\n\n    /**\n     * Our threshold for how much we need before we declare ourselves as\n     * starving is based on whether or not we were just starving. If we\n     * were just starving, we are more likely to starve again, so we require\n     * more content to be buffered than if we were not just starving.\n     *\n     * @type {number}\n     */\n    const threshold = this.thresholds_.get(this.previousState_);\n\n    const oldState = this.previousState_;\n    const newState = (bufferedToEnd || bufferLead >= threshold) ?\n                     (State.SATISFIED) :\n                     (State.STARVING);\n\n    // Save the new state now so that calls to |getState| from any callbacks\n    // will be accurate.\n    this.previousState_ = newState;\n\n    // Return |true| only when the state has changed.\n    return oldState != newState;\n  }\n\n  /**\n   * Set which state that the observer should think playback was in.\n   *\n   * @param {shaka.media.BufferingObserver.State} state\n   */\n  setState(state) {\n    this.previousState_ = state;\n  }\n\n  /**\n   * Get the state that the observer last thought playback was in.\n   *\n   * @return {shaka.media.BufferingObserver.State}\n   */\n  getState() {\n    return this.previousState_;\n  }\n};\n\n/**\n * Rather than using booleans to communicate what state we are in, we have this\n * enum.\n *\n * @enum {number}\n */\nshaka.media.BufferingObserver.State = {\n  STARVING: 0,\n  SATISFIED: 1,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.config.AutoShowText');\n\n/**\n * @enum {number}\n * @export\n */\nshaka.config.AutoShowText = {\n  /** Never show text automatically on startup. */\n  'NEVER': 0,\n  /** Always show text automatically on startup. */\n  'ALWAYS': 1,\n  /**\n   * Show text automatically on startup if it matches the preferred text\n   * language.\n   */\n  'IF_PREFERRED_TEXT_LANGUAGE': 2,\n  /**\n   * Show text automatically on startup if we think that subtitles may be\n   * needed.  This is specifically if the selected text matches the preferred\n   * text language AND is different from the initial audio language.  (Example:\n   * You prefer English, but the audio is only available in French, so English\n   * subtitles should be enabled by default.)\n   * <br>\n   * This is the default setting.\n   */\n  'IF_SUBTITLES_MAY_BE_NEEDED': 3,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.Backoff');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Backoff represents delay and backoff state.  This is used by NetworkingEngine\n * for individual requests and by StreamingEngine to retry streaming failures.\n *\n * @final\n */\nshaka.net.Backoff = class {\n  /**\n   * @param {shaka.extern.RetryParameters} parameters\n   * @param {boolean=} autoReset  If true, start at a \"first retry\" state and\n   *   and auto-reset that state when we reach maxAttempts.\n   *   Default set to false.\n   */\n  constructor(parameters, autoReset = false) {\n    // Set defaults as we unpack these, so that individual app-level requests in\n    // NetworkingEngine can be missing parameters.\n\n    const defaults = shaka.net.Backoff.defaultRetryParameters();\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.maxAttempts_ = (parameters.maxAttempts == null) ?\n        defaults.maxAttempts : parameters.maxAttempts;\n\n    goog.asserts.assert(this.maxAttempts_ >= 1, 'maxAttempts should be >= 1');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.baseDelay_ = (parameters.baseDelay == null) ?\n        defaults.baseDelay : parameters.baseDelay;\n\n    goog.asserts.assert(this.baseDelay_ >= 0, 'baseDelay should be >= 0');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.fuzzFactor_ = (parameters.fuzzFactor == null) ?\n        defaults.fuzzFactor : parameters.fuzzFactor;\n\n    goog.asserts.assert(this.fuzzFactor_ >= 0, 'fuzzFactor should be >= 0');\n\n    /**\n     * @const\n     * @private {number}\n     */\n    this.backoffFactor_ = (parameters.backoffFactor == null) ?\n        defaults.backoffFactor : parameters.backoffFactor;\n\n    goog.asserts.assert(\n        this.backoffFactor_ >= 0, 'backoffFactor should be >= 0');\n\n    /** @private {number} */\n    this.numAttempts_ = 0;\n\n    /** @private {number} */\n    this.nextUnfuzzedDelay_ = this.baseDelay_;\n\n    /** @private {boolean} */\n    this.autoReset_ = autoReset;\n\n    if (this.autoReset_) {\n      // There is no delay before the first attempt.  In StreamingEngine (the\n      // intended user of auto-reset mode), the first attempt was implied, so we\n      // reset numAttempts to 1.  Therefore maxAttempts (which includes the\n      // first attempt) must be at least 2 for us to see a delay.\n      goog.asserts.assert(this.maxAttempts_ >= 2,\n          'maxAttempts must be >= 2 for autoReset == true');\n      this.numAttempts_ = 1;\n    }\n  }\n\n  /**\n   * @return {!Promise} Resolves when the caller may make an attempt, possibly\n   *   after a delay.  Rejects if no more attempts are allowed.\n   */\n  async attempt() {\n    if (this.numAttempts_ >= this.maxAttempts_) {\n      if (this.autoReset_) {\n        this.reset_();\n      } else {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.PLAYER,\n            shaka.util.Error.Code.ATTEMPTS_EXHAUSTED);\n      }\n    }\n\n    const currentAttempt = this.numAttempts_;\n    this.numAttempts_++;\n\n    if (currentAttempt == 0) {\n      goog.asserts.assert(!this.autoReset_, 'Failed to delay with auto-reset!');\n      return;\n    }\n\n    // We've already tried before, so delay the Promise.\n\n    // Fuzz the delay to avoid tons of clients hitting the server at once\n    // after it recovers from whatever is causing it to fail.\n    const fuzzedDelayMs = shaka.net.Backoff.fuzz_(\n        this.nextUnfuzzedDelay_, this.fuzzFactor_);\n\n    await new Promise((resolve) => {\n      shaka.net.Backoff.defer(fuzzedDelayMs, resolve);\n    });\n\n    // Update delay_ for next time.\n    this.nextUnfuzzedDelay_ *= this.backoffFactor_;\n  }\n\n  /**\n   * Gets a copy of the default retry parameters.\n   *\n   * @return {shaka.extern.RetryParameters}\n   */\n  static defaultRetryParameters() {\n    // Use a function rather than a constant member so the calling code can\n    // modify the values without affecting other call results.\n    return {\n      maxAttempts: 2,\n      baseDelay: 1000,\n      backoffFactor: 2,\n      fuzzFactor: 0.5,\n      timeout: 30000,\n      stallTimeout: 5000,\n      connectionTimeout: 10000,\n    };\n  }\n\n  /**\n   * Fuzz the input value by +/- fuzzFactor.  For example, a fuzzFactor of 0.5\n   * will create a random value that is between 50% and 150% of the input value.\n   *\n   * @param {number} value\n   * @param {number} fuzzFactor\n   * @return {number} The fuzzed value\n   * @private\n   */\n  static fuzz_(value, fuzzFactor) {\n    // A random number between -1 and +1.\n    const negToPosOne = (Math.random() * 2.0) - 1.0;\n\n    // A random number between -fuzzFactor and +fuzzFactor.\n    const negToPosFuzzFactor = negToPosOne * fuzzFactor;\n\n    // The original value, fuzzed by +/- fuzzFactor.\n    return value * (1.0 + negToPosFuzzFactor);\n  }\n\n  /**\n   * Reset state in autoReset mode.\n   * @private\n   */\n  reset_() {\n    goog.asserts.assert(this.autoReset_, 'Should only be used for auto-reset!');\n    this.numAttempts_ = 1;\n    this.nextUnfuzzedDelay_ = this.baseDelay_;\n  }\n\n  /**\n   * This method is only public for testing. It allows us to intercept the\n   * time-delay call.\n   *\n   * @param {number} delayInMs\n   * @param {function()} callback\n   */\n  static defer(delayInMs, callback) {\n    const timer = new shaka.util.Timer(callback);\n    timer.tickAfter(delayInMs / 1000);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.AbortableOperation');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n/**\n * A utility to wrap abortable operations.  Note that these are not cancelable.\n * Cancelation implies undoing what has been done so far, whereas aborting only\n * means that further work is stopped.\n *\n * @implements {shaka.extern.IAbortableOperation.<T>}\n * @template T\n * @export\n */\nshaka.util.AbortableOperation = class {\n  /**\n   * @param {!Promise.<T>} promise\n   *   A Promise which represents the underlying operation.  It is resolved when\n   *   the operation is complete, and rejected if the operation fails or is\n   *   aborted.  Aborted operations should be rejected with a shaka.util.Error\n   *   object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.\n   *   This is not cancelation, and will not necessarily result in any work\n   *   being undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should never\n   *   be rejected.\n   */\n  constructor(promise, onAbort) {\n    /** @const {!Promise.<T>} */\n    this.promise = promise;\n\n    /** @private {function():!Promise} */\n    this.onAbort_ = onAbort;\n\n    /** @private {boolean} */\n    this.aborted_ = false;\n  }\n\n  /**\n   * @param {!shaka.util.Error} error\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error given by the caller.\n   * @export\n   */\n  static failed(error) {\n    return new shaka.util.AbortableOperation(\n        Promise.reject(error),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @return {!shaka.util.AbortableOperation} An operation which has already\n   *   failed with the error OPERATION_ABORTED.\n   * @export\n   */\n  static aborted() {\n    const p = Promise.reject(shaka.util.AbortableOperation.abortError());\n    // Silence uncaught rejection errors, which may otherwise occur any place\n    // we don't explicitly handle aborted operations.\n    p.catch(() => {});\n    return new shaka.util.AbortableOperation(p, () => Promise.resolve());\n  }\n\n  /** @return {!shaka.util.Error} */\n  static abortError() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OPERATION_ABORTED);\n  }\n\n  /**\n   * @param {U} value\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which has already\n   *   completed with the given value.\n   * @template U\n   * @export\n   */\n  static completed(value) {\n    return new shaka.util.AbortableOperation(\n        Promise.resolve(value),\n        () => Promise.resolve());\n  }\n\n  /**\n   * @param {!Promise.<U>} promise\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which cannot be\n   *   aborted.  It will be completed when the given Promise is resolved, or\n   *   will be failed when the given Promise is rejected.\n   * @template U\n   * @export\n   */\n  static notAbortable(promise) {\n    return new shaka.util.AbortableOperation(\n        promise,\n        // abort() here will return a Promise which is resolved when the input\n        // promise either resolves or fails.\n        () => promise.catch(() => {}));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  abort() {\n    this.aborted_ = true;\n    return this.onAbort_();\n  }\n\n  /**\n   * @param {!Array.<!shaka.util.AbortableOperation>} operations\n   * @return {!shaka.util.AbortableOperation} An operation which is resolved\n   *   when all operations are successful and fails when any operation fails.\n   *   For this operation, abort() aborts all given operations.\n   * @export\n   */\n  static all(operations) {\n    return new shaka.util.AbortableOperation(\n        Promise.all(operations.map((op) => op.promise)),\n        () => Promise.all(operations.map((op) => op.abort())));\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  finally(onFinal) {\n    this.promise.then((value) => onFinal(true), (e) => onFinal(false));\n    return this;\n  }\n\n  /**\n   * @param {(undefined|\n   *          function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>)} onSuccess\n   *   A callback to be invoked after this operation is complete, to chain to\n   *   another operation.  The callback can return a plain value, a Promise to\n   *   an asynchronous value, or another AbortableOperation.\n   * @param {function(*)=} onError\n   *   An optional callback to be invoked if this operation fails, to perform\n   *   some cleanup or error handling.  Analogous to the second parameter of\n   *   Promise.prototype.then.\n   * @return {!shaka.util.AbortableOperation.<U>} An operation which is resolved\n   *   when this operation and the operation started by the callback are both\n   *   complete.\n   * @template U\n   * @export\n   */\n  chain(onSuccess, onError) {\n    const newPromise = new shaka.util.PublicPromise();\n    const abortError = shaka.util.AbortableOperation.abortError();\n\n    // If called before \"this\" completes, just abort \"this\".\n    let abort = () => {\n      newPromise.reject(abortError);\n      return this.abort();\n    };\n\n    const makeCallback = (isSuccess) => {\n      return (value) => {\n        if (this.aborted_ && isSuccess) {\n          // If \"this\" is not abortable(), or if abort() is called after \"this\"\n          // is complete but before the next stage in the chain begins, we\n          // should stop right away.\n          newPromise.reject(abortError);\n          return;\n        }\n\n        const cb = isSuccess ? onSuccess : onError;\n        if (!cb) {\n          // No callback?  Pass it along.\n          const next = isSuccess ? newPromise.resolve : newPromise.reject;\n          next(value);\n          return;\n        }\n\n        // Call the callback, interpret the return value, set the Promise state,\n        // and get the next abort function.\n        abort = shaka.util.AbortableOperation.wrapChainCallback_(\n            cb, value, newPromise);\n      };\n    };\n    this.promise.then(makeCallback(true), makeCallback(false));\n\n    return new shaka.util.AbortableOperation(\n        newPromise,\n        // By creating a closure around abort(), we can update the value of\n        // abort() at various stages.\n        () => abort());\n  }\n\n  /**\n   * @param {(function(T):U|\n   *          function(T):!Promise.<U>|\n   *          function(T):!shaka.util.AbortableOperation.<U>|\n   *          function(*))} callback\n   *   A callback to be invoked with the given value.\n   * @param {T} value\n   * @param {!shaka.util.PublicPromise} newPromise The promise for the next\n   *   stage in the chain.\n   * @return {function():!Promise} The next abort() function for the chain.\n   * @private\n   * @template T, U\n   */\n  static wrapChainCallback_(callback, value, newPromise) {\n    try {\n      const ret = callback(value);\n\n      if (ret && ret.promise && ret.abort) {\n        // This is an abortable operation, with its own abort() method.\n        // After this point, abort() should abort the operation from the\n        // callback, and the new promise should be tied to the promise\n        // from the callback's operation.\n        newPromise.resolve(ret.promise);\n        // This used to say \"return ret.abort;\", but it caused subtle issues by\n        // unbinding part of the abort chain.  There is now a test to ensure\n        // that we don't call abort with the wrong \"this\".\n        return () => ret.abort();\n      } else {\n        // This is a Promise or a plain value, and this step cannot be aborted.\n        newPromise.resolve(ret);\n        // Abort is complete when the returned value/Promise is resolved or\n        // fails, but never fails itself nor returns a value.\n        return () => Promise.resolve(ret).then(() => {}, () => {});\n      }\n    } catch (exception) {\n      // The callback threw an exception or error.  Reject the new Promise and\n      // resolve any future abort call right away.\n      newPromise.reject(exception);\n      return () => Promise.resolve();\n    }\n  }\n};\n\n/**\n * @const {!Promise.<T>}\n * @exportInterface\n */\n// eslint-disable-next-line no-restricted-syntax\nshaka.util.AbortableOperation.prototype.promise;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FakeEvent');\n\ngoog.require('goog.asserts');\n\n\n/**\n * @summary Create an Event work-alike object based on the provided dictionary.\n * The event should contain all of the same properties from the dict.\n *\n * @extends {Event}\n * @export\n */\nshaka.util.FakeEvent = class {\n  /**\n   * @param {!Event} event\n   * @return {!shaka.util.FakeEvent}\n   */\n  static fromRealEvent(event) {\n    const fakeEvent = new shaka.util.FakeEvent(event.type);\n    for (const key in event) {\n      Object.defineProperty(fakeEvent, key, {\n        value: event[key],\n        writable: true,\n        enumerable: true,\n      });\n    }\n    return fakeEvent;\n  }\n\n  /**\n   * Allows us to tell the compiler that the dictionary \"map\" is actually a\n   * generic object, for backwards compatibility.\n   * @param {!Map.<string, Object>} dict\n   * @return {!Object}\n   * @suppress {invalidCasts}\n   * @private\n   */\n  static recastDictAsObject_(dict) {\n    goog.asserts.assert(!(dict instanceof Map), 'dict should not be a map');\n    return /** @type {!Object} */ (dict);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Map.<string, Object>=} dict\n   */\n  constructor(type, dict) {\n    if (dict) {\n      if (dict instanceof Map) {\n        // Take properties from dict if present.\n        for (const key of dict.keys()) {\n          Object.defineProperty(this, key, {\n            value: dict.get(key),\n            writable: true,\n            enumerable: true,\n          });\n        }\n      } else {\n        // For backwards compatibility with external apps that may make use of\n        // this public constructor, this should still accept generic objects.\n        const obj = shaka.util.FakeEvent.recastDictAsObject_(dict);\n        for (const key in obj) {\n          Object.defineProperty(this, key, {\n            value: obj[key],\n            writable: true,\n            enumerable: true,\n          });\n        }\n      }\n    }\n\n    // The properties below cannot be set by the dict.  They are all provided\n    // for compatibility with native events.\n\n    /** @const {boolean} */\n    this.bubbles = false;\n\n    /** @type {boolean} */\n    this.cancelable = false;\n\n    /** @type {boolean} */\n    this.defaultPrevented = false;\n\n    /**\n     * According to MDN, Chrome uses high-res timers instead of epoch time.\n     * Follow suit so that timeStamps on FakeEvents use the same base as\n     * on native Events.\n     * @const {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp\n     */\n    this.timeStamp = window.performance && window.performance.now ?\n        window.performance.now() : Date.now();\n\n    /** @const {string} */\n    this.type = type;\n\n    /** @const {boolean} */\n    this.isTrusted = false;\n\n    /** @type {EventTarget} */\n    this.currentTarget = null;\n\n    /** @type {EventTarget} */\n    this.target = null;\n\n    /**\n     * Non-standard property read by FakeEventTarget to stop processing\n     * listeners.\n     * @type {boolean}\n     */\n    this.stopped = false;\n  }\n\n  /**\n   * Prevents the default action of the event.  Has no effect if the event isn't\n   * cancellable.\n   * @override\n   */\n  preventDefault() {\n    if (this.cancelable) {\n      this.defaultPrevented = true;\n    }\n  }\n\n  /**\n   * Stops processing event listeners for this event.  Provided for\n   * compatibility with native Events.\n   * @override\n   */\n  stopImmediatePropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Does nothing, since FakeEvents do not bubble.  Provided for compatibility\n   * with native Events.\n   * @override\n   */\n  stopPropagation() {}\n};\n\n\n/**\n * An internal enum that contains the string values of all of the player events.\n * This exists primarily to act as an implicit list of events, for tests.\n *\n * @enum {string}\n */\nshaka.util.FakeEvent.EventName = {\n  AbrStatusChanged: 'abrstatuschanged',\n  Adaptation: 'adaptation',\n  Buffering: 'buffering',\n  DownloadFailed: 'downloadfailed',\n  DownloadHeadersReceived: 'downloadheadersreceived',\n  DrmSessionUpdate: 'drmsessionupdate',\n  Emsg: 'emsg',\n  Prft: 'prft',\n  Error: 'error',\n  ExpirationUpdated: 'expirationupdated',\n  GapJumped: 'gapjumped',\n  Loaded: 'loaded',\n  Loading: 'loading',\n  ManifestParsed: 'manifestparsed',\n  MediaQualityChanged: 'mediaqualitychanged',\n  Metadata: 'metadata',\n  OnStateChange: 'onstatechange',\n  OnStateIdle: 'onstateidle',\n  RateChange: 'ratechange',\n  SegmentAppended: 'segmentappended',\n  SessionDataEvent: 'sessiondata',\n  StallDetected: 'stalldetected',\n  Streaming: 'streaming',\n  TextChanged: 'textchanged',\n  TextTrackVisibility: 'texttrackvisibility',\n  TimelineRegionAdded: 'timelineregionadded',\n  TimelineRegionEnter: 'timelineregionenter',\n  TimelineRegionExit: 'timelineregionexit',\n  TracksChanged: 'trackschanged',\n  Unloading: 'unloading',\n  VariantChanged: 'variantchanged',\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FakeEventTarget');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary A work-alike for EventTarget.  Only DOM elements may be true\n * EventTargets, but this can be used as a base class to provide event dispatch\n * to non-DOM classes.  Only FakeEvents should be dispatched.\n *\n * @implements {EventTarget}\n * @implements {shaka.util.IReleasable}\n * @exportInterface\n */\nshaka.util.FakeEventTarget = class {\n  /** */\n  constructor() {\n    /**\n     * @private {shaka.util.MultiMap.<shaka.util.FakeEventTarget.ListenerType>}\n     */\n    this.listeners_ = new shaka.util.MultiMap();\n\n    /**\n     * The target of all dispatched events.  Defaults to |this|.\n     * @type {EventTarget}\n     */\n    this.dispatchTarget = this;\n  }\n\n  /**\n   * Add an event listener to this object.\n   *\n   * @param {string} type The event type to listen for.\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to invoke.\n   * @param {(!AddEventListenerOptions|boolean)=} options Ignored.\n   * @override\n   * @exportInterface\n   */\n  addEventListener(type, listener, options) {\n    if (!this.listeners_) {\n      return;\n    }\n    this.listeners_.push(type, listener);\n  }\n\n  /**\n   * Add an event listener to this object that is invoked for all events types\n   * the object fires.\n   *\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to invoke.\n   * @exportInterface\n   */\n  listenToAllEvents(listener) {\n    this.addEventListener(shaka.util.FakeEventTarget.ALL_EVENTS_, listener);\n  }\n\n  /**\n   * Remove an event listener from this object.\n   *\n   * @param {string} type The event type for which you wish to remove a\n   *   listener.\n   * @param {shaka.util.FakeEventTarget.ListenerType} listener The callback or\n   *   listener object to remove.\n   * @param {(EventListenerOptions|boolean)=} options Ignored.\n   * @override\n   * @exportInterface\n   */\n  removeEventListener(type, listener, options) {\n    if (!this.listeners_) {\n      return;\n    }\n    this.listeners_.remove(type, listener);\n  }\n\n  /**\n   * Dispatch an event from this object.\n   *\n   * @param {!Event} event The event to be dispatched from this object.\n   * @return {boolean} True if the default action was prevented.\n   * @override\n   * @exportInterface\n   */\n  dispatchEvent(event) {\n    // In many browsers, it is complex to overwrite properties of actual Events.\n    // Here we expect only to dispatch FakeEvents, which are simpler.\n    goog.asserts.assert(event instanceof shaka.util.FakeEvent,\n        'FakeEventTarget can only dispatch FakeEvents!');\n\n    if (!this.listeners_) {\n      return true;\n    }\n\n    let listeners = this.listeners_.get(event.type) || [];\n    const universalListeners =\n      this.listeners_.get(shaka.util.FakeEventTarget.ALL_EVENTS_);\n    if (universalListeners) {\n      listeners = listeners.concat(universalListeners);\n    }\n\n    // Execute this event on listeners until the event has been stopped or we\n    // run out of listeners.\n    for (const listener of listeners) {\n      // Do this every time, since events can be re-dispatched from handlers.\n      event.target = this.dispatchTarget;\n      event.currentTarget = this.dispatchTarget;\n\n      try {\n        // Check for the |handleEvent| member to test if this is a\n        // |EventListener| instance or a basic function.\n        if (listener.handleEvent) {\n          listener.handleEvent(event);\n        } else {\n          // eslint-disable-next-line no-restricted-syntax\n          listener.call(this, event);\n        }\n      } catch (exception) {\n        // Exceptions during event handlers should not affect the caller,\n        // but should appear on the console as uncaught, according to MDN:\n        // https://mzl.la/2JXgwRo\n        shaka.log.error('Uncaught exception in event handler', exception,\n            exception ? exception.message : null,\n            exception ? exception.stack : null);\n      }\n\n      if (event.stopped) {\n        break;\n      }\n    }\n\n    return event.defaultPrevented;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  release() {\n    this.listeners_ = null;\n  }\n};\n\n/**\n * These are the listener types defined in the closure extern for EventTarget.\n * @typedef {EventListener|function(!Event):*}\n * @exportInterface\n */\nshaka.util.FakeEventTarget.ListenerType;\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.util.FakeEventTarget.ALL_EVENTS_ = 'All';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ObjectUtils');\n\n\nshaka.util.ObjectUtils = class {\n  /**\n   * Performs a deep clone of the given simple object.  This does not copy\n   * prototypes, custom properties (e.g. read-only), or multiple references to\n   * the same object.  If the caller needs these fields, it will need to set\n   * them after this returns.\n   *\n   * @template T\n   * @param {T} arg\n   * @return {T}\n   */\n  static cloneObject(arg) {\n    const seenObjects = new Set();\n    // This recursively clones the value |val|, using the captured variable\n    // |seenObjects| to track the objects we have already cloned.\n    /** @suppress {strictMissingProperties} */\n    const clone = (val) => {\n      switch (typeof val) {\n        case 'undefined':\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'symbol':\n        case 'function':\n          return val;\n        case 'object':\n        default: {\n          // typeof null === 'object'\n          if (!val) {\n            return val;\n          }\n\n          // This covers Uint8Array and friends, even without a TypedArray\n          // base-class constructor.\n          const isTypedArray =\n              val.buffer && val.buffer.constructor == ArrayBuffer;\n          if (isTypedArray) {\n            return val;\n          }\n\n          if (seenObjects.has(val)) {\n            return null;\n          }\n\n          const isArray = val.constructor == Array;\n          if (val.constructor != Object && !isArray) {\n            return null;\n          }\n\n          seenObjects.add(val);\n          const ret = isArray ? [] : {};\n          // Note |name| will equal a number for arrays.\n          for (const name in val) {\n            ret[name] = clone(val[name]);\n          }\n\n          // Length is a non-enumerable property, but we should copy it over in\n          // case it is not the default.\n          if (isArray) {\n            ret.length = val.length;\n          }\n          return ret;\n        }\n      }\n    };\n    return clone(arg);\n  }\n\n  /**\n   * Performs a shallow clone of the given simple object.  This does not copy\n   * prototypes or custom properties (e.g. read-only).\n   *\n   * @template T\n   * @param {T} original\n   * @return {T}\n   */\n  static shallowCloneObject(original) {\n    const clone = /** @type {?} */({});\n    for (const k in original) {\n      clone[k] = original[k];\n    }\n    return clone;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.OperationManager');\n\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * A utility for cleaning up AbortableOperations, to help simplify common\n * patterns and reduce code duplication.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.util.OperationManager = class {\n  /** */\n  constructor() {\n    /** @private {!Array.<!shaka.extern.IAbortableOperation>} */\n    this.operations_ = [];\n  }\n\n  /**\n   * Manage an operation.  This means aborting it on destroy() and removing it\n   * from the management set when it complete.\n   *\n   * @param {!shaka.extern.IAbortableOperation} operation\n   */\n  manage(operation) {\n    this.operations_.push(operation.finally(() => {\n      shaka.util.ArrayUtils.remove(this.operations_, operation);\n    }));\n  }\n\n  /** @override */\n  destroy() {\n    const cleanup = [];\n    for (const op of this.operations_) {\n      // Catch and ignore any failures.  This silences error logs in the\n      // JavaScript console about uncaught Promise failures.\n      op.promise.catch(() => {});\n\n      // Now abort the operation.\n      cleanup.push(op.abort());\n    }\n\n    this.operations_ = [];\n    return Promise.all(cleanup);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.NetworkingEngine');\ngoog.provide('shaka.net.NetworkingEngine.RequestType');\ngoog.provide('shaka.net.NetworkingEngine.PendingRequest');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @event shaka.net.NetworkingEngine.RetryEvent\n * @description Fired when the networking engine receives a recoverable error\n *   and retries.\n * @property {string} type\n *   'retry'\n * @property {?shaka.util.Error} error\n *   The error that caused the retry. If it was a non-Shaka error, this is set\n *   to null.\n * @exportDoc\n */\n\n\n/**\n * NetworkingEngine wraps all networking operations.  This accepts plugins that\n * handle the actual request.  A plugin is registered using registerScheme.\n * Each scheme has at most one plugin to handle the request.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.net.NetworkingEngine = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {function(number, number)=} onProgressUpdated Called when a progress\n   *   event is triggered. Passed the duration, in milliseconds, that the\n   *   request took, and the number of bytes transferred.\n   * @param {shaka.net.NetworkingEngine.OnHeadersReceived=} onHeadersReceived\n   *   Called when the headers are received for a download.\n   * @param {shaka.net.NetworkingEngine.OnDownloadFailed=} onDownloadFailed\n   *   Called when a download fails, for any reason.\n   */\n  constructor(onProgressUpdated, onHeadersReceived, onDownloadFailed) {\n    super();\n\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /** @private {!Set.<shaka.extern.RequestFilter>} */\n    this.requestFilters_ = new Set();\n\n    /** @private {!Set.<shaka.extern.ResponseFilter>} */\n    this.responseFilters_ = new Set();\n\n    /** @private {?function(number, number)} */\n    this.onProgressUpdated_ = onProgressUpdated || null;\n\n    /** @private {?shaka.net.NetworkingEngine.OnHeadersReceived} */\n    this.onHeadersReceived_ = onHeadersReceived || null;\n\n    /** @private {?shaka.net.NetworkingEngine.OnDownloadFailed} */\n    this.onDownloadFailed_ = onDownloadFailed || null;\n\n    /** @private {boolean} */\n    this.forceHTTPS_ = false;\n  }\n\n  /**\n   * @param {boolean} forceHTTPS\n   * @export\n   */\n  setForceHTTPS(forceHTTPS) {\n    this.forceHTTPS_ = forceHTTPS;\n  }\n\n  /**\n   * Registers a scheme plugin.  This plugin will handle all requests with the\n   * given scheme.  If a plugin with the same scheme already exists, it is\n   * replaced, unless the existing plugin is of higher priority.\n   * If no priority is provided, this defaults to the highest priority of\n   * APPLICATION.\n   *\n   * @param {string} scheme\n   * @param {shaka.extern.SchemePlugin} plugin\n   * @param {number=} priority\n   * @param {boolean=} progressSupport\n   * @export\n   */\n  static registerScheme(scheme, plugin, priority, progressSupport = false) {\n    goog.asserts.assert(\n        priority == undefined || priority > 0, 'explicit priority must be > 0');\n    priority =\n        priority || shaka.net.NetworkingEngine.PluginPriority.APPLICATION;\n    const existing = shaka.net.NetworkingEngine.schemes_[scheme];\n    if (!existing || priority >= existing.priority) {\n      shaka.net.NetworkingEngine.schemes_[scheme] = {\n        priority: priority,\n        plugin: plugin,\n        progressSupport: progressSupport,\n      };\n    }\n  }\n\n  /**\n   * Removes a scheme plugin.\n   *\n   * @param {string} scheme\n   * @export\n   */\n  static unregisterScheme(scheme) {\n    delete shaka.net.NetworkingEngine.schemes_[scheme];\n  }\n\n  /**\n   * Registers a new request filter.  All filters are applied in the order they\n   * are registered.\n   *\n   * @param {shaka.extern.RequestFilter} filter\n   * @export\n   */\n  registerRequestFilter(filter) {\n    this.requestFilters_.add(filter);\n  }\n\n  /**\n   * Removes a request filter.\n   *\n   * @param {shaka.extern.RequestFilter} filter\n   * @export\n   */\n  unregisterRequestFilter(filter) {\n    this.requestFilters_.delete(filter);\n  }\n\n  /**\n   * Clears all request filters.\n   *\n   * @export\n   */\n  clearAllRequestFilters() {\n    this.requestFilters_.clear();\n  }\n\n  /**\n   * Registers a new response filter.  All filters are applied in the order they\n   * are registered.\n   *\n   * @param {shaka.extern.ResponseFilter} filter\n   * @export\n   */\n  registerResponseFilter(filter) {\n    this.responseFilters_.add(filter);\n  }\n\n  /**\n   * Removes a response filter.\n   *\n   * @param {shaka.extern.ResponseFilter} filter\n   * @export\n   */\n  unregisterResponseFilter(filter) {\n    this.responseFilters_.delete(filter);\n  }\n\n  /**\n   * Clears all response filters.\n   *\n   * @export\n   */\n  clearAllResponseFilters() {\n    this.responseFilters_.clear();\n  }\n\n  /**\n   * Gets a copy of the default retry parameters.\n   *\n   * @return {shaka.extern.RetryParameters}\n   *\n   * NOTE: The implementation moved to shaka.net.Backoff to avoid a circular\n   * dependency between the two classes.\n   *\n   * @export\n   */\n  static defaultRetryParameters() {\n    return shaka.net.Backoff.defaultRetryParameters();\n  }\n\n  /**\n   * Makes a simple network request for the given URIs.\n   *\n   * @param {!Array.<string>} uris\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @param {?function(BufferSource):!Promise=} streamDataCallback\n   * @return {shaka.extern.Request}\n   * @export\n   */\n  static makeRequest(uris, retryParams, streamDataCallback = null) {\n    return {\n      uris: uris,\n      method: 'GET',\n      body: null,\n      headers: {},\n      allowCrossSiteCredentials: false,\n      retryParameters: retryParams,\n      licenseRequestType: null,\n      sessionId: null,\n      drmInfo: null,\n      initData: null,\n      initDataType: null,\n      streamDataCallback: streamDataCallback,\n    };\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    this.destroyed_ = true;\n    this.requestFilters_.clear();\n    this.responseFilters_.clear();\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n\n    return this.operationManager_.destroy();\n  }\n\n  /**\n   * Makes a network request and returns the resulting data.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @return {!shaka.net.NetworkingEngine.PendingRequest}\n   * @export\n   */\n  request(type, request) {\n    const ObjectUtils = shaka.util.ObjectUtils;\n    const numBytesRemainingObj =\n        new shaka.net.NetworkingEngine.NumBytesRemainingClass();\n\n    // Reject all requests made after destroy is called.\n    if (this.destroyed_) {\n      const p = Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED));\n      // Silence uncaught rejection errors, which may otherwise occur any place\n      // we don't explicitly handle aborted operations.\n      p.catch(() => {});\n      return new shaka.net.NetworkingEngine.PendingRequest(\n          p, () => Promise.resolve(), numBytesRemainingObj);\n    }\n\n    goog.asserts.assert(\n        request.uris && request.uris.length, 'Request without URIs!');\n\n    // If a request comes from outside the library, some parameters may be left\n    // undefined.  To make it easier for application developers, we will fill\n    // them in with defaults if necessary.\n    //\n    // We clone retryParameters and uris so that if a filter modifies the\n    // request, it doesn't contaminate future requests.\n    request.method = request.method || 'GET';\n    request.headers = request.headers || {};\n    request.retryParameters = request.retryParameters ?\n        ObjectUtils.cloneObject(request.retryParameters) :\n        shaka.net.NetworkingEngine.defaultRetryParameters();\n    request.uris = ObjectUtils.cloneObject(request.uris);\n\n    // Apply the registered filters to the request.\n    const requestFilterOperation = this.filterRequest_(type, request);\n    const requestOperation = requestFilterOperation.chain(\n        () => this.makeRequestWithRetry_(type, request, numBytesRemainingObj));\n    const responseFilterOperation = requestOperation.chain(\n        (responseAndGotProgress) =>\n          this.filterResponse_(type, responseAndGotProgress));\n\n    // Keep track of time spent in filters.\n    const requestFilterStartTime = Date.now();\n    let requestFilterMs = 0;\n    requestFilterOperation.promise.then(() => {\n      requestFilterMs = Date.now() - requestFilterStartTime;\n    }, () => {});  // Silence errors in this fork of the Promise chain.\n\n    let responseFilterStartTime = 0;\n    requestOperation.promise.then(() => {\n      responseFilterStartTime = Date.now();\n    }, () => {});  // Silence errors in this fork of the Promise chain.\n\n    const op = responseFilterOperation.chain((responseAndGotProgress) => {\n      const responseFilterMs = Date.now() - responseFilterStartTime;\n      const response = responseAndGotProgress.response;\n      response.timeMs += requestFilterMs;\n      response.timeMs += responseFilterMs;\n      if (!responseAndGotProgress.gotProgress &&\n          this.onProgressUpdated_ &&\n          !response.fromCache &&\n          type == shaka.net.NetworkingEngine.RequestType.SEGMENT) {\n        this.onProgressUpdated_(response.timeMs, response.data.byteLength);\n      }\n      return response;\n    }, (e) => {\n      // Any error thrown from elsewhere should be recategorized as CRITICAL\n      // here.  This is because by the time it gets here, we've exhausted\n      // retries.\n      if (e) {\n        goog.asserts.assert(e instanceof shaka.util.Error, 'Wrong error type');\n        e.severity = shaka.util.Error.Severity.CRITICAL;\n      }\n\n      throw e;\n    });\n\n    // Return the pending request, which carries the response operation, and the\n    // number of bytes remaining to be downloaded, updated by the progress\n    // events.  Add the operation to the manager for later cleanup.\n    const pendingRequest =\n        new shaka.net.NetworkingEngine.PendingRequest(\n            op.promise, () => op.abort(), numBytesRemainingObj);\n    this.operationManager_.manage(pendingRequest);\n    return pendingRequest;\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @return {!shaka.util.AbortableOperation.<undefined>}\n   * @private\n   */\n  filterRequest_(type, request) {\n    let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n\n    for (const requestFilter of this.requestFilters_) {\n      // Request filters are run sequentially.\n      filterOperation = filterOperation.chain(() => {\n        if (request.body) {\n          // TODO: For v4.0 we should remove this or change to always pass a\n          // Uint8Array.  To make it easier for apps to write filters, it may be\n          // better to always pass a Uint8Array so they know what they are\n          // getting; but we shouldn't use ArrayBuffer since that would require\n          // copying buffers if this is a partial view.\n          request.body = shaka.util.BufferUtils.toArrayBuffer(request.body);\n        }\n        return requestFilter(type, request);\n      });\n    }\n\n    // Catch any errors thrown by request filters, and substitute\n    // them with a Shaka-native error.\n    return filterOperation.chain(undefined, (e) => {\n      if (e instanceof shaka.util.Error &&\n          e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        // Don't change anything if the operation was aborted.\n        throw e;\n      }\n\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.REQUEST_FILTER_ERROR, e);\n    });\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *            numBytesRemainingObj\n   * @return {!shaka.extern.IAbortableOperation.<\n   *            shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  makeRequestWithRetry_(type, request, numBytesRemainingObj) {\n    const backoff = new shaka.net.Backoff(\n        request.retryParameters, /* autoReset= */ false);\n    const index = 0;\n    return this.send_(\n        type, request, backoff, index, /* lastError= */ null,\n        numBytesRemainingObj);\n  }\n\n  /**\n   * Sends the given request to the correct plugin and retry using Backoff.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @param {!shaka.net.Backoff} backoff\n   * @param {number} index\n   * @param {?shaka.util.Error} lastError\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *     numBytesRemainingObj\n   * @return {!shaka.extern.IAbortableOperation.<\n   *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  send_(type, request, backoff, index, lastError, numBytesRemainingObj) {\n    if (this.forceHTTPS_) {\n      request.uris[index] = request.uris[index].replace('http://', 'https://');\n    }\n\n    const uri = new goog.Uri(request.uris[index]);\n    let scheme = uri.getScheme();\n    // Whether it got a progress event.\n    let gotProgress = false;\n    if (!scheme) {\n      // If there is no scheme, infer one from the location.\n      scheme = shaka.net.NetworkingEngine.getLocationProtocol_();\n      goog.asserts.assert(\n          scheme[scheme.length - 1] == ':',\n          'location.protocol expected to end with a colon!');\n      // Drop the colon.\n      scheme = scheme.slice(0, -1);\n\n      // Override the original URI to make the scheme explicit.\n      uri.setScheme(scheme);\n      request.uris[index] = uri.toString();\n    }\n\n    // Schemes are meant to be case-insensitive.\n    // See https://github.com/shaka-project/shaka-player/issues/2173\n    // and https://tools.ietf.org/html/rfc3986#section-3.1\n    scheme = scheme.toLowerCase();\n\n    const object = shaka.net.NetworkingEngine.schemes_[scheme];\n    const plugin = object ? object.plugin : null;\n    if (!plugin) {\n      return shaka.util.AbortableOperation.failed(\n          new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.NETWORK,\n              shaka.util.Error.Code.UNSUPPORTED_SCHEME,\n              uri));\n    }\n    const progressSupport = object.progressSupport;\n\n\n    // Every attempt must have an associated backoff.attempt() call so that the\n    // accounting is correct.\n    const backoffOperation =\n        shaka.util.AbortableOperation.notAbortable(backoff.attempt());\n\n    /** @type {?shaka.util.Timer} */\n    let connectionTimer = null;\n\n    /** @type {?shaka.util.Timer} */\n    let stallTimer = null;\n\n    let aborted = false;\n\n    let headersReceivedCalled = false;\n\n    let startTimeMs;\n    const sendOperation = backoffOperation.chain(() => {\n      if (this.destroyed_) {\n        return shaka.util.AbortableOperation.aborted();\n      }\n\n      startTimeMs = Date.now();\n      const segment = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n      const progressUpdated = (time, bytes, numBytesRemaining) => {\n        if (connectionTimer) {\n          connectionTimer.stop();\n        }\n        if (stallTimer) {\n          stallTimer.tickAfter(stallTimeoutMs / 1000);\n        }\n        if (this.onProgressUpdated_ && type == segment) {\n          this.onProgressUpdated_(time, bytes);\n          gotProgress = true;\n          numBytesRemainingObj.setBytes(numBytesRemaining);\n        }\n      };\n      const headersReceived = (headers) => {\n        if (this.onHeadersReceived_) {\n          this.onHeadersReceived_(headers, request, type);\n        }\n        headersReceivedCalled = true;\n      };\n      const requestPlugin = plugin(\n          request.uris[index], request, type, progressUpdated, headersReceived);\n\n      if (!progressSupport) {\n        return requestPlugin;\n      }\n\n      const connectionTimeoutMs = request.retryParameters.connectionTimeout;\n      if (connectionTimeoutMs) {\n        connectionTimer = new shaka.util.Timer(() => {\n          aborted = true;\n          requestPlugin.abort();\n        });\n\n        connectionTimer.tickAfter(connectionTimeoutMs / 1000);\n      }\n\n      const stallTimeoutMs = request.retryParameters.stallTimeout;\n      if (stallTimeoutMs) {\n        stallTimer = new shaka.util.Timer(() => {\n          aborted = true;\n          requestPlugin.abort();\n        });\n      }\n\n      return requestPlugin;\n    }).chain((response) => {\n      if (connectionTimer) {\n        connectionTimer.stop();\n      }\n      if (stallTimer) {\n        stallTimer.stop();\n      }\n      if (response.timeMs == undefined) {\n        response.timeMs = Date.now() - startTimeMs;\n      }\n      const responseAndGotProgress = {\n        response: response,\n        gotProgress: gotProgress,\n      };\n      if (!headersReceivedCalled) {\n        // The plugin did not call headersReceived, perhaps because it is not\n        // able to track that information. So, fire the event manually.\n        if (this.onHeadersReceived_) {\n          this.onHeadersReceived_(response.headers, request, type);\n        }\n      }\n\n      return responseAndGotProgress;\n    }, (error) => {\n      if (connectionTimer) {\n        connectionTimer.stop();\n      }\n      if (stallTimer) {\n        stallTimer.stop();\n      }\n      if (this.onDownloadFailed_) {\n        let shakaError = null;\n        let httpResponseCode = 0;\n        if (error instanceof shaka.util.Error) {\n          shakaError = error;\n          if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n            httpResponseCode = /** @type {number} */ (error.data[1]);\n          }\n        }\n        this.onDownloadFailed_(request, shakaError, httpResponseCode, aborted);\n      }\n      if (this.destroyed_) {\n        return shaka.util.AbortableOperation.aborted();\n      }\n\n      if (aborted) {\n        // It is necessary to change the error code to the correct one because\n        // otherwise the retry logic would not work.\n        error = new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            request.uris[index], type);\n      }\n\n      if (error instanceof shaka.util.Error) {\n        if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n          // Don't change anything if the operation was aborted.\n          throw error;\n        } else if (error.code == shaka.util.Error.Code.ATTEMPTS_EXHAUSTED) {\n          goog.asserts.assert(lastError, 'Should have last error');\n          throw lastError;\n        }\n\n        if (error.severity == shaka.util.Error.Severity.RECOVERABLE) {\n          const data = (new Map()).set('error', error);\n          const event = new shaka.util.FakeEvent('retry', data);\n          this.dispatchEvent(event);\n\n          // Move to the next URI.\n          index = (index + 1) % request.uris.length;\n          return this.send_(\n              type, request, backoff, index, error, numBytesRemainingObj);\n        }\n      }\n\n      // The error was not recoverable, so do not try again.\n      throw error;\n    });\n\n    return sendOperation;\n  }\n\n  /**\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.net.NetworkingEngine.ResponseAndGotProgress}\n   *        responseAndGotProgress\n   * @return {!shaka.extern.IAbortableOperation.<\n   *               shaka.net.NetworkingEngine.ResponseAndGotProgress>}\n   * @private\n   */\n  filterResponse_(type, responseAndGotProgress) {\n    let filterOperation = shaka.util.AbortableOperation.completed(undefined);\n    for (const responseFilter of this.responseFilters_) {\n      // Response filters are run sequentially.\n      filterOperation = filterOperation.chain(() => {\n        const resp = responseAndGotProgress.response;\n        if (resp.data) {\n          // TODO: See TODO in filterRequest_.\n          resp.data = shaka.util.BufferUtils.toArrayBuffer(resp.data);\n        }\n        return responseFilter(type, resp);\n      });\n    }\n    // If successful, return the filtered response with whether it got\n    // progress.\n    return filterOperation.chain(() => {\n      return responseAndGotProgress;\n    }, (e) => {\n      // Catch any errors thrown by request filters, and substitute\n      // them with a Shaka-native error.\n\n      // The error is assumed to be critical if the original wasn't a Shaka\n      // error.\n      let severity = shaka.util.Error.Severity.CRITICAL;\n      if (e instanceof shaka.util.Error) {\n        if (e.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n          // Don't change anything if the operation was aborted.\n          throw e;\n        }\n\n        severity = e.severity;\n      }\n\n      throw new shaka.util.Error(\n          severity,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.RESPONSE_FILTER_ERROR, e);\n    });\n  }\n\n  /**\n   * This is here only for testability.  We can't mock location in our tests on\n   * all browsers, so instead we mock this.\n   *\n   * @return {string} The value of location.protocol.\n   * @private\n   */\n  static getLocationProtocol_() {\n    return location.protocol;\n  }\n};\n\n/**\n * A wrapper class for the number of bytes remaining to be downloaded for the\n * request.\n * Instead of using PendingRequest directly, this class is needed to be sent to\n * plugin as a parameter, and a Promise is returned, before PendingRequest is\n * created.\n *\n * @export\n */\nshaka.net.NetworkingEngine.NumBytesRemainingClass = class {\n  /**\n   * Constructor\n   */\n  constructor() {\n    /** @private {number} */\n    this.bytesToLoad_ = 0;\n  }\n\n  /**\n   * @param {number} bytesToLoad\n   */\n  setBytes(bytesToLoad) {\n    this.bytesToLoad_ = bytesToLoad;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytes() {\n    return this.bytesToLoad_;\n  }\n};\n\n/**\n * A pending network request. This can track the current progress of the\n * download, and allows the request to be aborted if the network is slow.\n *\n * @implements {shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n * @extends {shaka.util.AbortableOperation}\n * @export\n */\nshaka.net.NetworkingEngine.PendingRequest =\nclass extends shaka.util.AbortableOperation {\n  /**\n   * @param {!Promise} promise\n   *   A Promise which represents the underlying operation.  It is resolved\n   *   when the operation is complete, and rejected if the operation fails or\n   *   is aborted.  Aborted operations should be rejected with a\n   *   shaka.util.Error object using the error code OPERATION_ABORTED.\n   * @param {function():!Promise} onAbort\n   *   Will be called by this object to abort the underlying operation.  This\n   *   is not cancelation, and will not necessarily result in any work being\n   *   undone.  abort() should return a Promise which is resolved when the\n   *   underlying operation has been aborted.  The returned Promise should\n   *   never be rejected.\n   * @param {shaka.net.NetworkingEngine.NumBytesRemainingClass}\n   *   numBytesRemainingObj\n   */\n  constructor(promise, onAbort, numBytesRemainingObj) {\n    super(promise, onAbort);\n\n    /** @private {shaka.net.NetworkingEngine.NumBytesRemainingClass} */\n    this.bytesRemaining_ = numBytesRemainingObj;\n  }\n\n  /**\n   * @return {number}\n   */\n  getBytesRemaining() {\n    return this.bytesRemaining_.getBytes();\n  }\n};\n\n/**\n * Request types.  Allows a filter to decide which requests to read/alter.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.RequestType = {\n  'MANIFEST': 0,\n  'SEGMENT': 1,\n  'LICENSE': 2,\n  'APP': 3,\n  'TIMING': 4,\n  'SERVER_CERTIFICATE': 5,\n  'KEY': 6,\n};\n\n\n/**\n * Priority level for network scheme plugins.\n * If multiple plugins are provided for the same scheme, only the\n * highest-priority one is used.\n *\n * @enum {number}\n * @export\n */\nshaka.net.NetworkingEngine.PluginPriority = {\n  'FALLBACK': 1,\n  'PREFERRED': 2,\n  'APPLICATION': 3,\n};\n\n\n/**\n * @typedef {{\n *   plugin: shaka.extern.SchemePlugin,\n *   priority: number,\n *   progressSupport: boolean\n * }}\n * @property {shaka.extern.SchemePlugin} plugin\n *   The associated plugin.\n * @property {number} priority\n *   The plugin's priority.\n * @property {boolean} progressSupport\n *   The plugin's supports progress events\n */\nshaka.net.NetworkingEngine.SchemeObject;\n\n\n/**\n * Contains the scheme plugins.\n *\n * @private {!Object.<string, shaka.net.NetworkingEngine.SchemeObject>}\n */\nshaka.net.NetworkingEngine.schemes_ = {};\n\n/**\n * @typedef {{\n *   response: shaka.extern.Response,\n *   gotProgress: boolean\n * }}\n *\n * @description\n * Defines a response wrapper object, including the response object and whether\n * progress event is fired by the scheme plugin.\n *\n * @property {shaka.extern.Response} response\n * @property {boolean} gotProgress\n * @private\n */\nshaka.net.NetworkingEngine.ResponseAndGotProgress;\n\n\n/**\n * @typedef {function(\n *    !Object.<string, string>,\n *    !shaka.extern.Request,\n *    !shaka.net.NetworkingEngine.RequestType)}\n *\n * @description\n * A callback function that passes the shaka.extern.HeadersReceived along to\n * the player, plus some extra data.\n * @export\n */\nshaka.net.NetworkingEngine.OnHeadersReceived;\n\n\n/**\n * @typedef {function(\n *    !shaka.extern.Request,\n *    ?shaka.util.Error,\n *    number,\n *    boolean)}\n *\n * @description\n * A callback function that notifies the player when a download fails, for any\n * reason (e.g. even if the download was aborted).\n * @export\n */\nshaka.net.NetworkingEngine.OnDownloadFailed;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Destroyer');\n\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * @summary\n * A utility class to help work with |shaka.util.IDestroyable| objects.\n *\n * @final\n */\nshaka.util.Destroyer = class {\n  /**\n   * @param {function():!Promise} callback\n   *    A callback to destroy an object. This callback will only be called once\n   *    regardless of how many times |destroy| is called.\n   */\n  constructor(callback) {\n    /** @private {boolean} */\n    this.destroyed_ = false;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.waitOnDestroy_ = new shaka.util.PublicPromise();\n\n    /** @private {function():!Promise} */\n    this.onDestroy_ = callback;\n  }\n\n  /**\n   * Check if |destroy| has been called. This returning |true| does not mean\n   * that the promise returned by |destroy| has resolved yet.\n   *\n   * @return {boolean}\n   * @final\n   */\n  destroyed() {\n    return this.destroyed_;\n  }\n\n  /**\n   * Request that the destroy callback be called. Will return a promise that\n   * will resolve once the callback terminates. The promise will never be\n   * rejected.\n   *\n   * @return {!Promise}\n   * @final\n   */\n  destroy() {\n    if (this.destroyed_) {\n      return this.waitOnDestroy_;\n    }\n\n    // We have started destroying this object, so we should never get here\n    // again.\n    this.destroyed_ = true;\n\n    return this.onDestroy_().then(\n        () => { this.waitOnDestroy_.resolve(); },\n        () => { this.waitOnDestroy_.resolve(); });\n  }\n\n  /**\n   * Checks if the object is destroyed and throws an error if it is.\n   * @param {*=} error The inner error, if any.\n   */\n  ensureNotDestroyed(error) {\n    if (this.destroyed_) {\n      if (error instanceof shaka.util.Error &&\n          error.code == shaka.util.Error.Code.OBJECT_DESTROYED) {\n        throw error;\n      }\n      throw shaka.util.Destroyer.destroyedError(error);\n    }\n  }\n\n  /**\n   * @param {*=} error The inner error, if any.\n   * @return {!shaka.util.Error}\n   */\n  static destroyedError(error) {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.PLAYER,\n        shaka.util.Error.Code.OBJECT_DESTROYED,\n        error);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.EventManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MultiMap');\n\n\n/**\n * @summary\n * An EventManager maintains a collection of \"event\n * bindings\" between event targets and event listeners.\n *\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.util.EventManager = class {\n  /** */\n  constructor() {\n    /**\n     * Maps an event type to an array of event bindings.\n     * @private {shaka.util.MultiMap.<!shaka.util.EventManager.Binding_>}\n     */\n    this.bindingMap_ = new shaka.util.MultiMap();\n  }\n\n\n  /**\n   * Detaches all event listeners.\n   * @override\n   * @export\n   */\n  release() {\n    this.removeAll();\n    this.bindingMap_ = null;\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listen(target, type, listener, options) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const binding =\n        new shaka.util.EventManager.Binding_(target, type, listener, options);\n    this.bindingMap_.push(type, binding);\n  }\n\n\n  /**\n   * Attaches an event listener to an event target.  The listener will be\n   * removed when the first instance of the event is fired.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   * @export\n   */\n  listenOnce(target, type, listener, options) {\n    // Install a shim listener that will stop listening after the first event.\n    const shim = (event) => {\n      // Stop listening to this event.\n      this.unlisten(target, type, shim);\n      // Call the original listener.\n      listener(event);\n    };\n    this.listen(target, type, shim, options);\n  }\n\n\n  /**\n   * Detaches an event listener from an event target.\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType=} listener The event listener.\n   * @export\n   */\n  unlisten(target, type, listener) {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.get(type) || [];\n\n    for (const binding of list) {\n      if (binding.target == target) {\n        if (listener == binding.listener || !listener) {\n          binding.unlisten();\n          this.bindingMap_.remove(type, binding);\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Detaches all event listeners from all targets.\n   * @export\n   */\n  removeAll() {\n    if (!this.bindingMap_) {\n      return;\n    }\n\n    const list = this.bindingMap_.getAll();\n\n    for (const binding of list) {\n      binding.unlisten();\n    }\n\n    this.bindingMap_.clear();\n  }\n};\n\n\n/**\n * @typedef {function(!Event)}\n * @export\n */\nshaka.util.EventManager.ListenerType;\n\n\n/**\n * Creates a new Binding_ and attaches the event listener to the event target.\n *\n * @private\n */\nshaka.util.EventManager.Binding_ = class {\n  /**\n   * @param {EventTarget} target The event target.\n   * @param {string} type The event type.\n   * @param {shaka.util.EventManager.ListenerType} listener The event listener.\n   * @param {(boolean|!AddEventListenerOptions)=} options An object that\n   *    specifies characteristics about the event listener.\n   *    The passive option, if true, indicates that this function will never\n   *    call preventDefault(), which improves scrolling performance.\n   */\n  constructor(target, type, listener, options) {\n    /** @type {EventTarget} */\n    this.target = target;\n\n    /** @type {string} */\n    this.type = type;\n\n    /** @type {?shaka.util.EventManager.ListenerType} */\n    this.listener = listener;\n\n    /** @type {(boolean|!AddEventListenerOptions)} */\n    this.options =\n        shaka.util.EventManager.Binding_.convertOptions_(target, options);\n\n    this.target.addEventListener(type, listener, this.options);\n  }\n\n\n  /**\n   * Detaches the event listener from the event target. This does nothing if\n   * the event listener is already detached.\n   */\n  unlisten() {\n    goog.asserts.assert(this.target, 'Missing target');\n    this.target.removeEventListener(this.type, this.listener, this.options);\n\n    this.target = null;\n    this.listener = null;\n    this.options = false;\n  }\n\n  /**\n   * Converts the provided options value into a value accepted by the browser.\n   * Some browsers (e.g. Tizen) don't support passing options as an\n   * object.  So this detects this case and converts it.\n   *\n   * @param {EventTarget} target\n   * @param {(boolean|!AddEventListenerOptions)=} value\n   * @return {(boolean|!AddEventListenerOptions)}\n   * @private\n   */\n  static convertOptions_(target, value) {\n    if (value == undefined) {\n      return false;\n    } else if (typeof value == 'boolean') {\n      return value;\n    } else {\n      // Ignore the 'passive' option since it is just an optimization and\n      // doesn't affect behavior.  Assert there aren't any other settings to\n      // ensure we don't have different behavior on different browsers by\n      // ignoring an important option.\n      const ignored = new Set(['passive', 'capture']);\n      const keys = Object.keys(value).filter((k) => !ignored.has(k));\n      goog.asserts.assert(\n          keys.length == 0,\n          'Unsupported flag(s) to addEventListener: ' + keys.join(','));\n\n      const supports =\n          shaka.util.EventManager.Binding_.doesSupportObject_(target);\n      if (supports) {\n        return value;\n      } else {\n        return value['capture'] || false;\n      }\n    }\n  }\n\n  /**\n   * Checks whether the browser supports passing objects as the third argument\n   * to addEventListener.  This caches the result value in a static field to\n   * avoid a bunch of checks.\n   *\n   * @param {EventTarget} target\n   * @return {boolean}\n   * @private\n   */\n  static doesSupportObject_(target) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n    let supports = shaka.util.EventManager.Binding_.supportsObject_;\n    if (supports == undefined) {\n      supports = false;\n      try {\n        const options = {};\n        // This defines a getter that will set this variable if called.  So if\n        // the browser gets this property, it supports using an object.  If the\n        // browser doesn't get these fields, it won't support objects.\n        const prop = {\n          get: () => {\n            supports = true;\n            return false;\n          },\n        };\n        Object.defineProperty(options, 'passive', prop);\n        Object.defineProperty(options, 'capture', prop);\n\n        const call = () => {};\n        target.addEventListener('test', call, options);\n        target.removeEventListener('test', call, options);\n      } catch (e) {\n        supports = false;\n      }\n      shaka.util.EventManager.Binding_.supportsObject_ = supports;\n    }\n    return supports || false;  // \"false\" fallback needed for compiler.\n  }\n};\n\n/** @private {(boolean|undefined)} */\nshaka.util.EventManager.Binding_.supportsObject_ = undefined;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Iterables');\n\n\n/**\n * Recreations of Array-like functions so that they work on any iterable\n * type.\n * @final\n */\nshaka.util.Iterables = class {\n  /**\n   * @param {!Iterable.<FROM>} iterable\n   * @param {function(FROM):TO} mapping\n   * @return {!Iterable.<TO>}\n   * @template FROM,TO\n   */\n  static map(iterable, mapping) {\n    const array = [];\n    for (const x of iterable) {\n      array.push(mapping(x));\n    }\n    return array;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static every(iterable, test) {\n    for (const x of iterable) {\n      if (!test(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} test\n   * @return {boolean}\n   * @template T\n   */\n  static some(iterable, test) {\n    for (const x of iterable) {\n      if (test(x)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate over an iterable object and return only the items that |filter|\n   * returns true for.\n   *\n   * @param {!Iterable.<T>} iterable\n   * @param {function(T):boolean} filter\n   * @return {!Array.<T>}\n   * @template T\n   */\n  static filter(iterable, filter) {\n    const out = [];\n    for (const x of iterable) {\n      if (filter(x)) {\n        out.push(x);\n      }\n    }\n    return out;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MapUtils');\n\n\n/**\n * @summary A set of map/object utility functions.\n */\nshaka.util.MapUtils = class {\n  /**\n   * @param {!Object.<KEY, VALUE>} object\n   * @return {!Map.<KEY, VALUE>}\n   * @template KEY,VALUE\n   */\n  static asMap(object) {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n      map.set(key, object[key]);\n    }\n\n    return map;\n  }\n\n\n  /**\n   * @param {!Map.<KEY, VALUE>} map\n   * @return {!Object.<KEY, VALUE>}\n   * @template KEY,VALUE\n   */\n  static asObject(map) {\n    const obj = {};\n    map.forEach((value, key) => {\n      obj[key] = value;\n    });\n\n    return obj;\n  }\n\n  /**\n   * NOTE: This only works for simple value types and\n   * will not be accurate if map values are objects!\n   *\n   * @param {Map.<KEY, VALUE>} map1\n   * @param {Map.<KEY, VALUE>} map2\n   * @return {boolean}\n   * @template KEY,VALUE\n   */\n  static hasSameElements(map1, map2) {\n    if (!map1 && !map2) {\n      return true;\n    } else if (map1 && !map2) {\n      return false;\n    } else if (map2 && !map1) {\n      return false;\n    }\n\n    if (map1.size != map2.size) {\n      return false;\n    }\n\n    for (const [key, val] of map1) {\n      if (!map2.has(key)) {\n        return false;\n      }\n\n      const val2 = map2.get(key);\n      if (val2 != val || (val2 == undefined)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.DataViewReader');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n  * @summary DataViewReader abstracts a DataView object.\n  * @export\n  */\nshaka.util.DataViewReader = class {\n  /**\n   * @param {BufferSource} data\n   * @param {shaka.util.DataViewReader.Endianness} endianness The endianness.\n   */\n  constructor(data, endianness) {\n    /** @private {!DataView} */\n    this.dataView_ = shaka.util.BufferUtils.toDataView(data);\n\n    /** @private {boolean} */\n    this.littleEndian_ =\n        endianness == shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN;\n\n    /** @private {number} */\n    this.position_ = 0;\n  }\n\n\n  /** @return {!DataView} The underlying DataView instance. */\n  getDataView() {\n    return this.dataView_;\n  }\n\n\n  /**\n   * @return {boolean} True if the reader has more data, false otherwise.\n   * @export\n   */\n  hasMoreData() {\n    return this.position_ < this.dataView_.byteLength;\n  }\n\n\n  /**\n   * Gets the current byte position.\n   * @return {number}\n   * @export\n   */\n  getPosition() {\n    return this.position_;\n  }\n\n\n  /**\n   * Gets the byte length of the DataView.\n   * @return {number}\n   * @export\n   */\n  getLength() {\n    return this.dataView_.byteLength;\n  }\n\n\n  /**\n   * Reads an unsigned 8 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint8() {\n    try {\n      const value = this.dataView_.getUint8(this.position_);\n      this.position_ += 1;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 16 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint16() {\n    try {\n      const value =\n          this.dataView_.getUint16(this.position_, this.littleEndian_);\n      this.position_ += 2;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 32 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint32() {\n    try {\n      const value =\n          this.dataView_.getUint32(this.position_, this.littleEndian_);\n      this.position_ += 4;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads a signed 32 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readInt32() {\n    try {\n      const value = this.dataView_.getInt32(this.position_, this.littleEndian_);\n      this.position_ += 4;\n      return value;\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n  }\n\n\n  /**\n   * Reads an unsigned 64 bit integer, and advances the reader.\n   * @return {number} The integer.\n   * @export\n   */\n  readUint64() {\n    /** @type {number} */\n    let low;\n    /** @type {number} */\n    let high;\n\n    try {\n      if (this.littleEndian_) {\n        low = this.dataView_.getUint32(this.position_, true);\n        high = this.dataView_.getUint32(this.position_ + 4, true);\n      } else {\n        high = this.dataView_.getUint32(this.position_, false);\n        low = this.dataView_.getUint32(this.position_ + 4, false);\n      }\n    } catch (exception) {\n      throw this.outOfBounds_();\n    }\n\n    if (high > 0x1FFFFF) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    this.position_ += 8;\n\n    // NOTE: This is subtle, but in JavaScript you can't shift left by 32\n    // and get the full range of 53-bit values possible.\n    // You must multiply by 2^32.\n    return (high * Math.pow(2, 32)) + low;\n  }\n\n\n  /**\n   * Reads the specified number of raw bytes.\n   * @param {number} bytes The number of bytes to read.\n   * @return {!Uint8Array}\n   * @export\n   */\n  readBytes(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.readBytes');\n    if (this.position_ + bytes > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n\n    const value =\n        shaka.util.BufferUtils.toUint8(this.dataView_, this.position_, bytes);\n    this.position_ += bytes;\n    return value;\n  }\n\n\n  /**\n   * Skips the specified number of bytes.\n   * @param {number} bytes The number of bytes to skip.\n   * @export\n   */\n  skip(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.skip');\n    if (this.position_ + bytes > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n    this.position_ += bytes;\n  }\n\n\n  /**\n   * Rewinds the specified number of bytes.\n   * @param {number} bytes The number of bytes to rewind.\n   * @export\n   */\n  rewind(bytes) {\n    goog.asserts.assert(bytes >= 0, 'Bad call to DataViewReader.rewind');\n    if (this.position_ < bytes) {\n      throw this.outOfBounds_();\n    }\n    this.position_ -= bytes;\n  }\n\n\n  /**\n   * Seeks to a specified position.\n   * @param {number} position The desired byte position within the DataView.\n   * @export\n   */\n  seek(position) {\n    goog.asserts.assert(position >= 0, 'Bad call to DataViewReader.seek');\n    if (position < 0 || position > this.dataView_.byteLength) {\n      throw this.outOfBounds_();\n    }\n    this.position_ = position;\n  }\n\n\n  /**\n   * Keeps reading until it reaches a byte that equals to zero.  The text is\n   * assumed to be UTF-8.\n   * @return {string}\n   * @export\n   */\n  readTerminatedString() {\n    const start = this.position_;\n    while (this.hasMoreData()) {\n      const value = this.dataView_.getUint8(this.position_);\n      if (value == 0) {\n        break;\n      }\n      this.position_ += 1;\n    }\n\n    const ret = shaka.util.BufferUtils.toUint8(\n        this.dataView_, start, this.position_ - start);\n    // Skip string termination.\n    this.position_ += 1;\n    return shaka.util.StringUtils.fromUTF8(ret);\n  }\n\n\n  /**\n   * @return {!shaka.util.Error}\n   * @private\n   */\n  outOfBounds_() {\n    return new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n  }\n};\n\n/**\n * Endianness.\n * @enum {number}\n * @export\n */\nshaka.util.DataViewReader.Endianness = {\n  'BIG_ENDIAN': 0,\n  'LITTLE_ENDIAN': 1,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Mp4Parser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\n\n\n/**\n * @export\n */\nshaka.util.Mp4Parser = class {\n  /** */\n  constructor() {\n    /** @private {!Object.<number, shaka.util.Mp4Parser.BoxType_>} */\n    this.headers_ = [];\n\n    /** @private {!Object.<number, !shaka.util.Mp4Parser.CallbackType>} */\n    this.boxDefinitions_ = [];\n\n    /** @private {boolean} */\n    this.done_ = false;\n  }\n\n\n  /**\n   * Declare a box type as a Box.\n   *\n   * @param {string} type\n   * @param {!shaka.util.Mp4Parser.CallbackType} definition\n   * @return {!shaka.util.Mp4Parser}\n   * @export\n   */\n  box(type, definition) {\n    const typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n    this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.BASIC_BOX;\n    this.boxDefinitions_[typeCode] = definition;\n    return this;\n  }\n\n\n  /**\n   * Declare a box type as a Full Box.\n   *\n   * @param {string} type\n   * @param {!shaka.util.Mp4Parser.CallbackType} definition\n   * @return {!shaka.util.Mp4Parser}\n   * @export\n   */\n  fullBox(type, definition) {\n    const typeCode = shaka.util.Mp4Parser.typeFromString_(type);\n    this.headers_[typeCode] = shaka.util.Mp4Parser.BoxType_.FULL_BOX;\n    this.boxDefinitions_[typeCode] = definition;\n    return this;\n  }\n\n\n  /**\n   * Stop parsing.  Useful for extracting information from partial segments and\n   * avoiding an out-of-bounds error once you find what you are looking for.\n   *\n   * @export\n   */\n  stop() {\n    this.done_ = true;\n  }\n\n\n  /**\n   * Parse the given data using the added callbacks.\n   *\n   * @param {!BufferSource} data\n   * @param {boolean=} partialOkay If true, allow reading partial payloads\n   *   from some boxes. If the goal is a child box, we can sometimes find it\n   *   without enough data to find all child boxes.\n   * @param {boolean=} stopOnPartial If true, stop reading if an incomplete\n   *   box is detected.\n   * @export\n   */\n  parse(data, partialOkay, stopOnPartial) {\n    const reader = new shaka.util.DataViewReader(\n        data, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    this.done_ = false;\n    while (reader.hasMoreData() && !this.done_) {\n      this.parseNext(0, reader, partialOkay, stopOnPartial);\n    }\n  }\n\n\n  /**\n   * Parse the next box on the current level.\n   *\n   * @param {number} absStart The absolute start position in the original\n   *   byte array.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {boolean=} partialOkay If true, allow reading partial payloads\n   *   from some boxes. If the goal is a child box, we can sometimes find it\n   *   without enough data to find all child boxes.\n   * @param {boolean=} stopOnPartial If true, stop reading if an incomplete\n   *   box is detected.\n   * @export\n   */\n  parseNext(absStart, reader, partialOkay, stopOnPartial) {\n    const start = reader.getPosition();\n\n    // size(4 bytes) + type(4 bytes) = 8 bytes\n    if (stopOnPartial && start + 8 > reader.getLength()) {\n      this.done_ = true;\n      return;\n    }\n\n    let size = reader.readUint32();\n    const type = reader.readUint32();\n    const name = shaka.util.Mp4Parser.typeToString(type);\n    let has64BitSize = false;\n    shaka.log.v2('Parsing MP4 box', name);\n\n    switch (size) {\n      case 0:\n        size = reader.getLength() - start;\n        break;\n      case 1:\n        if (stopOnPartial && reader.getPosition() + 8 > reader.getLength()) {\n          this.done_ = true;\n          return;\n        }\n        size = reader.readUint64();\n        has64BitSize = true;\n        break;\n    }\n\n    const boxDefinition = this.boxDefinitions_[type];\n\n    if (boxDefinition) {\n      let version = null;\n      let flags = null;\n\n      if (this.headers_[type] == shaka.util.Mp4Parser.BoxType_.FULL_BOX) {\n        if (stopOnPartial && reader.getPosition() + 4 > reader.getLength()) {\n          this.done_ = true;\n          return;\n        }\n        const versionAndFlags = reader.readUint32();\n        version = versionAndFlags >>> 24;\n        flags = versionAndFlags & 0xFFFFFF;\n      }\n\n      // Read the whole payload so that the current level can be safely read\n      // regardless of how the payload is parsed.\n      let end = start + size;\n      if (partialOkay && end > reader.getLength()) {\n        // For partial reads, truncate the payload if we must.\n        end = reader.getLength();\n      }\n\n      if (stopOnPartial && end > reader.getLength()) {\n        this.done_ = true;\n        return;\n      }\n      const payloadSize = end - reader.getPosition();\n      const payload =\n      (payloadSize > 0) ? reader.readBytes(payloadSize) : new Uint8Array(0);\n\n      const payloadReader = new shaka.util.DataViewReader(\n          payload, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n      /** @type {shaka.extern.ParsedBox} */\n      const box = {\n        name,\n        parser: this,\n        partialOkay: partialOkay || false,\n        version,\n        flags,\n        reader: payloadReader,\n        size,\n        start: start + absStart,\n        has64BitSize,\n      };\n\n      boxDefinition(box);\n    } else {\n      // Move the read head to be at the end of the box.\n      // If the box is longer than the remaining parts of the file, e.g. the\n      // mp4 is improperly formatted, or this was a partial range request that\n      // ended in the middle of a box, just skip to the end.\n      const skipLength = Math.min(\n          start + size - reader.getPosition(),\n          reader.getLength() - reader.getPosition());\n      reader.skip(skipLength);\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a series\n   * of boxes. The number of boxes is limited by the size of the parent box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static children(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  The header size varies.\n    const headerSize = shaka.util.Mp4Parser.headerSize(box);\n    while (box.reader.hasMoreData() && !box.parser.done_) {\n      box.parser.parseNext(box.start + headerSize, box.reader, box.partialOkay);\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a sample\n   * description. A sample description box has a fixed number of children. The\n   * number of children is represented by a 4 byte unsigned integer. Each child\n   * is a box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static sampleDescription(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  The header size varies.\n    const headerSize = shaka.util.Mp4Parser.headerSize(box);\n    const count = box.reader.readUint32();\n    for (let i = 0; i < count; i++) {\n      box.parser.parseNext(box.start + headerSize, box.reader, box.partialOkay);\n      if (box.parser.done_) {\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * A callback that tells the Mp4 parser to treat the body of a box as a visual\n   * sample entry.  A visual sample entry has some fixed-sized fields\n   * describing the video codec parameters, followed by an arbitrary number of\n   * appended children.  Each child is a box.\n   *\n   * @param {!shaka.extern.ParsedBox} box\n   * @export\n   */\n  static visualSampleEntry(box) {\n    // The \"reader\" starts at the payload, so we need to add the header to the\n    // start position.  The header size varies.\n    const headerSize = shaka.util.Mp4Parser.headerSize(box);\n\n    // Skip 6 reserved bytes.\n    // Skip 2-byte data reference index.\n    // Skip 16 more reserved bytes.\n    // Skip 4 bytes for width/height.\n    // Skip 8 bytes for horizontal/vertical resolution.\n    // Skip 4 more reserved bytes (0)\n    // Skip 2-byte frame count.\n    // Skip 32-byte compressor name (length byte, then name, then 0-padding).\n    // Skip 2-byte depth.\n    // Skip 2 more reserved bytes (0xff)\n    // 78 bytes total.\n    // See also https://github.com/shaka-project/shaka-packager/blob/d5ca6e84/packager/media/formats/mp4/box_definitions.cc#L1544\n    box.reader.skip(78);\n\n    while (box.reader.hasMoreData() && !box.parser.done_) {\n      box.parser.parseNext(box.start + headerSize, box.reader, box.partialOkay);\n    }\n  }\n\n\n  /**\n   * Create a callback that tells the Mp4 parser to treat the body of a box as a\n   * binary blob and to parse the body's contents using the provided callback.\n   *\n   * @param {function(!Uint8Array)} callback\n   * @return {!shaka.util.Mp4Parser.CallbackType}\n   * @export\n   */\n  static allData(callback) {\n    return (box) => {\n      const all = box.reader.getLength() - box.reader.getPosition();\n      callback(box.reader.readBytes(all));\n    };\n  }\n\n\n  /**\n   * Convert an ascii string name to the integer type for a box.\n   *\n   * @param {string} name The name of the box. The name must be four\n   *                      characters long.\n   * @return {number}\n   * @private\n   */\n  static typeFromString_(name) {\n    goog.asserts.assert(\n        name.length == 4,\n        'Mp4 box names must be 4 characters long');\n\n    let code = 0;\n    for (const chr of name) {\n      code = (code << 8) | chr.charCodeAt(0);\n    }\n    return code;\n  }\n\n\n  /**\n   * Convert an integer type from a box into an ascii string name.\n   * Useful for debugging.\n   *\n   * @param {number} type The type of the box, a uint32.\n   * @return {string}\n   * @export\n   */\n  static typeToString(type) {\n    const name = String.fromCharCode(\n        (type >> 24) & 0xff,\n        (type >> 16) & 0xff,\n        (type >> 8) & 0xff,\n        type & 0xff);\n    return name;\n  }\n\n  /**\n   * Find the header size of the box.\n   * Useful for modifying boxes in place or finding the exact offset of a field.\n   *\n   * @param {shaka.extern.ParsedBox} box\n   * @return {number}\n   * @export\n   */\n  static headerSize(box) {\n    const basicHeaderSize = 8;\n    const _64BitFieldSize = box.has64BitSize ? 8 : 0;\n    const versionAndFlagsSize = box.flags != null ? 4 : 0;\n    return basicHeaderSize + _64BitFieldSize + versionAndFlagsSize;\n  }\n};\n\n\n/**\n * @typedef {function(!shaka.extern.ParsedBox)}\n * @exportInterface\n */\nshaka.util.Mp4Parser.CallbackType;\n\n\n/**\n * An enum used to track the type of box so that the correct values can be\n * read from the header.\n *\n * @enum {number}\n * @private\n */\nshaka.util.Mp4Parser.BoxType_ = {\n  BASIC_BOX: 0,\n  FULL_BOX: 1,\n};\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Pssh');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary\n * Parse a PSSH box and extract the system IDs.\n */\nshaka.util.Pssh = class {\n  /**\n   * @param {!Uint8Array} psshBox\n   */\n  constructor(psshBox) {\n    /**\n     * In hex.\n     * @type {!Array.<string>}\n     */\n    this.systemIds = [];\n\n    /**\n     * In hex.\n     * @type {!Array.<string>}\n     */\n    this.cencKeyIds = [];\n\n    /**\n     * Array with the pssh boxes found.\n     * @type {!Array.<!Uint8Array>}\n     */\n    this.data = [];\n\n    new shaka.util.Mp4Parser()\n        .box('moov', shaka.util.Mp4Parser.children)\n        .box('moof', shaka.util.Mp4Parser.children)\n        .fullBox('pssh', (box) => this.parsePsshBox_(box))\n        .parse(psshBox);\n\n    if (this.data.length == 0) {\n      shaka.log.v2('No pssh box found!');\n    }\n  }\n\n\n  /**\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   */\n  parsePsshBox_(box) {\n    goog.asserts.assert(\n        box.version != null,\n        'PSSH boxes are full boxes and must have a valid version');\n\n    goog.asserts.assert(\n        box.flags != null,\n        'PSSH boxes are full boxes and must have a valid flag');\n\n    if (box.version > 1) {\n      shaka.log.warning('Unrecognized PSSH version found!');\n      return;\n    }\n\n    // The \"reader\" gives us a view on the payload of the box.  Create a new\n    // view that contains the whole box.\n    const dataView = box.reader.getDataView();\n    goog.asserts.assert(\n        dataView.byteOffset >= 12, 'DataView at incorrect position');\n    const pssh = shaka.util.BufferUtils.toUint8(dataView, -12, box.size);\n    this.data.push(pssh);\n\n    this.systemIds.push(\n        shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16)));\n    if (box.version > 0) {\n      const numKeyIds = box.reader.readUint32();\n      for (let i = 0; i < numKeyIds; i++) {\n        const keyId =\n            shaka.util.Uint8ArrayUtils.toHex(box.reader.readBytes(16));\n        this.cencKeyIds.push(keyId);\n      }\n    }\n  }\n\n  /**\n   * Creates a pssh blob from the given system ID, data, keyIds and version.\n   *\n   * @param {!Uint8Array} data\n   * @param {!Uint8Array} systemId\n   * @param {!Set.<string>} keyIds\n   * @param {number} version\n   * @return {!Uint8Array}\n   */\n  static createPssh(data, systemId, keyIds, version) {\n    goog.asserts.assert(systemId.byteLength == 16, 'Invalid system ID length');\n    const dataLength = data.length;\n    let psshSize = 0x4 + 0x4 + 0x4 + systemId.length + 0x4 + dataLength;\n    if (version > 0) {\n      psshSize += 0x4 + (16 * keyIds.size);\n    }\n\n    /** @type {!Uint8Array} */\n    const psshBox = new Uint8Array(psshSize);\n    /** @type {!DataView} */\n    const psshData = shaka.util.BufferUtils.toDataView(psshBox);\n\n    let byteCursor = 0;\n    psshData.setUint32(byteCursor, psshSize);\n    byteCursor += 0x4;\n    psshData.setUint32(byteCursor, 0x70737368);  // 'pssh'\n    byteCursor += 0x4;\n    (version < 1) ? psshData.setUint32(byteCursor, 0) :\n        psshData.setUint32(byteCursor, 0x01000000); // version + flags\n    byteCursor += 0x4;\n    psshBox.set(systemId, byteCursor);\n    byteCursor += systemId.length;\n\n    // if version > 0, add KID count and kid values.\n    if (version > 0) {\n      psshData.setUint32(byteCursor, keyIds.size); // KID_count\n      byteCursor += 0x4;\n      const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n      for (const keyId of keyIds) {\n        const KID = Uint8ArrayUtils.fromHex(keyId);\n        psshBox.set(KID, byteCursor);\n        byteCursor += KID.length;\n      }\n    }\n\n    psshData.setUint32(byteCursor, dataLength);\n    byteCursor += 0x4;\n    psshBox.set(data, byteCursor);\n    byteCursor += dataLength;\n\n    goog.asserts.assert(byteCursor === psshSize, 'PSSH invalid length.');\n    return psshBox;\n  }\n\n\n  /**\n   * Normalise the initData array. This is to apply browser specific\n   * work-arounds, e.g. removing duplicates which appears to occur\n   * intermittently when the native msneedkey event fires (i.e. event.initData\n   * contains dupes).\n   *\n   * @param {!Uint8Array} initData\n   * @return {!Uint8Array}\n   */\n  static normaliseInitData(initData) {\n    if (!initData) {\n      return initData;\n    }\n\n    const pssh = new shaka.util.Pssh(initData);\n\n    // If there is only a single pssh, return the original array.\n    if (pssh.data.length <= 1) {\n      return initData;\n    }\n\n    // Dedupe psshData.\n    /** @type {!Array.<!Uint8Array>} */\n    const dedupedInitDatas = [];\n    for (const initData of pssh.data) {\n      const found = dedupedInitDatas.some((x) => {\n        return shaka.util.BufferUtils.equal(x, initData);\n      });\n\n      if (!found) {\n        dedupedInitDatas.push(initData);\n      }\n    }\n\n    return shaka.util.Uint8ArrayUtils.concat(...dedupedInitDatas);\n  }\n};\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.XmlUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A set of XML utility functions.\n */\nshaka.util.XmlUtils = class {\n  /**\n   * Finds a child XML element.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} name The child XML element's tag name.\n   * @return {Element} The child XML element, or null if a child XML element\n   *   does not exist with the given tag name OR if there exists more than one\n   *   child XML element with the given tag name.\n   */\n  static findChild(elem, name) {\n    const children = shaka.util.XmlUtils.findChildren(elem, name);\n    if (children.length != 1) {\n      return null;\n    }\n    return children[0];\n  }\n\n\n  /**\n   * Finds a namespace-qualified child XML element.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} ns The child XML element's namespace URI.\n   * @param {string} name The child XML element's local name.\n   * @return {Element} The child XML element, or null if a child XML element\n   *   does not exist with the given tag name OR if there exists more than one\n   *   child XML element with the given tag name.\n   */\n  static findChildNS(elem, ns, name) {\n    const children = shaka.util.XmlUtils.findChildrenNS(elem, ns, name);\n    if (children.length != 1) {\n      return null;\n    }\n    return children[0];\n  }\n\n\n  /**\n   * Finds child XML elements.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} name The child XML element's tag name.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static findChildren(elem, name) {\n    const found = [];\n    for (const child of elem.childNodes) {\n      if (child instanceof Element && child.tagName == name) {\n        found.push(child);\n      }\n    }\n    return found;\n  }\n\n\n  /**\n   * @param {!Node} elem the parent XML element.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static getChildren(elem) {\n    return Array.from(elem.childNodes).filter((child) => {\n      return child instanceof Element;\n    });\n  }\n\n\n  /**\n   * Finds namespace-qualified child XML elements.\n   * @param {!Node} elem The parent XML element.\n   * @param {string} ns The child XML element's namespace URI.\n   * @param {string} name The child XML element's local name.\n   * @return {!Array.<!Element>} The child XML elements.\n   */\n  static findChildrenNS(elem, ns, name) {\n    const found = [];\n    for (const child of elem.childNodes) {\n      if (child instanceof Element && child.localName == name &&\n          child.namespaceURI == ns) {\n        found.push(child);\n      }\n    }\n    return found;\n  }\n\n\n  /**\n   * Gets a namespace-qualified attribute.\n   * @param {!Element} elem The element to get from.\n   * @param {string} ns The namespace URI.\n   * @param {string} name The local name of the attribute.\n   * @return {?string} The attribute's value, or null if not present.\n   */\n  static getAttributeNS(elem, ns, name) {\n    // Some browsers return the empty string when the attribute is missing,\n    // so check if it exists first.  See: https://mzl.la/2L7F0UK\n    return elem.hasAttributeNS(ns, name) ? elem.getAttributeNS(ns, name) : null;\n  }\n\n\n  /**\n   * Gets a namespace-qualified attribute.\n   * @param {!Element} elem The element to get from.\n   * @param {!Array.<string>} nsList The lis of namespace URIs.\n   * @param {string} name The local name of the attribute.\n   * @return {?string} The attribute's value, or null if not present.\n   */\n  static getAttributeNSList(elem, nsList, name) {\n    // Some browsers return the empty string when the attribute is missing,\n    // so check if it exists first.  See: https://mzl.la/2L7F0UK\n    for (const ns of nsList) {\n      if (elem.hasAttributeNS(ns, name)) {\n        return elem.getAttributeNS(ns, name);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Gets the text contents of a node.\n   * @param {!Node} elem The XML element.\n   * @return {?string} The text contents, or null if there are none.\n   */\n  static getContents(elem) {\n    const XmlUtils = shaka.util.XmlUtils;\n    if (!Array.from(elem.childNodes).every(XmlUtils.isText)) {\n      return null;\n    }\n\n    // Read merged text content from all text nodes.\n    return elem.textContent.trim();\n  }\n\n  /**\n   * Checks if a node is of type text.\n   * @param {!Node} elem The XML element.\n   * @return {boolean} True if it is a text node.\n   */\n  static isText(elem) {\n    return elem.nodeType == Node.TEXT_NODE ||\n        elem.nodeType == Node.CDATA_SECTION_NODE;\n  }\n\n  /**\n   * Parses an attribute by its name.\n   * @param {!Element} elem The XML element.\n   * @param {string} name The attribute name.\n   * @param {function(string): (T|null)} parseFunction A function that parses\n   *   the attribute.\n   * @param {(T|null)=} defaultValue The attribute's default value, if not\n   *   specified, the attibute's default value is null.\n   * @return {(T|null)} The parsed attribute on success, or the attribute's\n   *   default value if the attribute does not exist or could not be parsed.\n   * @template T\n   */\n  static parseAttr(\n      elem, name, parseFunction, defaultValue = null) {\n    let parsedValue = null;\n\n    const value = elem.getAttribute(name);\n    if (value != null) {\n      parsedValue = parseFunction(value);\n    }\n    return parsedValue == null ? defaultValue : parsedValue;\n  }\n\n\n  /**\n   * Parses an XML date string.\n   * @param {string} dateString\n   * @return {?number} The parsed date in seconds on success; otherwise, return\n   *   null.\n   */\n  static parseDate(dateString) {\n    if (!dateString) {\n      return null;\n    }\n\n    // Times in the manifest should be in UTC. If they don't specify a timezone,\n    // Date.parse() will use the local timezone instead of UTC.  So manually add\n    // the timezone if missing ('Z' indicates the UTC timezone).\n    // Format: YYYY-MM-DDThh:mm:ss.ssssss\n    if (/^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/.test(dateString)) {\n      dateString += 'Z';\n    }\n\n    const result = Date.parse(dateString);\n    return isNaN(result) ? null : (result / 1000.0);\n  }\n\n\n  /**\n   * Parses an XML duration string.\n   * Negative values are not supported. Years and months are treated as exactly\n   * 365 and 30 days respectively.\n   * @param {string} durationString The duration string, e.g., \"PT1H3M43.2S\",\n   *   which means 1 hour, 3 minutes, and 43.2 seconds.\n   * @return {?number} The parsed duration in seconds on success; otherwise,\n   *   return null.\n   * @see {@link http://www.datypic.com/sc/xsd/t-xsd_duration.html}\n   */\n  static parseDuration(durationString) {\n    if (!durationString) {\n      return null;\n    }\n\n    const re = '^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?' +\n             '(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$';\n    const matches = new RegExp(re).exec(durationString);\n\n    if (!matches) {\n      shaka.log.warning('Invalid duration string:', durationString);\n      return null;\n    }\n\n    // Note: Number(null) == 0 but Number(undefined) == NaN.\n    const years = Number(matches[1] || null);\n    const months = Number(matches[2] || null);\n    const days = Number(matches[3] || null);\n    const hours = Number(matches[4] || null);\n    const minutes = Number(matches[5] || null);\n    const seconds = Number(matches[6] || null);\n\n    // Assume a year always has 365 days and a month always has 30 days.\n    const d = (60 * 60 * 24 * 365) * years +\n            (60 * 60 * 24 * 30) * months +\n            (60 * 60 * 24) * days +\n            (60 * 60) * hours +\n            60 * minutes +\n            seconds;\n    return isFinite(d) ? d : null;\n  }\n\n\n  /**\n   * Parses a range string.\n   * @param {string} rangeString The range string, e.g., \"101-9213\".\n   * @return {?{start: number, end: number}} The parsed range on success;\n   *   otherwise, return null.\n   */\n  static parseRange(rangeString) {\n    const matches = /([0-9]+)-([0-9]+)/.exec(rangeString);\n\n    if (!matches) {\n      return null;\n    }\n\n    const start = Number(matches[1]);\n    if (!isFinite(start)) {\n      return null;\n    }\n\n    const end = Number(matches[2]);\n    if (!isFinite(end)) {\n      return null;\n    }\n\n    return {start: start, end: end};\n  }\n\n\n  /**\n   * Parses an integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed integer on success; otherwise, return null.\n   */\n  static parseInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a positive integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed positive integer on success; otherwise,\n   *   return null.\n   */\n  static parsePositiveInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) && (n > 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a non-negative integer.\n   * @param {string} intString The integer string.\n   * @return {?number} The parsed non-negative integer on success; otherwise,\n   *   return null.\n   */\n  static parseNonNegativeInt(intString) {\n    const n = Number(intString);\n    return (n % 1 === 0) && (n >= 0) ? n : null;\n  }\n\n\n  /**\n   * Parses a floating point number.\n   * @param {string} floatString The floating point number string.\n   * @return {?number} The parsed floating point number on success; otherwise,\n   *   return null. May return -Infinity or Infinity.\n   */\n  static parseFloat(floatString) {\n    const n = Number(floatString);\n    return !isNaN(n) ? n : null;\n  }\n\n\n  /**\n   * Evaluate a division expressed as a string.\n   * @param {string} exprString\n   *   The expression to evaluate, e.g. \"200/2\". Can also be a single number.\n   * @return {?number} The evaluated expression as floating point number on\n   *   success; otherwise return null.\n   */\n  static evalDivision(exprString) {\n    let res;\n    let n;\n    if ((res = exprString.match(/^(\\d+)\\/(\\d+)$/))) {\n      n = Number(res[1]) / Number(res[2]);\n    } else {\n      n = Number(exprString);\n    }\n    return !isNaN(n) ? n : null;\n  }\n\n\n  /**\n   * Parse a string and return the resulting root element if it was valid XML.\n   *\n   * @param {string} xmlString\n   * @param {string} expectedRootElemName\n   * @return {Element}\n   */\n  static parseXmlString(xmlString, expectedRootElemName) {\n    const parser = new DOMParser();\n    const unsafeXmlString =\n        shaka.util.XmlUtils.trustedHTMLFromString_.value()(xmlString);\n    let unsafeXml = null;\n    try {\n      unsafeXml = parser.parseFromString(unsafeXmlString, 'text/xml');\n    } catch (exception) {\n      shaka.log.error('XML parsing exception:', exception);\n      return null;\n    }\n\n    // According to MDN, parseFromString never returns null.\n    goog.asserts.assert(unsafeXml, 'Parsed XML document cannot be null!');\n\n    // Check for empty documents.\n    const rootElem = unsafeXml.documentElement;\n    if (!rootElem) {\n      shaka.log.error('XML document was empty!');\n      return null;\n    }\n\n    // Check for parser errors.\n    const parserErrorElements = rootElem.getElementsByTagName('parsererror');\n    if (parserErrorElements.length) {\n      shaka.log.error('XML parser error found:', parserErrorElements[0]);\n      return null;\n    }\n\n    // The top-level element in the loaded XML should have the name we expect.\n    if (rootElem.tagName != expectedRootElemName) {\n      shaka.log.error(\n          `XML tag name does not match expected \"${expectedRootElemName}\":`,\n          rootElem.tagName);\n      return null;\n    }\n\n    // SECURITY: Verify that the document does not contain elements from the\n    // HTML or SVG namespaces, which could trigger script execution and XSS.\n    const iterator = document.createNodeIterator(\n        unsafeXml,\n        NodeFilter.SHOW_ALL,\n    );\n    let currentNode;\n    while (currentNode = iterator.nextNode()) {\n      if (currentNode instanceof HTMLElement ||\n          currentNode instanceof SVGElement) {\n        shaka.log.error('XML document embeds unsafe content!');\n        return null;\n      }\n    }\n\n    return rootElem;\n  }\n\n\n  /**\n   * Parse some UTF8 data and return the resulting root element if\n   * it was valid XML.\n   * @param {BufferSource} data\n   * @param {string} expectedRootElemName\n   * @return {Element}\n   */\n  static parseXml(data, expectedRootElemName) {\n    try {\n      const string = shaka.util.StringUtils.fromUTF8(data);\n      return shaka.util.XmlUtils.parseXmlString(string, expectedRootElemName);\n    } catch (exception) {\n      shaka.log.error('parseXmlString threw!', exception);\n      return null;\n    }\n  }\n};\n\n/**\n * Promote a string to TrustedHTML. This function is security-sensitive and\n * should only be used with security approval where the string is guaranteed not\n * to cause an XSS vulnerability.\n *\n * @private {!shaka.util.Lazy.<function(!string): (!TrustedHTML|!string)>}\n */\nshaka.util.XmlUtils.trustedHTMLFromString_ = new shaka.util.Lazy(() => {\n  if (typeof trustedTypes !== 'undefined') {\n    // Create a Trusted Types policy for promoting the string to TrustedHTML.\n    // The Lazy wrapper ensures this policy is only created once.\n    const policy = trustedTypes.createPolicy('shaka-player#xml', {\n      createHTML: (s) => s,\n    });\n    return (s) => policy.createHTML(s);\n  }\n  // Fall back to strings in environments that don't support Trusted Types.\n  return (s) => s;\n});\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.DrmEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StreamUtils');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/** @implements {shaka.util.IDestroyable} */\nshaka.media.DrmEngine = class {\n  /**\n   * @param {shaka.media.DrmEngine.PlayerInterface} playerInterface\n   * @param {number=} updateExpirationTime\n   */\n  constructor(playerInterface, updateExpirationTime = 1) {\n    /** @private {?shaka.media.DrmEngine.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {!Set.<string>} */\n    this.supportedTypes_ = new Set();\n\n    /** @private {MediaKeys} */\n    this.mediaKeys_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = null;\n\n    /** @private {boolean} */\n    this.initialized_ = false;\n\n    /** @private {boolean} */\n    this.initializedForStorage_ = false;\n\n    /** @private {number} */\n    this.licenseTimeSeconds_ = 0;\n\n    /** @private {?shaka.extern.DrmInfo} */\n    this.currentDrmInfo_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /**\n     * @private {!Map.<MediaKeySession,\n     *           shaka.media.DrmEngine.SessionMetaData>}\n     */\n    this.activeSessions_ = new Map();\n\n    /** @private {!Array.<string>} */\n    this.offlineSessionIds_ = [];\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.allSessionsLoaded_ = new shaka.util.PublicPromise();\n\n    /** @private {?shaka.extern.DrmConfiguration} */\n    this.config_ = null;\n\n    /** @private {function(!shaka.util.Error)} */\n    this.onError_ = (err) => {\n      this.allSessionsLoaded_.reject(err);\n      playerInterface.onError(err);\n    };\n\n    /**\n     * The most recent key status information we have.\n     * We may not have announced this information to the outside world yet,\n     * which we delay to batch up changes and avoid spurious \"missing key\"\n     * errors.\n     * @private {!Map.<string, string>}\n     */\n    this.keyStatusByKeyId_ = new Map();\n\n    /**\n     * The key statuses most recently announced to other classes.\n     * We may have more up-to-date information being collected in\n     * this.keyStatusByKeyId_, which has not been batched up and released yet.\n     * @private {!Map.<string, string>}\n     */\n    this.announcedKeyStatusByKeyId_ = new Map();\n\n    /** @private {shaka.util.Timer} */\n    this.keyStatusTimer_ =\n        new shaka.util.Timer(() => this.processKeyStatusChanges_());\n\n    /** @private {boolean} */\n    this.usePersistentLicenses_ = false;\n\n    /** @private {!Array.<!MediaKeyMessageEvent>} */\n    this.mediaKeyMessageEvents_ = [];\n\n    /** @private {boolean} */\n    this.initialRequestsSent_ = false;\n\n    /** @private {?shaka.util.Timer} */\n    this.expirationTimer_ = new shaka.util.Timer(() => {\n      this.pollExpiration_();\n    }).tickEvery(/* seconds= */ updateExpirationTime);\n\n    // Add a catch to the Promise to avoid console logs about uncaught errors.\n    const noop = () => {};\n    this.allSessionsLoaded_.catch(noop);\n\n    /** @const {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.destroyNow_());\n\n    /** @private {boolean} */\n    this.srcEquals_ = false;\n\n    /** @private {Promise} */\n    this.mediaKeysAttached_ = null;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * Destroy this instance of DrmEngine. This assumes that all other checks\n   * about \"if it should\" have passed.\n   *\n   * @private\n   */\n  async destroyNow_() {\n    // |eventManager_| should only be |null| after we call |destroy|. Destroy it\n    // first so that we will stop responding to events.\n    this.eventManager_.release();\n    this.eventManager_ = null;\n\n    // Since we are destroying ourselves, we don't want to react to the \"all\n    // sessions loaded\" event.\n    this.allSessionsLoaded_.reject();\n\n    // Stop all timers. This will ensure that they do not start any new work\n    // while we are destroying ourselves.\n    this.expirationTimer_.stop();\n    this.expirationTimer_ = null;\n\n    this.keyStatusTimer_.stop();\n    this.keyStatusTimer_ = null;\n\n    // Close all open sessions.\n    await this.closeOpenSessions_();\n\n    // |video_| will be |null| if we never attached to a video element.\n    if (this.video_) {\n      goog.asserts.assert(!this.video_.src, 'video src must be removed first!');\n\n      try {\n        await this.video_.setMediaKeys(null);\n      } catch (error) {\n        // Ignore any failures while removing media keys from the video element.\n      }\n\n      this.video_ = null;\n    }\n\n    // Break references to everything else we hold internally.\n    this.currentDrmInfo_ = null;\n    this.supportedTypes_.clear();\n    this.mediaKeys_ = null;\n    this.offlineSessionIds_ = [];\n    this.config_ = null;\n    this.onError_ = () => {};\n    this.playerInterface_ = null;\n    this.srcEquals_ = false;\n    this.mediaKeysAttached_ = null;\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes.\n   * Must be called at least once before init().\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * @param {!boolean} value\n   */\n  setSrcEquals(value) {\n    this.srcEquals_ = value;\n  }\n\n  /**\n   * Initialize the drm engine for storing and deleting stored content.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that are going to be stored.\n   * @param {boolean} usePersistentLicenses\n   *    Whether or not persistent licenses should be requested and stored for\n   *    |manifest|.\n   * @return {!Promise}\n   */\n  initForStorage(variants, usePersistentLicenses) {\n    this.initializedForStorage_ = true;\n    // There are two cases for this call:\n    //  1. We are about to store a manifest - in that case, there are no offline\n    //     sessions and therefore no offline session ids.\n    //  2. We are about to remove the offline sessions for this manifest - in\n    //     that case, we don't need to know about them right now either as\n    //     we will be told which ones to remove later.\n    this.offlineSessionIds_ = [];\n\n    // What we really need to know is whether or not they are expecting to use\n    // persistent licenses.\n    this.usePersistentLicenses_ = usePersistentLicenses;\n\n    return this.init_(variants);\n  }\n\n  /**\n   * Initialize the drm engine for playback operations.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that we want to support playing.\n   * @param {!Array.<string>} offlineSessionIds\n   * @return {!Promise}\n   */\n  initForPlayback(variants, offlineSessionIds) {\n    this.offlineSessionIds_ = offlineSessionIds;\n    this.usePersistentLicenses_ = offlineSessionIds.length > 0;\n\n    return this.init_(variants);\n  }\n\n  /**\n   * Initializes the drm engine for removing persistent sessions.  Only the\n   * removeSession(s) methods will work correctly, creating new sessions may not\n   * work as desired.\n   *\n   * @param {string} keySystem\n   * @param {string} licenseServerUri\n   * @param {Uint8Array} serverCertificate\n   * @param {!Array.<MediaKeySystemMediaCapability>} audioCapabilities\n   * @param {!Array.<MediaKeySystemMediaCapability>} videoCapabilities\n   * @return {!Promise}\n   */\n  initForRemoval(keySystem, licenseServerUri, serverCertificate,\n      audioCapabilities, videoCapabilities) {\n    /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n    const configsByKeySystem = new Map();\n\n    /** @type {MediaKeySystemConfiguration} */\n    const config = {\n      audioCapabilities: audioCapabilities,\n      videoCapabilities: videoCapabilities,\n      distinctiveIdentifier: 'optional',\n      persistentState: 'required',\n      sessionTypes: ['persistent-license'],\n      label: keySystem,  // Tracked by us, ignored by EME.\n    };\n\n    // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n    config['drmInfos'] = [{  // Non-standard attribute, ignored by EME.\n      keySystem: keySystem,\n      licenseServerUri: licenseServerUri,\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: true,\n      audioRobustness: '',  // Not required by queryMediaKeys_\n      videoRobustness: '',  // Same\n      serverCertificate: serverCertificate,\n      serverCertificateUri: '',\n      initData: null,\n      keyIds: null,\n    }];\n\n    configsByKeySystem.set(keySystem, config);\n    return this.queryMediaKeys_(configsByKeySystem,\n        /* variants= */ []);\n  }\n\n  /**\n   * Negotiate for a key system and set up MediaKeys.\n   * This will assume that both |usePersistentLicences_| and\n   * |offlineSessionIds_| have been properly set.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   *    The variants that we expect to operate with during the drm engine's\n   *    lifespan of the drm engine.\n   * @return {!Promise} Resolved if/when a key system has been chosen.\n   * @private\n   */\n  async init_(variants) {\n    goog.asserts.assert(this.config_,\n        'DrmEngine configure() must be called before init()!');\n\n    // ClearKey config overrides the manifest DrmInfo if present. The variants\n    // are modified so that filtering in Player still works.\n    // This comes before hadDrmInfo because it influences the value of that.\n    /** @type {?shaka.extern.DrmInfo} */\n    const clearKeyDrmInfo = this.configureClearKey_();\n    if (clearKeyDrmInfo) {\n      for (const variant of variants) {\n        if (variant.video) {\n          variant.video.drmInfos = [clearKeyDrmInfo];\n        }\n        if (variant.audio) {\n          variant.audio.drmInfos = [clearKeyDrmInfo];\n        }\n      }\n    }\n\n    const hadDrmInfo = variants.some((variant) => {\n      if (variant.video && variant.video.drmInfos.length) {\n        return true;\n      }\n      if (variant.audio && variant.audio.drmInfos.length) {\n        return true;\n      }\n      return false;\n    });\n\n    // When preparing to play live streams, it is possible that we won't know\n    // about some upcoming encrypted content. If we initialize the drm engine\n    // with no key systems, we won't be able to play when the encrypted content\n    // comes.\n    //\n    // To avoid this, we will set the drm engine up to work with as many key\n    // systems as possible so that we will be ready.\n    if (!hadDrmInfo) {\n      const servers = shaka.util.MapUtils.asMap(this.config_.servers);\n      shaka.media.DrmEngine.replaceDrmInfo_(variants, servers);\n    }\n\n    // Make sure all the drm infos are valid and filled in correctly.\n    for (const variant of variants) {\n      const drmInfos = this.getVariantDrmInfos_(variant);\n      for (const info of drmInfos) {\n        shaka.media.DrmEngine.fillInDrmInfoDefaults_(\n            info,\n            shaka.util.MapUtils.asMap(this.config_.servers),\n            shaka.util.MapUtils.asMap(this.config_.advanced || {}),\n            this.config_.keySystemsMapping);\n      }\n    }\n\n    /** @type {!Map.<string, MediaKeySystemConfiguration>} */\n    let configsByKeySystem;\n\n    // We should get the decodingInfo results for the variants after we filling\n    // in the drm infos, and before queryMediaKeys_().\n    await shaka.util.StreamUtils.getDecodingInfosForVariants(variants,\n        this.usePersistentLicenses_, this.srcEquals_);\n\n    const hasDrmInfo = hadDrmInfo || Object.keys(this.config_.servers).length;\n    // An unencrypted content is initialized.\n    if (!hasDrmInfo) {\n      this.initialized_ = true;\n      return Promise.resolve();\n    }\n\n    const p = this.queryMediaKeys_(configsByKeySystem, variants);\n\n    // TODO(vaage): Look into the assertion below. If we do not have any drm\n    // info, we create drm info so that content can play if it has drm info\n    // later.\n    // However it is okay if we fail to initialize? If we fail to initialize,\n    // it means we won't be able to play the later-encrypted content, which is\n    // not okay.\n\n    // If the content did not originally have any drm info, then it doesn't\n    // matter if we fail to initialize the drm engine, because we won't need it\n    // anyway.\n    return hadDrmInfo ? p : p.catch(() => {});\n  }\n\n  /**\n   * Attach MediaKeys to the video element\n   * @return {Promise}\n   * @private\n   */\n  async attachMediaKeys_() {\n    if (this.video_.mediaKeys) {\n      return;\n    }\n\n    // An attach process has already started, let's wait it out\n    if (this.mediaKeysAttached_) {\n      await this.mediaKeysAttached_;\n\n      this.destroyer_.ensureNotDestroyed();\n      return;\n    }\n\n    try {\n      this.mediaKeysAttached_ = this.video_.setMediaKeys(this.mediaKeys_);\n\n      await this.mediaKeysAttached_;\n    } catch (exception) {\n      goog.asserts.assert(exception instanceof Error, 'Wrong error type!');\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO,\n          exception.message));\n    }\n\n    this.destroyer_.ensureNotDestroyed();\n  }\n\n  /**\n   * Processes encrypted event and start licence challenging\n   * @return {!Promise}\n   * @private\n   */\n  async onEncryptedEvent_(event) {\n    /**\n     * MediaKeys should be added when receiving an encrypted event. Setting\n     * mediaKeys before could result into encrypted event not being fired on\n     * some browsers\n     */\n    await this.attachMediaKeys_();\n\n    this.newInitData(\n        event.initDataType,\n        shaka.util.BufferUtils.toUint8(event.initData));\n  }\n\n  /**\n   * Start processing events.\n   * @param {HTMLMediaElement} video\n   * @return {!Promise}\n   */\n  async attach(video) {\n    if (!this.mediaKeys_) {\n      // Unencrypted, or so we think.  We listen for encrypted events in order\n      // to warn when the stream is encrypted, even though the manifest does\n      // not know it.\n      // Don't complain about this twice, so just listenOnce().\n      // FIXME: This is ineffective when a prefixed event is translated by our\n      // polyfills, since those events are only caught and translated by a\n      // MediaKeys instance.  With clear content and no polyfilled MediaKeys\n      // instance attached, you'll never see the 'encrypted' event on those\n      // platforms (Safari).\n      this.eventManager_.listenOnce(video, 'encrypted', (event) => {\n        this.onError_(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO));\n      });\n      return;\n    }\n\n    this.video_ = video;\n\n    this.eventManager_.listenOnce(this.video_, 'play', () => this.onPlay_());\n    if ('webkitCurrentPlaybackTargetIsWireless' in this.video_) {\n      this.eventManager_.listen(this.video_,\n          'webkitcurrentplaybacktargetiswirelesschanged',\n          () => this.closeOpenSessions_());\n    }\n\n    const manifestInitData = this.currentDrmInfo_.initData.find(\n        (initDataOverride) => initDataOverride.initData.length > 0);\n\n    /**\n     * We can attach media keys before the playback actually begins when:\n     *  - If we are not using FairPlay Modern EME\n     *  - Some initData already has been generated (through the manifest)\n     *  - In case of an offline session\n     */\n    if (manifestInitData ||\n        this.currentDrmInfo_.keySystem !== 'com.apple.fps' ||\n        this.offlineSessionIds_.length) {\n      await this.attachMediaKeys_();\n    }\n\n    this.createOrLoad();\n\n    // Explicit init data for any one stream or an offline session is\n    // sufficient to suppress 'encrypted' events for all streams.\n    // Also suppress 'encrypted' events when parsing in-band ppsh\n    // from media segments because that serves the same purpose as the\n    // 'encrypted' events.\n    if (!manifestInitData && !this.offlineSessionIds_.length &&\n        !this.config_.parseInbandPsshEnabled) {\n      this.eventManager_.listen(\n          this.video_, 'encrypted', (e) => this.onEncryptedEvent_(e));\n    }\n  }\n\n  /**\n   * Sets the server certificate based on the current DrmInfo.\n   *\n   * @return {!Promise}\n   */\n  async setServerCertificate() {\n    goog.asserts.assert(this.initialized_,\n        'Must call init() before setServerCertificate');\n\n    if (!this.mediaKeys_ || !this.currentDrmInfo_) {\n      return;\n    }\n\n    if (this.currentDrmInfo_.serverCertificateUri &&\n       (!this.currentDrmInfo_.serverCertificate ||\n       !this.currentDrmInfo_.serverCertificate.length)) {\n      const request = shaka.net.NetworkingEngine.makeRequest(\n          [this.currentDrmInfo_.serverCertificateUri],\n          this.config_.retryParameters);\n\n      try {\n        const operation = this.playerInterface_.netEngine.request(\n            shaka.net.NetworkingEngine.RequestType.SERVER_CERTIFICATE,\n            request);\n        const response = await operation.promise;\n\n        this.currentDrmInfo_.serverCertificate =\n          shaka.util.BufferUtils.toUint8(response.data);\n      } catch (error) {\n        // Request failed!\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong NetworkingEngine error type!');\n\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.SERVER_CERTIFICATE_REQUEST_FAILED,\n            error);\n      }\n\n      if (this.destroyer_.destroyed()) {\n        return;\n      }\n    }\n\n    if (!this.currentDrmInfo_.serverCertificate ||\n        !this.currentDrmInfo_.serverCertificate.length) {\n      return;\n    }\n\n    try {\n      const supported = await this.mediaKeys_.setServerCertificate(\n          this.currentDrmInfo_.serverCertificate);\n\n      if (!supported) {\n        shaka.log.warning('Server certificates are not supported by the ' +\n                          'key system.  The server certificate has been ' +\n                          'ignored.');\n      }\n    } catch (exception) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE,\n          exception.message);\n    }\n  }\n\n  /**\n   * Remove an offline session and delete it's data. This can only be called\n   * after a successful call to |init|. This will wait until the\n   * 'license-release' message is handled. The returned Promise will be rejected\n   * if there is an error releasing the license.\n   *\n   * @param {string} sessionId\n   * @return {!Promise}\n   */\n  async removeSession(sessionId) {\n    goog.asserts.assert(this.mediaKeys_,\n        'Must call init() before removeSession');\n\n    const session = await this.loadOfflineSession_(sessionId);\n\n    // This will be null on error, such as session not found.\n    if (!session) {\n      shaka.log.v2('Ignoring attempt to remove missing session', sessionId);\n      return;\n    }\n\n    // TODO: Consider adding a timeout to get the 'message' event.\n    // Note that the 'message' event will get raised after the remove()\n    // promise resolves.\n    const tasks = [];\n\n    const found = this.activeSessions_.get(session);\n    if (found) {\n      // This will force us to wait until the 'license-release' message has been\n      // handled.\n      found.updatePromise = new shaka.util.PublicPromise();\n      tasks.push(found.updatePromise);\n    }\n\n    shaka.log.v2('Attempting to remove session', sessionId);\n    tasks.push(session.remove());\n\n    await Promise.all(tasks);\n    this.activeSessions_.delete(session);\n  }\n\n  /**\n   * Creates the sessions for the init data and waits for them to become ready.\n   *\n   * @return {!Promise}\n   */\n  createOrLoad() {\n    // Create temp sessions.\n    const initDatas =\n        (this.currentDrmInfo_ ? this.currentDrmInfo_.initData : []) || [];\n    for (const initDataOverride of initDatas) {\n      this.newInitData(\n          initDataOverride.initDataType, initDataOverride.initData);\n    }\n\n    // Load each session.\n    for (const sessionId of this.offlineSessionIds_) {\n      this.loadOfflineSession_(sessionId);\n    }\n\n    // If we have no sessions, we need to resolve the promise right now or else\n    // it will never get resolved.\n    if (!initDatas.length && !this.offlineSessionIds_.length) {\n      this.allSessionsLoaded_.resolve();\n    }\n\n    return this.allSessionsLoaded_;\n  }\n\n  /**\n   * Called when new initialization data is encountered.  If this data hasn't\n   * been seen yet, this will create a new session for it.\n   *\n   * @param {string} initDataType\n   * @param {!Uint8Array} initData\n   */\n  newInitData(initDataType, initData) {\n    if (!initData.length) {\n      return;\n    }\n\n    // Suppress duplicate init data.\n    // Note that some init data are extremely large and can't portably be used\n    // as keys in a dictionary.\n\n    const metadatas = this.activeSessions_.values();\n    for (const metadata of metadatas) {\n      // Tizen 2015 and 2016 models will send multiple webkitneedkey events\n      // with the same init data. If the duplicates are supressed, playback\n      // will stall without errors.\n      if (shaka.util.BufferUtils.equal(initData, metadata.initData) &&\n          !shaka.util.Platform.isTizen2()) {\n        shaka.log.debug('Ignoring duplicate init data.');\n        return;\n      }\n    }\n\n    // If there are pre-existing sessions that have all been loaded\n    // then reset the allSessionsLoaded_ promise, which can now be\n    // used to wait for new sesssions to be loaded\n    if (this.activeSessions_.size > 0 && this.areAllSessionsLoaded_()) {\n      this.allSessionsLoaded_.resolve();\n      this.allSessionsLoaded_ = new shaka.util.PublicPromise();\n      this.allSessionsLoaded_.catch(() => {});\n    }\n    this.createSession(initDataType, initData,\n        this.currentDrmInfo_.sessionType);\n  }\n\n  /** @return {boolean} */\n  initialized() {\n    return this.initialized_;\n  }\n\n  /**\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @return {string} */\n  static keySystem(drmInfo) {\n    return drmInfo ? drmInfo.keySystem : '';\n  }\n\n  /**\n   * @param {?string} keySystem\n   * @return {boolean} */\n  static isPlayReadyKeySystem(keySystem) {\n    if (keySystem) {\n      return !!keySystem.match(/^com\\.(microsoft|chromecast)\\.playready/);\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {?string} keySystem\n   * @return {boolean} */\n  static isFairPlayKeySystem(keySystem) {\n    if (keySystem) {\n      return !!keySystem.match(/^com\\.apple\\.fps/);\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if DrmEngine (as initialized) will likely be able to support the\n   * given content type.\n   *\n   * @param {string} contentType\n   * @return {boolean}\n   */\n  willSupport(contentType) {\n    // Edge 14 does not report correct capabilities.  It will only report the\n    // first MIME type even if the others are supported.  To work around this,\n    // we say that Edge supports everything.\n    //\n    // See https://github.com/shaka-project/shaka-player/issues/1495 for details.\n    if (shaka.util.Platform.isLegacyEdge()) {\n      return true;\n    }\n\n    contentType = contentType.toLowerCase();\n\n    if (shaka.util.Platform.isTizen() &&\n        contentType.includes('codecs=\"ac-3\"')) {\n      // Some Tizen devices seem to misreport AC-3 support.  This works around\n      // the issue, by falling back to EC-3, which seems to be supported on the\n      // same devices and be correctly reported in all cases we have observed.\n      // See https://github.com/shaka-project/shaka-player/issues/2989 for\n      // details.\n      const fallback = contentType.replace('ac-3', 'ec-3');\n      return this.supportedTypes_.has(contentType) ||\n             this.supportedTypes_.has(fallback);\n    }\n\n    return this.supportedTypes_.has(contentType);\n  }\n\n  /**\n   * Returns the ID of the sessions currently active.\n   *\n   * @return {!Array.<string>}\n   */\n  getSessionIds() {\n    const sessions = this.activeSessions_.keys();\n    const ids = shaka.util.Iterables.map(sessions, (s) => s.sessionId);\n\n    // TODO: Make |getSessionIds| return |Iterable| instead of |Array|.\n    return Array.from(ids);\n  }\n\n  /**\n   * Returns the next expiration time, or Infinity.\n   * @return {number}\n   */\n  getExpiration() {\n    // This will equal Infinity if there are no entries.\n    let min = Infinity;\n\n    const sessions = this.activeSessions_.keys();\n    for (const session of sessions) {\n      if (!isNaN(session.expiration)) {\n        min = Math.min(min, session.expiration);\n      }\n    }\n\n    return min;\n  }\n\n  /**\n   * Returns the time spent on license requests during this session, or NaN.\n   *\n   * @return {number}\n   */\n  getLicenseTime() {\n    if (this.licenseTimeSeconds_) {\n      return this.licenseTimeSeconds_;\n    }\n    return NaN;\n  }\n\n  /**\n   * Returns the DrmInfo that was used to initialize the current key system.\n   *\n   * @return {?shaka.extern.DrmInfo}\n   */\n  getDrmInfo() {\n    return this.currentDrmInfo_;\n  }\n\n  /**\n   * Return the media keys created from the current mediaKeySystemAccess.\n   * @return {MediaKeys}\n   */\n  getMediaKeys() {\n    return this.mediaKeys_;\n  }\n\n  /**\n   * Returns the current key statuses.\n   *\n   * @return {!Object.<string, string>}\n   */\n  getKeyStatuses() {\n    return shaka.util.MapUtils.asObject(this.announcedKeyStatusByKeyId_);\n  }\n\n  /**\n   * Returns the current media key sessions.\n   *\n   * @return {!Array.<MediaKeySession>}\n   */\n  getMediaKeySessions() {\n    return Array.from(this.activeSessions_.keys());\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {string=} codecOverride\n   * @return {string}\n   * @private\n   */\n  static computeMimeType_(stream, codecOverride) {\n    const realMimeType = shaka.util.MimeUtils.getFullType(stream.mimeType,\n        codecOverride || stream.codecs);\n    if (shaka.media.Transmuxer.isSupported(realMimeType)) {\n      // This will be handled by the Transmuxer, so use the MIME type that the\n      // Transmuxer will produce.\n      return shaka.media.Transmuxer.convertCodecs(stream.type, realMimeType);\n    }\n    return realMimeType;\n  }\n\n  /**\n   * @param {!Map.<string, MediaKeySystemConfiguration>} configsByKeySystem\n   *   A dictionary of configs, indexed by key system, with an iteration order\n   *   (insertion order) that reflects the preference for the application.\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @return {!Promise} Resolved if/when a key system has been chosen.\n   * @private\n   */\n  async queryMediaKeys_(configsByKeySystem, variants) {\n    const drmInfosByKeySystem = new Map();\n\n    const mediaKeySystemAccess = variants.length ?\n        this.getKeySystemAccessFromVariants_(variants, drmInfosByKeySystem) :\n        await this.getKeySystemAccessByConfigs_(configsByKeySystem);\n\n    if (!mediaKeySystemAccess) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE);\n    }\n    this.destroyer_.ensureNotDestroyed();\n\n    try {\n      // Get the set of supported content types from the audio and video\n      // capabilities. Avoid duplicates so that it is easier to read what is\n      // supported.\n      this.supportedTypes_.clear();\n\n      // Store the capabilities of the key system.\n      const realConfig = mediaKeySystemAccess.getConfiguration();\n\n      shaka.log.v2(\n          'Got MediaKeySystemAccess with configuration',\n          realConfig);\n\n      const audioCaps = realConfig.audioCapabilities || [];\n      const videoCaps = realConfig.videoCapabilities || [];\n\n      for (const cap of audioCaps) {\n        this.supportedTypes_.add(cap.contentType.toLowerCase());\n      }\n\n      for (const cap of videoCaps) {\n        this.supportedTypes_.add(cap.contentType.toLowerCase());\n      }\n\n      goog.asserts.assert(this.supportedTypes_.size,\n          'We should get at least one supported MIME type');\n\n      if (variants.length) {\n        this.currentDrmInfo_ = this.createDrmInfoByInfos_(\n            mediaKeySystemAccess.keySystem,\n            drmInfosByKeySystem.get(mediaKeySystemAccess.keySystem));\n      } else {\n        this.currentDrmInfo_ = shaka.media.DrmEngine.createDrmInfoByConfigs_(\n            mediaKeySystemAccess.keySystem,\n            configsByKeySystem.get(mediaKeySystemAccess.keySystem));\n      }\n      if (!this.currentDrmInfo_.licenseServerUri) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN,\n            this.currentDrmInfo_.keySystem);\n      }\n\n      const mediaKeys = await mediaKeySystemAccess.createMediaKeys();\n      this.destroyer_.ensureNotDestroyed();\n      shaka.log.info('Created MediaKeys object for key system',\n          this.currentDrmInfo_.keySystem);\n\n      this.mediaKeys_ = mediaKeys;\n      this.initialized_ = true;\n\n      await this.setServerCertificate();\n      this.destroyer_.ensureNotDestroyed();\n    } catch (exception) {\n      this.destroyer_.ensureNotDestroyed(exception);\n\n      // Don't rewrap a shaka.util.Error from earlier in the chain:\n      this.currentDrmInfo_ = null;\n      this.supportedTypes_.clear();\n      if (exception instanceof shaka.util.Error) {\n        throw exception;\n      }\n\n      // We failed to create MediaKeys.  This generally shouldn't happen.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_CDM,\n          exception.message);\n    }\n  }\n\n  /**\n   * Get the MediaKeySystemAccess from the decodingInfos of the variants.\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {!Map.<string, !Array.<shaka.extern.DrmInfo>>} drmInfosByKeySystem\n   *   A dictionary of drmInfos, indexed by key system.\n   * @return {MediaKeySystemAccess}\n   * @private\n   */\n  getKeySystemAccessFromVariants_(variants, drmInfosByKeySystem) {\n    for (const variant of variants) {\n      // Get all the key systems in the variant that shouldHaveLicenseServer.\n      const drmInfos = this.getVariantDrmInfos_(variant);\n      for (const info of drmInfos) {\n        if (!drmInfosByKeySystem.has(info.keySystem)) {\n          drmInfosByKeySystem.set(info.keySystem, []);\n        }\n        drmInfosByKeySystem.get(info.keySystem).push(info);\n      }\n    }\n\n    if (drmInfosByKeySystem.size == 1 && drmInfosByKeySystem.has('')) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS);\n    }\n\n    // If we have configured preferredKeySystems, choose a preferred keySystem\n    // if available.\n    for (const preferredKeySystem of this.config_.preferredKeySystems) {\n      for (const variant of variants) {\n        const decodingInfo = variant.decodingInfos.find((decodingInfo) => {\n          return decodingInfo.supported &&\n              decodingInfo.keySystemAccess != null &&\n              decodingInfo.keySystemAccess.keySystem == preferredKeySystem;\n        });\n        if (decodingInfo) {\n          return decodingInfo.keySystemAccess;\n        }\n      }\n    }\n\n    // Try key systems with configured license servers first.  We only have to\n    // try key systems without configured license servers for diagnostic\n    // reasons, so that we can differentiate between \"none of these key\n    // systems are available\" and \"some are available, but you did not\n    // configure them properly.\"  The former takes precedence.\n    for (const shouldHaveLicenseServer of [true, false]) {\n      for (const variant of variants) {\n        for (const decodingInfo of variant.decodingInfos) {\n          if (!decodingInfo.supported || !decodingInfo.keySystemAccess) {\n            continue;\n          }\n          const drmInfos =\n              drmInfosByKeySystem.get(decodingInfo.keySystemAccess.keySystem);\n          for (const info of drmInfos) {\n            if (!!info.licenseServerUri == shouldHaveLicenseServer) {\n              return decodingInfo.keySystemAccess;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the MediaKeySystemAccess by querying requestMediaKeySystemAccess.\n   * @param {!Map.<string, MediaKeySystemConfiguration>} configsByKeySystem\n   *   A dictionary of configs, indexed by key system, with an iteration order\n   *   (insertion order) that reflects the preference for the application.\n   * @return {!Promise.<MediaKeySystemAccess>} Resolved if/when a\n   *   mediaKeySystemAccess has been chosen.\n   * @private\n   */\n  async getKeySystemAccessByConfigs_(configsByKeySystem) {\n    /** @type {MediaKeySystemAccess} */\n    let mediaKeySystemAccess;\n\n    if (configsByKeySystem.size == 1 && configsByKeySystem.has('')) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS);\n    }\n\n    // If there are no tracks of a type, these should be not present.\n    // Otherwise the query will fail.\n    for (const config of configsByKeySystem.values()) {\n      if (config.audioCapabilities.length == 0) {\n        delete config.audioCapabilities;\n      }\n      if (config.videoCapabilities.length == 0) {\n        delete config.videoCapabilities;\n      }\n    }\n\n    // If we have configured preferredKeySystems, choose the preferred one if\n    // available.\n    for (const keySystem of this.config_.preferredKeySystems) {\n      if (configsByKeySystem.has(keySystem)) {\n        const config = configsByKeySystem.get(keySystem);\n        try {\n          mediaKeySystemAccess =  // eslint-disable-next-line no-await-in-loop\n              await navigator.requestMediaKeySystemAccess(keySystem, [config]);\n          return mediaKeySystemAccess;\n        } catch (error) {\n          // Suppress errors.\n          shaka.log.v2(\n              'Requesting', keySystem, 'failed with config', config, error);\n        }\n        this.destroyer_.ensureNotDestroyed();\n      }\n    }\n\n    // Try key systems with configured license servers first.  We only have to\n    // try key systems without configured license servers for diagnostic\n    // reasons, so that we can differentiate between \"none of these key\n    // systems are available\" and \"some are available, but you did not\n    // configure them properly.\"  The former takes precedence.\n    // TODO: once MediaCap implementation is complete, this part can be\n    // simplified or removed.\n    for (const shouldHaveLicenseServer of [true, false]) {\n      for (const keySystem of configsByKeySystem.keys()) {\n        const config = configsByKeySystem.get(keySystem);\n        // TODO: refactor, don't stick drmInfos onto\n        // MediaKeySystemConfiguration\n        const hasLicenseServer = config['drmInfos'].some((info) => {\n          return !!info.licenseServerUri;\n        });\n        if (hasLicenseServer != shouldHaveLicenseServer) {\n          continue;\n        }\n\n        try {\n          mediaKeySystemAccess =  // eslint-disable-next-line no-await-in-loop\n              await navigator.requestMediaKeySystemAccess(keySystem, [config]);\n          return mediaKeySystemAccess;\n        } catch (error) {\n          // Suppress errors.\n          shaka.log.v2(\n              'Requesting', keySystem, 'failed with config', config, error);\n        }\n        this.destroyer_.ensureNotDestroyed();\n      }\n    }\n    return mediaKeySystemAccess;\n  }\n\n  /**\n   * Create a DrmInfo using configured clear keys.\n   * The server URI will be a data URI which decodes to a clearkey license.\n   * @return {?shaka.extern.DrmInfo} or null if clear keys are not configured.\n   * @private\n   * @see https://bit.ly/2K8gOnv for the spec on the clearkey license format.\n   */\n  configureClearKey_() {\n    const clearKeys = shaka.util.MapUtils.asMap(this.config_.clearKeys);\n    if (clearKeys.size == 0) {\n      return null;\n    }\n\n    const StringUtils = shaka.util.StringUtils;\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const keys = [];\n    const keyIds = [];\n\n    clearKeys.forEach((key, keyId) => {\n      let kid = keyId;\n      if (kid.length != 22) {\n        kid = Uint8ArrayUtils.toBase64(\n            Uint8ArrayUtils.fromHex(keyId), false);\n      }\n      let k = key;\n      if (k.length != 22) {\n        k = Uint8ArrayUtils.toBase64(\n            Uint8ArrayUtils.fromHex(key), false);\n      }\n      const keyObj = {\n        kty: 'oct',\n        kid: kid,\n        k: k,\n      };\n\n      keys.push(keyObj);\n      keyIds.push(keyObj.kid);\n    });\n\n    const jwkSet = {keys: keys};\n    const license = JSON.stringify(jwkSet);\n\n    // Use the keyids init data since is suggested by EME.\n    // Suggestion: https://bit.ly/2JYcNTu\n    // Format: https://www.w3.org/TR/eme-initdata-keyids/\n    const initDataStr = JSON.stringify({'kids': keyIds});\n    const initData =\n        shaka.util.BufferUtils.toUint8(StringUtils.toUTF8(initDataStr));\n    const initDatas = [{initData: initData, initDataType: 'keyids'}];\n\n    return {\n      keySystem: 'org.w3.clearkey',\n      licenseServerUri: 'data:application/json;base64,' + window.btoa(license),\n      distinctiveIdentifierRequired: false,\n      persistentStateRequired: false,\n      audioRobustness: '',\n      videoRobustness: '',\n      serverCertificate: null,\n      serverCertificateUri: '',\n      sessionType: '',\n      initData: initDatas,\n      keyIds: new Set(keyIds),\n    };\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {!Promise.<MediaKeySession>}\n   * @private\n   */\n  async loadOfflineSession_(sessionId) {\n    let session;\n\n    const sessionType = 'persistent-license';\n\n    try {\n      shaka.log.v1('Attempting to load an offline session', sessionId);\n      session = this.mediaKeys_.createSession(sessionType);\n    } catch (exception) {\n      const error = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          exception.message);\n      this.onError_(error);\n      return Promise.reject(error);\n    }\n\n    this.eventManager_.listen(session, 'message',\n        /** @type {shaka.util.EventManager.ListenerType} */(\n          (event) => this.onSessionMessage_(event)));\n    this.eventManager_.listen(session, 'keystatuseschange',\n        (event) => this.onKeyStatusesChange_(event));\n\n    const metadata = {\n      initData: null,\n      initDataType: null,\n      loaded: false,\n      oldExpiration: Infinity,\n      updatePromise: null,\n      type: sessionType,\n    };\n    this.activeSessions_.set(session, metadata);\n\n    try {\n      const present = await session.load(sessionId);\n      this.destroyer_.ensureNotDestroyed();\n      shaka.log.v2('Loaded offline session', sessionId, present);\n\n      if (!present) {\n        this.activeSessions_.delete(session);\n\n        this.onError_(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.OFFLINE_SESSION_REMOVED));\n        return Promise.resolve();\n      }\n\n      // TODO: We should get a key status change event.  Remove once Chrome CDM\n      // is fixed.\n      metadata.loaded = true;\n      if (this.areAllSessionsLoaded_()) {\n        this.allSessionsLoaded_.resolve();\n      }\n\n      return session;\n    } catch (error) {\n      this.destroyer_.ensureNotDestroyed(error);\n\n      this.activeSessions_.delete(session);\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          error.message));\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {string} initDataType\n   * @param {!Uint8Array} initData\n   * @param {string} sessionType\n   */\n  createSession(initDataType, initData, sessionType) {\n    goog.asserts.assert(this.mediaKeys_,\n        'mediaKeys_ should be valid when creating temporary session.');\n\n    let session;\n\n    try {\n      shaka.log.info('Creating new', sessionType, 'session');\n\n      session = this.mediaKeys_.createSession(sessionType);\n    } catch (exception) {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_CREATE_SESSION,\n          exception.message));\n      return;\n    }\n\n    this.eventManager_.listen(session, 'message',\n    /** @type {shaka.util.EventManager.ListenerType} */(\n          (event) => this.onSessionMessage_(event)));\n    this.eventManager_.listen(session, 'keystatuseschange',\n        (event) => this.onKeyStatusesChange_(event));\n\n    const metadata = {\n      initData: initData,\n      initDataType: initDataType,\n      loaded: false,\n      oldExpiration: Infinity,\n      updatePromise: null,\n      type: sessionType,\n    };\n    this.activeSessions_.set(session, metadata);\n\n    try {\n      initData = this.config_.initDataTransform(\n          initData, initDataType, this.currentDrmInfo_);\n    } catch (error) {\n      let shakaError = error;\n      if (!(error instanceof shaka.util.Error)) {\n        shakaError = new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.DRM,\n            shaka.util.Error.Code.INIT_DATA_TRANSFORM_ERROR,\n            error);\n      }\n      this.onError_(shakaError);\n      return;\n    }\n\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(initData);\n      shaka.log.info('EME init data: type=', initDataType, 'data=', str);\n    }\n\n    session.generateRequest(initDataType, initData).catch((error) => {\n      if (this.destroyer_.destroyed()) {\n        return;\n      }\n      goog.asserts.assert(error instanceof Error, 'Wrong error type!');\n\n      this.activeSessions_.delete(session);\n\n      // This may be supplied by some polyfills.\n      /** @type {MediaKeyError} */\n      const errorCode = error['errorCode'];\n\n      let extended;\n      if (errorCode && errorCode.systemCode) {\n        extended = errorCode.systemCode;\n        if (extended < 0) {\n          extended += Math.pow(2, 32);\n        }\n        extended = '0x' + extended.toString(16);\n      }\n\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST,\n          error.message, error, extended));\n    });\n  }\n\n  /**\n   * @param {!MediaKeyMessageEvent} event\n   * @private\n   */\n  onSessionMessage_(event) {\n    if (this.delayLicenseRequest_()) {\n      this.mediaKeyMessageEvents_.push(event);\n    } else {\n      this.sendLicenseRequest_(event);\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  delayLicenseRequest_() {\n    if (!this.video_) {\n      // If there's no video, don't delay the license request; i.e., in the case\n      // of offline storage.\n      return false;\n    }\n    return (this.config_.delayLicenseRequestUntilPlayed &&\n            this.video_.paused && !this.initialRequestsSent_);\n  }\n\n  /**\n   * Sends a license request.\n   * @param {!MediaKeyMessageEvent} event\n   * @private\n   */\n  async sendLicenseRequest_(event) {\n    /** @type {!MediaKeySession} */\n    const session = event.target;\n    shaka.log.v1(\n        'Sending license request for session', session.sessionId, 'of type',\n        event.messageType);\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(event.message);\n      shaka.log.info('EME license request', str);\n    }\n\n    const metadata = this.activeSessions_.get(session);\n\n    let url = this.currentDrmInfo_.licenseServerUri;\n    const advancedConfig =\n        this.config_.advanced[this.currentDrmInfo_.keySystem];\n\n    if (event.messageType == 'individualization-request' && advancedConfig &&\n        advancedConfig.individualizationServer) {\n      url = advancedConfig.individualizationServer;\n    }\n\n    const requestType = shaka.net.NetworkingEngine.RequestType.LICENSE;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [url], this.config_.retryParameters);\n    request.body = event.message;\n    request.method = 'POST';\n    request.licenseRequestType = event.messageType;\n    request.sessionId = session.sessionId;\n    request.drmInfo = this.currentDrmInfo_;\n    if (metadata) {\n      request.initData = metadata.initData;\n      request.initDataType = metadata.initDataType;\n    }\n    // NOTE: allowCrossSiteCredentials can be set in a request filter.\n\n    if (shaka.media.DrmEngine.isPlayReadyKeySystem(\n        this.currentDrmInfo_.keySystem)) {\n      this.unpackPlayReadyRequest_(request);\n    }\n\n    const startTimeRequest = Date.now();\n\n    let response;\n    try {\n      const req = this.playerInterface_.netEngine.request(requestType, request);\n      response = await req.promise;\n    } catch (error) {\n      // Request failed!\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Wrong NetworkingEngine error type!');\n      const shakaErr = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.LICENSE_REQUEST_FAILED,\n          error);\n      this.onError_(shakaErr);\n      if (metadata && metadata.updatePromise) {\n        metadata.updatePromise.reject(shakaErr);\n      }\n      return;\n    }\n    if (this.destroyer_.destroyed()) {\n      return;\n    }\n\n    this.licenseTimeSeconds_ += (Date.now() - startTimeRequest) / 1000;\n\n    if (this.config_.logLicenseExchange) {\n      const str = shaka.util.Uint8ArrayUtils.toBase64(response.data);\n      shaka.log.info('EME license response', str);\n    }\n\n    // Request succeeded, now pass the response to the CDM.\n    try {\n      shaka.log.v1('Updating session', session.sessionId);\n      await session.update(response.data);\n    } catch (error) {\n      // Session update failed!\n      const shakaErr = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED,\n          error.message);\n      this.onError_(shakaErr);\n      if (metadata && metadata.updatePromise) {\n        metadata.updatePromise.reject(shakaErr);\n      }\n      return;\n    }\n    if (this.destroyer_.destroyed()) {\n      return;\n    }\n\n    const updateEvent = new shaka.util.FakeEvent('drmsessionupdate');\n    this.playerInterface_.onEvent(updateEvent);\n\n    if (metadata) {\n      if (metadata.updatePromise) {\n        metadata.updatePromise.resolve();\n      }\n      // In case there are no key statuses, consider this session loaded\n      // after a reasonable timeout.  It should definitely not take 5\n      // seconds to process a license.\n      const timer = new shaka.util.Timer(() => {\n        metadata.loaded = true;\n        if (this.areAllSessionsLoaded_()) {\n          this.allSessionsLoaded_.resolve();\n        }\n      });\n\n      timer.tickAfter(\n          /* seconds= */ shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_);\n    }\n  }\n\n  /**\n   * Unpacks PlayReady license requests.  Modifies the request object.\n   * @param {shaka.extern.Request} request\n   * @private\n   */\n  unpackPlayReadyRequest_(request) {\n    // On Edge, the raw license message is UTF-16-encoded XML.  We need\n    // to unpack the Challenge element (base64-encoded string containing the\n    // actual license request) and any HttpHeader elements (sent as request\n    // headers).\n\n    // Example XML:\n\n    // <PlayReadyKeyMessage type=\"LicenseAcquisition\">\n    //   <LicenseAcquisition Version=\"1\">\n    //     <Challenge encoding=\"base64encoded\">{Base64Data}</Challenge>\n    //     <HttpHeaders>\n    //       <HttpHeader>\n    //         <name>Content-Type</name>\n    //         <value>text/xml; charset=utf-8</value>\n    //       </HttpHeader>\n    //       <HttpHeader>\n    //         <name>SOAPAction</name>\n    //         <value>http://schemas.microsoft.com/DRM/etc/etc</value>\n    //       </HttpHeader>\n    //     </HttpHeaders>\n    //   </LicenseAcquisition>\n    // </PlayReadyKeyMessage>\n\n    const xml = shaka.util.StringUtils.fromUTF16(\n        request.body, /* littleEndian= */ true, /* noThrow= */ true);\n    if (!xml.includes('PlayReadyKeyMessage')) {\n      // This does not appear to be a wrapped message as on Edge.  Some\n      // clients do not need this unwrapping, so we will assume this is one of\n      // them.  Note that \"xml\" at this point probably looks like random\n      // garbage, since we interpreted UTF-8 as UTF-16.\n      shaka.log.debug('PlayReady request is already unwrapped.');\n      request.headers['Content-Type'] = 'text/xml; charset=utf-8';\n      return;\n    }\n    shaka.log.debug('Unwrapping PlayReady request.');\n    const dom = shaka.util.XmlUtils.parseXmlString(xml, 'PlayReadyKeyMessage');\n    goog.asserts.assert(dom, 'Failed to parse PlayReady XML!');\n\n    // Set request headers.\n    const headers = dom.getElementsByTagName('HttpHeader');\n    for (const header of headers) {\n      const name = header.getElementsByTagName('name')[0];\n      const value = header.getElementsByTagName('value')[0];\n      goog.asserts.assert(name && value, 'Malformed PlayReady headers!');\n      request.headers[name.textContent] = value.textContent;\n    }\n\n    // Unpack the base64-encoded challenge.\n    const challenge = dom.getElementsByTagName('Challenge')[0];\n    goog.asserts.assert(challenge, 'Malformed PlayReady challenge!');\n    goog.asserts.assert(challenge.getAttribute('encoding') == 'base64encoded',\n        'Unexpected PlayReady challenge encoding!');\n    request.body = shaka.util.Uint8ArrayUtils.fromBase64(challenge.textContent);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   * @suppress {invalidCasts} to swap keyId and status\n   */\n  onKeyStatusesChange_(event) {\n    const session = /** @type {!MediaKeySession} */(event.target);\n    shaka.log.v2('Key status changed for session', session.sessionId);\n\n    const found = this.activeSessions_.get(session);\n    const keyStatusMap = session.keyStatuses;\n    let hasExpiredKeys = false;\n\n    keyStatusMap.forEach((status, keyId) => {\n      // The spec has changed a few times on the exact order of arguments here.\n      // As of 2016-06-30, Edge has the order reversed compared to the current\n      // EME spec.  Given the back and forth in the spec, it may not be the only\n      // one.  Try to detect this and compensate:\n      if (typeof keyId == 'string') {\n        const tmp = keyId;\n        keyId = /** @type {!ArrayBuffer} */(status);\n        status = /** @type {string} */(tmp);\n      }\n\n      // Microsoft's implementation in Edge seems to present key IDs as\n      // little-endian UUIDs, rather than big-endian or just plain array of\n      // bytes.\n      // standard: 6e 5a 1d 26 - 27 57 - 47 d7 - 80 46 ea a5 d1 d3 4b 5a\n      // on Edge:  26 1d 5a 6e - 57 27 - d7 47 - 80 46 ea a5 d1 d3 4b 5a\n      // Bug filed: https://bit.ly/2thuzXu\n\n      // NOTE that we skip this if byteLength != 16.  This is used for Edge\n      // which uses single-byte dummy key IDs.\n      // However, unlike Edge and Chromecast, Tizen doesn't have this problem.\n      if (shaka.media.DrmEngine.isPlayReadyKeySystem(\n          this.currentDrmInfo_.keySystem) &&\n          keyId.byteLength == 16 &&\n          (shaka.util.Platform.isEdge() || shaka.util.Platform.isPS4())) {\n        // Read out some fields in little-endian:\n        const dataView = shaka.util.BufferUtils.toDataView(keyId);\n        const part0 = dataView.getUint32(0, /* LE= */ true);\n        const part1 = dataView.getUint16(4, /* LE= */ true);\n        const part2 = dataView.getUint16(6, /* LE= */ true);\n        // Write it back in big-endian:\n        dataView.setUint32(0, part0, /* BE= */ false);\n        dataView.setUint16(4, part1, /* BE= */ false);\n        dataView.setUint16(6, part2, /* BE= */ false);\n      }\n\n      if (status != 'status-pending') {\n        found.loaded = true;\n      }\n\n      if (!found) {\n        // We can get a key status changed for a closed session after it has\n        // been removed from |activeSessions_|.  If it is closed, none of its\n        // keys should be usable.\n        goog.asserts.assert(\n            status != 'usable', 'Usable keys found in closed session');\n      }\n\n      if (status == 'expired') {\n        hasExpiredKeys = true;\n      }\n\n      const keyIdHex = shaka.util.Uint8ArrayUtils.toHex(keyId).slice(0, 32);\n\n      this.keyStatusByKeyId_.set(keyIdHex, status);\n    });\n\n    // If the session has expired, close it.\n    // Some CDMs do not have sub-second time resolution, so the key status may\n    // fire with hundreds of milliseconds left until the stated expiration time.\n    const msUntilExpiration = session.expiration - Date.now();\n    if (msUntilExpiration < 0 || (hasExpiredKeys && msUntilExpiration < 1000)) {\n      // If this is part of a remove(), we don't want to close the session until\n      // the update is complete.  Otherwise, we will orphan the session.\n      if (found && !found.updatePromise) {\n        shaka.log.debug('Session has expired', session.sessionId);\n        this.activeSessions_.delete(session);\n        session.close().catch(() => {});  // Silence uncaught rejection errors\n      }\n    }\n\n    if (!this.areAllSessionsLoaded_()) {\n      // Don't announce key statuses or resolve the \"all loaded\" promise until\n      // everything is loaded.\n      return;\n    }\n\n    this.allSessionsLoaded_.resolve();\n\n    // Batch up key status changes before checking them or notifying Player.\n    // This handles cases where the statuses of multiple sessions are set\n    // simultaneously by the browser before dispatching key status changes for\n    // each of them.  By batching these up, we only send one status change event\n    // and at most one EXPIRED error on expiration.\n    this.keyStatusTimer_.tickAfter(\n        /* seconds= */ shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME);\n  }\n\n  /** @private */\n  processKeyStatusChanges_() {\n    const privateMap = this.keyStatusByKeyId_;\n    const publicMap = this.announcedKeyStatusByKeyId_;\n\n    // Copy the latest key statuses into the publicly-accessible map.\n    publicMap.clear();\n    privateMap.forEach((status, keyId) => publicMap.set(keyId, status));\n\n    // If all keys are expired, fire an error. |every| is always true for an\n    // empty array but we shouldn't fire an error for a lack of key status info.\n    const statuses = Array.from(publicMap.values());\n    const allExpired = statuses.length &&\n                       statuses.every((status) => status == 'expired');\n\n    if (allExpired) {\n      this.onError_(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.EXPIRED));\n    }\n\n    this.playerInterface_.onKeyStatus(shaka.util.MapUtils.asObject(publicMap));\n  }\n\n  /**\n   * Returns true if the browser has recent EME APIs.\n   *\n   * @return {boolean}\n   */\n  static isBrowserSupported() {\n    const basic =\n        !!window.MediaKeys &&\n        !!window.navigator &&\n        !!window.navigator.requestMediaKeySystemAccess &&\n        !!window.MediaKeySystemAccess &&\n        // eslint-disable-next-line no-restricted-syntax\n        !!window.MediaKeySystemAccess.prototype.getConfiguration;\n\n    return basic;\n  }\n\n  /**\n   * Returns a Promise to a map of EME support for well-known key systems.\n   *\n   * @return {!Promise.<!Object.<string, ?shaka.extern.DrmSupportType>>}\n   */\n  static async probeSupport() {\n    goog.asserts.assert(shaka.media.DrmEngine.isBrowserSupported(),\n        'Must have basic EME support');\n\n    const testKeySystems = [\n      'org.w3.clearkey',\n      'com.widevine.alpha',\n      'com.microsoft.playready',\n      'com.microsoft.playready.recommendation',\n      'com.apple.fps.1_0',\n      'com.apple.fps',\n      'com.adobe.primetime',\n    ];\n\n    const basicVideoCapabilities = [\n      {contentType: 'video/mp4; codecs=\"avc1.42E01E\"'},\n      {contentType: 'video/webm; codecs=\"vp8\"'},\n    ];\n\n    const basicConfig = {\n      initDataTypes: ['cenc'],\n      videoCapabilities: basicVideoCapabilities,\n    };\n    const offlineConfig = {\n      videoCapabilities: basicVideoCapabilities,\n      persistentState: 'required',\n      sessionTypes: ['persistent-license'],\n    };\n\n    // Try the offline config first, then fall back to the basic config.\n    const configs = [offlineConfig, basicConfig];\n\n    /** @type {!Map.<string, ?shaka.extern.DrmSupportType>} */\n    const support = new Map();\n\n    const testSystem = async (keySystem) => {\n      try {\n        // Our Polyfill will reject anything apart com.apple.fps key systems.\n        // It seems the Safari modern EME API will allow to request a\n        // MediaKeySystemAccess for the ClearKey CDM, create and update a key\n        // session but playback will never start\n        // Safari bug: https://bugs.webkit.org/show_bug.cgi?id=231006\n        if (keySystem === 'org.w3.clearkey' &&\n            shaka.util.Platform.isSafari()) {\n          throw new Error('Unsupported keySystem');\n        }\n\n        const access = await navigator.requestMediaKeySystemAccess(\n            keySystem, configs);\n\n        // Edge doesn't return supported session types, but current versions\n        // do not support persistent-license.  If sessionTypes is missing,\n        // assume no support for persistent-license.\n        // TODO: Polyfill Edge to return known supported session types.\n        // Edge bug: https://bit.ly/2IeKzho\n        const sessionTypes = access.getConfiguration().sessionTypes;\n        let persistentState = sessionTypes ?\n            sessionTypes.includes('persistent-license') : false;\n\n        // Tizen 3.0 doesn't support persistent licenses, but reports that it\n        // does.  It doesn't fail until you call update() with a license\n        // response, which is way too late.\n        // This is a work-around for #894.\n        if (shaka.util.Platform.isTizen3()) {\n          persistentState = false;\n        }\n\n        support.set(keySystem, {persistentState: persistentState});\n        await access.createMediaKeys();\n      } catch (e) {\n        // Either the request failed or createMediaKeys failed.\n        // Either way, write null to the support object.\n        support.set(keySystem, null);\n      }\n    };\n\n    // Test each key system.\n    const tests = testKeySystems.map((keySystem) => testSystem(keySystem));\n    await Promise.all(tests);\n    return shaka.util.MapUtils.asObject(support);\n  }\n\n  /** @private */\n  onPlay_() {\n    for (const event of this.mediaKeyMessageEvents_) {\n      this.sendLicenseRequest_(event);\n    }\n\n    this.initialRequestsSent_ = true;\n    this.mediaKeyMessageEvents_ = [];\n  }\n\n  /**\n   * Close a drm session while accounting for a bug in Chrome. Sometimes the\n   * Promise returned by close() never resolves.\n   *\n   * See issue #2741 and http://crbug.com/1108158.\n   * @param {!MediaKeySession} session\n   * @return {!Promise}\n   * @private\n   */\n  async closeSession_(session) {\n    const DrmEngine = shaka.media.DrmEngine;\n\n    const timeout = new Promise((resolve, reject) => {\n      const timer = new shaka.util.Timer(reject);\n      timer.tickAfter(DrmEngine.CLOSE_TIMEOUT_);\n    });\n\n    try {\n      await Promise.race([\n        Promise.all([session.close(), session.closed]),\n        timeout,\n      ]);\n    } catch (e) {\n      shaka.log.warning('Timeout waiting for session close');\n    }\n  }\n\n  /** @private */\n  async closeOpenSessions_() {\n    // Close all open sessions.\n    const openSessions = Array.from(this.activeSessions_.entries());\n    this.activeSessions_.clear();\n\n    // Close all sessions before we remove media keys from the video element.\n    await Promise.all(openSessions.map(async ([session, metadata]) => {\n      try {\n        /**\n         * Special case when a persistent-license session has been initiated,\n         * without being registered in the offline sessions at start-up.\n         * We should remove the session to prevent it from being orphaned after\n         * the playback session ends\n         */\n        if (!this.initializedForStorage_ &&\n            !this.offlineSessionIds_.includes(session.sessionId) &&\n            metadata.type === 'persistent-license') {\n          shaka.log.v1('Removing session', session.sessionId);\n\n          await session.remove();\n        } else {\n          shaka.log.v1('Closing session', session.sessionId, metadata);\n\n          await this.closeSession_(session);\n        }\n      } catch (error) {\n        // Ignore errors when closing the sessions. Closing a session that\n        // generated no key requests will throw an error.\n\n        shaka.log.error('Failed to close or remove the session', error);\n      }\n    }));\n  }\n\n  /**\n   * Check if a variant is likely to be supported by DrmEngine. This will err on\n   * the side of being too accepting and may not reject a variant that it will\n   * later fail to play.\n   *\n   * @param {!shaka.extern.Variant} variant\n   * @return {boolean}\n   */\n  supportsVariant(variant) {\n    /** @type {?shaka.extern.Stream} */\n    const audio = variant.audio;\n    /** @type {?shaka.extern.Stream} */\n    const video = variant.video;\n\n    if (audio && audio.encrypted) {\n      const audioContentType = shaka.media.DrmEngine.computeMimeType_(audio);\n      if (!this.willSupport(audioContentType)) {\n        return false;\n      }\n    }\n\n    if (video && video.encrypted) {\n      const videoContentType = shaka.media.DrmEngine.computeMimeType_(video);\n      if (!this.willSupport(videoContentType)) {\n        return false;\n      }\n    }\n\n    const keySystem = shaka.media.DrmEngine.keySystem(this.currentDrmInfo_);\n    const drmInfos = this.getVariantDrmInfos_(variant);\n\n    return drmInfos.length == 0 ||\n        drmInfos.some((drmInfo) => drmInfo.keySystem == keySystem);\n  }\n\n  /**\n   * Checks if two DrmInfos can be decrypted using the same key system.\n   * Clear content is considered compatible with every key system.\n   *\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n   * @return {boolean}\n   */\n  static areDrmCompatible(drms1, drms2) {\n    if (!drms1.length || !drms2.length) {\n      return true;\n    }\n\n    return shaka.media.DrmEngine.getCommonDrmInfos(\n        drms1, drms2).length > 0;\n  }\n\n  /**\n   * Returns an array of drm infos that are present in both input arrays.\n   * If one of the arrays is empty, returns the other one since clear\n   * content is considered compatible with every drm info.\n   *\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms1\n   * @param {!Array.<!shaka.extern.DrmInfo>} drms2\n   * @return {!Array.<!shaka.extern.DrmInfo>}\n   */\n  static getCommonDrmInfos(drms1, drms2) {\n    if (!drms1.length) {\n      return drms2;\n    }\n    if (!drms2.length) {\n      return drms1;\n    }\n\n    const commonDrms = [];\n\n    for (const drm1 of drms1) {\n      for (const drm2 of drms2) {\n        // This method is only called to compare drmInfos of a video and an\n        // audio adaptations, so we shouldn't have to worry about checking\n        // robustness.\n        if (drm1.keySystem == drm2.keySystem) {\n          /** @type {Array<shaka.extern.InitDataOverride>} */\n          let initData = [];\n          initData = initData.concat(drm1.initData || []);\n          initData = initData.concat(drm2.initData || []);\n          initData = initData.filter((d, i) => {\n            return d.keyId === undefined || i === initData.findIndex((d2) => {\n              return d2.keyId === d.keyId;\n            });\n          });\n\n          const keyIds = drm1.keyIds && drm2.keyIds ?\n              new Set([...drm1.keyIds, ...drm2.keyIds]) :\n              drm1.keyIds || drm2.keyIds;\n          const mergedDrm = {\n            keySystem: drm1.keySystem,\n            licenseServerUri: drm1.licenseServerUri || drm2.licenseServerUri,\n            distinctiveIdentifierRequired: drm1.distinctiveIdentifierRequired ||\n                drm2.distinctiveIdentifierRequired,\n            persistentStateRequired: drm1.persistentStateRequired ||\n                drm2.persistentStateRequired,\n            videoRobustness: drm1.videoRobustness || drm2.videoRobustness,\n            audioRobustness: drm1.audioRobustness || drm2.audioRobustness,\n            serverCertificate: drm1.serverCertificate || drm2.serverCertificate,\n            serverCertificateUri: drm1.serverCertificateUri ||\n                drm2.serverCertificateUri,\n            initData,\n            keyIds,\n          };\n          commonDrms.push(mergedDrm);\n          break;\n        }\n      }\n    }\n\n    return commonDrms;\n  }\n\n  /**\n   * Concat the audio and video drmInfos in a variant.\n   * @param {shaka.extern.Variant} variant\n   * @return {!Array.<!shaka.extern.DrmInfo>}\n   * @private\n   */\n  getVariantDrmInfos_(variant) {\n    const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n    const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n    return videoDrmInfos.concat(audioDrmInfos);\n  }\n\n  /**\n   * Called in an interval timer to poll the expiration times of the sessions.\n   * We don't get an event from EME when the expiration updates, so we poll it\n   * so we can fire an event when it happens.\n   * @private\n   */\n  pollExpiration_() {\n    this.activeSessions_.forEach((metadata, session) => {\n      const oldTime = metadata.oldExpiration;\n      let newTime = session.expiration;\n      if (isNaN(newTime)) {\n        newTime = Infinity;\n      }\n\n      if (newTime != oldTime) {\n        this.playerInterface_.onExpirationUpdated(session.sessionId, newTime);\n        metadata.oldExpiration = newTime;\n      }\n    });\n  }\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  areAllSessionsLoaded_() {\n    const metadatas = this.activeSessions_.values();\n    return shaka.util.Iterables.every(metadatas, (data) => data.loaded);\n  }\n\n  /**\n   * Replace the drm info used in each variant in |variants| to reflect each\n   * key service in |keySystems|.\n   *\n   * @param {!Array.<shaka.extern.Variant>} variants\n   * @param {!Map.<string, string>} keySystems\n   * @private\n   */\n  static replaceDrmInfo_(variants, keySystems) {\n    const drmInfos = [];\n\n    keySystems.forEach((uri, keySystem) => {\n      drmInfos.push({\n        keySystem: keySystem,\n        licenseServerUri: uri,\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        audioRobustness: '',\n        videoRobustness: '',\n        serverCertificate: null,\n        serverCertificateUri: '',\n        initData: [],\n        keyIds: new Set(),\n      });\n    });\n\n    for (const variant of variants) {\n      if (variant.video) {\n        variant.video.drmInfos = drmInfos;\n      }\n      if (variant.audio) {\n        variant.audio.drmInfos = drmInfos;\n      }\n    }\n  }\n\n\n  /**\n   * Creates a DrmInfo object describing the settings used to initialize the\n   * engine.\n   *\n   * @param {string} keySystem\n   * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n   * @return {shaka.extern.DrmInfo}\n   *\n   * @private\n   */\n  createDrmInfoByInfos_(keySystem, drmInfos) {\n    /** @type {!Array.<string>} */\n    const licenseServers = [];\n\n    /** @type {!Array.<string>} */\n    const serverCertificateUris = [];\n\n    /** @type {!Array.<!Uint8Array>} */\n    const serverCerts = [];\n\n    /** @type {!Array.<!shaka.extern.InitDataOverride>} */\n    const initDatas = [];\n\n    /** @type {!Set.<string>} */\n    const keyIds = new Set();\n\n    shaka.media.DrmEngine.processDrmInfos_(\n        drmInfos, licenseServers, serverCerts,\n        serverCertificateUris, initDatas, keyIds);\n\n    if (serverCerts.length > 1) {\n      shaka.log.warning('Multiple unique server certificates found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (licenseServers.length > 1) {\n      shaka.log.warning('Multiple unique license server URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (serverCertificateUris.length > 1) {\n      shaka.log.warning('Multiple unique server certificate URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    const defaultSessionType =\n        this.usePersistentLicenses_ ? 'persistent-license' : 'temporary';\n\n    /** @type {shaka.extern.DrmInfo} */\n    const res = {\n      keySystem,\n      licenseServerUri: licenseServers[0],\n      distinctiveIdentifierRequired: drmInfos[0].distinctiveIdentifierRequired,\n      persistentStateRequired: drmInfos[0].persistentStateRequired,\n      sessionType: drmInfos[0].sessionType || defaultSessionType,\n      audioRobustness: drmInfos[0].audioRobustness || '',\n      videoRobustness: drmInfos[0].videoRobustness || '',\n      serverCertificate: serverCerts[0],\n      serverCertificateUri: serverCertificateUris[0],\n      initData: initDatas,\n      keyIds,\n    };\n\n    for (const info of drmInfos) {\n      if (info.distinctiveIdentifierRequired) {\n        res.distinctiveIdentifierRequired = info.distinctiveIdentifierRequired;\n      }\n\n      if (info.persistentStateRequired) {\n        res.persistentStateRequired = info.persistentStateRequired;\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Creates a DrmInfo object describing the settings used to initialize the\n   * engine.\n   *\n   * @param {string} keySystem\n   * @param {MediaKeySystemConfiguration} config\n   * @return {shaka.extern.DrmInfo}\n   *\n   * @private\n   */\n  static createDrmInfoByConfigs_(keySystem, config) {\n    /** @type {!Array.<string>} */\n    const licenseServers = [];\n\n    /** @type {!Array.<string>} */\n    const serverCertificateUris = [];\n\n    /** @type {!Array.<!Uint8Array>} */\n    const serverCerts = [];\n\n    /** @type {!Array.<!shaka.extern.InitDataOverride>} */\n    const initDatas = [];\n\n    /** @type {!Set.<string>} */\n    const keyIds = new Set();\n\n    // TODO: refactor, don't stick drmInfos onto MediaKeySystemConfiguration\n    shaka.media.DrmEngine.processDrmInfos_(\n        config['drmInfos'], licenseServers, serverCerts,\n        serverCertificateUris, initDatas, keyIds);\n\n    if (serverCerts.length > 1) {\n      shaka.log.warning('Multiple unique server certificates found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (serverCertificateUris.length > 1) {\n      shaka.log.warning('Multiple unique server certificate URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    if (licenseServers.length > 1) {\n      shaka.log.warning('Multiple unique license server URIs found! ' +\n                        'Only the first will be used.');\n    }\n\n    // TODO: This only works when all DrmInfo have the same robustness.\n    const audioRobustness =\n        config.audioCapabilities ? config.audioCapabilities[0].robustness : '';\n    const videoRobustness =\n        config.videoCapabilities ? config.videoCapabilities[0].robustness : '';\n\n    const distinctiveIdentifier = config.distinctiveIdentifier;\n    return {\n      keySystem,\n      licenseServerUri: licenseServers[0],\n      distinctiveIdentifierRequired: (distinctiveIdentifier == 'required'),\n      persistentStateRequired: (config.persistentState == 'required'),\n      sessionType: config.sessionTypes[0] || 'temporary',\n      audioRobustness: audioRobustness || '',\n      videoRobustness: videoRobustness || '',\n      serverCertificate: serverCerts[0],\n      serverCertificateUri: serverCertificateUris[0],\n      initData: initDatas,\n      keyIds,\n    };\n  }\n\n  /**\n   * Extract license server, server cert, and init data from |drmInfos|, taking\n   * care to eliminate duplicates.\n   *\n   * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n   * @param {!Array.<string>} licenseServers\n   * @param {!Array.<!Uint8Array>} serverCerts\n   * @param {!Array.<string>} serverCertificateUris\n   * @param {!Array.<!shaka.extern.InitDataOverride>} initDatas\n   * @param {!Set.<string>} keyIds\n   * @private\n   */\n  static processDrmInfos_(\n      drmInfos, licenseServers, serverCerts,\n      serverCertificateUris, initDatas, keyIds) {\n    /** @type {function(shaka.extern.InitDataOverride,\n     *                  shaka.extern.InitDataOverride):boolean} */\n    const initDataOverrideEqual = (a, b) => {\n      if (a.keyId && a.keyId == b.keyId) {\n        // Two initDatas with the same keyId are considered to be the same,\n        // unless that \"same keyId\" is null.\n        return true;\n      }\n      return a.initDataType == b.initDataType &&\n         shaka.util.BufferUtils.equal(a.initData, b.initData);\n    };\n\n    for (const drmInfo of drmInfos) {\n      // Build an array of unique license servers.\n      if (!licenseServers.includes(drmInfo.licenseServerUri)) {\n        licenseServers.push(drmInfo.licenseServerUri);\n      }\n\n      // Build an array of unique license servers.\n      if (!serverCertificateUris.includes(drmInfo.serverCertificateUri)) {\n        serverCertificateUris.push(drmInfo.serverCertificateUri);\n      }\n\n      // Build an array of unique server certs.\n      if (drmInfo.serverCertificate) {\n        const found = serverCerts.some(\n            (cert) => shaka.util.BufferUtils.equal(\n                cert, drmInfo.serverCertificate));\n        if (!found) {\n          serverCerts.push(drmInfo.serverCertificate);\n        }\n      }\n\n      // Build an array of unique init datas.\n      if (drmInfo.initData) {\n        for (const initDataOverride of drmInfo.initData) {\n          const found = initDatas.some(\n              (initData) =>\n                initDataOverrideEqual(initData, initDataOverride));\n          if (!found) {\n            initDatas.push(initDataOverride);\n          }\n        }\n      }\n\n      if (drmInfo.keyIds) {\n        for (const keyId of drmInfo.keyIds) {\n          keyIds.add(keyId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Use |servers| and |advancedConfigs| to fill in missing values in drmInfo\n   * that the parser left blank. Before working with any drmInfo, it should be\n   * passed through here as it is uncommon for drmInfo to be complete when\n   * fetched from a manifest because most manifest formats do not have the\n   * required information. Also applies the key systems mapping.\n   *\n   * @param {shaka.extern.DrmInfo} drmInfo\n   * @param {!Map.<string, string>} servers\n   * @param {!Map.<string, shaka.extern.AdvancedDrmConfiguration>}\n   *   advancedConfigs\n   * @param {!Object.<string, string>} keySystemsMapping\n   * @private\n   */\n  static fillInDrmInfoDefaults_(drmInfo, servers, advancedConfigs,\n      keySystemsMapping) {\n    const originalKeySystem = drmInfo.keySystem;\n\n    if (!originalKeySystem) {\n      // This is a placeholder from the manifest parser for an unrecognized key\n      // system.  Skip this entry, to avoid logging nonsensical errors.\n      return;\n    }\n\n    // The order of preference for drmInfo:\n    // 1. Clear Key config, used for debugging, should override everything else.\n    //    (The application can still specify a clearkey license server.)\n    // 2. Application-configured servers, if any are present, should override\n    //    anything from the manifest.  Nuance: if key system A is in the\n    //    manifest and key system B is in the player config, only B will be\n    //    used, not A.\n    // 3. Manifest-provided license servers are only used if nothing else is\n    //    specified.\n    // This is important because it allows the application a clear way to\n    // indicate which DRM systems should be used on platforms with multiple DRM\n    // systems.\n    // The only way to get license servers from the manifest is not to specify\n    // any in your player config.\n\n    if (originalKeySystem == 'org.w3.clearkey' && drmInfo.licenseServerUri) {\n      // Preference 1: Clear Key with pre-configured keys will have a data URI\n      // assigned as its license server.  Don't change anything.\n      return;\n    } else if (servers.size) {\n      // Preference 2: If anything is configured at the application level,\n      // override whatever was in the manifest.\n      const server = servers.get(originalKeySystem) || '';\n\n      drmInfo.licenseServerUri = server;\n    } else {\n      // Preference 3: Keep whatever we had in drmInfo.licenseServerUri, which\n      // comes from the manifest.\n    }\n\n    if (!drmInfo.keyIds) {\n      drmInfo.keyIds = new Set();\n    }\n\n    const advancedConfig = advancedConfigs.get(originalKeySystem);\n\n    if (advancedConfig) {\n      if (!drmInfo.distinctiveIdentifierRequired) {\n        drmInfo.distinctiveIdentifierRequired =\n            advancedConfig.distinctiveIdentifierRequired;\n      }\n\n      if (!drmInfo.persistentStateRequired) {\n        drmInfo.persistentStateRequired =\n            advancedConfig.persistentStateRequired;\n      }\n\n      if (!drmInfo.videoRobustness) {\n        drmInfo.videoRobustness = advancedConfig.videoRobustness;\n      }\n\n      if (!drmInfo.audioRobustness) {\n        drmInfo.audioRobustness = advancedConfig.audioRobustness;\n      }\n\n      if (!drmInfo.serverCertificate) {\n        drmInfo.serverCertificate = advancedConfig.serverCertificate;\n      }\n\n      if (advancedConfig.sessionType) {\n        drmInfo.sessionType = advancedConfig.sessionType;\n      }\n\n      if (!drmInfo.serverCertificateUri) {\n        drmInfo.serverCertificateUri = advancedConfig.serverCertificateUri;\n      }\n    }\n\n    if (keySystemsMapping[originalKeySystem]) {\n      drmInfo.keySystem = keySystemsMapping[originalKeySystem];\n    }\n\n    // Chromecast has a variant of PlayReady that uses a different key\n    // system ID.  Since manifest parsers convert the standard PlayReady\n    // UUID to the standard PlayReady key system ID, here we will switch\n    // to the Chromecast version if we are running on that platform.\n    // Note that this must come after fillInDrmInfoDefaults_, since the\n    // player config uses the standard PlayReady ID for license server\n    // configuration.\n    if (window.cast && window.cast.__platform__) {\n      if (originalKeySystem == 'com.microsoft.playready') {\n        drmInfo.keySystem = 'com.chromecast.playready';\n      }\n    }\n  }\n\n  /**\n   * Parse  pssh from a media segment and announce new initData\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {!BufferSource} mediaSegment\n   * @return {!Promise<void>}\n   */\n  parseInbandPssh(contentType, mediaSegment) {\n    if (!this.config_.parseInbandPsshEnabled) {\n      return Promise.resolve();\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (![ContentType.AUDIO, ContentType.VIDEO].includes(contentType)) {\n      return Promise.resolve();\n    }\n\n    const pssh = new shaka.util.Pssh(\n        shaka.util.BufferUtils.toUint8(mediaSegment));\n\n    let totalLength = 0;\n    for (const data of pssh.data) {\n      totalLength += data.length;\n    }\n    if (totalLength == 0) {\n      return Promise.resolve();\n    }\n    const combinedData = new Uint8Array(totalLength);\n    let pos = 0;\n    for (const data of pssh.data) {\n      combinedData.set(data, pos);\n      pos += data.length;\n    }\n    this.newInitData('cenc', combinedData);\n    return this.allSessionsLoaded_;\n  }\n};\n\n\n/**\n * @typedef {{\n *   loaded: boolean,\n *   initData: Uint8Array,\n *   initDataType: ?string,\n *   oldExpiration: number,\n *   type: string,\n *   updatePromise: shaka.util.PublicPromise\n * }}\n *\n * @description A record to track sessions and suppress duplicate init data.\n * @property {boolean} loaded\n *   True once the key status has been updated (to a non-pending state).  This\n *   does not mean the session is 'usable'.\n * @property {Uint8Array} initData\n *   The init data used to create the session.\n * @property {?string} initDataType\n *   The init data type used to create the session.\n * @property {!MediaKeySession} session\n *   The session object.\n * @property {number} oldExpiration\n *   The expiration of the session on the last check.  This is used to fire\n *   an event when it changes.\n * @property {string} type\n *   The session type\n * @property {shaka.util.PublicPromise} updatePromise\n *   An optional Promise that will be resolved/rejected on the next update()\n *   call.  This is used to track the 'license-release' message when calling\n *   remove().\n */\nshaka.media.DrmEngine.SessionMetaData;\n\n\n/**\n * @typedef {{\n *   netEngine: !shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onKeyStatus: function(!Object.<string,string>),\n *   onExpirationUpdated: function(string,number),\n *   onEvent: function(!Event)\n * }}\n *\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use.  The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs.  If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Object.<string,string>)} onKeyStatus\n *   Called when key status changes.  The argument is a map of hex key IDs to\n *   statuses.\n * @property {function(string,number)} onExpirationUpdated\n *   Called when the session expiration value changes.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n */\nshaka.media.DrmEngine.PlayerInterface;\n\n/**\n * The amount of time, in seconds, we wait to consider a session closed.\n * This allows us to work around Chrome bug https://crbug.com/1108158.\n * @private {number}\n */\nshaka.media.DrmEngine.CLOSE_TIMEOUT_ = 1;\n\n\n/**\n * The amount of time, in seconds, we wait to consider session loaded even if no\n * key status information is available.  This allows us to support browsers/CDMs\n * without key statuses.\n * @private {number}\n */\nshaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_ = 5;\n\n\n/**\n * The amount of time, in seconds, we wait to batch up rapid key status changes.\n * This allows us to avoid multiple expiration events in most cases.\n * @type {number}\n */\nshaka.media.DrmEngine.KEY_STATUS_BATCH_TIME = 0.5;\n\n\n/**\n * Contains the suggested \"default\" key ID used by EME polyfills that do not\n * have a per-key key status. See w3c/encrypted-media#32.\n * @type {!shaka.util.Lazy.<!ArrayBuffer>}\n */\nshaka.media.DrmEngine.DUMMY_KEY_ID = new shaka.util.Lazy(\n    () => shaka.util.BufferUtils.toArrayBuffer(new Uint8Array([0])));\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ManifestParser');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Platform');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * @summary An interface to register manifest parsers.\n * @export\n */\nshaka.media.ManifestParser = class {\n  /**\n   * Registers a manifest parser by file extension.\n   *\n   * @param {string} extension The file extension of the manifest.\n   * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n   *   used to create parser instances.\n   * @export\n   */\n  static registerParserByExtension(extension, parserFactory) {\n    shaka.media.ManifestParser.parsersByExtension[extension] = parserFactory;\n  }\n\n\n  /**\n   * Registers a manifest parser by MIME type.\n   *\n   * @param {string} mimeType The MIME type of the manifest.\n   * @param {shaka.extern.ManifestParser.Factory} parserFactory The factory\n   *   used to create parser instances.\n   * @export\n   */\n  static registerParserByMime(mimeType, parserFactory) {\n    shaka.media.ManifestParser.parsersByMime[mimeType] = parserFactory;\n  }\n\n  /**\n   * Unregisters a manifest parser by MIME type.\n   *\n   * @param {string} mimeType The MIME type of the manifest.\n   * @export\n   */\n  static unregisterParserByMime(mimeType) {\n    delete shaka.media.ManifestParser.parsersByMime[mimeType];\n  }\n\n\n  /**\n   * Returns a map of manifest support for well-known types.\n   *\n   * @return {!Object.<string, boolean>}\n   */\n  static probeSupport() {\n    const ManifestParser = shaka.media.ManifestParser;\n    const support = {};\n\n    // Make sure all registered parsers are shown, but only for MSE-enabled\n    // platforms where our parsers matter.\n    if (shaka.util.Platform.supportsMediaSource()) {\n      for (const type in ManifestParser.parsersByMime) {\n        support[type] = true;\n      }\n      for (const type in ManifestParser.parsersByExtension) {\n        support[type] = true;\n      }\n    }\n\n    // Make sure all well-known types are tested as well, just to show an\n    // explicit false for things people might be expecting.\n    const testMimeTypes = [\n      // DASH\n      'application/dash+xml',\n      // HLS\n      'application/x-mpegurl',\n      'application/vnd.apple.mpegurl',\n      // SmoothStreaming\n      'application/vnd.ms-sstr+xml',\n    ];\n    const testExtensions = {\n      // DASH\n      'mpd': 'application/dash+xml',\n      // HLS\n      'm3u8': 'application/x-mpegurl',\n      // SmoothStreaming\n      'ism': 'application/vnd.ms-sstr+xml',\n    };\n\n    for (const type of testMimeTypes) {\n      // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n      // temporary media element for native support for these types.\n      if (shaka.util.Platform.supportsMediaSource()) {\n        support[type] = !!ManifestParser.parsersByMime[type];\n      } else {\n        support[type] = shaka.util.Platform.supportsMediaType(type);\n      }\n    }\n\n    for (const extension in testExtensions) {\n      // Only query our parsers for MSE-enabled platforms.  Otherwise, query a\n      // temporary media element for native support for these MIME type for the\n      // extension.\n      if (shaka.util.Platform.supportsMediaSource()) {\n        support[extension] = !!ManifestParser.parsersByExtension[extension];\n      } else {\n        const type = testExtensions[extension];\n        support[extension] = shaka.util.Platform.supportsMediaType(type);\n      }\n    }\n\n    return support;\n  }\n\n\n  /**\n   * Get a factory that can create a manifest parser that should be able to\n   * parse the manifest at |uri|.\n   *\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @param {?string} mimeType\n   * @return {!Promise.<shaka.extern.ManifestParser.Factory>}\n   */\n  static async getFactory(uri, netEngine, retryParams, mimeType) {\n    const ManifestParser = shaka.media.ManifestParser;\n\n    // Try using the MIME type we were given.\n    if (mimeType) {\n      const factory = ManifestParser.parsersByMime[mimeType.toLowerCase()];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning(\n          'Could not determine manifest type using MIME type ', mimeType);\n    }\n\n    const extension = ManifestParser.getExtension(uri);\n    if (extension) {\n      const factory = ManifestParser.parsersByExtension[extension];\n      if (factory) {\n        return factory;\n      }\n\n      shaka.log.warning(\n          'Could not determine manifest type for extension ', extension);\n    } else {\n      shaka.log.warning('Could not find extension for ', uri);\n    }\n\n    if (!mimeType) {\n      mimeType = await ManifestParser.getMimeType(uri, netEngine, retryParams);\n\n      if (mimeType) {\n        const factory = shaka.media.ManifestParser.parsersByMime[mimeType];\n        if (factory) {\n          return factory;\n        }\n\n        shaka.log.warning('Could not determine manifest type using MIME type',\n            mimeType);\n      }\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MANIFEST,\n        shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE,\n        uri);\n  }\n\n\n  /**\n   * @param {string} uri\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.extern.RetryParameters} retryParams\n   * @return {!Promise.<string>}\n   */\n  static async getMimeType(uri, netEngine, retryParams) {\n    const type = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n    const request = shaka.net.NetworkingEngine.makeRequest([uri], retryParams);\n    request.method = 'HEAD';\n\n    const response = await netEngine.request(type, request).promise;\n\n    // https://bit.ly/2K9s9kf says this header should always be available,\n    // but just to be safe:\n    const mimeType = response.headers['content-type'];\n    return mimeType ? mimeType.toLowerCase().split(';').shift() : '';\n  }\n\n\n  /**\n   * @param {string} uri\n   * @return {string}\n   */\n  static getExtension(uri) {\n    const uriObj = new goog.Uri(uri);\n    const uriPieces = uriObj.getPath().split('/');\n    const uriFilename = uriPieces.pop();\n    const filenamePieces = uriFilename.split('.');\n\n    // Only one piece means there is no extension.\n    if (filenamePieces.length == 1) {\n      return '';\n    }\n\n    return filenamePieces.pop().toLowerCase();\n  }\n\n\n  /**\n   * Determines whether or not this URI and MIME type are supported by our own\n   * manifest parsers on this platform.  This takes into account whether or not\n   * MediaSource is available, as well as which parsers are registered to the\n   * system.\n   *\n   * @param {string} uri\n   * @param {string} mimeType\n   * @return {boolean}\n   */\n  static isSupported(uri, mimeType) {\n    // Without MediaSource, our own parsers are useless.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      return false;\n    }\n\n    if (mimeType in shaka.media.ManifestParser.parsersByMime) {\n      return true;\n    }\n\n    const extension = shaka.media.ManifestParser.getExtension(uri);\n    if (extension in shaka.media.ManifestParser.parsersByExtension) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\n\n/**\n * Contains the parser factory functions indexed by MIME type.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByMime = {};\n\n\n/**\n * Contains the parser factory functions indexed by file extension.\n *\n * @type {!Object.<string, shaka.extern.ManifestParser.Factory>}\n */\nshaka.media.ManifestParser.parsersByExtension = {};\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ContentWorkarounds');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Lazy');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary\n * A collection of methods to work around content issues on various platforms.\n */\nshaka.media.ContentWorkarounds = class {\n  /**\n   * Transform the init segment into a new init segment buffer that indicates\n   * encryption.  If the init segment already indicates encryption, return the\n   * original init segment.\n   *\n   * Should only be called for MP4 init segments, and only on platforms that\n   * need this workaround.\n   *\n   * @param {!BufferSource} initSegmentBuffer\n   * @return {!Uint8Array}\n   * @see https://github.com/shaka-project/shaka-player/issues/2759\n   */\n  static fakeEncryption(initSegmentBuffer) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    let initSegment = shaka.util.BufferUtils.toUint8(initSegmentBuffer);\n    let isEncrypted = false;\n    /** @type {shaka.extern.ParsedBox} */\n    let stsdBox;\n    const ancestorBoxes = [];\n\n    const onSimpleAncestorBox = (box) => {\n      ancestorBoxes.push(box);\n      shaka.util.Mp4Parser.children(box);\n    };\n\n    const onEncryptionMetadataBox = (box) => {\n      isEncrypted = true;\n    };\n\n    // Multiplexed content could have multiple boxes that we need to modify.\n    // Add to this array in order of box offset.  This will be important later,\n    // when we process the boxes.\n    /** @type {!Array.<{box: shaka.extern.ParsedBox, newType: number}>} */\n    const boxesToModify = [];\n\n    new shaka.util.Mp4Parser()\n        .box('moov', onSimpleAncestorBox)\n        .box('trak', onSimpleAncestorBox)\n        .box('mdia', onSimpleAncestorBox)\n        .box('minf', onSimpleAncestorBox)\n        .box('stbl', onSimpleAncestorBox)\n        .fullBox('stsd', (box) => {\n          stsdBox = box;\n          ancestorBoxes.push(box);\n          shaka.util.Mp4Parser.sampleDescription(box);\n        })\n        .fullBox('encv', onEncryptionMetadataBox)\n        .fullBox('enca', onEncryptionMetadataBox)\n        .fullBox('hev1', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('hvc1', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('avc1', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('avc3', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCV_,\n          });\n        })\n        .fullBox('ac-3', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCA_,\n          });\n        })\n        .fullBox('ec-3', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCA_,\n          });\n        })\n        .fullBox('mp4a', (box) => {\n          boxesToModify.push({\n            box,\n            newType: ContentWorkarounds.BOX_TYPE_ENCA_,\n          });\n        }).parse(initSegment);\n\n    if (isEncrypted) {\n      shaka.log.debug('Init segment already indicates encryption.');\n      return initSegment;\n    }\n\n    if (boxesToModify.length == 0 || !stsdBox) {\n      shaka.log.error('Failed to find boxes needed to fake encryption!');\n      shaka.log.v2('Failed init segment (hex):',\n          shaka.util.Uint8ArrayUtils.toHex(initSegment));\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.CONTENT_TRANSFORMATION_FAILED);\n    }\n\n    // Modify boxes in order from largest offset to smallest, so that earlier\n    // boxes don't have their offsets changed before we process them.\n    boxesToModify.reverse();  // in place!\n    for (const workItem of boxesToModify) {\n      const insertedBoxType =\n          shaka.util.Mp4Parser.typeToString(workItem.newType);\n      shaka.log.debug(`Inserting \"${insertedBoxType}\" box into init segment.`);\n      initSegment = ContentWorkarounds.insertEncryptionMetadata_(\n          initSegment, stsdBox, workItem.box, ancestorBoxes, workItem.newType);\n    }\n\n    return initSegment;\n  }\n\n  /**\n   * Insert an encryption metadata box (\"encv\" or \"enca\" box) into the MP4 init\n   * segment, based on the source box (\"mp4a\", \"avc1\", etc).  Returns a new\n   * buffer containing the modified init segment.\n   *\n   * @param {!Uint8Array} initSegment\n   * @param {shaka.extern.ParsedBox} stsdBox\n   * @param {shaka.extern.ParsedBox} sourceBox\n   * @param {!Array.<shaka.extern.ParsedBox>} ancestorBoxes\n   * @param {number} metadataBoxType\n   * @return {!Uint8Array}\n   * @private\n   */\n  static insertEncryptionMetadata_(\n      initSegment, stsdBox, sourceBox, ancestorBoxes, metadataBoxType) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    const metadataBoxArray = ContentWorkarounds.createEncryptionMetadata_(\n        initSegment, sourceBox, metadataBoxType);\n\n    // Construct a new init segment array with room for the encryption metadata\n    // box we're adding.\n    const newInitSegment =\n        new Uint8Array(initSegment.byteLength + metadataBoxArray.byteLength);\n\n    // For Xbox One, we cut and insert at the start of the source box.  For\n    // other platforms, we cut and insert at the end of the source box.  It's\n    // not clear why this is necessary on Xbox One, but it seems to be evidence\n    // of another bug in the firmware implementation of MediaSource & EME.\n    const cutPoint = shaka.util.Platform.isXboxOne() ?\n        sourceBox.start :\n        sourceBox.start + sourceBox.size;\n\n    // The data before the cut point will be copied to the same location as\n    // before.  The data after that will be appended after the added metadata\n    // box.\n    const beforeData = initSegment.subarray(0, cutPoint);\n    const afterData = initSegment.subarray(cutPoint);\n\n    newInitSegment.set(beforeData);\n    newInitSegment.set(metadataBoxArray, cutPoint);\n    newInitSegment.set(afterData, cutPoint + metadataBoxArray.byteLength);\n\n    // The parents up the chain from the encryption metadata box need their\n    // sizes adjusted to account for the added box.  These offsets should not be\n    // changed, because they should all be within the first section we copy.\n    for (const box of ancestorBoxes) {\n      goog.asserts.assert(box.start < cutPoint,\n          'Ancestor MP4 box found in the wrong location!  ' +\n          'Modified init segment will not make sense!');\n      ContentWorkarounds.updateBoxSize_(\n          newInitSegment, box.start, box.size + metadataBoxArray.byteLength);\n    }\n\n    // Add one to the sample entries field of the \"stsd\" box.  This is a 4-byte\n    // field just past the box header.\n    const stsdBoxView = shaka.util.BufferUtils.toDataView(\n        newInitSegment, stsdBox.start);\n    const stsdBoxHeaderSize = shaka.util.Mp4Parser.headerSize(stsdBox);\n    const numEntries = stsdBoxView.getUint32(stsdBoxHeaderSize);\n    stsdBoxView.setUint32(stsdBoxHeaderSize, numEntries + 1);\n\n    return newInitSegment;\n  }\n\n  /**\n   * Create an encryption metadata box (\"encv\" or \"enca\" box), based on the\n   * source box (\"mp4a\", \"avc1\", etc).  Returns a new buffer containing the\n   * encryption metadata box.\n   *\n   * @param {!Uint8Array} initSegment\n   * @param {shaka.extern.ParsedBox} sourceBox\n   * @param {number} metadataBoxType\n   * @return {!Uint8Array}\n   * @private\n   */\n  static createEncryptionMetadata_(initSegment, sourceBox, metadataBoxType) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    const sinfBoxArray = ContentWorkarounds.CANNED_SINF_BOX_.value();\n\n    // Create a subarray which points to the source box data.\n    const sourceBoxArray = initSegment.subarray(\n        /* start= */ sourceBox.start,\n        /* end= */ sourceBox.start + sourceBox.size);\n\n    // Create a view on the source box array.\n    const sourceBoxView = shaka.util.BufferUtils.toDataView(sourceBoxArray);\n\n    // Create an array to hold the new encryption metadata box, which is based\n    // on the source box.\n    const metadataBoxArray = new Uint8Array(\n        sourceBox.size + sinfBoxArray.byteLength);\n\n    // Copy the source box into the new array.\n    metadataBoxArray.set(sourceBoxArray, /* targetOffset= */ 0);\n\n    // Change the box type.\n    const metadataBoxView = shaka.util.BufferUtils.toDataView(metadataBoxArray);\n    metadataBoxView.setUint32(\n        ContentWorkarounds.BOX_TYPE_OFFSET_, metadataBoxType);\n\n    // Append the \"sinf\" box to the encryption metadata box.\n    metadataBoxArray.set(sinfBoxArray, /* targetOffset= */ sourceBox.size);\n\n    // Update the \"sinf\" box's format field (in the child \"frma\" box) to reflect\n    // the format of the original source box.\n    const sourceBoxType = sourceBoxView.getUint32(\n        ContentWorkarounds.BOX_TYPE_OFFSET_);\n    metadataBoxView.setUint32(\n        sourceBox.size + ContentWorkarounds.CANNED_SINF_BOX_FORMAT_OFFSET_,\n        sourceBoxType);\n\n    // Now update the encryption metadata box size.\n    ContentWorkarounds.updateBoxSize_(\n        metadataBoxArray, /* boxStart= */ 0, metadataBoxArray.byteLength);\n\n    return metadataBoxArray;\n  }\n\n  /**\n   * Modify an MP4 box's size field in-place.\n   *\n   * @param {!Uint8Array} dataArray\n   * @param {number} boxStart The start position of the box in dataArray.\n   * @param {number} newBoxSize The new size of the box.\n   * @private\n   */\n  static updateBoxSize_(dataArray, boxStart, newBoxSize) {\n    const ContentWorkarounds = shaka.media.ContentWorkarounds;\n    const boxView = shaka.util.BufferUtils.toDataView(dataArray, boxStart);\n    const sizeField = boxView.getUint32(ContentWorkarounds.BOX_SIZE_OFFSET_);\n    if (sizeField == 0) { // Means \"the rest of the box\".\n      // No adjustment needed for this box.\n    } else if (sizeField == 1) { // Means \"use 64-bit size box\".\n      // Set the 64-bit int in two 32-bit parts.\n      // The high bits should definitely be 0 in practice, but we're being\n      // thorough here.\n      boxView.setUint32(ContentWorkarounds.BOX_SIZE_64_OFFSET_,\n          newBoxSize >> 32);\n      boxView.setUint32(ContentWorkarounds.BOX_SIZE_64_OFFSET_ + 4,\n          newBoxSize & 0xffffffff);\n    } else { // Normal 32-bit size field.\n      // Not checking the size of the value here, since a box larger than 4GB is\n      // unrealistic.\n      boxView.setUint32(ContentWorkarounds.BOX_SIZE_OFFSET_, newBoxSize);\n    }\n  }\n};\n\n/**\n * A canned \"sinf\" box for use when adding fake encryption metadata to init\n * segments.\n *\n * @const {!shaka.util.Lazy.<!Uint8Array>}\n * @private\n * @see https://github.com/shaka-project/shaka-player/issues/2759\n */\nshaka.media.ContentWorkarounds.CANNED_SINF_BOX_ =\n    new shaka.util.Lazy(() => new Uint8Array([\n      // sinf box\n      // Size: 0x50 = 80\n      0x00, 0x00, 0x00, 0x50,\n\n      // Type: sinf\n      0x73, 0x69, 0x6e, 0x66,\n\n      // Children of sinf...\n\n      // frma box\n      // Size: 0x0c = 12\n      0x00, 0x00, 0x00, 0x0c,\n\n      // Type: frma (child of sinf)\n      0x66, 0x72, 0x6d, 0x61,\n\n      // Format: filled in later based on the source box (\"avc1\", \"mp4a\", etc)\n      0x00, 0x00, 0x00, 0x00,\n      // end of frma box\n\n      // schm box\n      // Size: 0x14 = 20\n      0x00, 0x00, 0x00, 0x14,\n\n      // Type: schm (child of sinf)\n      0x73, 0x63, 0x68, 0x6d,\n\n      // Version: 0, Flags: 0\n      0x00, 0x00, 0x00, 0x00,\n\n      // Scheme: cenc\n      0x63, 0x65, 0x6e, 0x63,\n\n      // Scheme version: 1.0\n      0x00, 0x01, 0x00, 0x00,\n      // end of schm box\n\n      // schi box\n      // Size: 0x28 = 40\n      0x00, 0x00, 0x00, 0x28,\n\n      // Type: schi (child of sinf)\n      0x73, 0x63, 0x68, 0x69,\n\n      // Children of schi...\n\n      // tenc box\n      // Size: 0x20 = 32\n      0x00, 0x00, 0x00, 0x20,\n\n      // Type: tenc (child of schi)\n      0x74, 0x65, 0x6e, 0x63,\n\n      // Version: 0, Flags: 0\n      0x00, 0x00, 0x00, 0x00,\n\n      // Reserved fields\n      0x00, 0x00,\n\n      // Default protected: true\n      0x01,\n\n      // Default per-sample IV size: 8\n      0x08,\n\n      // Default key ID: all zeros (dummy)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // end of tenc box\n\n      // end of schi box\n\n      // end of sinf box\n    ]));\n\n/**\n * The location of the format field in the \"frma\" box inside the canned \"sinf\"\n * box above.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.CANNED_SINF_BOX_FORMAT_OFFSET_ = 0x10;\n\n/**\n * Offset to a box's size field.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_SIZE_OFFSET_ = 0;\n\n/**\n * Offset to a box's type field.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_TYPE_OFFSET_ = 4;\n\n/**\n * Offset to a box's 64-bit size field, if it has one.\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_SIZE_64_OFFSET_ = 8;\n\n/**\n * Box type for \"encv\".\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_TYPE_ENCV_ = 0x656e6376;\n\n/**\n * Box type for \"enca\".\n *\n * @const {number}\n * @private\n */\nshaka.media.ContentWorkarounds.BOX_TYPE_ENCA_ = 0x656e6361;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.CeaUtils');\ngoog.provide('shaka.cea.CeaUtils.StyledChar');\n\ngoog.require('shaka.cea.ICaptionDecoder');\ngoog.require('shaka.text.Cue');\n\n\nshaka.cea.CeaUtils = class {\n  /**\n   * Emits a closed caption based on the state of the buffer.\n   * @param {!shaka.text.Cue} topLevelCue\n   * @param {string} stream\n   * @param {!Array<!Array<?shaka.cea.CeaUtils.StyledChar>>} memory\n   * @param {number} startTime Start time of the cue.\n   * @param {number} endTime End time of the cue.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  static getParsedCaption(topLevelCue, stream, memory, startTime, endTime) {\n    if (startTime >= endTime) {\n      return null;\n    }\n\n    // Find the first and last row that contains characters.\n    let firstNonEmptyRow = -1;\n    let lastNonEmptyRow = -1;\n\n    for (let i = 0; i < memory.length; i++) {\n      if (memory[i].some((e) => e != null && e.getChar().trim() != '')) {\n        firstNonEmptyRow = i;\n        break;\n      }\n    }\n\n    for (let i = memory.length - 1; i >= 0; i--) {\n      if (memory[i].some((e) => e != null && e.getChar().trim() != '')) {\n        lastNonEmptyRow = i;\n        break;\n      }\n    }\n\n    // Exit early if no non-empty row was found.\n    if (firstNonEmptyRow === -1 || lastNonEmptyRow === -1) {\n      return null;\n    }\n\n    // Keeps track of the current styles for a cue being emitted.\n    let currentUnderline = false;\n    let currentItalics = false;\n    let currentTextColor = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    let currentBackgroundColor = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n\n    // Create first cue that will be nested in top level cue. Default styles.\n    let currentCue = shaka.cea.CeaUtils.createStyledCue(\n        startTime, endTime, currentUnderline, currentItalics,\n        currentTextColor, currentBackgroundColor);\n\n    // Logic: Reduce rows into a single top level cue containing nested cues.\n    // Each nested cue corresponds either a style change or a line break.\n\n    for (let i = firstNonEmptyRow; i <= lastNonEmptyRow; i++) {\n      // Find the first and last non-empty characters in this row. We do this so\n      // no styles creep in before/after the first and last non-empty chars.\n      const row = memory[i];\n      let firstNonEmptyCol = -1;\n      let lastNonEmptyCol = -1;\n\n      for (let j = 0; j < row.length; j++) {\n        if (row[j] != null && row[j].getChar().trim() !== '') {\n          firstNonEmptyCol = j;\n          break;\n        }\n      }\n\n      for (let j = row.length - 1; j >= 0; j--) {\n        if (row[j] != null && row[j].getChar().trim() !== '') {\n          lastNonEmptyCol = j;\n          break;\n        }\n      }\n\n      // If no non-empty char. was found in this row, it must be a linebreak.\n      if (firstNonEmptyCol === -1 || lastNonEmptyCol === -1) {\n        const linebreakCue = shaka.cea.CeaUtils\n            .createLineBreakCue(startTime, endTime);\n        topLevelCue.nestedCues.push(linebreakCue);\n        continue;\n      }\n\n      for (let j = firstNonEmptyCol; j <= lastNonEmptyCol; j++) {\n        const styledChar = row[j];\n\n        // A null between non-empty cells in a row is handled as a space.\n        if (!styledChar) {\n          currentCue.payload += ' ';\n          continue;\n        }\n        const underline = styledChar.isUnderlined();\n        const italics = styledChar.isItalicized();\n        const textColor = styledChar.getTextColor();\n        const backgroundColor = styledChar.getBackgroundColor();\n\n        // If any style properties have changed, we need to open a new cue.\n        if (underline != currentUnderline || italics != currentItalics ||\n            textColor != currentTextColor ||\n            backgroundColor != currentBackgroundColor) {\n          // Push the currently built cue and start a new cue, with new styles.\n          if (currentCue.payload) {\n            topLevelCue.nestedCues.push(currentCue);\n          }\n          currentCue = shaka.cea.CeaUtils.createStyledCue(\n              startTime, endTime, underline,\n              italics, textColor, backgroundColor);\n\n          currentUnderline = underline;\n          currentItalics = italics;\n          currentTextColor = textColor;\n          currentBackgroundColor = backgroundColor;\n        }\n\n        currentCue.payload += styledChar.getChar();\n      }\n      if (currentCue.payload) {\n        topLevelCue.nestedCues.push(currentCue);\n      }\n\n      // Add a linebreak since the row just ended.\n      if (i !== lastNonEmptyRow) {\n        const linebreakCue = shaka.cea.CeaUtils\n            .createLineBreakCue(startTime, endTime);\n        topLevelCue.nestedCues.push(linebreakCue);\n      }\n\n      // Create a new cue.\n      currentCue = shaka.cea.CeaUtils.createStyledCue(\n          startTime, endTime, currentUnderline, currentItalics,\n          currentTextColor, currentBackgroundColor);\n    }\n\n    if (topLevelCue.nestedCues.length) {\n      return {\n        cue: topLevelCue,\n        stream,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {boolean} underline\n   * @param {boolean} italics\n   * @param {string} txtColor\n   * @param {string} bgColor\n   * @return {!shaka.text.Cue}\n   */\n  static createStyledCue(startTime, endTime, underline,\n      italics, txtColor, bgColor) {\n    const cue = new shaka.text.Cue(startTime, endTime, /* payload= */ '');\n    if (underline) {\n      cue.textDecoration.push(shaka.text.Cue.textDecoration.UNDERLINE);\n    }\n    if (italics) {\n      cue.fontStyle = shaka.text.Cue.fontStyle.ITALIC;\n    }\n    cue.color = txtColor;\n    cue.backgroundColor = bgColor;\n    return cue;\n  }\n\n  /**\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {!shaka.text.Cue}\n   */\n  static createLineBreakCue(startTime, endTime) {\n    const linebreakCue = new shaka.text.Cue(\n        startTime, endTime, /* payload= */ '');\n    linebreakCue.lineBreak = true;\n    return linebreakCue;\n  }\n};\n\nshaka.cea.CeaUtils.StyledChar = class {\n  /**\n   * @param {string} character\n   * @param {boolean} underline\n   * @param {boolean} italics\n   * @param {string} backgroundColor\n   * @param {string} textColor\n   */\n  constructor(character, underline, italics, backgroundColor, textColor) {\n    /**\n     * @private {string}\n     */\n    this.character_ = character;\n\n    /**\n     * @private {boolean}\n     */\n    this.underline_ = underline;\n\n    /**\n     * @private {boolean}\n     */\n    this.italics_ = italics;\n\n    /**\n     * @private {string}\n     */\n    this.backgroundColor_ = backgroundColor;\n\n    /**\n     * @private {string}\n     */\n    this.textColor_ = textColor;\n  }\n\n  /**\n   * @return {string}\n   */\n  getChar() {\n    return this.character_;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isUnderlined() {\n    return this.underline_;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isItalicized() {\n    return this.italics_;\n  }\n\n  /**\n   * @return {string}\n   */\n  getBackgroundColor() {\n    return this.backgroundColor_;\n  }\n\n  /**\n   * @return {string}\n   */\n  getTextColor() {\n    return this.textColor_;\n  }\n};\n\n/**\n * Default background color for text.\n * @const {string}\n */\nshaka.cea.CeaUtils.DEFAULT_BG_COLOR = 'black';\n\n/**\n * Default text color.\n * @const {string}\n */\nshaka.cea.CeaUtils.DEFAULT_TXT_COLOR = 'white';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea608Memory');\n\ngoog.require('shaka.cea.CeaUtils');\ngoog.require('shaka.text.Cue');\ngoog.requireType('shaka.cea.ICaptionDecoder');\n\n\n/**\n * CEA-608 captions memory/buffer.\n */\nshaka.cea.Cea608Memory = class {\n  /**\n   * @param {number} fieldNum Field number.\n   * @param {number} channelNum Channel number.\n   */\n  constructor(fieldNum, channelNum) {\n    /**\n     * Buffer for storing decoded characters.\n     * @private @const {!Array<!Array<!shaka.cea.CeaUtils.StyledChar>>}\n     */\n    this.rows_ = [];\n\n    /**\n     * Current row.\n     * @private {number}\n     */\n    this.row_ = 1;\n\n    /**\n     * Number of rows in the scroll window. Used for rollup mode.\n     * @private {number}\n     */\n    this.scrollRows_ = 0;\n\n    /**\n     * Field number.\n     * @private {number}\n     */\n    this.fieldNum_ = fieldNum;\n\n    /**\n     * Channel number.\n     * @private {number}\n     */\n    this.channelNum_ = channelNum;\n\n    /**\n     * @private {boolean}\n     */\n    this.underline_ = false;\n\n    /**\n     * @private {boolean}\n     */\n    this.italics_ = false;\n\n    /**\n     * @private {string}\n     */\n    this.textColor_ = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n\n    /**\n     * @private {string}\n     */\n    this.backgroundColor_ = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n\n    this.reset();\n  }\n\n  /**\n   * Emits a closed caption based on the state of the buffer.\n   * @param {number} startTime Start time of the cue.\n   * @param {number} endTime End time of the cue.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  forceEmit(startTime, endTime) {\n    const stream = `CC${(this.fieldNum_<< 1) | this.channelNum_ +1}`;\n    const topLevelCue = new shaka.text.Cue(\n        startTime, endTime, /* payload= */ '');\n    return shaka.cea.CeaUtils.getParsedCaption(\n        topLevelCue, stream, this.rows_, startTime, endTime);\n  }\n\n  /**\n   * Resets the memory buffer.\n   */\n  reset() {\n    this.resetAllRows();\n    this.row_ = 1;\n  }\n\n  /**\n   * @return {number}\n   */\n  getRow() {\n    return this.row_;\n  }\n\n  /**\n   * @param {number} row\n   */\n  setRow(row) {\n    this.row_ = row;\n  }\n\n  /**\n   * @return {number}\n   */\n  getScrollSize() {\n    return this.scrollRows_;\n  }\n\n  /**\n   * @param {number} scrollRows\n   */\n  setScrollSize(scrollRows) {\n    this.scrollRows_ = scrollRows;\n  }\n\n  /**\n   * Adds a character to the buffer.\n   * @param {!shaka.cea.Cea608Memory.CharSet} set Character set.\n   * @param {number} b CC byte to add.\n   */\n  addChar(set, b) {\n    // Valid chars are in the range [0x20, 0x7f]\n    if (b < 0x20 || b > 0x7f) {\n      return;\n    }\n\n    let char = '';\n    switch (set) {\n      case shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN:\n        if (shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars.has(b)) {\n          char =\n                shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars.get(b);\n        } else {\n          // Regular ASCII\n          char = String.fromCharCode(b);\n        }\n        break;\n      case shaka.cea.Cea608Memory.CharSet.SPECIAL_NORTH_AMERICAN:\n        char =\n              shaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars.get(b);\n        break;\n      case shaka.cea.Cea608Memory.CharSet.SPANISH_FRENCH:\n        // Extended charset does a BS over preceding char, 6.4.2 EIA-608-B.\n        this.eraseChar();\n        char =\n              shaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench.get(b);\n        break;\n      case shaka.cea.Cea608Memory.CharSet.PORTUGUESE_GERMAN:\n        this.eraseChar();\n        char =\n              shaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman.get(b);\n        break;\n    }\n\n    if (char) {\n      const styledChar = new shaka.cea.CeaUtils.StyledChar(\n          char, this.underline_, this.italics_,\n          this.backgroundColor_, this.textColor_);\n      this.rows_[this.row_].push(styledChar);\n    }\n  }\n\n  /**\n   * Erases a character from the buffer.\n   */\n  eraseChar() {\n    this.rows_[this.row_].pop();\n  }\n\n  /**\n   * Moves rows of characters.\n   * @param {number} dst Destination row index.\n   * @param {number} src Source row index.\n   * @param {number} count Count of rows to move.\n   */\n  moveRows(dst, src, count) {\n    if (src < 0 || dst < 0) {\n      return;\n    }\n\n    if (dst >= src) {\n      for (let i = count-1; i >= 0; i--) {\n        this.rows_[dst + i] = this.rows_[src + i].map((e) => e);\n      }\n    } else {\n      for (let i = 0; i < count; i++) {\n        this.rows_[dst + i] = this.rows_[src + i].map((e) => e);\n      }\n    }\n  }\n\n  /**\n   * Resets rows of characters.\n   * @param {number} idx Starting index.\n   * @param {number} count Count of rows to reset.\n   */\n  resetRows(idx, count) {\n    for (let i = 0; i <= count; i++) {\n      this.rows_[idx + i] = [];\n    }\n  }\n\n  /**\n   * Resets the entire memory buffer.\n   */\n  resetAllRows() {\n    this.resetRows(0, shaka.cea.Cea608Memory.CC_ROWS);\n  }\n\n  /**\n   * Erases entire memory buffer.\n   * Doesn't change scroll state or number of rows.\n   */\n  eraseBuffer() {\n    this.row_ = (this.scrollRows_ > 0) ? this.scrollRows_ : 0;\n    this.resetAllRows();\n  }\n\n  /**\n   * @param {boolean} underline\n   */\n  setUnderline(underline) {\n    this.underline_ = underline;\n  }\n\n  /**\n   * @param {boolean} italics\n   */\n  setItalics(italics) {\n    this.italics_ = italics;\n  }\n\n  /**\n   * @param {string} color\n   */\n  setTextColor(color) {\n    this.textColor_ = color;\n  }\n\n  /**\n   * @param {string} color\n   */\n  setBackgroundColor(color) {\n    this.backgroundColor_ = color;\n  }\n};\n\n/**\n * Maximum number of rows in the buffer.\n * @const {number}\n */\nshaka.cea.Cea608Memory.CC_ROWS = 15;\n\n/**\n * Characters sets.\n * @const @enum {number}\n */\nshaka.cea.Cea608Memory.CharSet = {\n  BASIC_NORTH_AMERICAN: 0,\n  SPECIAL_NORTH_AMERICAN: 1,\n  SPANISH_FRENCH: 2,\n  PORTUGUESE_GERMAN: 3,\n};\n\n/**\n * Basic North American char set deviates from ASCII with these exceptions.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars = new Map([\n  [0x27, ''], [0x2a, ''], [0x5c, ''], [0x5c, ''], [0x5e, ''], [0x5f, ''],\n  [0x60, ''], [0x7b, ''], [0x7c, ''], [0x7d, ''], [0x7e, ''], [0x7f, ''],\n]);\n\n/**\n * Special North American char set.\n * Note: Transparent Space is currently implemented as a regular space.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars = new Map([\n  [0x30, ''], [0x31, ''], [0x32, ''], [0x33, ''], [0x34, ''], [0x35, ''],\n  [0x36, ''], [0x37, ''], [0x38, ''], [0x39, ''], [0x3a, ''], [0x3b, ''],\n  [0x3c, ''], [0x3d, ''], [0x3e, ''], [0x3f, ''],\n]);\n\n/**\n * Extended Spanish/Misc/French char set.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench = new Map([\n  [0x20, ''], [0x21, ''], [0x22, ''], [0x23, ''], [0x24, ''], [0x25, ''],\n  [0x26, ''], [0x27, ''], [0x28, '*'], [0x29, '\\''], [0x2a, ''], [0x2b, ''],\n  [0x2c, ''], [0x2d, ''], [0x2e, ''], [0x2f, ''], [0x30, ''], [0x31, ''],\n  [0x32, ''], [0x33, ''], [0x34, ''], [0x35, ''], [0x36, ''], [0x37, ''],\n  [0x38, ''], [0x39, ''], [0x3a, ''], [0x3b, ''], [0x3c, ''], [0x3d, ''],\n  [0x3e, ''], [0x3f, ''],\n]);\n\n/**\n * Extended Portuguese/German/Danish char set.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman = new Map([\n  [0x20, ''], [0x21, ''], [0x22, ''], [0x23, ''], [0x24, ''], [0x25, ''],\n  [0x26, ''], [0x27, ''], [0x28, ''], [0x29, '{'], [0x2a, '}'], [0x2b, '\\\\'],\n  [0x2c, '^'], [0x2d, '_'], [0x2e, '|'], [0x2f, '~'], [0x30, ''], [0x31, ''],\n  [0x32, ''], [0x33, ''], [0x34, ''], [0x35, ''], [0x36, ''], [0x37, ''],\n  [0x38, ''], [0x39, ''], [0x3a, ''], [0x3b, ''], [0x3c, ''], [0x3d, ''],\n  [0x3e, ''], [0x3f, ''],\n]);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea608DataChannel');\n\ngoog.require('shaka.cea.Cea608Memory');\ngoog.require('shaka.cea.CeaUtils');\ngoog.require('shaka.log');\ngoog.requireType('shaka.cea.ICaptionDecoder');\n\n\n/**\n * 608 closed captions channel.\n */\nshaka.cea.Cea608DataChannel = class {\n  /**\n   * @param {number} fieldNum Field number.\n   * @param {number} channelNum Channel number.\n   */\n  constructor(fieldNum, channelNum) {\n    /**\n     * Current Caption Type.\n     * @public {!shaka.cea.Cea608DataChannel.CaptionType}\n     */\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.NONE;\n\n    /**\n     * Text buffer for CEA-608 \"text mode\". Although, we don't emit text mode.\n     * So, this buffer serves as a no-op placeholder, just in case we receive\n     * captions that toggle text mode.\n     * @private @const {!shaka.cea.Cea608Memory}\n     */\n    this.text_ =\n        new shaka.cea.Cea608Memory(fieldNum, channelNum);\n\n    /**\n     * Displayed memory.\n     * @private {!shaka.cea.Cea608Memory}\n     */\n    this.displayedMemory_ =\n        new shaka.cea.Cea608Memory(fieldNum, channelNum);\n\n    /**\n     * Non-displayed memory.\n     * @private {!shaka.cea.Cea608Memory}\n     */\n    this.nonDisplayedMemory_ =\n        new shaka.cea.Cea608Memory(fieldNum, channelNum);\n\n    /**\n     * Points to current buffer.\n     * @private {!shaka.cea.Cea608Memory}\n     */\n    this.curbuf_ = this.displayedMemory_;\n\n    /**\n     * End time of the previous caption, serves as start time of next caption.\n     * @private {number}\n     */\n    this.prevEndTime_ = 0;\n\n    /**\n     * Last control pair, 16 bits representing byte 1 and byte 2\n     * @private {?number}\n     */\n    this.lastcp_ = null;\n  }\n\n  /**\n   * Resets channel state.\n   */\n  reset() {\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.PAINTON;\n    this.curbuf_ = this.displayedMemory_;\n    this.lastcp_ = null;\n    this.displayedMemory_.reset();\n    this.nonDisplayedMemory_.reset();\n    this.text_.reset();\n  }\n\n  /**\n   * Gets the row index from a Preamble Address Code byte pair.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {number} Row index.\n   * @private\n   */\n  pacToRow_(b1, b2) {\n    const ccrowtab = [\n      11, 11,  // 0x00 or 0x01\n      1, 2,    // 0x02 -> 0x03\n      3, 4,    // 0x04 -> 0x05\n      12, 13,  // 0x06 -> 0x07\n      14, 15,  // 0x08 -> 0x09\n      5, 6,    // 0x0A -> 0x0B\n      7, 8,    // 0x0C -> 0x0D\n      9, 10,   // 0x0E -> 0x0F\n    ];\n    return ccrowtab[((b1 & 0x07) << 1) | ((b2 >> 5) & 0x01)];\n  }\n\n  /**\n   * PAC - Preamble Address Code.\n   * b1 is of the form |P|0|0|1|C|0|ROW|\n   * b2 is of the form |P|1|N|ATTRIBUTE|U|\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @private\n   */\n  controlPac_(b1, b2) {\n    const row = this.pacToRow_(b1, b2);\n\n    // Get attribute bits (4 bits)\n    const attr = (b2 & 0x1E) >> 1;\n\n    // Set up the defaults.\n    let textColor = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    let italics = false;\n\n\n    // Attributes < 7 are colors, = 7 is white w/ italics, and >7 are indents\n    if (attr < 7) {\n      textColor = shaka.cea.Cea608DataChannel.TEXT_COLORS[attr];\n    } else if (attr === 7) {\n      italics = true; // color stays white\n    }\n\n    // PACs toggle underline on the last bit of b2.\n    const underline = (b2 & 0x01) === 0x01;\n\n    if (this.type_ === shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      // Don't execute the PAC if in text mode.\n      return;\n    }\n\n    // Execute the PAC.\n    const buf = this.curbuf_;\n\n    // Move entire scroll window to a new base in rollup mode.\n    if (this.type_ === shaka.cea.Cea608DataChannel.CaptionType.ROLLUP &&\n        row !== buf.getRow()) {\n      const oldTopRow = 1 + buf.getRow() - buf.getScrollSize();\n      const newTopRow = 1 + row - buf.getScrollSize();\n\n      // Shift up the scroll window.\n      buf.moveRows(newTopRow, oldTopRow, buf.getScrollSize());\n\n      // Clear everything outside of the new scroll window.\n      buf.resetRows(0, newTopRow - 1);\n      buf.resetRows(row + 1,\n          shaka.cea.Cea608Memory.CC_ROWS - row);\n    }\n    buf.setRow(row);\n\n    this.curbuf_.setUnderline(underline);\n    this.curbuf_.setItalics(italics);\n    this.curbuf_.setTextColor(textColor);\n\n    // Clear the background color, since new row (PAC) should reset ALL styles.\n    this.curbuf_.setBackgroundColor(shaka.cea.CeaUtils.DEFAULT_BG_COLOR);\n  }\n\n  /**\n   * Mid-Row control code handler.\n   * @param {number} b2 Byte #2.\n   * @private\n   */\n  controlMidrow_(b2) {\n    // Clear all pre-existing midrow style attributes.\n    this.curbuf_.setUnderline(false);\n    this.curbuf_.setItalics(false);\n    this.curbuf_.setTextColor(shaka.cea.CeaUtils.DEFAULT_TXT_COLOR);\n\n    // Mid-row attrs use a space.\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN, ' '.charCodeAt(0));\n\n    let textColor = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    let italics = false;\n\n    // Midrow codes set underline on last (LSB) bit.\n    const underline = (b2 & 0x01) === 0x01;\n\n    // b2 has the form |P|0|1|0|STYLE|U|\n    textColor = shaka.cea.Cea608DataChannel.TEXT_COLORS[(b2 & 0xe) >> 1];\n    if (textColor === 'white_italics') {\n      textColor = 'white';\n      italics = true;\n    }\n\n    this.curbuf_.setUnderline(underline);\n    this.curbuf_.setItalics(italics);\n    this.curbuf_.setTextColor(textColor);\n  }\n\n  /**\n   * Background attribute control code handler.\n   * @param {number} b1 Byte #1\n   * @param {number} b2 Byte #2.\n   * @private\n   */\n  controlBackgroundAttribute_(b1, b2) {\n    let backgroundColor = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n    if ((b1 & 0x07) === 0x0) {\n      // If background provided, last 3 bits of b1 are |0|0|0|. Color is in b2.\n      backgroundColor = shaka.cea.Cea608DataChannel.BG_COLORS[(b2 & 0xe) >> 1];\n    }\n    this.curbuf_.setBackgroundColor(backgroundColor);\n  }\n\n  /**\n   * The Cea608DataChannel control methods implement all CC control operations.\n   * @param {!shaka.cea.Cea608DataChannel.Cea608Packet} ccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlMiscellaneous_(ccPacket) {\n    const MiscCmd = shaka.cea.Cea608DataChannel.MiscCmd_;\n    const b2 = ccPacket.ccData2;\n    const pts = ccPacket.pts;\n    let parsedClosedCaption = null;\n\n    switch (b2) {\n      case MiscCmd.RCL:\n        this.controlRcl_();\n        break;\n      case MiscCmd.BS:\n        this.controlBs_();\n        break;\n        // unused (alarm off and alarm on)\n      case MiscCmd.AOD:\n      case MiscCmd.AON:\n        break;\n      case MiscCmd.DER:\n        // Delete to End of Row. Not implemented since position not supported.\n        break;\n      case MiscCmd.RU2:\n        parsedClosedCaption = this.controlRu_(2, pts);\n        break;\n      case MiscCmd.RU3:\n        parsedClosedCaption = this.controlRu_(3, pts);\n        break;\n      case MiscCmd.RU4:\n        parsedClosedCaption = this.controlRu_(4, pts);\n        break;\n      case MiscCmd.FON:\n        this.controlFon_();\n        break;\n      case MiscCmd.RDC:\n        this.controlRdc_(pts);\n        break;\n      case MiscCmd.TR:\n        this.controlTr_();\n        break;\n      case MiscCmd.RTD:\n        this.controlRtd_();\n        break;\n      case MiscCmd.EDM:\n        parsedClosedCaption = this.controlEdm_(pts);\n        break;\n      case MiscCmd.CR:\n        parsedClosedCaption = this.controlCr_(pts);\n        break;\n      case MiscCmd.ENM:\n        this.controlEnm_();\n        break;\n      case MiscCmd.EOC:\n        parsedClosedCaption = this.controlEoc_(pts);\n        break;\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles CR - Carriage Return (Start new row).\n   * CR only affects scroll windows (Rollup and Text modes).\n   * Any currently buffered line needs to be emitted, along\n   * with a window scroll action.\n   * @param {number} pts in seconds.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlCr_(pts) {\n    const buf = this.curbuf_;\n    // Only rollup and text mode is affected, but we don't emit text mode.\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.ROLLUP) {\n      return null;\n    }\n    // Force out the scroll window since the top row will cleared.\n    const parsedClosedCaption = buf.forceEmit(this.prevEndTime_, pts);\n\n    // Calculate the top of the scroll window.\n    const toprow = (buf.getRow() - buf.getScrollSize()) + 1;\n\n    // Shift up the window one row higher.\n    buf.moveRows(toprow - 1, toprow, buf.getScrollSize());\n\n    // Clear out anything that's outside of our current scroll window.\n    buf.resetRows(0, toprow - 1);\n    buf.resetRows(buf.getRow(), shaka.cea.Cea608Memory.CC_ROWS - buf.getRow());\n\n    // Update the end time so the next caption emits starting at this time.\n    this.prevEndTime_ = pts;\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles RU2, RU3, RU4 - Roll-Up, N rows.\n   * If in TEXT, POPON or PAINTON, any displayed captions are erased.\n   *    This means must force emit entire display buffer.\n   * @param {number} scrollSize New scroll window size.\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlRu_(scrollSize, pts) {\n    this.curbuf_ = this.displayedMemory_;  // Point to displayed memory\n    const buf = this.curbuf_;\n    let parsedClosedCaption = null;\n\n    // For any type except rollup and text mode, it should be emitted,\n    // and memories cleared.\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.ROLLUP &&\n        this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      parsedClosedCaption = buf.forceEmit(this.prevEndTime_, pts);\n\n      // Clear both memories.\n      this.displayedMemory_.eraseBuffer();\n      this.nonDisplayedMemory_.eraseBuffer();\n\n      // Rollup base row defaults to the last row (15).\n      buf.setRow(shaka.cea.Cea608Memory.CC_ROWS);\n    }\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.ROLLUP;\n\n    // Set the new rollup window size.\n    buf.setScrollSize(scrollSize);\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles flash on.\n   * @private\n   */\n  controlFon_() {\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN,\n        ' '.charCodeAt(0));\n  }\n\n\n  /**\n   * Handles EDM - Erase Displayed Mem\n   * Mode check:\n   * EDM affects all captioning modes (but not Text mode);\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  controlEdm_(pts) {\n    const buf = this.displayedMemory_;\n    let parsedClosedCaption = null;\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      // Clearing displayed memory means we now know how long\n      // its contents were displayed, so force it out.\n      parsedClosedCaption = buf.forceEmit(this.prevEndTime_, pts);\n    }\n    buf.resetAllRows();\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles RDC - Resume Direct Captions. Initiates Paint-On captioning mode.\n   * RDC does not affect current display, so nothing needs to be forced out yet.\n   * @param {number} pts in seconds\n   * @private\n   */\n  controlRdc_(pts) {\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.PAINTON;\n    // Point to displayed memory.\n    this.curbuf_ = this.displayedMemory_;\n\n    // No scroll window now.\n    this.curbuf_.setScrollSize(0);\n\n    // The next paint-on caption needs this time as the start time.\n    this.prevEndTime_ = pts;\n  }\n\n\n  /**\n   * Handles ENM - Erase Nondisplayed Mem\n   * @private\n   */\n  controlEnm_() {\n    this.nonDisplayedMemory_.resetAllRows();\n  }\n\n  /**\n   * Handles EOC - End Of Caption (flip mem)\n   * This forces Pop-On mode, and swaps the displayed and nondisplayed memories.\n   * @private\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  controlEoc_(pts) {\n    let parsedClosedCaption = null;\n    if (this.type_ !== shaka.cea.Cea608DataChannel.CaptionType.TEXT) {\n      parsedClosedCaption =\n        this.displayedMemory_.forceEmit(this.prevEndTime_, pts);\n    }\n    // Swap memories\n    const buf = this.nonDisplayedMemory_;\n    this.nonDisplayedMemory_ = this.displayedMemory_;  // Swap buffers\n    this.displayedMemory_ = buf;\n\n    // Enter Pop-On mode.\n    this.controlRcl_();\n\n    // The caption ended, and so the previous end time should be updated.\n    this.prevEndTime_ = pts;\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Handles RCL - Resume Caption Loading\n   * Initiates Pop-On style captioning. No need to force anything out upon\n   * entering Pop-On mode because it does not affect the current display.\n   * @private\n   */\n  controlRcl_() {\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.POPON;\n    this.curbuf_ = this.nonDisplayedMemory_;\n    // No scroll window now\n    this.curbuf_.setScrollSize(0);\n  }\n\n\n  /**\n   * Handles BS - BackSpace.\n   * @private\n   */\n  controlBs_() {\n    this.curbuf_.eraseChar();\n  }\n\n  /**\n   * Handles TR - Text Restart.\n   * Clears text buffer and resumes Text Mode.\n   * @private\n   */\n  controlTr_() {\n    this.text_.reset();\n    this.controlRtd_();  // Put into text mode.\n  }\n\n  /**\n   * Handles RTD - Resume Text Display.\n   * Resumes text mode. No need to force anything out, because Text Mode doesn't\n   * affect current display. Also, this decoder does not emit Text Mode anyway.\n   * @private\n   */\n  controlRtd_() {\n    shaka.log.warnOnce('Cea608DataChannel',\n        'CEA-608 text mode entered, but is unsupported');\n    this.curbuf_ = this.text_;\n    this.type_ = shaka.cea.Cea608DataChannel.CaptionType.TEXT;\n  }\n\n  /**\n   * Handles a Basic North American byte pair.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   */\n  handleBasicNorthAmericanChar(b1, b2) {\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN, b1);\n    this.curbuf_.addChar(\n        shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN, b2);\n  }\n\n  /**\n   * Handles an Extended Western European byte pair.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @private\n   */\n  handleExtendedWesternEuropeanChar_(b1, b2) {\n    // Get the char set from the LSB, which is the char set toggle bit.\n    const charSet = b1 & 0x01 ?\n          shaka.cea.Cea608Memory.CharSet.PORTUGUESE_GERMAN:\n          shaka.cea.Cea608Memory.CharSet.SPANISH_FRENCH;\n\n    this.curbuf_.addChar(charSet, b2);\n  }\n\n  /**\n   * Decodes control code.\n   * Three types of control codes:\n   * Preamble Address Codes, Mid-Row Codes, and Miscellaneous Control Codes.\n   * @param {!shaka.cea.Cea608DataChannel.Cea608Packet} ccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  handleControlCode(ccPacket) {\n    const b1 = ccPacket.ccData1;\n    const b2 = ccPacket.ccData2;\n\n    // FCC wants control codes transmitted twice, and that will often be\n    // seen in broadcast captures. If the very next frame has a duplicate\n    // control code, that duplicate is ignored. Note that this only applies\n    // to the very next frame, and only for one match.\n    if (this.lastcp_ === ((b1 << 8) | b2)) {\n      this.lastcp_ = null;\n      return null;\n    }\n\n    // Remember valid control code for checking in next frame!\n    this.lastcp_ = (b1 << 8) | b2;\n\n    if (this.isPAC_(b1, b2)) {\n      this.controlPac_(b1, b2);\n    } else if (this.isMidrowStyleChange_(b1, b2)) {\n      this.controlMidrow_(b2);\n    } else if (this.isBackgroundAttribute_(b1, b2)) {\n      this.controlBackgroundAttribute_(b1, b2);\n    } else if (this.isSpecialNorthAmericanChar_(b1, b2)) {\n      this.curbuf_.addChar(\n          shaka.cea.Cea608Memory.CharSet.SPECIAL_NORTH_AMERICAN, b2);\n    } else if (this.isExtendedWesternEuropeanChar_(b1, b2)) {\n      this.handleExtendedWesternEuropeanChar_(b1, b2);\n    } else if (this.isMiscellaneous_(b1, b2)) {\n      return this.controlMiscellaneous_(ccPacket);\n    }\n    return null;\n  }\n\n  /**\n   * Checks if this is a Miscellaneous control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isMiscellaneous_(b1, b2) {\n    // For Miscellaneous Control Codes, the bytes take the following form:\n    // b1 -> |0|0|0|1|C|1|0|F|\n    // b2 -> |0|0|1|0|X|X|X|X|\n    return ((b1 & 0xf6) === 0x14) && ((b2 & 0xf0) === 0x20);\n  }\n\n  /**\n   * Checks if this is a PAC control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isPAC_(b1, b2) {\n    // For Preamble Address Codes, the bytes take the following form:\n    // b1 -> |0|0|0|1|X|X|X|X|\n    // b2 -> |0|1|X|X|X|X|X|X|\n    return ((b1 & 0xf0) === 0x10) && ((b2 & 0xc0) === 0x40);\n  }\n\n  /**\n   * Checks if this is a Midrow style change control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isMidrowStyleChange_(b1, b2) {\n    // For Midrow Control Codes, the bytes take the following form:\n    // b1 -> |0|0|0|1|C|0|0|1|\n    // b2 -> |0|0|1|0|X|X|X|X|\n    return ((b1 & 0xf7) === 0x11) && ((b2 & 0xf0) === 0x20);\n  }\n\n  /**\n   * Checks if this is a background attribute control code.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isBackgroundAttribute_(b1, b2) {\n    // For Background Attribute Codes, the bytes take the following form:\n    // Bg provided: b1 -> |0|0|0|1|C|0|0|0| b2 -> |0|0|1|0|COLOR|T|\n    // No Bg:       b1 -> |0|0|0|1|C|1|1|1| b2 -> |0|0|1|0|1|1|0|1|\n    return (((b1 & 0xf7) === 0x10) && ((b2 & 0xf0) === 0x20)) ||\n             (((b1 & 0xf7) === 0x17) && ((b2 & 0xff) === 0x2D));\n  }\n\n  /**\n   * Checks if the character is in the Special North American char. set.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isSpecialNorthAmericanChar_(b1, b2) {\n    // The bytes take the following form:\n    // b1 -> |0|0|0|1|C|0|0|1|\n    // b2 -> |0|0|1|1|  CHAR |\n    return ((b1 & 0xf7) === 0x11) && ((b2 & 0xf0) === 0x30);\n  }\n\n  /**\n   * Checks if the character is in the Extended Western European char. set.\n   * @param {number} b1 Byte 1.\n   * @param {number} b2 Byte 2.\n   * @return {boolean}\n   * @private\n   */\n  isExtendedWesternEuropeanChar_(b1, b2) {\n    // The bytes take the following form:\n    // b1 -> |0|0|0|1|C|0|1|S|\n    // b2 -> |0|0|1|CHARACTER|\n    return ((b1 & 0xf6) === 0x12) && ((b2 & 0xe0) === 0x20);\n  }\n\n  /**\n   * Checks if the data contains a control code.\n   * @param {number} b1 Byte 1.\n   * @return {boolean}\n   */\n  static isControlCode(b1) {\n    // For control codes, the first byte takes the following form:\n    // b1 -> |P|0|0|1|X|X|X|X|\n    return (b1 & 0x70) === 0x10;\n  }\n};\n\n/**\n * Command codes.\n * @enum {number}\n * @private\n */\nshaka.cea.Cea608DataChannel.MiscCmd_ = {\n  // \"RCL - Resume Caption Loading\"\n  RCL: 0x20,\n\n  // \"BS  - BackSpace\"\n  BS: 0x21,\n\n  // \"AOD - Unused (alarm off)\"\n  AOD: 0x22,\n\n  // \"AON - Unused (alarm on)\"\n  AON: 0x23,\n\n  // \"DER - Delete to End of Row\"\n  DER: 0x24,\n\n  // \"RU2 - Roll-Up, 2 rows\"\n  RU2: 0x25,\n\n  // \"RU3 - Roll-Up, 3 rows\"\n  RU3: 0x26,\n\n  // \"RU4 - Roll-Up, 4 rows\"\n  RU4: 0x27,\n\n  // \"FON - Flash On\"\n  FON: 0x28,\n\n  // \"RDC - Resume Direct Captions\"\n  RDC: 0x29,\n\n  // \"TR - Text Restart\"\n  TR: 0x2a,\n\n  // \"RTD - Resume Text Display\"\n  RTD: 0x2b,\n\n  // \"EDM - Erase Displayed Mem\"\n  EDM: 0x2c,\n\n  // \"CR  - Carriage return\"\n  CR: 0x2d,\n\n  // \"ENM - Erase Nondisplayed Mem\"\n  ENM: 0x2e,\n\n  // \"EOC - End Of Caption (flip mem)\"\n  EOC: 0x2f,\n};\n\n/**\n * Caption type.\n * @private @const @enum {number}\n */\nshaka.cea.Cea608DataChannel.CaptionType = {\n  NONE: 0,\n  POPON: 1,\n  PAINTON: 2,\n  ROLLUP: 3,\n  TEXT: 4,\n};\n\n/**\n * @const {!Array<string>}\n */\nshaka.cea.Cea608DataChannel.BG_COLORS = [\n  'black',\n  'green',\n  'blue',\n  'cyan',\n  'red',\n  'yellow',\n  'magenta',\n  'black',\n];\n\n/**\n * @const {!Array<string>}\n */\nshaka.cea.Cea608DataChannel.TEXT_COLORS = [\n  'white',\n  'green',\n  'blue',\n  'cyan',\n  'red',\n  'yellow',\n  'magenta',\n  'white_italics',\n];\n\n/**\n * Style associated with a cue.\n * @typedef {{\n *   textColor: ?string,\n *   backgroundColor: ?string,\n *   italics: ?boolean,\n *   underline: ?boolean\n * }}\n */\nshaka.cea.Cea608DataChannel.Style;\n\n/**\n * CEA closed captions packet.\n * @typedef {{\n  *   pts: number,\n  *   type: number,\n  *   ccData1: number,\n  *   ccData2: number,\n  *   order: number\n  * }}\n  *\n  * @property {number} pts\n  *   Presentation timestamp (in second) at which this packet was received.\n  * @property {number} type\n  *   Type of the packet. Either 0 or 1, representing the CEA-608 field.\n  * @property {number} ccData1 CEA-608 byte 1.\n  * @property {number} ccData2 CEA-608 byte 2.\n  * @property {number} order\n  *   A number indicating the order this packet was received in a sequence\n  *   of packets. Used to break ties in a stable sorting algorithm\n  */\nshaka.cea.Cea608DataChannel.Cea608Packet;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea708Window');\n\ngoog.require('shaka.cea.CeaUtils');\ngoog.require('shaka.cea.CeaUtils.StyledChar');\ngoog.require('shaka.cea.ICaptionDecoder');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.util.Functional');\n\n\n/**\n * CEA-708 Window. Each CEA-708 service owns 8 of these.\n */\nshaka.cea.Cea708Window = class {\n  /**\n   * @param {number} windowNum\n   */\n  constructor(windowNum) {\n    /**\n     * A number from 0 - 7 indicating the window number in the\n     * service that owns this window.\n     * @private {number}\n     */\n    this.windowNum_ = windowNum;\n\n    /**\n     * Indicates whether this window is visible.\n     * @private {boolean}\n     */\n    this.visible_ = false;\n\n    /**\n     * Indicates whether the horizontal and vertical anchors coordinates specify\n     * a percentage of the screen, or physical coordinates on the screen.\n     * @private {boolean}\n     */\n    this.relativeToggle_ = false;\n\n    /**\n     * Horizontal anchor. Loosely corresponds to a WebVTT viewport X anchor.\n     * @private {number}\n     */\n    this.horizontalAnchor_ = 0;\n\n    /**\n     * Vertical anchor. Loosely corresponds to a WebVTT viewport Y anchor.\n     * @private {number}\n     */\n    this.verticalAnchor_ = 0;\n\n    /**\n     * If valid, ranges from 0 to 8, specifying one of 9 locations on window:\n     * 0________1________2\n     * |        |        |\n     * 3________4________5\n     * |        |        |\n     * 6________7________8\n     * Diagram is valid as per CEA-708-E section 8.4.4.\n     * Each of these locations corresponds to a WebVTT region's \"region anchor\".\n     * @private {number}\n     */\n    this.anchorId_ = 0;\n\n    /**\n     * Indicates the number of rows in this window's buffer/memory.\n     * @private {number}\n     */\n    this.rowCount_ = 0;\n\n    /**\n     * Indicates the number of columns in this window's buffer/memory.\n     * @private {number}\n     */\n    this.colCount_ = 0;\n\n    /**\n     * Center by default.\n     * @private {!shaka.cea.Cea708Window.TextJustification}\n     */\n    this.justification_ = shaka.cea.Cea708Window.TextJustification.CENTER;\n\n    /**\n     * An array of rows of styled characters, representing the\n     * current text and styling of text in this window.\n     * @private {!Array<!Array<?shaka.cea.CeaUtils.StyledChar>>}\n     */\n    this.memory_ = [];\n\n    /**\n     * @private {number}\n     */\n    this.startTime_ = 0;\n\n    /**\n     * Row that the current pen is pointing at.\n     * @private {number}\n     */\n    this.row_ = 0;\n\n    /**\n     * Column that the current pen is pointing at.\n     * @private {number}\n     */\n    this.col_ = 0;\n\n    /**\n     * Indicates whether the current pen position is italicized.\n     * @private {boolean}\n     */\n    this.italics_ = false;\n\n    /**\n     * Indicates whether the current pen position is underlined.\n     * @private {boolean}\n     */\n    this.underline_ = false;\n\n    /**\n     * Indicates the text color at the current pen position.\n     * @private {string}\n     */\n    this.textColor_ = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n\n    /**\n     * Indicates the background color at the current pen position.\n     * @private {string}\n     */\n    this.backgroundColor_ = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n\n    this.resetMemory();\n\n    // TODO Support window positioning by mapping them to Regions.\n    // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-708\n    shaka.util.Functional.ignored(this.verticalAnchor_, this.relativeToggle_,\n        this.horizontalAnchor_, this.anchorId_, this.windowNum_);\n  }\n\n  /**\n   * @param {boolean} visible\n   * @param {number} verticalAnchor\n   * @param {number} horizontalAnchor\n   * @param {number} anchorId\n   * @param {boolean} relativeToggle\n   * @param {number} rowCount\n   * @param {number} colCount\n   */\n  defineWindow(visible, verticalAnchor, horizontalAnchor, anchorId,\n      relativeToggle, rowCount, colCount) {\n    this.visible_ = visible;\n    this.verticalAnchor_ = verticalAnchor;\n    this.horizontalAnchor_ = horizontalAnchor;\n    this.anchorId_ = anchorId;\n    this.relativeToggle_ = relativeToggle;\n    this.rowCount_ = rowCount;\n    this.colCount_ = colCount;\n  }\n\n  /**\n   * Resets the memory buffer.\n   */\n  resetMemory() {\n    this.memory_ = [];\n    for (let i = 0; i < shaka.cea.Cea708Window.MAX_ROWS; i++) {\n      this.memory_.push(this.createNewRow_());\n    }\n  }\n\n  /**\n   * Allocates and returns a new row.\n   * @return {!Array<?shaka.cea.CeaUtils.StyledChar>}\n   * @private\n   */\n  createNewRow_() {\n    const row = [];\n    for (let j = 0; j < shaka.cea.Cea708Window.MAX_COLS; j++) {\n      row.push(null);\n    }\n    return row;\n  }\n\n  /**\n   * Sets the unicode value for a char at the current pen location.\n   * @param {string} char\n   */\n  setCharacter(char) {\n    // Check if the pen is out of bounds.\n    if (!this.isPenInBounds_()) {\n      return;\n    }\n\n    const cea708Char = new shaka.cea.CeaUtils.StyledChar(\n        char, this.underline_, this.italics_,\n        this.backgroundColor_, this.textColor_);\n    this.memory_[this.row_][this.col_] = cea708Char;\n\n    // Increment column\n    this.col_ ++;\n  }\n\n  /**\n   * Erases a character from the buffer and moves the pen back.\n   */\n  backspace() {\n    if (!this.isPenInBounds_()) {\n      return;\n    }\n\n    // Check if a backspace can be done.\n    if (this.col_ <= 0 && this.row_ <= 0) {\n      return;\n    }\n\n    if (this.col_ <= 0) {\n      // Move pen back a row.\n      this.col_ = this.colCount_ - 1;\n      this.row_--;\n    } else {\n      // Move pen back a column.\n      this.col_--;\n    }\n\n    // Erase the character occupied at that position.\n    this.memory_[this.row_][this.col_] = null;\n  }\n\n  /**\n   * @private\n   */\n  isPenInBounds_() {\n    const inRowBounds = this.row_ < this.rowCount_ && this.row_ >= 0;\n    const inColBounds = this.col_ < this.colCount_ && this.col_ >= 0;\n    return inRowBounds && inColBounds;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isVisible() {\n    return this.visible_;\n  }\n\n  /**\n   * Moves up <count> rows in the buffer.\n   * @param {number} count\n   * @private\n   */\n  moveUpRows_(count) {\n    let dst = 0; // Row each row should be moved to.\n\n    // Move existing rows up by <count>.\n    for (let i = count; i < shaka.cea.Cea708Window.MAX_ROWS; i++, dst++) {\n      this.memory_[dst] = this.memory_[i];\n    }\n\n    // Create <count> new rows at the bottom.\n    for (let i = 0; i < count; i++, dst++) {\n      this.memory_[dst] = this.createNewRow_();\n    }\n  }\n\n  /**\n   * Handles CR. Increments row - if last row, \"roll up\" all rows by one.\n   */\n  carriageReturn() {\n    if (this.row_ + 1 >= this.rowCount_) {\n      this.moveUpRows_(1);\n      this.col_ = 0;\n      return;\n    }\n\n    this.row_++;\n    this.col_ = 0;\n  }\n\n  /**\n   * Handles HCR. Moves the pen to the beginning of the cur. row and clears it.\n   */\n  horizontalCarriageReturn() {\n    this.memory_[this.row_] = this.createNewRow_();\n    this.col_ = 0;\n  }\n\n  /**\n   * @param {number} endTime\n   * @param {number} serviceNumber Number of the service emitting this caption.\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   */\n  forceEmit(endTime, serviceNumber) {\n    const stream = `svc${serviceNumber}`;\n    const TextJustification = shaka.cea.Cea708Window.TextJustification;\n    const topLevelCue = new shaka.text.Cue(\n        this.startTime_, endTime, /* payload= */ '');\n\n    if (this.justification_ === TextJustification.LEFT) {\n      // LEFT justified.\n      topLevelCue.textAlign = shaka.text.Cue.textAlign.LEFT;\n    } else if (this.justification_ === TextJustification.RIGHT) {\n      // RIGHT justified.\n      topLevelCue.textAlign = shaka.text.Cue.textAlign.RIGHT;\n    } else {\n      // CENTER justified. Both FULL and CENTER are handled as CENTER justified.\n      topLevelCue.textAlign = shaka.text.Cue.textAlign.CENTER;\n    }\n\n    const caption = shaka.cea.CeaUtils.getParsedCaption(\n        topLevelCue, stream, this.memory_, this.startTime_, endTime);\n    if (caption) {\n      // If a caption is being emitted, then the next caption's start time\n      // should be no less than this caption's end time.\n      this.setStartTime(endTime);\n    }\n    return caption;\n  }\n\n  /**\n   * @param {number} row\n   * @param {number} col\n   */\n  setPenLocation(row, col) {\n    this.row_ = row;\n    this.col_ = col;\n  }\n\n  /**\n   * @param {string} backgroundColor\n   */\n  setPenBackgroundColor(backgroundColor) {\n    this.backgroundColor_ = backgroundColor;\n  }\n\n  /**\n   * @param {string} textColor\n   */\n  setPenTextColor(textColor) {\n    this.textColor_ = textColor;\n  }\n\n  /**\n   * @param {boolean} underline\n   */\n  setPenUnderline(underline) {\n    this.underline_ = underline;\n  }\n\n  /**\n   * @param {boolean} italics\n   */\n  setPenItalics(italics) {\n    this.italics_ = italics;\n  }\n\n  /** Reset the pen to 0,0 with default styling. */\n  resetPen() {\n    this.row_ = 0;\n    this.col_ = 0;\n    this.underline_ = false;\n    this.italics_ = false;\n    this.textColor_ = shaka.cea.CeaUtils.DEFAULT_TXT_COLOR;\n    this.backgroundColor_ = shaka.cea.CeaUtils.DEFAULT_BG_COLOR;\n  }\n\n  /**\n   * @param {!shaka.cea.Cea708Window.TextJustification} justification\n   */\n  setJustification(justification) {\n    this.justification_ = justification;\n  }\n\n  /**\n   * Sets the window to visible.\n   */\n  display() {\n    this.visible_ = true;\n  }\n\n  /**\n   * Sets the window to invisible.\n   */\n  hide() {\n    this.visible_ = false;\n  }\n\n  /**\n   * Toggles the visibility of the window.\n   */\n  toggle() {\n    this.visible_ = !this.visible_;\n  }\n\n  /**\n   * Sets the start time for the cue to be emitted.\n   * @param {number} pts\n   */\n  setStartTime(pts) {\n    this.startTime_ = pts;\n  }\n};\n\n/**\n * Caption type.\n * @const @enum {number}\n */\nshaka.cea.Cea708Window.TextJustification = {\n  LEFT: 0,\n  RIGHT: 1,\n  CENTER: 2,\n  FULL: 3,\n};\n\n/**\n * Can be indexed 0-31 for 4:3 format, and 0-41 for 16:9 formats.\n * Thus the absolute maximum is 42 columns for the 16:9 format.\n * @private @const {number}\n */\nshaka.cea.Cea708Window.MAX_COLS = 42;\n\n/**\n * Maximum of 16 rows that can be indexed from 0 to 15.\n * @private @const {number}\n */\nshaka.cea.Cea708Window.MAX_ROWS = 16;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.DtvccPacketBuilder');\ngoog.provide('shaka.cea.DtvccPacket');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.cea.Cea708Service');\n\n\n/**\n * CEA-708 DTVCC Packet Builder.\n * Builds packets based on Figure 5 CCP State Table in 5.2 of CEA-708-E.\n * Initially, there is no packet. When a DTVCC_PACKET_START payload is received,\n * a packet begins construction. The packet is considered \"built\" once all bytes\n * indicated in the header are read, and ignored if a new packet starts building\n * before the current packet is finished being built.\n */\nshaka.cea.DtvccPacketBuilder = class {\n  /** */\n  constructor() {\n    /**\n     * An array containing built DTVCC packets that are ready to be processed.\n     * @private {!Array<!shaka.cea.DtvccPacket>}\n     */\n    this.builtPackets_ = [];\n\n    /**\n     * Stores the packet data for the current packet being processed, if any.\n     * @private {?Array<!shaka.cea.Cea708Service.Cea708Byte>}\n     */\n    this.currentPacketBeingBuilt_ = null;\n\n    /**\n     * Keeps track of the number of bytes left to add in the current packet.\n     * @private {number}\n     */\n    this.bytesLeftToAddInCurrentPacket_ = 0;\n  }\n\n  /**\n   * @param {!shaka.cea.Cea708Service.Cea708Byte} cea708Byte\n   */\n  addByte(cea708Byte) {\n    if (cea708Byte.type === shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_START) {\n      // If there was a packet being built that finished, it would have\n      // already been added to the built packets when it finished. So if\n      // there's an open packet at this point, it must be unfinished. As\n      // per the spec, we don't deal with unfinished packets. So we ignore them.\n\n      // A new packet should be opened.\n      const packetSize = cea708Byte.value & 0x3f;\n\n      // As per spec, number of packet data bytes to follow is packetSize*2-1.\n      this.bytesLeftToAddInCurrentPacket_ = packetSize * 2 - 1;\n      this.currentPacketBeingBuilt_ = [];\n      return;\n    }\n\n    if (!this.currentPacketBeingBuilt_) {\n      // There is no packet open. Then an incoming byte should not\n      // have come in at all. Ignore it.\n      return;\n    }\n\n    if (this.bytesLeftToAddInCurrentPacket_ > 0) {\n      this.currentPacketBeingBuilt_.push(cea708Byte);\n      this.bytesLeftToAddInCurrentPacket_--;\n    }\n\n    if (this.bytesLeftToAddInCurrentPacket_ === 0) {\n      // Current packet is complete and ready for processing.\n      const packet = new shaka.cea.DtvccPacket(this.currentPacketBeingBuilt_);\n      this.builtPackets_.push(packet);\n      this.currentPacketBeingBuilt_ = null;\n      this.bytesLeftToAddInCurrentPacket_ = 0;\n    }\n  }\n\n  /**\n   * @return {!Array<!shaka.cea.DtvccPacket>}\n   */\n  getBuiltPackets() {\n    return this.builtPackets_;\n  }\n\n  /** Clear built packets. */\n  clearBuiltPackets() {\n    this.builtPackets_ = [];\n  }\n\n  /** Clear built packets and packets in progress. */\n  clear() {\n    this.builtPackets_ = [];\n    this.currentPacketBeingBuilt_ = [];\n    this.bytesLeftToAddInCurrentPacket_ = 0;\n  }\n};\n\n\nshaka.cea.DtvccPacket = class {\n  /**\n   * @param {!Array<!shaka.cea.Cea708Service.Cea708Byte>} packetData\n   */\n  constructor(packetData) {\n    /**\n     * Keeps track of the position to read the next byte from in the packet.\n     * @private {number}\n     */\n    this.pos_ = 0;\n\n    /**\n     * Bytes that represent the data in the DTVCC packet.\n     * @private {!Array<!shaka.cea.Cea708Service.Cea708Byte>}\n     */\n    this.packetData_ = packetData;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasMoreData() {\n    return this.pos_ < this.packetData_.length;\n  }\n\n  /**\n   * @return {number}\n   */\n  getPosition() {\n    return this.pos_;\n  }\n\n  /**\n   * Reads a byte from the packet. TODO CONSIDER RENAMING THIS TO BLOCK\n   * @return {!shaka.cea.Cea708Service.Cea708Byte}\n   * @throws {!shaka.util.Error}\n   */\n  readByte() {\n    if (!this.hasMoreData()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n    }\n    return this.packetData_[this.pos_++];\n  }\n\n  /**\n   * Skips the provided number of blocks in the buffer.\n   * @param {number} numBlocks\n   * @throws {!shaka.util.Error}\n   */\n  skip(numBlocks) {\n    if (this.pos_ + numBlocks > this.packetData_.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS);\n    }\n    this.pos_ += numBlocks;\n  }\n};\n\n/**\n * @const {number}\n */\nshaka.cea.DtvccPacketBuilder.DTVCC_PACKET_DATA = 2;\n\n/**\n * @const {number}\n */\nshaka.cea.DtvccPacketBuilder.DTVCC_PACKET_START = 3;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Cea708Service');\n\ngoog.require('shaka.cea.Cea708Window');\ngoog.require('shaka.cea.DtvccPacket');\ngoog.require('shaka.cea.ICaptionDecoder');\n\n\n/**\n * CEA-708 closed captions service as defined by CEA-708-E. A decoder can own up\n * to 63 services. Each service owns eight windows.\n */\nshaka.cea.Cea708Service = class {\n  /**\n   * @param {number} serviceNumber\n   */\n  constructor(serviceNumber) {\n    /**\n     * Number for this specific service (1 - 63).\n     * @private {number}\n     */\n    this.serviceNumber_ = serviceNumber;\n\n    /**\n     * Eight Cea708 Windows, as defined by the spec.\n     * @private {!Array<?shaka.cea.Cea708Window>}\n     */\n    this.windows_ = [\n      null, null, null, null, null, null, null, null,\n    ];\n\n    /**\n     * The current window for which window command operate on.\n     * @private {?shaka.cea.Cea708Window}\n     */\n    this.currentWindow_ = null;\n  }\n\n  /**\n   * Processes a CEA-708 control code.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @throws {!shaka.util.Error}\n   */\n  handleCea708ControlCode(dtvccPacket) {\n    const blockData = dtvccPacket.readByte();\n    let controlCode = blockData.value;\n    const pts = blockData.pts;\n\n    // Read extended control code if needed.\n    if (controlCode === shaka.cea.Cea708Service.EXT_CEA708_CTRL_CODE_BYTE1) {\n      const extendedControlCodeBlock = dtvccPacket.readByte();\n      controlCode = (controlCode << 16) | extendedControlCodeBlock.value;\n    }\n\n    // Control codes are in 1 of 4 logical groups:\n    // CL (C0, C2), CR (C1, C3), GL (G0, G2), GR (G1, G2).\n    if (controlCode >= 0x00 && controlCode <= 0x1f) {\n      return this.handleC0_(controlCode, pts);\n    } else if (controlCode >= 0x80 && controlCode <= 0x9f) {\n      return this.handleC1_(dtvccPacket, controlCode, pts);\n    } else if (controlCode >= 0x1000 && controlCode <= 0x101f) {\n      this.handleC2_(dtvccPacket, controlCode & 0xff);\n    } else if (controlCode >= 0x1080 && controlCode <= 0x109f) {\n      this.handleC3_(dtvccPacket, controlCode & 0xff);\n    } else if (controlCode >= 0x20 && controlCode <= 0x7f) {\n      this.handleG0_(controlCode);\n    } else if (controlCode >= 0xa0 && controlCode <= 0xff) {\n      this.handleG1_(controlCode);\n    } else if (controlCode >= 0x1020 && controlCode <= 0x107f) {\n      this.handleG2_(controlCode & 0xff);\n    } else if (controlCode >= 0x10a0 && controlCode <= 0x10ff) {\n      this.handleG3_(controlCode & 0xff);\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles G0 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG0_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n    // G0 contains ASCII from 0x20 to 0x7f, with the exception that 0x7f\n    // is replaced by a musical note.\n    if (controlCode === 0x7f) {\n      this.currentWindow_.setCharacter('');\n      return;\n    }\n    this.currentWindow_.setCharacter(String.fromCharCode(controlCode));\n  }\n\n  /**\n   * Handles G1 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG1_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n    // G1 is the Latin-1 Character Set from 0xa0 to 0xff.\n    this.currentWindow_.setCharacter(String.fromCharCode(controlCode));\n  }\n\n  /**\n   * Handles G2 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG2_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n    if (!shaka.cea.Cea708Service.G2Charset.has(controlCode)) {\n      // If the character is unsupported, the spec says to put an underline.\n      this.currentWindow_.setCharacter('_');\n      return;\n    }\n\n    const char = shaka.cea.Cea708Service.G2Charset.get(controlCode);\n    this.currentWindow_.setCharacter(char);\n  }\n\n  /**\n   * Handles G3 group data.\n   * @param {number} controlCode\n   * @private\n   */\n  handleG3_(controlCode) {\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    // As of CEA-708-E, the G3 group only contains 1 character. It's a\n    // [CC] character which has no unicode value on 0xa0.\n    if (controlCode != 0xa0) {\n      // Similar to G2, the spec decrees an underline if char is unsupported.\n      this.currentWindow_.setCharacter('_');\n      return;\n    }\n\n    this.currentWindow_.setCharacter('[CC]');\n  }\n\n  /**\n   * Handles C0 group data.\n   * @param {number} controlCode\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  handleC0_(controlCode, pts) {\n    // All these commands pertain to the current window, so ensure it exists.\n    if (!this.currentWindow_) {\n      return null;\n    }\n\n    const window = this.currentWindow_;\n    let parsedClosedCaption = null;\n\n    // Note: This decoder ignores the \"ETX\" (end of text) control code. Since\n    // this is JavaScript, a '\\0' is not needed to terminate a string.\n    switch (controlCode) {\n      case shaka.cea.Cea708Service.ASCII_BACKSPACE:\n        window.backspace();\n        break;\n      case shaka.cea.Cea708Service.ASCII_CARRIAGE_RETURN:\n        // Force out the buffer, since the top row could be lost.\n        if (window.isVisible()) {\n          parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n        }\n        window.carriageReturn();\n        break;\n      case shaka.cea.Cea708Service.ASCII_HOR_CARRIAGE_RETURN:\n        // Force out the buffer, a row will be erased.\n        if (window.isVisible()) {\n          parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n        }\n        window.horizontalCarriageReturn();\n        break;\n      case shaka.cea.Cea708Service.ASCII_FORM_FEED:\n        // Clear window and move pen to (0,0).\n        // Force emit if the window is visible.\n        if (window.isVisible()) {\n          parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n        }\n        window.resetMemory();\n        window.setPenLocation(0, 0);\n        break;\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Processes C1 group data.\n   * These are caption commands.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} captionCommand\n   * @param {number} pts in seconds\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @throws {!shaka.util.Error} a possible out-of-range buffer read.\n   * @private\n   */\n  handleC1_(dtvccPacket, captionCommand, pts) {\n    // Note: This decoder ignores delay and delayCancel control codes in the C1.\n    // group. These control codes delay processing of data for a set amount of\n    // time, however this decoder processes that data immediately.\n\n    if (captionCommand >= 0x80 && captionCommand <= 0x87) {\n      const windowNum = captionCommand & 0x07;\n      this.setCurrentWindow_(windowNum);\n    } else if (captionCommand === 0x88) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.clearWindows_(bitmap, pts);\n    } else if (captionCommand === 0x89) {\n      const bitmap = dtvccPacket.readByte().value;\n      this.displayWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8a) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.hideWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8b) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.toggleWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8c) {\n      const bitmap = dtvccPacket.readByte().value;\n      return this.deleteWindows_(bitmap, pts);\n    } else if (captionCommand === 0x8f) {\n      return this.reset_(pts);\n    } else if (captionCommand === 0x90) {\n      this.setPenAttributes_(dtvccPacket);\n    } else if (captionCommand === 0x91) {\n      this.setPenColor_(dtvccPacket);\n    } else if (captionCommand === 0x92) {\n      this.setPenLocation_(dtvccPacket);\n    } else if (captionCommand === 0x97) {\n      this.setWindowAttributes_(dtvccPacket);\n    } else if (captionCommand >= 0x98 && captionCommand <= 0x9f) {\n      const windowNum = (captionCommand & 0x0f) - 8;\n      this.defineWindow_(dtvccPacket, windowNum, pts);\n    }\n    return null;\n  }\n\n  /**\n   * Handles C2 group data.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} controlCode\n   * @private\n   */\n  handleC2_(dtvccPacket, controlCode) {\n    // As of the CEA-708-E spec there are no commands on the C2 table, but if\n    // seen, then the appropriate number of bytes must be skipped as per spec.\n    if (controlCode >= 0x08 && controlCode <= 0x0f) {\n      dtvccPacket.skip(1);\n    } else if (controlCode >= 0x10 && controlCode <= 0x17) {\n      dtvccPacket.skip(2);\n    } else if (controlCode >= 0x18 && controlCode <= 0x1f) {\n      dtvccPacket.skip(3);\n    }\n  }\n\n  /**\n   * Handles C3 group data.\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} controlCode\n   * @private\n   */\n  handleC3_(dtvccPacket, controlCode) {\n    // As of the CEA-708-E spec there are no commands on the C3 table, but if\n    // seen, then the appropriate number of bytes must be skipped as per spec.\n    if (controlCode >= 0x80 && controlCode <= 0x87) {\n      dtvccPacket.skip(4);\n    } else if (controlCode >= 0x88 && controlCode <= 0x8f) {\n      dtvccPacket.skip(5);\n    }\n  }\n\n  /**\n   * @param {number} windowNum\n   * @private\n   */\n  setCurrentWindow_(windowNum) {\n    // If the window isn't created, ignore the command.\n    if (!this.windows_[windowNum]) {\n      return;\n    }\n    this.currentWindow_ = this.windows_[windowNum];\n  }\n\n  /**\n   * Yields each non-null window specified in the 8-bit bitmap.\n   * @param {number} bitmap 8 bits corresponding to each of the 8 windows.\n   * @return {!Array.<number>}\n   * @private\n   */\n  getSpecifiedWindowIds_(bitmap) {\n    const ids = [];\n    for (let i = 0; i < 8; i++) {\n      const windowSpecified = (bitmap & 0x01) === 0x01;\n      if (windowSpecified && this.windows_[i]) {\n        ids.push(i);\n      }\n      bitmap >>= 1;\n    }\n    return ids;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  clearWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n\n    // Clears windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      // If window visible and being cleared, emit buffer and reset start time!\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      }\n      window.resetMemory();\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @private\n   */\n  displayWindows_(windowsBitmap, pts) {\n    // Displays windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (!window.isVisible()) {\n        // We are turning on the visibility, set the start time.\n        window.setStartTime(pts);\n      }\n      window.display();\n    }\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  hideWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n\n    // Hides windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        // We are turning off the visibility, emit!\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      }\n      window.hide();\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  toggleWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n\n    // Toggles windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        // We are turning off the visibility, emit!\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      } else {\n        // We are turning on visibility, set the start time.\n        window.setStartTime(pts);\n      }\n\n      window.toggle();\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * @param {number} windowsBitmap\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  deleteWindows_(windowsBitmap, pts) {\n    let parsedClosedCaption = null;\n    // Deletes windows from the 8 bit bitmap.\n    for (const windowId of this.getSpecifiedWindowIds_(windowsBitmap)) {\n      const window = this.windows_[windowId];\n      if (window.isVisible()) {\n        // We are turning off the visibility, emit!\n        parsedClosedCaption = window.forceEmit(pts, this.serviceNumber_);\n      }\n      // Delete the window from the list of windows\n      this.windows_[windowId] = null;\n    }\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Emits anything currently present in any of the windows, and then\n   * deletes all windows, cancels all delays, reinitializes the service.\n   * @param {number} pts\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  reset_(pts) {\n    const allWindowsBitmap = 0xff; // All windows should be deleted.\n    const caption = this.deleteWindows_(allWindowsBitmap, pts);\n    this.clear();\n    return caption;\n  }\n\n  /**\n   * Clears the state of the service completely.\n   */\n  clear() {\n    this.currentWindow_ = null;\n    this.windows_ = [null, null, null, null, null, null, null, null];\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setPenAttributes_(dtvccPacket) {\n    // Two bytes follow. For the purpose of this decoder, we are only concerned\n    // with byte 2, which is of the form |I|U|EDTYP|FNTAG|.\n\n    // I (1 bit): Italics toggle.\n    // U (1 bit): Underline toggle.\n    // EDTYP (3 bits): Edge type (unused in this decoder).\n    // FNTAG (3 bits): Font tag (unused in this decoder).\n    // More info at https://en.wikipedia.org/wiki/CEA-708#SetPenAttributes_(0x90_+_2_bytes)\n\n    dtvccPacket.skip(1); // Skip first byte\n    const attrByte2 = dtvccPacket.readByte().value;\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    const italics = (attrByte2 & 0x80) > 0;\n    const underline = (attrByte2 & 0x40) > 0;\n\n    this.currentWindow_.setPenItalics(italics);\n    this.currentWindow_.setPenUnderline(underline);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setPenColor_(dtvccPacket) {\n    // Read foreground and background properties.\n    const foregroundByte = dtvccPacket.readByte().value;\n    const backgroundByte = dtvccPacket.readByte().value;\n    dtvccPacket.skip(1); // Edge color not supported, skip it.\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    // Byte semantics are described at the following link:\n    // https://en.wikipedia.org/wiki/CEA-708#SetPenColor_(0x91_+_3_bytes)\n\n    // Foreground color properties: |FOP|F_R|F_G|F_B|.\n    const foregroundBlue = foregroundByte & 0x03;\n    const foregroundGreen = (foregroundByte & 0x0c) >> 2;\n    const foregroundRed = (foregroundByte & 0x30) >> 4;\n\n    // Background color properties: |BOP|B_R|B_G|B_B|.\n    const backgroundBlue = backgroundByte & 0x03;\n    const backgroundGreen = (backgroundByte & 0x0c) >> 2;\n    const backgroundRed = (backgroundByte & 0x30) >> 4;\n\n    const foregroundColor = this.rgbColorToHex_(\n        foregroundRed, foregroundGreen, foregroundBlue);\n\n    const backgroundColor = this.rgbColorToHex_(\n        backgroundRed, backgroundGreen, backgroundBlue);\n\n    this.currentWindow_.setPenTextColor(foregroundColor);\n    this.currentWindow_.setPenBackgroundColor(backgroundColor);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setPenLocation_(dtvccPacket) {\n    // Following 2 bytes take the following form:\n    // b1 = |0|0|0|0|ROW| and b2 = |0|0|COLUMN|\n    const locationByte1 = dtvccPacket.readByte().value;\n    const locationByte2 = dtvccPacket.readByte().value;\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    const row = locationByte1 & 0x0f;\n    const col = locationByte2 & 0x3f;\n    this.currentWindow_.setPenLocation(row, col);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  setWindowAttributes_(dtvccPacket) {\n    // 4 bytes follow, with the following form:\n    // Byte 1 contains fill-color information. Unused in this decoder.\n    // Byte 2 contains border color information. Unused in this decoder.\n    // Byte 3 contains justification information. In this decoder, we only use\n    // the last 2 bits, which specifies text justification on the screen.\n    // Byte 4 is special effects. Unused in this decoder.\n    // More info at https://en.wikipedia.org/wiki/CEA-708#SetWindowAttributes_(0x97_+_4_bytes)\n    dtvccPacket.skip(1); // Fill color not supported, skip.\n    dtvccPacket.skip(1); // Border colors not supported, skip.\n    const b3 = dtvccPacket.readByte().value;\n    dtvccPacket.skip(1); // Effects not supported, skip.\n\n    if (!this.currentWindow_) {\n      return;\n    }\n\n    // Word wrap is outdated as of CEA-708-E, so we ignore those bits.\n    // Extract the text justification and set it on the window.\n    const justification =\n      /** @type {!shaka.cea.Cea708Window.TextJustification} */ (b3 & 0x03);\n    this.currentWindow_.setJustification(justification);\n  }\n\n  /**\n   * @param {!shaka.cea.DtvccPacket} dtvccPacket\n   * @param {number} windowNum\n   * @param {number} pts\n   * @throws {!shaka.util.Error}\n   * @private\n   */\n  defineWindow_(dtvccPacket, windowNum, pts) {\n    // Create the window if it doesn't exist.\n    const windowAlreadyExists = this.windows_[windowNum] !== null;\n    if (!windowAlreadyExists) {\n      const window = new shaka.cea.Cea708Window(windowNum);\n      window.setStartTime(pts);\n      this.windows_[windowNum] = window;\n    }\n\n    // 6 Bytes follow, with the following form:\n    // b1 = |0|0|V|R|C|PRIOR| , b2 = |P|VERT_ANCHOR| , b3 = |HOR_ANCHOR|\n    // b4 = |ANC_ID|ROW_CNT| , b5 = |0|0|COL_COUNT| , b6 = |0|0|WNSTY|PNSTY|\n    // Semantics of these bytes at https://en.wikipedia.org/wiki/CEA-708#DefineWindow07_(0x98-0x9F,_+_6_bytes)\n    const b1 = dtvccPacket.readByte().value;\n    const b2 = dtvccPacket.readByte().value;\n    const b3 = dtvccPacket.readByte().value;\n    const b4 = dtvccPacket.readByte().value;\n    const b5 = dtvccPacket.readByte().value;\n    const b6 = dtvccPacket.readByte().value;\n\n    // As per 8.4.7 of CEA-708-E, row locks and column locks are to be ignored.\n    // So this decoder will ignore these values.\n\n    const visible = (b1 & 0x20) > 0;\n    const verticalAnchor = b2 & 0x7f;\n    const relativeToggle = (b2 & 0x80) > 0;\n    const horAnchor = b3;\n    const rowCount = (b4 & 0x0f) + 1; // Spec says to add 1.\n    const anchorId = (b4 & 0xf0) >> 4;\n    const colCount = (b5 & 0x3f) + 1; // Spec says to add 1.\n\n    // If pen style = 0 AND window previously existed, keep its pen style.\n    // Otherwise, change the pen style (For now, just reset to the default pen).\n    // TODO add support for predefined pen styles and fonts.\n    const penStyle = b6 & 0x07;\n    if (!windowAlreadyExists || penStyle !== 0) {\n      this.windows_[windowNum].resetPen();\n    }\n\n    this.windows_[windowNum].defineWindow(visible, verticalAnchor,\n        horAnchor, anchorId, relativeToggle, rowCount, colCount);\n\n    // Set the current window to the newly defined window.\n    this.currentWindow_ = this.windows_[windowNum];\n  }\n\n  /**\n   * Maps 64 possible CEA-708 colors to 8 CSS colors.\n   * @param {number} red value from 0-3\n   * @param {number} green value from 0-3\n   * @param {number} blue value from 0-3\n   * @return {string}\n   * @private\n   */\n  rgbColorToHex_(red, green, blue) {\n    // Rather than supporting 64 colors, this decoder supports 8 colors and\n    // gets the closest color, as per 9.19 of CEA-708-E. This is because some\n    // colors on television such as white, are often sent with lower intensity\n    // and often appear dull/greyish on the browser, making them hard to read.\n\n    // As per CEA-708-E 9.19, these mappings will map 64 colors to 8 colors.\n    const colorMapping = {0: 0, 1: 0, 2: 1, 3: 1};\n    red = colorMapping[red];\n    green = colorMapping[green];\n    blue = colorMapping[blue];\n\n    const colorCode = (red << 2) | (green << 1) | blue;\n    return shaka.cea.Cea708Service.Colors[colorCode];\n  }\n};\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_BACKSPACE = 0x08;\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_FORM_FEED = 0x0c;\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_CARRIAGE_RETURN = 0x0d;\n\n/**\n * @private @const {number}\n */\nshaka.cea.Cea708Service.ASCII_HOR_CARRIAGE_RETURN = 0x0e;\n\n/**\n * For extended control codes in block_data on CEA-708, byte 1 is 0x10.\n * @private @const {number}\n */\nshaka.cea.Cea708Service.EXT_CEA708_CTRL_CODE_BYTE1 = 0x10;\n\n/**\n * Holds characters mapping for bytes that are G2 control codes.\n * @private @const {!Map<number, string>}\n */\nshaka.cea.Cea708Service.G2Charset = new Map([\n  [0x20, ' '], [0x21, '\\xa0'], [0x25, ''], [0x2a, ''], [0x2c, ''],\n  [0x30, ''], [0x31, ''], [0x32, ''], [0x33, ''], [0x34, ''],\n  [0x35, ''], [0x39, ''], [0x3a, ''], [0x3c, ''], [0x3d, ''],\n  [0x3f, ''], [0x76, ''], [0x77, ''], [0x78, ''], [0x79, ''],\n  [0x7a, ''], [0x7b, ''], [0x7c, ''], [0x7d, ''], [0x7e, ''], [0x7f, ''],\n]);\n\n/**\n * An array of 8 colors that 64 colors can be quantized to. Order here matters.\n * @private @const {!Array<string>}\n */\nshaka.cea.Cea708Service.Colors = [\n  'black', 'blue', 'green', 'cyan',\n  'red', 'magenta', 'yellow', 'white',\n];\n\n/**\n * CEA-708 closed captions byte.\n * @typedef {{\n *   pts: number,\n *   type: number,\n *   value: number,\n *   order: number\n * }}\n *\n * @property {number} pts\n *   Presentation timestamp (in second) at which this packet was received.\n * @property {number} type\n *   Type of the byte. Either 2 or 3, DTVCC Packet Data or a DTVCC Packet Start.\n * @property {number} value The byte containing data relevant to the packet.\n * @property {number} order\n *   A number indicating the order this packet was received in a sequence\n *   of packets. Used to break ties in a stable sorting algorithm\n */\nshaka.cea.Cea708Service.Cea708Byte;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.CeaDecoder');\n\ngoog.require('shaka.cea.Cea608DataChannel');\ngoog.require('shaka.cea.Cea708Service');\ngoog.require('shaka.cea.DtvccPacketBuilder');\ngoog.require('shaka.cea.ICaptionDecoder');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.cea.DtvccPacket');\n\n\n/**\n * CEA-X08 captions decoder. Currently only CEA-608 supported.\n * @implements {shaka.cea.ICaptionDecoder}\n */\nshaka.cea.CeaDecoder = class {\n  /** */\n  constructor() {\n    /**\n     * An array of CEA-608 closed caption data extracted for decoding.\n     * @private {!Array<!shaka.cea.Cea608DataChannel.Cea608Packet>}\n     */\n    this.cea608DataArray_ = [];\n\n    /**\n     * An array of CEA-708 closed caption data extracted for decoding.\n     * @private {!Array<!shaka.cea.Cea708Service.Cea708Byte>}\n     */\n    this.cea708DataArray_ = [];\n\n    /**\n     * A DTVCC Packet builder for CEA-708 data.\n     * @private {!shaka.cea.DtvccPacketBuilder}\n     */\n    this.dtvccPacketBuilder_ = new shaka.cea.DtvccPacketBuilder();\n\n    /**\n     * Number of consecutive bad frames decoded on CEA-608.\n     * @private {number}\n     */\n    this.badFrames_ = 0;\n\n    /**\n     * A map containing the stream for each mode.\n     * @private {!Map<string, !shaka.cea.Cea608DataChannel>}\n     */\n    this.cea608ModeToStream_ = new Map([\n      ['CC1', new shaka.cea.Cea608DataChannel(0, 0)], // F1 + C1 -> CC1\n      ['CC2', new shaka.cea.Cea608DataChannel(0, 1)], // F1 + C2 -> CC2\n      ['CC3', new shaka.cea.Cea608DataChannel(1, 0)], // F2 + C1 -> CC3\n      ['CC4', new shaka.cea.Cea608DataChannel(1, 1)], // F2 + C2 -> CC4\n    ]);\n\n    /**\n     * The current channel that is active on CEA-608 field 1.\n     * @private {number}\n     */\n    this.currentField1Channel_ = 0;\n\n    /**\n     * The current channel that is active on CEA-608 field 2.\n     * @private {number}\n     */\n    this.currentField2Channel_ = 0;\n\n    /**\n     * Map of service number to CEA-708 services, initially empty. Since there\n     * can be up to 63 services, they are created dynamically only when needed.\n     * @private {!Map<number, shaka.cea.Cea708Service>}\n     */\n    this.serviceNumberToService_ = new Map();\n\n    this.reset();\n  }\n\n  /**\n   * Clears the decoder.\n   * @override\n   */\n  clear() {\n    this.badFrames_ = 0;\n    this.cea608DataArray_ = [];\n    this.cea708DataArray_ = [];\n    this.dtvccPacketBuilder_.clear();\n    this.reset();\n\n    // Clear all the CEA-708 services.\n    for (const service of this.serviceNumberToService_.values()) {\n      service.clear();\n    }\n  }\n\n  /**\n   * Resets the decoder.\n   */\n  reset() {\n    this.currentField1Channel_ = 0;\n    this.currentField2Channel_ = 0;\n    for (const stream of this.cea608ModeToStream_.values()) {\n      stream.reset();\n    }\n  }\n\n  /**\n   * Extracts closed caption bytes from CEA-X08 packets from the stream based on\n   * ANSI/SCTE 128 and A/53, Part 4.\n   * @override\n   */\n  extract(userDataSeiMessage, pts) {\n    const reader = new shaka.util.DataViewReader(\n        userDataSeiMessage, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    if (reader.readUint8() !== shaka.cea.CeaDecoder.USA_COUNTRY_CODE) {\n      return;\n    }\n    if (reader.readUint16() !== shaka.cea.CeaDecoder.ATSC_PROVIDER_CODE) {\n      return;\n    }\n    if (reader.readUint32() !== shaka.cea.CeaDecoder.ATSC1_USER_IDENTIFIER) {\n      return;\n    }\n\n    // user_data_type_code: 0x03 - cc_data()\n    if (reader.readUint8() !== 0x03) {\n      return;\n    }\n\n    // 1 bit reserved\n    // 1 bit process_cc_data_flag\n    // 1 bit zero_bit\n    // 5 bits cc_count\n    const captionData = reader.readUint8();\n    // If process_cc_data_flag is not set, do not process this data.\n    if ((captionData & 0x40) === 0) {\n      return;\n    }\n\n    const count = captionData & 0x1f;\n\n    // 8 bits reserved\n    reader.skip(1);\n\n    for (let i = 0; i < count; i++) {\n      const cc = reader.readUint8();\n      // When ccValid is 0, the next two bytes should be discarded.\n      const ccValid = (cc & 0x04) >> 2;\n      const ccData1 = reader.readUint8();\n      const ccData2 = reader.readUint8();\n\n      if (ccValid) {\n        const ccType = cc & 0x03;\n        // Send the packet to the appropriate data array (CEA-608 or CEA-708).\n        if (ccType === shaka.cea.CeaDecoder.NTSC_CC_FIELD_1 ||\n            ccType === shaka.cea.CeaDecoder.NTSC_CC_FIELD_2) {\n          // CEA-608 NTSC (Line 21) Data.\n          this.cea608DataArray_.push({\n            pts,\n            type: ccType,\n            ccData1,\n            ccData2,\n            order: this.cea608DataArray_.length,\n          });\n        } else {\n          // CEA-708 DTVCC Data.\n          this.cea708DataArray_.push({\n            pts,\n            type: ccType,\n            value: ccData1,\n            order: this.cea708DataArray_.length,\n          });\n\n          // The second byte should always be labelled as DTVCC packet data.\n          // Even if this pair was a DTVCC packet start, only the first byte\n          // contains header info, and the second byte is just packet data.\n          this.cea708DataArray_.push({\n            pts,\n            type: shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_DATA,\n            value: ccData2,\n            order: this.cea708DataArray_.length,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Decodes extracted closed caption data.\n   * @override\n   */\n  decode() {\n    /** @type {!Array.<!shaka.cea.ICaptionDecoder.ClosedCaption>} */\n    const parsedClosedCaptions = [];\n\n    // In some versions of Chrome, and other browsers, the default sorting\n    // algorithm isn't stable. This comparator sorts on presentation\n    // timestamp, and breaks ties on receive order (position in array).\n    const stableComparator =\n      (p1, p2) => (p1.pts - p2.pts) || (p1.order - p2.order);\n\n    this.cea608DataArray_.sort(stableComparator);\n    this.cea708DataArray_.sort(stableComparator);\n\n    // CEA-608 packets are just byte pairs. Decode all of them.\n    for (const cea608Packet of this.cea608DataArray_) {\n      const parsedClosedCaption = this.decodeCea608_(cea608Packet);\n      if (parsedClosedCaption) {\n        parsedClosedCaptions.push(parsedClosedCaption);\n      }\n    }\n\n    // CEA-708 packets are DTVCC packets composed of many byte pairs. Add all\n    // byte pairs to the packet builder, and process + clear any ready packets.\n    for (const cea708Byte of this.cea708DataArray_) {\n      this.dtvccPacketBuilder_.addByte(cea708Byte);\n    }\n    const dtvccPackets = this.dtvccPacketBuilder_.getBuiltPackets();\n    for (const dtvccPacket of dtvccPackets) {\n      const closedCaptions = this.decodeCea708_(dtvccPacket);\n      parsedClosedCaptions.push(...closedCaptions);\n    }\n\n    // Clear all processed data.\n    this.dtvccPacketBuilder_.clearBuiltPackets();\n    this.cea608DataArray_ = [];\n    this.cea708DataArray_ = [];\n\n    return parsedClosedCaptions;\n  }\n\n  /**\n   * Decodes a CEA-608 closed caption packet based on ANSI/CEA-608.\n   * @param {shaka.cea.Cea608DataChannel.Cea608Packet} ccPacket\n   * @return {?shaka.cea.ICaptionDecoder.ClosedCaption}\n   * @private\n   */\n  decodeCea608_(ccPacket) {\n    const fieldNum = ccPacket.type;\n\n    // If this packet is a control code, then it also sets the channel.\n    // For control codes, cc_data_1 has the form |P|0|0|1|C|X|X|X|.\n    // \"C\" is the channel bit. It indicates whether to set C2 active.\n    if (shaka.cea.Cea608DataChannel.isControlCode(ccPacket.ccData1)) {\n      const channelNum = (ccPacket.ccData1 >> 3) & 0x01; // Get channel bit.\n\n      // Change the stream based on the field, and the new channel\n      if (fieldNum === 0) {\n        this.currentField1Channel_ = channelNum;\n      } else {\n        this.currentField2Channel_ = channelNum;\n      }\n    }\n\n    // Get the correct stream for this caption packet (CC1, ..., CC4)\n    const selectedChannel = fieldNum ?\n        this.currentField2Channel_ : this.currentField1Channel_;\n    const selectedMode = `CC${(fieldNum << 1) | selectedChannel + 1}`;\n    const selectedStream = this.cea608ModeToStream_.get(selectedMode);\n\n    // Check for bad frames (bad pairs). This can be two 0xff, two 0x00, or any\n    // byte of even parity. ccData1 and ccData2 should be uint8 of odd parity.\n    if ((ccPacket.ccData1 === 0xff && ccPacket.ccData2 === 0xff) ||\n        (!ccPacket.ccData1 && !ccPacket.ccData2) ||\n        !this.isOddParity_(ccPacket.ccData1) ||\n        !this.isOddParity_(ccPacket.ccData2)) {\n      // Per CEA-608-B C.21, reset the memory after 45 consecutive bad frames.\n      if (++this.badFrames_ >= 45) {\n        this.reset();\n      }\n      return null;\n    }\n    this.badFrames_ = 0;\n\n    // Remove the MSB (parity bit).\n    ccPacket.ccData1 &= 0x7f;\n    ccPacket.ccData2 &= 0x7f;\n\n    // Check for empty captions and skip them.\n    if (!ccPacket.ccData1 && !ccPacket.ccData2) {\n      return null;\n    }\n\n    // Process the clean CC data pair.\n    let parsedClosedCaption = null;\n    if (shaka.cea.Cea608DataChannel.isControlCode(ccPacket.ccData1)) {\n      parsedClosedCaption = selectedStream.handleControlCode(ccPacket);\n    } else {\n      // Handle as a Basic North American Character.\n      selectedStream.handleBasicNorthAmericanChar(\n          ccPacket.ccData1, ccPacket.ccData2);\n    }\n\n    return parsedClosedCaption;\n  }\n\n  /**\n   * Decodes a CEA-708 DTVCC packet based on ANSI/CTA-708-E.\n   * @param {shaka.cea.DtvccPacket} dtvccPacket\n   * @return {!Array<!shaka.cea.ICaptionDecoder.ClosedCaption>}\n   * @private\n   */\n  decodeCea708_(dtvccPacket) {\n    const parsedClosedCaptions = [];\n    try {\n      while (dtvccPacket.hasMoreData()) {\n        // Process a service block.\n        const serviceBlockHeader = dtvccPacket.readByte().value;\n\n        // First 3 bits are service number, next 5 are block size,\n        // representing the number of bytes coming in this block\n        // (discluding a possible extended service block header byte)\n        let serviceNumber = (serviceBlockHeader & 0xe0) >> 5;\n        const blockSize = serviceBlockHeader & 0x1f;\n\n        if (serviceNumber === /* 0b111 */ 0x07 && blockSize != 0) {\n          // 2 bits null padding, 6 bits extended service number\n          const extendedServiceBlockHeader = dtvccPacket.readByte().value;\n          serviceNumber = extendedServiceBlockHeader & 0x3f;\n        }\n\n        // As per CEA-708-E, service number 0 is invalid, and should be ignored.\n        if (serviceNumber != 0) {\n          // If the service doesn't already exist, create it.\n          if (!this.serviceNumberToService_.has(serviceNumber)) {\n            const service = new shaka.cea.Cea708Service(serviceNumber);\n            this.serviceNumberToService_.set(serviceNumber, service);\n          }\n          const service = this.serviceNumberToService_.get(serviceNumber);\n\n          // Process all control codes.\n          const startPos = dtvccPacket.getPosition();\n\n          // Execute this loop `blockSize` times, to decode the control codes.\n          while (dtvccPacket.getPosition() - startPos < blockSize) {\n            const closedCaption = service.handleCea708ControlCode(dtvccPacket);\n            if (closedCaption) {\n              parsedClosedCaptions.push(closedCaption);\n            }\n          }  // position < end of block\n        }  // serviceNumber != 0\n      }  // hasMoreData\n    } catch (error) {\n      if (error instanceof shaka.util.Error &&\n      error.code === shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS) {\n        shaka.log.warnOnce('CEA708_INVALID_DATA',\n            'Buffer read out of bounds / invalid CEA-708 Data.');\n      } else {\n        // This is an unexpected error, and should be rethrown.\n        throw error;\n      }\n    }\n    return parsedClosedCaptions;\n  }\n\n  /**\n   * Checks if a byte has odd parity (Odd number of 1s in binary).\n   * @param {number} byte\n   * @return {boolean} True if the byte has odd parity.\n   * @private\n   */\n  isOddParity_(byte) {\n    let parity = 0;\n    while (byte) {\n      parity ^= (byte & 1); // toggle parity if low bit is 1\n      byte >>= 1; // shift away the low bit\n    }\n    return parity === 1;\n  }\n};\n\n/**\n * itu_t_35_provider_code for ATSC user_data\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.ATSC_PROVIDER_CODE = 0x0031;\n\n/**\n * When provider is ATSC user data, the ATSC_user_identifier code\n * for ATSC1_data is \"GA94\" (0x47413934)\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.ATSC1_USER_IDENTIFIER = 0x47413934;\n\n/**\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.NTSC_CC_FIELD_1 = 0;\n\n/**\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.NTSC_CC_FIELD_2 = 1;\n\n/**\n * 0xB5 is USA's code (Rec. ITU-T T.35)\n * @private @const {number}\n */\nshaka.cea.CeaDecoder.USA_COUNTRY_CODE = 0xb5;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.DummyCeaParser');\n\ngoog.require('shaka.cea.ICeaParser');\n\n/**\n * Dummy CEA parser.\n * @implements {shaka.cea.ICeaParser}\n */\nshaka.cea.DummyCeaParser = class {\n  /**\n   * @override\n   */\n  init(initSegment) {\n  }\n\n  /**\n   * @override\n   */\n  parse(mediaSegment) {\n    return /* captionPackets= */ [];\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Mp4BoxParsers');\n\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Mp4Parser');\n\nshaka.util.Mp4BoxParsers = class {\n  /**\n   * Parses a TFHD Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} flags\n   * @return {!shaka.util.ParsedTFHDBox}\n   */\n  static parseTFHD(reader, flags) {\n    let defaultSampleDuration = null;\n    let defaultSampleSize = null;\n    let baseDataOffset = null;\n\n    const trackId = reader.readUint32(); // Read \"track_ID\"\n\n    // Skip \"base_data_offset\" if present.\n    if (flags & 0x000001) {\n      baseDataOffset = reader.readUint64();\n    }\n\n    // Skip \"sample_description_index\" if present.\n    if (flags & 0x000002) {\n      reader.skip(4);\n    }\n\n    // Read \"default_sample_duration\" if present.\n    if (flags & 0x000008) {\n      defaultSampleDuration = reader.readUint32();\n    }\n\n    // Read \"default_sample_size\" if present.\n    if (flags & 0x000010) {\n      defaultSampleSize = reader.readUint32();\n    }\n\n    return {\n      trackId,\n      defaultSampleDuration,\n      defaultSampleSize,\n      baseDataOffset,\n    };\n  }\n\n  /**\n   * Parses a TFDT Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @return {!shaka.util.ParsedTFDTBox}\n   */\n  static parseTFDT(reader, version) {\n    const baseMediaDecodeTime = version == 1 ?\n        reader.readUint64() : reader.readUint32();\n\n    return {\n      baseMediaDecodeTime,\n    };\n  }\n\n  /**\n   * Parses a MDHD Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @return {!shaka.util.ParsedMDHDBox}\n   */\n  static parseMDHD(reader, version) {\n    if (version == 1) {\n      reader.skip(8); // Skip \"creation_time\"\n      reader.skip(8); // Skip \"modification_time\"\n    } else {\n      reader.skip(4); // Skip \"creation_time\"\n      reader.skip(4); // Skip \"modification_time\"\n    }\n\n    const timescale = reader.readUint32();\n\n    return {\n      timescale,\n    };\n  }\n\n  /**\n   * Parses a TREX Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @return {!shaka.util.ParsedTREXBox}\n   */\n  static parseTREX(reader) {\n    reader.skip(4); // Skip \"track_ID\"\n    reader.skip(4); // Skip \"default_sample_description_index\"\n    const defaultSampleDuration = reader.readUint32();\n    const defaultSampleSize = reader.readUint32();\n\n    return {\n      defaultSampleDuration,\n      defaultSampleSize,\n    };\n  }\n\n  /**\n   * Parses a TRUN Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @param {number} flags\n   * @return {!shaka.util.ParsedTRUNBox}\n   */\n  static parseTRUN(reader, version, flags) {\n    const sampleCount = reader.readUint32();\n    const sampleData = [];\n    let dataOffset = null;\n\n    // \"data_offset\"\n    if (flags & 0x000001) {\n      dataOffset = reader.readUint32();\n    }\n\n    // Skip \"first_sample_flags\" if present.\n    if (flags & 0x000004) {\n      reader.skip(4);\n    }\n\n    for (let i = 0; i < sampleCount; i++) {\n      /** @type {shaka.util.ParsedTRUNSample} */\n      const sample = {\n        sampleDuration: null,\n        sampleSize: null,\n        sampleCompositionTimeOffset: null,\n      };\n\n      // Read \"sample duration\" if present.\n      if (flags & 0x000100) {\n        sample.sampleDuration = reader.readUint32();\n      }\n\n      // Read \"sample_size\" if present.\n      if (flags & 0x000200) {\n        sample.sampleSize = reader.readUint32();\n      }\n\n      // Skip \"sample_flags\" if present.\n      if (flags & 0x000400) {\n        reader.skip(4);\n      }\n\n      // Read \"sample_time_offset\" if present.\n      if (flags & 0x000800) {\n        sample.sampleCompositionTimeOffset = version == 0 ?\n              reader.readUint32() :\n              reader.readInt32();\n      }\n\n      sampleData.push(sample);\n    }\n\n    return {\n      sampleCount,\n      sampleData,\n      dataOffset,\n    };\n  }\n\n  /**\n   * Parses a TKHD Box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} version\n   * @return {!shaka.util.ParsedTKHDBox}\n   */\n  static parseTKHD(reader, version) {\n    let trackId = 0;\n    if (version == 1) {\n      reader.skip(8); // Skip \"creation_time\"\n      reader.skip(8); // Skip \"modification_time\"\n      trackId = reader.readUint32();\n    } else {\n      reader.skip(4); // Skip \"creation_time\"\n      reader.skip(4); // Skip \"modification_time\"\n      trackId = reader.readUint32();\n    }\n\n    return {\n      trackId,\n    };\n  }\n\n  /**\n   * Parses a FRMA box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @return {!shaka.util.ParsedFRMABox}\n   */\n  static parseFRMA(reader) {\n    const fourcc = reader.readUint32();\n    const codec = shaka.util.Mp4Parser.typeToString(fourcc);\n    return {codec};\n  }\n};\n\n\n/**\n * @typedef {{\n *    trackId: number,\n *    defaultSampleDuration: ?number,\n *    defaultSampleSize: ?number,\n *    baseDataOffset: ?number\n * }}\n *\n * @property {number} trackId\n *   As per the spec: an integer that uniquely identifies this\n *   track over the entire lifetime of this presentation\n * @property {?number} defaultSampleDuration\n *   If specified via flags, this overrides the default sample\n *   duration in the Track Extends Box for this fragment\n * @property {?number} defaultSampleSize\n *   If specified via flags, this overrides the default sample\n *   size in the Track Extends Box for this fragment\n * @property {?number} baseDataOffset\n *   If specified via flags, this indicate the base data offset\n *\n * @exportDoc\n */\nshaka.util.ParsedTFHDBox;\n\n/**\n * @typedef {{\n *    baseMediaDecodeTime: number\n * }}\n *\n * @property {number} baseMediaDecodeTime\n *   As per the spec: the absolute decode time, measured on the media\n *   timeline, of the first sample in decode order in the track fragment\n *\n * @exportDoc\n */\nshaka.util.ParsedTFDTBox;\n\n/**\n * @typedef {{\n *    timescale: number\n * }}\n *\n * @property {number} timescale\n *   As per the spec: an integer that specifies the timescale for this media;\n *   this is the number of time units that pass in one second\n *\n * @exportDoc\n */\nshaka.util.ParsedMDHDBox;\n\n/**\n * @typedef {{\n *    defaultSampleDuration: number,\n *    defaultSampleSize: number\n * }}\n *\n * @property {number} defaultSampleDuration\n *   The default sample duration to be used in track fragments\n * @property {number} defaultSampleSize\n *   The default sample size to be used in track fragments\n *\n * @exportDoc\n */\nshaka.util.ParsedTREXBox;\n\n/**\n * @typedef {{\n *    sampleCount: number,\n *    sampleData: !Array.<shaka.util.ParsedTRUNSample>,\n *    dataOffset: ?number\n * }}\n *\n * @property {number} sampleCount\n *   As per the spec: the number of samples being added in this run;\n * @property {!Array.<shaka.util.ParsedTRUNSample>} sampleData\n *   An array of size <sampleCount> containing data for each sample\n * @property {?number} dataOffset\n *   If specified via flags, this indicate the offset of the sample in bytes.\n *\n * @exportDoc\n */\nshaka.util.ParsedTRUNBox;\n\n/**\n * @typedef {{\n *    sampleDuration: ?number,\n *    sampleSize: ?number,\n *    sampleCompositionTimeOffset: ?number\n *  }}\n *\n * @property {?number} sampleDuration\n *   The length of the sample in timescale units.\n * @property {?number} sampleSize\n *   The size of the sample in bytes.\n * @property {?number} sampleCompositionTimeOffset\n *   The time since the start of the sample in timescale units. Time\n *   offset is based of the start of the sample. If this value is\n *   missing, the accumulated durations preceeding this time sample will\n *   be used to create the start time.\n *\n * @exportDoc\n */\nshaka.util.ParsedTRUNSample;\n\n/**\n * @typedef {{\n *    trackId: number\n *  }}\n *\n * @property {number} trackId\n *   Unique ID indicative of this track\n *\n * @exportDoc\n */\nshaka.util.ParsedTKHDBox;\n\n/**\n * @typedef {{\n *    codec: string\n *  }}\n *\n * @property {string} codec\n *   A fourcc for a codec\n *\n * @exportDoc\n */\nshaka.util.ParsedFRMABox;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.Mp4CeaParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cea.ICeaParser');\ngoog.require('shaka.cea.SeiProcessor');\ngoog.require('shaka.log');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Mp4BoxParsers');\n\n/**\n * MPEG4 stream parser used for extracting 708 closed captions data.\n * @implements {shaka.cea.ICeaParser}\n */\nshaka.cea.Mp4CeaParser = class {\n  /** */\n  constructor() {\n    /**\n     * SEI data processor.\n     * @private\n     * @const {!shaka.cea.SeiProcessor}\n     */\n    this.seiProcessor_ = new shaka.cea.SeiProcessor();\n\n    /**\n     * Map of track id to corresponding timescale.\n     * @private {!Map<number, number>}\n     */\n    this.trackIdToTimescale_ = new Map();\n\n    /**\n     * Default sample duration, as specified by the TREX box.\n     * @private {number}\n     */\n    this.defaultSampleDuration_ = 0;\n\n    /**\n     * Default sample size, as specified by the TREX box.\n     * @private {number}\n     */\n    this.defaultSampleSize_ = 0;\n\n    /**\n     * @private {shaka.cea.Mp4CeaParser.BitstreamFormat}\n     */\n    this.bitstreamFormat_ = shaka.cea.Mp4CeaParser.BitstreamFormat.UNKNOWN;\n  }\n\n  /**\n   * Parses the init segment. Gets Default Sample Duration and Size from the\n   * TREX box, and constructs a map of Track IDs to timescales. Each TRAK box\n   * contains a track header (TKHD) containing track ID, and a media header box\n   * (MDHD) containing the timescale for the track\n   * @override\n   */\n  init(initSegment) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n    const BitstreamFormat = shaka.cea.Mp4CeaParser.BitstreamFormat;\n    const trackIds = [];\n    const timescales = [];\n\n    const codecBoxParser = (box) => this.setBitstreamFormat_(box.name);\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('mvex', Mp4Parser.children)\n        .fullBox('trex', (box) => {\n          const parsedTREXBox = shaka.util.Mp4BoxParsers.parseTREX(\n              box.reader);\n\n          this.defaultSampleDuration_ = parsedTREXBox.defaultSampleDuration;\n          this.defaultSampleSize_ = parsedTREXBox.defaultSampleSize;\n        })\n        .box('trak', Mp4Parser.children)\n        .fullBox('tkhd', (box) => {\n          goog.asserts.assert(\n              box.version != null,\n              'TKHD is a full box and should have a valid version.');\n          const parsedTKHDBox = shaka.util.Mp4BoxParsers.parseTKHD(\n              box.reader, box.version);\n          trackIds.push(parsedTKHDBox.trackId);\n        })\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version != null,\n              'MDHD is a full box and should have a valid version.');\n          const parsedMDHDBox = shaka.util.Mp4BoxParsers.parseMDHD(\n              box.reader, box.version);\n          timescales.push(parsedMDHDBox.timescale);\n        })\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n\n        // These are the various boxes that signal a codec.\n        .box('avc1', codecBoxParser)\n        .box('avc3', codecBoxParser)\n        .box('hev1', codecBoxParser)\n        .box('hvc1', codecBoxParser)\n        .box('dvh1', codecBoxParser)\n        .box('dvhe', codecBoxParser)\n\n        // This signals an encrypted sample, which we can go inside of to find\n        // the codec used.\n        .box('encv', Mp4Parser.visualSampleEntry)\n        .box('sinf', Mp4Parser.children)\n        .box('frma', (box) => {\n          const {codec} = shaka.util.Mp4BoxParsers.parseFRMA(box.reader);\n          this.setBitstreamFormat_(codec);\n        })\n\n        .parse(initSegment, /* partialOkay= */ true);\n\n    // At least one track should exist, and each track should have a\n    // corresponding Id in TKHD box, and timescale in its MDHD box\n    if (!trackIds.length|| !timescales.length ||\n      trackIds.length != timescales.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_CEA);\n    }\n\n    if (this.bitstreamFormat_ == BitstreamFormat.UNKNOWN) {\n      shaka.log.alwaysWarn(\n          'Unable to determine bitstream format for CEA parsing!');\n    }\n\n    // Populate the map from track Id to timescale\n    trackIds.forEach((trackId, idx) => {\n      this.trackIdToTimescale_.set(trackId, timescales[idx]);\n    });\n  }\n\n  /**\n   * Parses each video segment. In fragmented MP4s, MOOF and MDAT come in\n   * pairs. The following logic gets the necessary info from MOOFs to parse\n   * MDATs (base media decode time, sample sizes/offsets/durations, etc),\n   * and then parses the MDAT boxes for CEA-708 packets using this information.\n   * CEA-708 packets are returned in the callback.\n   * @override\n   */\n  parse(mediaSegment) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n    const BitstreamFormat = shaka.cea.Mp4CeaParser.BitstreamFormat;\n\n    if (this.bitstreamFormat_ == BitstreamFormat.UNKNOWN) {\n      // We don't know how to extract SEI from this.\n      return [];\n    }\n\n    /** @type {!Array<!shaka.cea.ICeaParser.CaptionPacket>} **/\n    const captionPackets = [];\n\n    // Fields that are found in MOOF boxes\n    let defaultSampleDuration = this.defaultSampleDuration_;\n    let defaultSampleSize = this.defaultSampleSize_;\n    let sampleData = [];\n    let moofOffset = null;\n    let trunOffset = null;\n    let baseMediaDecodeTime = null;\n    let timescale = shaka.cea.ICeaParser.DEFAULT_TIMESCALE_VALUE;\n\n    new Mp4Parser()\n        .box('moof', (box) => {\n          moofOffset = box.start;\n          Mp4Parser.children(box);\n        })\n        .box('traf', Mp4Parser.children)\n        .fullBox('trun', (box) => {\n          goog.asserts.assert(\n              box.version != null && box.flags!=null,\n              'TRUN is a full box and should have a valid version & flags.');\n\n          const parsedTRUN = shaka.util.Mp4BoxParsers.parseTRUN(\n              box.reader, box.version, box.flags);\n\n          sampleData = parsedTRUN.sampleData;\n          trunOffset = parsedTRUN.dataOffset;\n        })\n\n        .fullBox('tfhd', (box) => {\n          goog.asserts.assert(\n              box.flags != null,\n              'TFHD is a full box and should have valid flags.');\n\n          const parsedTFHD = shaka.util.Mp4BoxParsers.parseTFHD(\n              box.reader, box.flags);\n\n          // If specified, defaultSampleDuration and defaultSampleSize\n          // override the ones specified in the TREX box\n          defaultSampleDuration = parsedTFHD.defaultSampleDuration ||\n              this.defaultSampleDuration_;\n\n          defaultSampleSize = parsedTFHD.defaultSampleSize ||\n              this.defaultSampleSize_;\n\n          const trackId = parsedTFHD.trackId;\n\n          // Get the timescale from the track Id\n          if (this.trackIdToTimescale_.has(trackId)) {\n            timescale = this.trackIdToTimescale_.get(trackId);\n          }\n        })\n\n        .fullBox('tfdt', (box) => {\n          goog.asserts.assert(\n              box.version != null,\n              'TFDT is a full box and should have a valid version.');\n\n          const parsedTFDT = shaka.util.Mp4BoxParsers.parseTFDT(\n              box.reader, box.version);\n\n          baseMediaDecodeTime = parsedTFDT.baseMediaDecodeTime;\n        })\n        .box('mdat', (box) => {\n          if (baseMediaDecodeTime === null) {\n            // This field should have been populated by\n            // the Base Media Decode time in the TFDT box\n            throw new shaka.util.Error(\n                shaka.util.Error.Severity.CRITICAL,\n                shaka.util.Error.Category.TEXT,\n                shaka.util.Error.Code.INVALID_MP4_CEA);\n          }\n          const offset = (moofOffset || 0) + (trunOffset || 0) - box.start - 8;\n          this.parseMdat_(box.reader, baseMediaDecodeTime, timescale,\n              defaultSampleDuration, defaultSampleSize, offset, sampleData,\n              captionPackets);\n        })\n        .parse(mediaSegment, /* partialOkay= */ false);\n\n    return captionPackets;\n  }\n\n  /**\n   * Parse MDAT box.\n   * @param {!shaka.util.DataViewReader} reader\n   * @param {number} time\n   * @param {number} timescale\n   * @param {number} defaultSampleDuration\n   * @param {number} defaultSampleSize\n   * @param {number} offset\n   * @param {!Array<shaka.util.ParsedTRUNSample>} sampleData\n   * @param {!Array<!shaka.cea.ICeaParser.CaptionPacket>} captionPackets\n   * @private\n   */\n  parseMdat_(reader, time, timescale, defaultSampleDuration,\n      defaultSampleSize, offset, sampleData, captionPackets) {\n    const BitstreamFormat = shaka.cea.Mp4CeaParser.BitstreamFormat;\n    const ICeaParser = shaka.cea.ICeaParser;\n    let sampleIndex = 0;\n\n    // The fields in each ParsedTRUNSample contained in the sampleData\n    // array are nullable. In the case of sample data and sample duration,\n    // we use the defaults provided by the TREX/TFHD boxes. For sample\n    // composition time offset, we default to 0.\n    let sampleSize = defaultSampleSize;\n\n    if (sampleData.length) {\n      sampleSize = sampleData[0].sampleSize || defaultSampleSize;\n    }\n\n    reader.skip(offset);\n\n    while (reader.hasMoreData()) {\n      const naluSize = reader.readUint32();\n      const naluHeader = reader.readUint8();\n      let naluType = null;\n      let isSeiMessage = false;\n\n      goog.asserts.assert(this.bitstreamFormat_ != BitstreamFormat.UNKNOWN,\n          'Bitstream format should have been checked before now!');\n      switch (this.bitstreamFormat_) {\n        case BitstreamFormat.H264:\n          naluType = naluHeader & 0x1f;\n          isSeiMessage = naluType == ICeaParser.H264_NALU_TYPE_SEI;\n          break;\n\n        case BitstreamFormat.H265:\n          naluType = (naluHeader >> 1) & 0x3f;\n          isSeiMessage =\n              naluType == ICeaParser.H265_PREFIX_NALU_TYPE_SEI ||\n              naluType == ICeaParser.H265_SUFFIX_NALU_TYPE_SEI;\n          break;\n\n        default:\n          return;\n      }\n\n      if (isSeiMessage) {\n        let timeOffset = 0;\n\n        if (sampleData.length > sampleIndex) {\n          timeOffset = sampleData[sampleIndex].sampleCompositionTimeOffset || 0;\n        }\n\n        const pts = (time + timeOffset)/timescale;\n        for (const packet of this.seiProcessor_\n            .process(reader.readBytes(naluSize - 1))) {\n          captionPackets.push({\n            packet,\n            pts,\n          });\n        }\n      } else {\n        try {\n          reader.skip(naluSize - 1);\n        } catch (e) {\n          // It is necessary to ignore this error because it can break the start\n          // of playback even if the user does not want to see the subtitles.\n          break;\n        }\n      }\n      sampleSize -= (naluSize + 4);\n      if (sampleSize == 0) {\n        if (sampleData.length > sampleIndex) {\n          time += sampleData[sampleIndex].sampleDuration ||\n              defaultSampleDuration;\n        } else {\n          time += defaultSampleDuration;\n        }\n\n        sampleIndex++;\n\n        if (sampleData.length > sampleIndex) {\n          sampleSize = sampleData[sampleIndex].sampleSize || defaultSampleSize;\n        } else {\n          sampleSize = defaultSampleSize;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {string} codec A fourcc for a codec.\n   * @private\n   */\n  setBitstreamFormat_(codec) {\n    if (codec in shaka.cea.Mp4CeaParser.CodecBitstreamMap_) {\n      this.bitstreamFormat_ = shaka.cea.Mp4CeaParser.CodecBitstreamMap_[codec];\n    }\n  }\n};\n\n/** @enum {number} */\nshaka.cea.Mp4CeaParser.BitstreamFormat = {\n  UNKNOWN: 0,\n  H264: 1,\n  H265: 2,\n};\n\n/** @private {Object.<string, shaka.cea.Mp4CeaParser.BitstreamFormat>} */\nshaka.cea.Mp4CeaParser.CodecBitstreamMap_ = {\n  'avc1': shaka.cea.Mp4CeaParser.BitstreamFormat.H264,\n  'avc3': shaka.cea.Mp4CeaParser.BitstreamFormat.H264,\n  'hev1': shaka.cea.Mp4CeaParser.BitstreamFormat.H265,\n  'hvc1': shaka.cea.Mp4CeaParser.BitstreamFormat.H265,\n  // Dobly vision is also H265.\n  'dvh1': shaka.cea.Mp4CeaParser.BitstreamFormat.H265,\n  'dvhe': shaka.cea.Mp4CeaParser.BitstreamFormat.H265,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.ICeaParser');\n\n/**\n * Interface for parsing inband closed caption data from MP4 streams.\n * @interface\n */\nshaka.cea.ICeaParser = class {\n  /**\n   * Initializes the parser with init segment data.\n   * @param {!BufferSource} initSegment init segment to parse.\n   */\n  init(initSegment) {}\n\n  /**\n   * Parses the stream and extracts closed captions packets.\n   * @param {!BufferSource} mediaSegment media segment to parse.\n   * @return {!Array<!shaka.cea.ICeaParser.CaptionPacket>}\n   */\n  parse(mediaSegment) {}\n};\n\n/**\n * NALU type for Supplemental Enhancement Information (SEI) for H.264.\n * @const {number}\n */\nshaka.cea.ICeaParser.H264_NALU_TYPE_SEI = 0x06;\n\n/**\n * NALU type for Supplemental Enhancement Information (SEI) for H.265.\n * @const {number}\n */\nshaka.cea.ICeaParser.H265_PREFIX_NALU_TYPE_SEI = 0x27;\n\n/**\n * NALU type for Supplemental Enhancement Information (SEI) for H.265.\n * @const {number}\n */\nshaka.cea.ICeaParser.H265_SUFFIX_NALU_TYPE_SEI = 0x28;\n\n/**\n * Default timescale value for a track.\n */\nshaka.cea.ICeaParser.DEFAULT_TIMESCALE_VALUE = 90000;\n\n/**\n * @typedef {{\n *   packet: !Uint8Array,\n *   pts: number\n * }}\n *\n * @description Parsed Caption Packet.\n * @property {!Uint8Array} packet\n * Caption packet. More specifically, it contains a \"User data\n * registered by Recommendation ITU-T T.35 SEI message\", from section D.1.6\n * and section D.2.6 of Rec. ITU-T H.264 (06/2019).\n * @property {number} pts\n * The presentation timestamp (pts) at which the ITU-T T.35 data shows up.\n * in seconds.\n * @exportDoc\n */\nshaka.cea.ICeaParser.CaptionPacket;\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cea.SeiProcessor');\n\n\n/**\n * H.264 SEI NALU Parser used for extracting 708 closed caption packets.\n */\nshaka.cea.SeiProcessor = class {\n  /**\n   * Processes supplemental enhancement information data.\n   * @param {!Uint8Array} naluData NALU from which SEI data is to be processed.\n   * @return {!Array.<!Uint8Array>}\n   */\n  process(naluData) {\n    const seiPayloads = [];\n    const naluClone = this.removeEmu(naluData);\n\n    // The following is an implementation of section 7.3.2.3.1\n    // in Rec. ITU-T H.264 (06/2019), the H.264 spec.\n    let offset = 0;\n\n    while (offset < naluClone.length) {\n      let payloadType = 0; // SEI payload type as defined by H.264 spec\n      while (naluClone[offset] == 0xFF) {\n        payloadType += 255;\n        offset++;\n      }\n      payloadType += naluClone[offset++];\n\n      let payloadSize = 0; // SEI payload size as defined by H.264 spec\n      while (naluClone[offset] == 0xFF) {\n        payloadSize += 255;\n        offset++;\n      }\n      payloadSize += naluClone[offset++];\n\n      // Payload type 4 is user_data_registered_itu_t_t35, as per the H.264\n      // spec. This payload type contains caption data.\n      if (payloadType == 0x04) {\n        seiPayloads.push(naluClone.subarray(offset, offset + payloadSize));\n      }\n      offset += payloadSize;\n    }\n\n    return seiPayloads;\n  }\n\n\n  /**\n   * Removes H.264 emulation prevention bytes from the byte array.\n   *\n   * Note: Remove bytes by shifting will cause Chromium (VDA) to complain\n   * about conformance. Recreating a new array solves it.\n   *\n   * @param {!Uint8Array} naluData NALU from which EMUs should be removed.\n   * @return {!Uint8Array} The NALU with the emulation prevention byte removed.\n   */\n  removeEmu(naluData) {\n    let naluClone = naluData;\n    let zeroCount = 0;\n    let src = 0;\n    while (src < naluClone.length) {\n      if (zeroCount == 2 && naluClone[src] == 0x03) {\n        // 0x00, 0x00, 0x03 pattern detected\n        zeroCount = 0;\n\n        // Splice the array and recreate a new one, instead of shifting bytes\n        const newArr = [...naluClone];\n        newArr.splice(src, 1);\n        naluClone = new Uint8Array(newArr);\n      } else {\n        if (naluClone[src] == 0x00) {\n          zeroCount++;\n        } else {\n          zeroCount = 0;\n        }\n      }\n      src++;\n    }\n    return naluClone;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.ClosedCaptionParser');\ngoog.provide('shaka.media.IClosedCaptionParser');\n\ngoog.require('shaka.cea.CeaDecoder');\ngoog.require('shaka.cea.DummyCeaParser');\ngoog.require('shaka.cea.Mp4CeaParser');\ngoog.require('shaka.util.BufferUtils');\ngoog.requireType('shaka.cea.ICaptionDecoder');\ngoog.requireType('shaka.cea.ICeaParser');\n\n\n/**\n * The IClosedCaptionParser defines the interface to provide all operations for\n * parsing the closed captions embedded in Dash videos streams.\n * TODO: Remove this interface and move method definitions\n * directly to ClosedCaptonParser.\n * @interface\n */\nshaka.media.IClosedCaptionParser = class {\n  /**\n   * Initialize the caption parser. This should be called only once.\n   * @param {BufferSource} initSegment\n   */\n  init(initSegment) {}\n\n  /**\n   * Parses embedded CEA closed captions and interacts with the underlying\n   * CaptionStream, and calls the callback function when there are closed\n   * captions.\n   *\n   * @param {BufferSource} mediaFragment\n   * @return {!Array<!shaka.cea.ICaptionDecoder.ClosedCaption>}\n   * An array of parsed closed captions.\n   */\n  parseFrom(mediaFragment) {}\n\n  /**\n   * Resets the CaptionStream.\n   */\n  reset() {}\n};\n\n/**\n * Closed Caption Parser provides all operations for parsing the closed captions\n * embedded in Dash videos streams.\n *\n * @implements {shaka.media.IClosedCaptionParser}\n * @final\n */\nshaka.media.ClosedCaptionParser = class {\n  /** */\n  constructor(mimeType) {\n    /** @private {!shaka.cea.ICeaParser} */\n    this.ceaParser_ = new shaka.cea.DummyCeaParser();\n\n    if (mimeType.includes('video/mp4')) {\n      // MP4 Parser to extract closed caption packets from H.264 video.\n      this.ceaParser_ = new shaka.cea.Mp4CeaParser();\n    }\n\n    /**\n     * Decoder for decoding CEA-X08 data from closed caption packets.\n     * @private {!shaka.cea.ICaptionDecoder}\n     */\n    this.ceaDecoder_ = new shaka.cea.CeaDecoder();\n  }\n\n  /**\n   * @override\n   */\n  init(initSegment) {\n    this.ceaParser_.init(initSegment);\n  }\n\n  /**\n   * @override\n   */\n  parseFrom(mediaFragment) {\n    // Parse the fragment.\n    const captionPackets = this.ceaParser_.parse(mediaFragment);\n\n    // Extract the caption packets for decoding.\n    for (const captionPacket of captionPackets) {\n      const uint8ArrayData =\n          shaka.util.BufferUtils.toUint8(captionPacket.packet);\n      if (uint8ArrayData.length > 0) {\n        this.ceaDecoder_.extract(uint8ArrayData, captionPacket.pts);\n      }\n    }\n\n    // Decode and return the parsed captions.\n    return this.ceaDecoder_.decode();\n  }\n\n  /**\n   * @override\n   */\n  reset() {\n    this.ceaDecoder_.clear();\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.TimeRangesUtils');\n\n\n/**\n * @summary A set of utility functions for dealing with TimeRanges objects.\n */\nshaka.media.TimeRangesUtils = class {\n  /**\n   * Gets the first timestamp in the buffer.\n   *\n   * @param {TimeRanges} b\n   * @return {?number} The first buffered timestamp, in seconds, if |buffered|\n   *   is non-empty; otherwise, return null.\n   */\n  static bufferStart(b) {\n    if (!b) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n    // Workaround Edge bug: https://bit.ly/2JYLPeB\n    if (b.length == 1 && b.start(0) < 0) {\n      return 0;\n    }\n    return b.length ? b.start(0) : null;\n  }\n\n\n  /**\n   * Gets the last timestamp in the buffer.\n   *\n   * @param {TimeRanges} b\n   * @return {?number} The last buffered timestamp, in seconds, if |buffered|\n   *   is non-empty; otherwise, return null.\n   */\n  static bufferEnd(b) {\n    if (!b) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n    return b.length ? b.end(b.length - 1) : null;\n  }\n\n\n  /**\n   * Determines if the given time is inside a buffered range.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time Playhead time\n   * @return {boolean}\n   */\n  static isBuffered(b, time) {\n    if (!b || !b.length) {\n      return false;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return false;\n    }\n\n    if (time > b.end(b.length - 1)) {\n      return false;\n    }\n\n    return time >= b.start(0);\n  }\n\n\n  /**\n   * Computes how far ahead of the given timestamp is buffered.  To provide\n   * smooth playback while jumping gaps, we don't include the gaps when\n   * calculating this.\n   * This only includes the amount of content that is buffered.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time\n   * @return {number} The number of seconds buffered, in seconds, ahead of the\n   *   given time.\n   */\n  static bufferedAheadOf(b, time) {\n    if (!b || !b.length) {\n      return 0;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return 0;\n    }\n\n    // We calculate the buffered amount by ONLY accounting for the content\n    // buffered (i.e. we ignore the times of the gaps).  We also buffer through\n    // all gaps.\n    // Therefore, we start at the end and add up all buffers until |time|.\n    let result = 0;\n    for (const {start, end} of shaka.media.TimeRangesUtils.getBufferedInfo(b)) {\n      if (end > time) {\n        result += end - Math.max(start, time);\n      }\n    }\n\n    return result;\n  }\n\n\n  /**\n   * Determines if the given time is inside a gap between buffered ranges.  If\n   * it is, this returns the index of the buffer that is *ahead* of the gap.\n   *\n   * @param {TimeRanges} b\n   * @param {number} time\n   * @param {number} threshold\n   * @return {?number} The index of the buffer after the gap, or null if not in\n   *   a gap.\n   */\n  static getGapIndex(b, time, threshold) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n\n    if (!b || !b.length) {\n      return null;\n    }\n    // Workaround Safari bug: https://bit.ly/2trx6O8\n    if (b.length == 1 && b.end(0) - b.start(0) < 1e-6) {\n      return null;\n    }\n\n    const idx = TimeRangesUtils.getBufferedInfo(b).findIndex((item, i, arr) => {\n      return item.start > time &&\n          (i == 0 || arr[i - 1].end - time <= threshold);\n    });\n    return idx >= 0 ? idx : null;\n  }\n\n\n  /**\n   * @param {TimeRanges} b\n   * @return {!Array.<shaka.extern.BufferedRange>}\n   */\n  static getBufferedInfo(b) {\n    if (!b) {\n      return [];\n    }\n    const ret = [];\n    for (let i = 0; i < b.length; i++) {\n      ret.push({start: b.start(i), end: b.end(i)});\n    }\n    return ret;\n  }\n\n  /**\n   * This operation can be potentially EXPENSIVE and should only be done in\n   * debug builds for debugging purposes.\n   *\n   * @param {TimeRanges} oldRanges\n   * @param {TimeRanges} newRanges\n   * @return {?shaka.extern.BufferedRange} The last added range,\n   *   chronologically by presentation time.\n   */\n  static computeAddedRange(oldRanges, newRanges) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n\n    if (!oldRanges || !oldRanges.length) {\n      return null;\n    }\n    if (!newRanges || !newRanges.length) {\n      return TimeRangesUtils.getBufferedInfo(newRanges).pop();\n    }\n\n    const newRangesReversed =\n        TimeRangesUtils.getBufferedInfo(newRanges).reverse();\n    const oldRangesReversed =\n        TimeRangesUtils.getBufferedInfo(oldRanges).reverse();\n    for (const newRange of newRangesReversed) {\n      let foundOverlap = false;\n\n      for (const oldRange of oldRangesReversed) {\n        if (oldRange.end >= newRange.start && oldRange.end <= newRange.end) {\n          foundOverlap = true;\n\n          // If the new range goes beyond the corresponding old one, the\n          // difference is newly-added.\n          if (newRange.end > oldRange.end) {\n            return {start: oldRange.end, end: newRange.end};\n          }\n        }\n      }\n\n      if (!foundOverlap) {\n        return newRange;\n      }\n    }\n\n    return null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Id3Utils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A set of Id3Utils utility functions.\n * @export\n */\nshaka.util.Id3Utils = class {\n  /**\n   * @param {Uint8Array} data\n   * @param {number} offset\n   * @return {boolean}\n   * @private\n   */\n  static isHeader_(data, offset) {\n    /*\n     * http://id3.org/id3v2.3.0\n     * [0]     = 'I'\n     * [1]     = 'D'\n     * [2]     = '3'\n     * [3,4]   = {Version}\n     * [5]     = {Flags}\n     * [6-9]   = {ID3 Size}\n     *\n     * An ID3v2 tag can be detected with the following pattern:\n     *  $49 44 33 yy yy xx zz zz zz zz\n     * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n     */\n    if (offset + 10 <= data.length) {\n      // look for 'ID3' identifier\n      if (data[offset] === 0x49 &&\n          data[offset + 1] === 0x44 &&\n          data[offset + 2] === 0x33) {\n        // check version is within range\n        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 &&\n              data[offset + 7] < 0x80 &&\n              data[offset + 8] < 0x80 &&\n              data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {number} offset\n   * @return {boolean}\n   * @private\n   */\n  static isFooter_(data, offset) {\n    /*\n     * The footer is a copy of the header, but with a different identifier\n     */\n    if (offset + 10 <= data.length) {\n      // look for '3DI' identifier\n      if (data[offset] === 0x33 &&\n          data[offset + 1] === 0x44 &&\n          data[offset + 2] === 0x49) {\n        // check version is within range\n        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 &&\n              data[offset + 7] < 0x80 &&\n              data[offset + 8] < 0x80 &&\n              data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {number} offset\n   * @return {number}\n   * @private\n   */\n  static readSize_(data, offset) {\n    let size = 0;\n    size = (data[offset] & 0x7f) << 21;\n    size |= (data[offset + 1] & 0x7f) << 14;\n    size |= (data[offset + 2] & 0x7f) << 7;\n    size |= data[offset + 3] & 0x7f;\n    return size;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @return {shaka.extern.MetadataRawFrame}\n   * @private\n   */\n  static getFrameData_(data) {\n    /*\n     * Frame ID       $xx xx xx xx (four characters)\n     * Size           $xx xx xx xx\n     * Flags          $xx xx\n     */\n    const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    const size = shaka.util.Id3Utils.readSize_(data, 4);\n\n    // skip frame id, size, and flags\n    const offset = 10;\n\n    return {\n      type,\n      size,\n      data: data.subarray(offset, offset + size),\n    };\n  }\n\n  /**\n   * @param {shaka.extern.MetadataRawFrame} frame\n   * @return {?shaka.extern.MetadataFrame}\n   * @private\n   */\n  static decodeFrame_(frame) {\n    const BufferUtils = shaka.util.BufferUtils;\n    const StringUtils = shaka.util.StringUtils;\n\n    const metadataFrame = {\n      key: frame.type,\n      description: '',\n      data: '',\n    };\n\n    if (frame.type === 'TXXX') {\n      /*\n       * Format:\n       * [0]   = {Text Encoding}\n       * [1-?] = {Description}\\0{Value}\n       */\n      if (frame.size < 2) {\n        return null;\n      }\n      if (frame.data[0] !== shaka.util.Id3Utils.UTF8_encoding) {\n        shaka.log.warning('Ignore frame with unrecognized character ' +\n            'encoding');\n        return null;\n      }\n      const descriptionEndIndex = frame.data.subarray(1).indexOf(0);\n\n      if (descriptionEndIndex === -1) {\n        return null;\n      }\n      const description = StringUtils.fromUTF8(\n          BufferUtils.toUint8(frame.data, 1, descriptionEndIndex));\n      const data = StringUtils.fromUTF8(\n          BufferUtils.toUint8(frame.data, 2 + descriptionEndIndex))\n          .replace(/\\0*$/, '');\n\n      metadataFrame.description = description;\n      metadataFrame.data = data;\n      return metadataFrame;\n    } else if (frame.type === 'WXXX') {\n      /*\n       * Format:\n       * [0]   = {Text Encoding}\n       * [1-?] = {Description}\\0{URL}\n       */\n      if (frame.size < 2) {\n        return null;\n      }\n      if (frame.data[0] !== shaka.util.Id3Utils.UTF8_encoding) {\n        shaka.log.warning('Ignore frame with unrecognized character ' +\n            'encoding');\n        return null;\n      }\n      const descriptionEndIndex = frame.data.subarray(1).indexOf(0);\n\n      if (descriptionEndIndex === -1) {\n        return null;\n      }\n      const description = StringUtils.fromUTF8(\n          BufferUtils.toUint8(frame.data, 1, descriptionEndIndex));\n      const data = StringUtils.fromUTF8(\n          BufferUtils.toUint8(frame.data, 2 + descriptionEndIndex))\n          .replace(/\\0*$/, '');\n\n      metadataFrame.description = description;\n      metadataFrame.data = data;\n      return metadataFrame;\n    } else if (frame.type === 'PRIV') {\n      /*\n       * Format: <text string>\\0<binary data>\n       */\n      if (frame.size < 2) {\n        return null;\n      }\n      const textEndIndex = frame.data.indexOf(0);\n      if (textEndIndex === -1) {\n        return null;\n      }\n      const text = StringUtils.fromUTF8(\n          BufferUtils.toUint8(frame.data, 0, textEndIndex));\n      const data = BufferUtils.toArrayBuffer(\n          frame.data.subarray(text.length + 1));\n      metadataFrame.description = text;\n      metadataFrame.data = data;\n      return metadataFrame;\n    } else if (frame.type[0] === 'T') {\n      /*\n       * Format:\n       * [0]   = {Text Encoding}\n       * [1-?] = {Value}\n       */\n      if (frame.size < 2) {\n        return null;\n      }\n      if (frame.data[0] !== shaka.util.Id3Utils.UTF8_encoding) {\n        shaka.log.warning('Ignore frame with unrecognized character ' +\n            'encoding');\n        return null;\n      }\n      const text = StringUtils.fromUTF8(frame.data.subarray(1))\n          .replace(/\\0*$/, '');\n      metadataFrame.data = text;\n      return metadataFrame;\n    } else if (frame.type[0] === 'W') {\n      /*\n       * Format:\n       * [0-?] = {URL}\n       */\n      const url = StringUtils.fromUTF8(frame.data)\n          .replace(/\\0*$/, '');\n      metadataFrame.data = url;\n      return metadataFrame;\n    } else if (frame.data) {\n      shaka.log.warning('Unrecognized ID3 frame type:', frame.type);\n      metadataFrame.data = BufferUtils.toArrayBuffer(frame.data);\n      return metadataFrame;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n   * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags\n   * @return {!Array.<shaka.extern.MetadataFrame>}\n   * @export\n   */\n  static getID3Frames(id3Data) {\n    const Id3Utils = shaka.util.Id3Utils;\n    let offset = 0;\n    const frames = [];\n    while (Id3Utils.isHeader_(id3Data, offset)) {\n      const size = Id3Utils.readSize_(id3Data, offset + 6);\n\n      if ((id3Data[offset + 5] >> 6) & 1) {\n        // skip extended header\n        offset += 10;\n      }\n      // skip past ID3 header\n      offset += 10;\n\n      const end = offset + size;\n      // loop through frames in the ID3 tag\n      while (offset + 10 < end) {\n        const frameData = Id3Utils.getFrameData_(id3Data.subarray(offset));\n        const frame = Id3Utils.decodeFrame_(frameData);\n        if (frame) {\n          frames.push(frame);\n        }\n\n        // skip frame header and frame data\n        offset += frameData.size + 10;\n      }\n\n      if (Id3Utils.isFooter_(id3Data, offset)) {\n        offset += 10;\n      }\n    }\n    return frames;\n  }\n};\n\n/**\n * UTF8 encoding byte\n * @const {number}\n */\nshaka.util.Id3Utils.UTF8_encoding = 0x03;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.TsParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Id3Utils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @see https://en.wikipedia.org/wiki/MPEG_transport_stream\n * @export\n */\nshaka.util.TsParser = class {\n  /** */\n  constructor() {\n    /** @private {?number} */\n    this.pmtId_ = null;\n\n    /** @private {boolean} */\n    this.pmtParsed_ = false;\n\n    /** @private {?number} */\n    this.videoStartTime_ = null;\n\n    /** @private {?number} */\n    this.videoPid_ = null;\n\n    /** @private {?string} */\n    this.videoCodec_ = null;\n\n    /** @private {!Array.<Uint8Array>} */\n    this.videoData_ = [];\n\n    /** @private {?number} */\n    this.audioStartTime_ = null;\n\n    /** @private {?number} */\n    this.audioPid_ = null;\n\n    /** @private {?string} */\n    this.audioCodec_ = null;\n\n    /** @private {!Array.<Uint8Array>} */\n    this.audioData_ = [];\n\n    /** @private {?number} */\n    this.id3Pid_ = null;\n\n    /** @private {!Array.<Uint8Array>} */\n    this.id3Data_ = [];\n  }\n\n  /**\n   * Parse the given data\n   *\n   * @param {Uint8Array} data\n   * @return {!shaka.util.TsParser}\n   */\n  parse(data) {\n    const timescale = shaka.util.TsParser.Timescale_;\n    const packetLength = shaka.util.TsParser.PacketLength_;\n\n    // A TS fragment should contain at least 3 TS packets, a PAT, a PMT, and\n    // one PID.\n    if (data.length < 3 * packetLength) {\n      return this;\n    }\n    const syncOffset = Math.max(0, shaka.util.TsParser.syncOffset(data));\n\n    const length = data.length - (data.length + syncOffset) % packetLength;\n\n    let unknownPIDs = false;\n\n    // loop through TS packets\n    for (let start = syncOffset; start < length; start += packetLength) {\n      if (data[start] === 0x47) {\n        const payloadUnitStartIndicator = !!(data[start + 1] & 0x40);\n        // pid is a 13-bit field starting at the last 5 bits of TS[1]\n        const pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n        const adaptationFieldControl = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the\n        // fifth byte of the TS packet header.\n        let offset;\n        if (adaptationFieldControl > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + packetLength) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case 0:\n            if (payloadUnitStartIndicator) {\n              offset += data[offset] + 1;\n            }\n\n            this.pmtId_ = this.getPmtId_(data, offset);\n            break;\n          case 17:\n          case 0x1fff:\n            break;\n          case this.pmtId_: {\n            if (payloadUnitStartIndicator) {\n              offset += data[offset] + 1;\n            }\n\n            const parsedPIDs = this.parsePMT(data, offset);\n\n            // only update track id if track PID found while parsing PMT\n            // this is to avoid resetting the PID to -1 in case\n            // track PID transiently disappears from the stream\n            // this could happen in case of transient missing audio samples\n            // for example\n            // NOTE this is only the PID of the track as found in TS,\n            // but we are not using this for MP4 track IDs.\n            if (this.videoPid_ == null) {\n              this.videoPid_ = parsedPIDs.video;\n              this.videoCodec_ = parsedPIDs.videoCodec;\n            }\n            if (this.audioPid_ == null) {\n              this.audioPid_ = parsedPIDs.audio;\n              this.audioCodec_ = parsedPIDs.audioCodec;\n            }\n            if (this.id3Pid_ == null) {\n              this.id3Pid_ = parsedPIDs.id3;\n            }\n\n            if (unknownPIDs && !this.pmtParsed_) {\n              shaka.log.debug('reparse from beginning');\n              unknownPIDs = false;\n              // we set it to -188, the += 188 in the for loop will reset\n              // start to 0\n              start = syncOffset - packetLength;\n            }\n            this.pmtParsed_ = true;\n            break;\n          }\n          case this.videoPid_: {\n            const videoData = data.subarray(offset, start + packetLength);\n            if (this.videoStartTime_ == null) {\n              const pes = this.parsePES(videoData);\n              if (pes && pes.pts != null) {\n                this.videoStartTime_ = pes.pts / timescale;\n              }\n            }\n            this.videoData_.push(videoData);\n            break;\n          }\n          case this.audioPid_: {\n            const audioData = data.subarray(offset, start + packetLength);\n            if (this.audioStartTime_ == null) {\n              const pes = this.parsePES(audioData);\n              if (pes && pes.pts != null) {\n                this.audioStartTime_ = pes.pts / timescale;\n              }\n            }\n            this.audioData_.push(audioData);\n            break;\n          }\n          case this.id3Pid_:\n            this.id3Data_.push(data.subarray(offset, start + packetLength));\n            break;\n          default:\n            unknownPIDs = true;\n            break;\n        }\n      } else {\n        shaka.log.warning('Found TS packet that do not start with 0x47');\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Get the PMT ID from the PAT\n   *\n   * @param {Uint8Array} data\n   * @param {number} offset\n   * @return {number}\n   * @private\n   */\n  getPmtId_(data, offset) {\n    // skip the PSI header and parse the first PMT entry\n    return ((data[offset + 10] & 0x1f) << 8) | data[offset + 11];\n  }\n\n  /**\n   * Parse PMT\n   *\n   * @param {Uint8Array} data\n   * @param {number} offset\n   * @return {!shaka.util.TsParser.PMT}\n   */\n  parsePMT(data, offset) {\n    const result = {\n      audio: -1,\n      video: -1,\n      id3: -1,\n      audioCodec: '',\n      videoCodec: '',\n    };\n    const sectionLength = ((data[offset + 1] & 0x0f) << 8) | data[offset + 2];\n    const tableEnd = offset + 3 + sectionLength - 4;\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    const programInfoLength =\n      ((data[offset + 10] & 0x0f) << 8) | data[offset + 11];\n    // advance the offset to the first entry in the mapping table\n    offset += 12 + programInfoLength;\n    while (offset < tableEnd) {\n      const pid = ((data[offset + 1] & 0x1f) << 8) | data[offset + 2];\n      switch (data[offset]) {\n        // SAMPLE-AES AAC\n        case 0xcf:\n          break;\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        case 0x0f:\n          if (result.audio === -1) {\n            result.audio = pid;\n            result.audioCodec = 'aac';\n          }\n          break;\n        // Packetized metadata (ID3)\n        case 0x15:\n          if (result.id3 === -1) {\n            result.id3 = pid;\n          }\n          break;\n        // SAMPLE-AES AVC\n        case 0xdb:\n          break;\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        case 0x1b:\n          if (result.video === -1) {\n            result.video = pid;\n            result.videoCodec = 'avc';\n          }\n          break;\n        // ISO/IEC 11172-3 (MPEG-1 audio)\n        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n        case 0x03:\n        case 0x04:\n          if (result.audio === -1) {\n            result.audio = pid;\n            result.audioCodec = 'mp3';\n          }\n          break;\n        // HEVC\n        case 0x24:\n          if (result.video === -1) {\n            result.video = pid;\n            result.videoCodec = 'hvc';\n          }\n          break;\n        default:\n          // shaka.log.warning('Unknown stream type:', data[offset]);\n          break;\n      }\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += (((data[offset + 3] & 0x0f) << 8) | data[offset + 4]) + 5;\n    }\n    return result;\n  }\n\n  /**\n   * Parse PES\n   *\n   * @param {Uint8Array} data\n   * @return {?shaka.util.TsParser.PES}\n   */\n  parsePES(data) {\n    const startPrefix = (data[0] << 16) | (data[1] << 8) | data[2];\n    // In certain live streams, the start of a TS fragment has ts packets\n    // that are frame data that is continuing from the previous fragment. This\n    // is to check that the pes data is the start of a new pes data\n    if (startPrefix !== 1) {\n      return null;\n    }\n    /** @type {shaka.util.TsParser.PES} */\n    const pes = {\n      data: new Uint8Array(0),\n      // get the packet length, this will be 0 for video\n      packetLength: 6 + ((data[4] << 8) | data[5]),\n      pts: null,\n      dts: null,\n    };\n\n    // PES packets may be annotated with a PTS value, or a PTS value\n    // and a DTS value. Determine what combination of values is\n    // available to work with.\n    const ptsDtsFlags = data[7];\n\n    // PTS and DTS are normally stored as a 33-bit number.  Javascript\n    // performs all bitwise operations on 32-bit integers but javascript\n    // supports a much greater range (52-bits) of integer using standard\n    // mathematical operations.\n    // We construct a 31-bit value using bitwise operators over the 31\n    // most significant bits and then multiply by 4 (equal to a left-shift\n    // of 2) before we add the final 2 least significant bits of the\n    // timestamp (equal to an OR.)\n    if (ptsDtsFlags & 0xC0) {\n      // the PTS and DTS are not written out directly. For information\n      // on how they are encoded, see\n      // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n      pes.pts =\n        (data[9] & 0x0e) * 536870912 + // 1 << 29\n        (data[10] & 0xff) * 4194304 + // 1 << 22\n        (data[11] & 0xfe) * 16384 + // 1 << 14\n        (data[12] & 0xff) * 128 + // 1 << 7\n        (data[13] & 0xfe) / 2;\n\n      pes.dts = pes.pts;\n      if (ptsDtsFlags & 0x40) {\n        pes.dts =\n          (data[14] & 0x0e) * 536870912 + // 1 << 29\n          (data[15] & 0xff) * 4194304 + // 1 << 22\n          (data[16] & 0xfe) * 16384 + // 1 << 14\n          (data[17] & 0xff) * 128 + // 1 << 7\n          (data[18] & 0xfe) / 2;\n      }\n    }\n    // the data section starts immediately after the PES header.\n    // pes_header_data_length specifies the number of header bytes\n    // that follow the last byte of the field.\n    pes.data = data.subarray(9 + data[8]);\n\n    return pes;\n  }\n\n  /**\n   * Return the ID3 metadata\n   *\n   * @return {!Array.<shaka.extern.ID3Metadata>}\n   */\n  getMetadata() {\n    const timescale = shaka.util.TsParser.Timescale_;\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const metadata = [];\n    let prevId3Data = new Uint8Array(0);\n    // parsePES() only works if the data begins on a PES boundary.\n    // Try the last data blob first, and if it doesn't begin on a\n    // PES boundary, prepend the previous blob and try again.\n    // This way, a successful parse will always begin and end on\n    // the correct boundary, and no data will be skipped.\n    for (let i = this.id3Data_.length - 1; i >= 0; i--) {\n      const data = this.id3Data_[i];\n      goog.asserts.assert(data, 'We should have a data');\n      const id3Data = Uint8ArrayUtils.concat(data, prevId3Data);\n      const pes = this.parsePES(id3Data);\n      if (pes) {\n        metadata.unshift({\n          cueTime: pes.pts ? pes.pts / timescale : null,\n          data: pes.data,\n          frames: shaka.util.Id3Utils.getID3Frames(pes.data),\n          dts: pes.dts,\n          pts: pes.pts,\n        });\n        prevId3Data = new Uint8Array(0);\n      } else {\n        prevId3Data = id3Data;\n      }\n    }\n    return metadata;\n  }\n\n  /**\n   * Return the start time for the audio and video\n   *\n   * @return {{audio: ?number, video: ?number}}\n   */\n  getStartTime() {\n    return {\n      audio: this.audioStartTime_,\n      video: this.videoStartTime_,\n    };\n  }\n\n  /**\n   * Return the audio and video codecs\n   *\n   * @return {{audio: ?string, video: ?string}}\n   */\n  getCodecs() {\n    return {\n      audio: this.audioCodec_,\n      video: this.videoCodec_,\n    };\n  }\n\n  /**\n   * Check if the passed data corresponds to an MPEG2-TS\n   *\n   * @param {Uint8Array} data\n   * @return {boolean}\n   */\n  static probe(data) {\n    const syncOffset = shaka.util.TsParser.syncOffset(data);\n    if (syncOffset < 0) {\n      return false;\n    } else {\n      if (syncOffset > 0) {\n        shaka.log.warning('MPEG2-TS detected but first sync word found @ ' +\n            'offset ' + syncOffset + ', junk ahead ?');\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Returns the synchronization offset\n   *\n   * @param {Uint8Array} data\n   * @return {number}\n   */\n  static syncOffset(data) {\n    const packetLength = shaka.util.TsParser.PacketLength_;\n    // scan 1000 first bytes\n    const scanwindow = Math.min(1000, data.length - 3 * packetLength);\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and\n      // one PID, each starting with 0x47\n      if (data[i] === 0x47 &&\n          data[i + packetLength] === 0x47 &&\n          data[i + 2 * packetLength] === 0x47) {\n        return i;\n      } else {\n        i++;\n      }\n    }\n    return -1;\n  }\n};\n\n\n/**\n * @const {number}\n * @private\n */\nshaka.util.TsParser.PacketLength_ = 188;\n\n\n/**\n * @const {number}\n * @private\n */\nshaka.util.TsParser.Timescale_ = 90000;\n\n\n/**\n * @typedef {{\n *   audio: number,\n *   video: number,\n *   id3: number,\n *   audioCodec: string,\n *   videoCodec: string\n * }}\n *\n * @summary PMT.\n * @property {number} audio\n *   Audio PID\n * @property {number} video\n *   Video PID\n * @property {number} id3\n *   ID3 PID\n * @property {string} audioCodec\n *   Audio codec\n * @property {string} videoCodec\n *   Video codec\n */\nshaka.util.TsParser.PMT;\n\n\n/**\n * @typedef {{\n *   data: Uint8Array,\n *   packetLength: number,\n *   pts: ?number,\n *   dts: ?number\n * }}\n *\n * @summary PES.\n * @property {Uint8Array} data\n * @property {number} packetLength\n * @property {?number} pts\n * @property {?number} dts\n */\nshaka.util.TsParser.PES;\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.lcevc.Dil');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IReleasable');\n\n/**\n * @summary\n *  lcevcDil - (MPEG-5 Part 2 LCEVC - Decoder Integration Layer) provides\n *  all the operations related to the enhancement and rendering\n *  of LCEVC enabled streams and on to a canvas.\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.lcevc.Dil = class {\n  /**\n   * @param {HTMLVideoElement} media The video element that will be attached to\n   * LCEVC Dil for input.\n   * @param {HTMLCanvasElement} canvas The canvas element that will be attached\n   * to LCEVC Dil to render the enhanced frames.\n   * @param {shaka.extern.LcevcConfiguration} dilConfig The LCEVC DIL\n   * config object to initialize the LCEVC DIL.\n   */\n  constructor(media, canvas, dilConfig) {\n    /** @private {?LcevcDil.LcevcDIL} */\n    this.dil_ = null;\n\n    /** @private {number} */\n    this.variantId_ = -1;\n\n    /** @private {HTMLVideoElement} */\n    this.media_ = media;\n\n    /** @private {HTMLCanvasElement} */\n    this.canvas_ = canvas;\n\n    /** @private {shaka.extern.LcevcConfiguration} */\n    this.dilConfig_ = dilConfig;\n\n    this.create_();\n  }\n\n  /**\n   * Append data to the LCEVC Dil.\n   * @param {BufferSource} data\n   */\n  appendBuffer(data) {\n    if (this.dil_) {\n      this.dil_.appendBuffer(data, 'video', this.variantId_);\n    }\n  }\n\n  /**\n   * Hide the canvas specifically in the case of a DRM Content\n   */\n  hideCanvas() {\n    if (this.dil_) {\n      this.canvas_.classList.add('shaka-hidden');\n    }\n  }\n\n  /**\n   * Create LCEVC Dil.\n   * @private\n   */\n  create_() {\n    if (this.isSupported_() && !this.dil_) {\n      if (LcevcDil.SupportObject.webGLSupport(this.canvas_)) {\n        // Make sure the canvas is not hidden from a previous playback session.\n        this.canvas_.classList.remove('shaka-hidden');\n        this.dil_ = new LcevcDil.LcevcDil(\n            this.media_,\n            this.canvas_,\n            this.dilConfig_);\n      }\n    }\n  }\n\n  /**\n   * Close LCEVC Dil.\n   * @override\n   * @export\n   */\n  release() {\n    if (this.dil_) {\n      this.dil_.close();\n      this.dil_ = null;\n    }\n  }\n\n  /**\n   * Check if the LCEVC Dil lib is present and is supported by the browser.\n   * @return {boolean}\n   * @private\n   */\n  isSupported_() {\n    if (typeof libDPIModule === 'undefined') {\n      shaka.log.alwaysWarn(\n          'Could not Find LCEVC Library dependencies on this page');\n    }\n\n    if (typeof LcevcDil === 'undefined') {\n      shaka.log.alwaysWarn('Could not Find LCEVC Library on this page');\n    } else {\n      if (!LcevcDil.SupportObject.SupportStatus) {\n        shaka.log.alwaysWarn(LcevcDil.SupportObject.SupportError);\n      }\n    }\n\n    return typeof LcevcDil !== 'undefined' &&\n      typeof libDPIModule !== 'undefined' &&\n      this.canvas_ instanceof HTMLCanvasElement &&\n      LcevcDil.SupportObject.SupportStatus;\n  }\n\n  /**\n   * Update current active variant\n   * @param {shaka.extern.Track} track\n   */\n  updateVariant(track) {\n    let containerFormat = shaka.lcevc.Dil.ContainerFormat.MPEG2_TS;\n    switch (track.mimeType) {\n      case 'video/webm': {\n        containerFormat = shaka.lcevc.Dil.ContainerFormat.WEBM;\n        break;\n      }\n      case 'video/mp4': {\n        containerFormat = shaka.lcevc.Dil.ContainerFormat.MP4;\n        break;\n      }\n    }\n    if (this.dil_) {\n      this.variantId_ = track.id;\n      this.dil_.setLevelSwitching(track.id, true);\n      this.dil_.setContainerFormat(containerFormat);\n    }\n  }\n};\n\n/**\n * Container Formats.\n * @const @enum {number}\n */\nshaka.lcevc.Dil.ContainerFormat = {\n  MPEG2_TS: 0,\n  WEBM: 1,\n  MP4: 2,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MediaSourceEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.Capabilities');\ngoog.require('shaka.media.ContentWorkarounds');\ngoog.require('shaka.media.ClosedCaptionParser');\ngoog.require('shaka.media.IClosedCaptionParser');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.Transmuxer');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Id3Utils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.TsParser');\ngoog.require('shaka.lcevc.Dil');\n\n\n/**\n * @summary\n * MediaSourceEngine wraps all operations on MediaSource and SourceBuffers.\n * All asynchronous operations return a Promise, and all operations are\n * internally synchronized and serialized as needed.  Operations that can\n * be done in parallel will be done in parallel.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.MediaSourceEngine = class {\n  /**\n   * @param {HTMLMediaElement} video The video element, whose source is tied to\n   *   MediaSource during the lifetime of the MediaSourceEngine.\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   *    The text displayer that will be used with the text engine.\n   *    MediaSourceEngine takes ownership of the displayer. When\n   *    MediaSourceEngine is destroyed, it will destroy the displayer.\n   * @param {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)=}\n   *    onMetadata\n   * @param {?shaka.lcevc.Dil} [lcevcDil] Optional -  LCEVC Dil Object\n   *\n   */\n  constructor(video, textDisplayer, onMetadata, lcevcDil) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {?shaka.extern.MediaSourceConfiguration} */\n    this.config_ = null;\n\n    /** @private {shaka.extern.TextDisplayer} */\n    this.textDisplayer_ = textDisplayer;\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           SourceBuffer>} */\n    this.sourceBuffers_ = {};\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           string>} */\n    this.sourceBufferTypes_ = {};\n\n\n    /** @private {!Object.<shaka.util.ManifestParserUtils.ContentType,\n                           boolean>} */\n    this.expectedEncryption_ = {};\n\n    /** @private {shaka.text.TextEngine} */\n    this.textEngine_ = null;\n\n    /** @private {boolean} */\n    this.segmentRelativeVttTiming_ = false;\n\n    const onMetadataNoOp = (metadata, timestampOffset, segmentEnd) => {};\n\n    /** @private {!function(!Array.<shaka.extern.ID3Metadata>,\n                    number, ?number)} */\n    this.onMetadata_ = onMetadata || onMetadataNoOp;\n\n    /** @private {?shaka.lcevc.Dil} */\n    this.lcevcDil_ = lcevcDil || null;\n\n    /**\n     * @private {!Object.<string,\n     *                    !Array.<shaka.media.MediaSourceEngine.Operation>>}\n     */\n    this.queues_ = {};\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {!Object.<string, !shaka.media.Transmuxer>} */\n    this.transmuxers_ = {};\n\n    /** @private {?shaka.media.IClosedCaptionParser} */\n    this.captionParser_ = null;\n\n    /** @private {!shaka.util.PublicPromise} */\n    this.mediaSourceOpen_ = new shaka.util.PublicPromise();\n\n    /** @private {MediaSource} */\n    this.mediaSource_ = this.createMediaSource(this.mediaSourceOpen_);\n\n    /** @type {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n\n    /** @private {string} */\n    this.url_ = '';\n\n    /** @private {boolean} */\n    this.sequenceMode_ = false;\n\n    /** @private {!shaka.util.PublicPromise.<number>} */\n    this.textSequenceModeOffset_ = new shaka.util.PublicPromise();\n  }\n\n  /**\n   * Create a MediaSource object, attach it to the video element, and return it.\n   * Resolves the given promise when the MediaSource is ready.\n   *\n   * Replaced by unit tests.\n   *\n   * @param {!shaka.util.PublicPromise} p\n   * @return {!MediaSource}\n   */\n  createMediaSource(p) {\n    const mediaSource = new MediaSource();\n\n    // Set up MediaSource on the video element.\n    this.eventManager_.listenOnce(\n        mediaSource, 'sourceopen', () => this.onSourceOpen_(p));\n\n    // Store the object URL for releasing it later.\n    this.url_ = shaka.media.MediaSourceEngine.createObjectURL(mediaSource);\n\n    this.video_.src = this.url_;\n\n    return mediaSource;\n  }\n\n  /**\n   * @param {!shaka.util.PublicPromise} p\n   * @private\n   */\n  onSourceOpen_(p) {\n    // Release the object URL that was previously created, to prevent memory\n    // leak.\n    // createObjectURL creates a strong reference to the MediaSource object\n    // inside the browser.  Setting the src of the video then creates another\n    // reference within the video element.  revokeObjectURL will remove the\n    // strong reference to the MediaSource object, and allow it to be\n    // garbage-collected later.\n    URL.revokeObjectURL(this.url_);\n    p.resolve();\n  }\n\n  /**\n   * Checks if a certain type is supported.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {boolean}\n   */\n  static isStreamSupported(stream) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    const extendedMimeType = shaka.util.MimeUtils.getExtendedType(stream);\n    return shaka.text.TextEngine.isTypeSupported(fullMimeType) ||\n        shaka.media.Capabilities.isTypeSupported(extendedMimeType) ||\n        shaka.media.Transmuxer.isSupported(fullMimeType, stream.type);\n  }\n\n  /**\n   * Returns a map of MediaSource support for well-known types.\n   *\n   * @return {!Object.<string, boolean>}\n   */\n  static probeSupport() {\n    const testMimeTypes = [\n      // MP4 types\n      'video/mp4; codecs=\"avc1.42E01E\"',\n      'video/mp4; codecs=\"avc3.42E01E\"',\n      'video/mp4; codecs=\"hev1.1.6.L93.90\"',\n      'video/mp4; codecs=\"hvc1.1.6.L93.90\"',\n      'video/mp4; codecs=\"hev1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n      'video/mp4; codecs=\"hvc1.2.4.L153.B0\"; eotf=\"smpte2084\"',  // HDR HEVC\n      'video/mp4; codecs=\"vp9\"',\n      'video/mp4; codecs=\"vp09.00.10.08\"',\n      'video/mp4; codecs=\"av01.0.01M.08\"',\n      'audio/mp4; codecs=\"mp4a.40.2\"',\n      'audio/mp4; codecs=\"ac-3\"',\n      'audio/mp4; codecs=\"ec-3\"',\n      'audio/mp4; codecs=\"opus\"',\n      'audio/mp4; codecs=\"flac\"',\n      // WebM types\n      'video/webm; codecs=\"vp8\"',\n      'video/webm; codecs=\"vp9\"',\n      'video/webm; codecs=\"vp09.00.10.08\"',\n      'audio/webm; codecs=\"vorbis\"',\n      'audio/webm; codecs=\"opus\"',\n      // MPEG2 TS types (video/ is also used for audio: https://bit.ly/TsMse)\n      'video/mp2t; codecs=\"avc1.42E01E\"',\n      'video/mp2t; codecs=\"avc3.42E01E\"',\n      'video/mp2t; codecs=\"hvc1.1.6.L93.90\"',\n      'video/mp2t; codecs=\"mp4a.40.2\"',\n      'video/mp2t; codecs=\"ac-3\"',\n      'video/mp2t; codecs=\"ec-3\"',\n      // WebVTT types\n      'text/vtt',\n      'application/mp4; codecs=\"wvtt\"',\n      // TTML types\n      'application/ttml+xml',\n      'application/mp4; codecs=\"stpp\"',\n      // Containerless types\n      ...shaka.media.MediaSourceEngine.RAW_FORMATS,\n    ];\n\n    const support = {};\n    for (const type of testMimeTypes) {\n      if (shaka.util.Platform.supportsMediaSource()) {\n        // Our TextEngine is only effective for MSE platforms at the moment.\n        if (shaka.text.TextEngine.isTypeSupported(type)) {\n          support[type] = true;\n        } else {\n          support[type] = shaka.media.Capabilities.isTypeSupported(type) ||\n                          shaka.media.Transmuxer.isSupported(type);\n        }\n      } else {\n        support[type] = shaka.util.Platform.supportsMediaType(type);\n      }\n\n      const basicType = type.split(';')[0];\n      support[basicType] = support[basicType] || support[type];\n    }\n\n    return support;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /** @private */\n  async doDestroy_() {\n    const Functional = shaka.util.Functional;\n\n    const cleanup = [];\n\n    for (const contentType in this.queues_) {\n      // Make a local copy of the queue and the first item.\n      const q = this.queues_[contentType];\n      const inProgress = q[0];\n\n      // Drop everything else out of the original queue.\n      this.queues_[contentType] = q.slice(0, 1);\n\n      // We will wait for this item to complete/fail.\n      if (inProgress) {\n        cleanup.push(inProgress.p.catch(Functional.noop));\n      }\n\n      // The rest will be rejected silently if possible.\n      for (const item of q.slice(1)) {\n        item.p.reject(shaka.util.Destroyer.destroyedError());\n      }\n    }\n\n    if (this.textEngine_) {\n      cleanup.push(this.textEngine_.destroy());\n    }\n    if (this.textDisplayer_) {\n      cleanup.push(this.textDisplayer_.destroy());\n    }\n\n    for (const contentType in this.transmuxers_) {\n      cleanup.push(this.transmuxers_[contentType].destroy());\n    }\n\n\n    await Promise.all(cleanup);\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.video_) {\n      // \"unload\" the video element.\n      this.video_.removeAttribute('src');\n      this.video_.load();\n      this.video_ = null;\n    }\n\n    this.config_ = null;\n    this.mediaSource_ = null;\n    this.textEngine_ = null;\n    this.textDisplayer_ = null;\n    this.sourceBuffers_ = {};\n    this.transmuxers_ = {};\n    this.captionParser_ = null;\n    if (goog.DEBUG) {\n      for (const contentType in this.queues_) {\n        goog.asserts.assert(\n            this.queues_[contentType].length == 0,\n            contentType + ' queue should be empty after destroy!');\n      }\n    }\n    this.queues_ = {};\n\n    // This object is owned by Player\n    this.lcevcDil_ = null;\n  }\n\n  /**\n   * @return {!Promise} Resolved when MediaSource is open and attached to the\n   *   media element.  This process is actually initiated by the constructor.\n   */\n  open() {\n    return this.mediaSourceOpen_;\n  }\n\n  /**\n   * Initialize MediaSourceEngine.\n   *\n   * Note that it is not valid to call this multiple times, except to add or\n   * reinitialize text streams.\n   *\n   * @param {!Map.<shaka.util.ManifestParserUtils.ContentType,\n   *               shaka.extern.Stream>} streamsByType\n   *   A map of content types to streams.  All streams must be supported\n   *   according to MediaSourceEngine.isStreamSupported.\n   * @param {boolean} forceTransmux\n   *   If true, this will transmux AAC and TS content even if it is natively\n   *   supported.\n   * @param {boolean=} sequenceMode\n   *   If true, the media segments are appended to the SourceBuffer in strict\n   *   sequence.\n   *\n   * @return {!Promise}\n   */\n  async init(streamsByType, forceTransmux, sequenceMode=false) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    await this.mediaSourceOpen_;\n\n    this.sequenceMode_ = sequenceMode;\n\n    for (const contentType of streamsByType.keys()) {\n      const stream = streamsByType.get(contentType);\n      goog.asserts.assert(\n          shaka.media.MediaSourceEngine.isStreamSupported(stream),\n          'Type negotiation should happen before MediaSourceEngine.init!');\n\n      let mimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      if (contentType == ContentType.TEXT) {\n        this.reinitText(mimeType, sequenceMode);\n      } else {\n        if ((forceTransmux ||\n            !shaka.media.Capabilities.isTypeSupported(mimeType)) &&\n            shaka.media.Transmuxer.isSupported(mimeType, contentType)) {\n          this.transmuxers_[contentType] =\n              new shaka.media.Transmuxer(mimeType);\n          mimeType =\n              shaka.media.Transmuxer.convertCodecs(contentType, mimeType);\n        }\n        const type = mimeType + this.config_.sourceBufferExtraFeatures;\n        const sourceBuffer = this.mediaSource_.addSourceBuffer(type);\n\n        this.eventManager_.listen(\n            sourceBuffer, 'error',\n            () => this.onError_(contentType));\n        this.eventManager_.listen(\n            sourceBuffer, 'updateend',\n            () => this.onUpdateEnd_(contentType));\n        this.sourceBuffers_[contentType] = sourceBuffer;\n        this.sourceBufferTypes_[contentType] = mimeType;\n        this.queues_[contentType] = [];\n        this.expectedEncryption_[contentType] = !!stream.drmInfos.length;\n      }\n    }\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes. Must be called at least once before init().\n   *\n   * @param {shaka.extern.MediaSourceConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * Reinitialize the TextEngine for a new text type.\n   * @param {string} mimeType\n   * @param {boolean} sequenceMode\n   */\n  reinitText(mimeType, sequenceMode) {\n    if (!this.textEngine_) {\n      this.textEngine_ = new shaka.text.TextEngine(this.textDisplayer_);\n    }\n    this.textEngine_.initParser(mimeType, sequenceMode,\n        this.segmentRelativeVttTiming_);\n  }\n\n  /**\n   * @return {boolean} True if the MediaSource is in an \"ended\" state, or if the\n   *   object has been destroyed.\n   */\n  ended() {\n    return this.mediaSource_ ? this.mediaSource_.readyState == 'ended' : true;\n  }\n\n  /**\n   * Gets the first timestamp in buffer for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n   */\n  bufferStart(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferStart();\n    }\n    return shaka.media.TimeRangesUtils.bufferStart(\n        this.getBuffered_(contentType));\n  }\n\n  /**\n   * Gets the last timestamp in buffer for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {?number} The timestamp in seconds, or null if nothing is buffered.\n   */\n  bufferEnd(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferEnd();\n    }\n    return shaka.media.TimeRangesUtils.bufferEnd(\n        this.getBuffered_(contentType));\n  }\n\n  /**\n   * Determines if the given time is inside the buffered range of the given\n   * content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} time Playhead time\n   * @return {boolean}\n   */\n  isBuffered(contentType, time) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.isBuffered(time);\n    } else {\n      const buffered = this.getBuffered_(contentType);\n      return shaka.media.TimeRangesUtils.isBuffered(buffered, time);\n    }\n  }\n\n  /**\n   * Computes how far ahead of the given timestamp is buffered for the given\n   * content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} time\n   * @return {number} The amount of time buffered ahead in seconds.\n   */\n  bufferedAheadOf(contentType, time) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      return this.textEngine_.bufferedAheadOf(time);\n    } else {\n      const buffered = this.getBuffered_(contentType);\n      return shaka.media.TimeRangesUtils.bufferedAheadOf(buffered, time);\n    }\n  }\n\n  /**\n   * Returns info about what is currently buffered.\n   * @return {shaka.extern.BufferedInfo}\n   */\n  getBufferedInfo() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n\n    const info = {\n      total: TimeRangesUtils.getBufferedInfo(this.video_.buffered),\n      audio: TimeRangesUtils.getBufferedInfo(\n          this.getBuffered_(ContentType.AUDIO)),\n      video: TimeRangesUtils.getBufferedInfo(\n          this.getBuffered_(ContentType.VIDEO)),\n      text: [],\n    };\n\n    if (this.textEngine_) {\n      const start = this.textEngine_.bufferStart();\n      const end = this.textEngine_.bufferEnd();\n\n      if (start != null && end != null) {\n        info.text.push({start: start, end: end});\n      }\n    }\n    return info;\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {TimeRanges} The buffered ranges for the given content type, or\n   *   null if the buffered ranges could not be obtained.\n   * @private\n   */\n  getBuffered_(contentType) {\n    try {\n      return this.sourceBuffers_[contentType].buffered;\n    } catch (exception) {\n      if (contentType in this.sourceBuffers_) {\n        // Note: previous MediaSource errors may cause access to |buffered| to\n        // throw.\n        shaka.log.error('failed to get buffered range for ' + contentType,\n            exception);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Create a new closed caption parser. This will ONLY be replaced by tests as\n   * a way to inject fake closed caption parser instances.\n   *\n   * @param {string} mimeType\n   * @return {!shaka.media.IClosedCaptionParser}\n   */\n  getCaptionParser(mimeType) {\n    return new shaka.media.ClosedCaptionParser(mimeType);\n  }\n\n  /**\n   * Enqueue an operation to append data to the SourceBuffer.\n   * Start and end times are needed for TextEngine, but not for MediaSource.\n   * Start and end times may be null for initialization segments; if present\n   * they are relative to the presentation timeline.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {!BufferSource} data\n   * @param {?shaka.media.SegmentReference} reference The segment reference\n   *   we are appending, or null for init segments\n   * @param {?boolean} hasClosedCaptions True if the buffer contains CEA closed\n   *   captions\n   * @param {boolean=} seeked True if we just seeked\n   * @param {boolean=} adaptation True if we just automatically switched active\n   *   variant(s).\n   * @return {!Promise}\n   */\n  async appendBuffer(\n      contentType, data, reference, hasClosedCaptions, seeked = false,\n      adaptation = false) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    if (contentType == ContentType.TEXT) {\n      if (this.sequenceMode_) {\n        // This won't be known until the first video segment is appended.\n        const offset = await this.textSequenceModeOffset_;\n        this.textEngine_.setTimestampOffset(offset);\n      }\n      await this.textEngine_.appendBuffer(\n          data,\n          reference ? reference.startTime : null,\n          reference ? reference.endTime : null);\n      return;\n    }\n\n    const uint8ArrayData = shaka.util.BufferUtils.toUint8(data);\n    let mimeType = this.sourceBufferTypes_[contentType];\n    if (this.transmuxers_[contentType]) {\n      mimeType = this.transmuxers_[contentType].getOrginalMimeType();\n    }\n    if (shaka.util.TsParser.probe(uint8ArrayData)) {\n      const tsParser = new shaka.util.TsParser().parse(uint8ArrayData);\n      // The SourceBuffer timestampOffset may or may not be set yet, so this is\n      // the timestamp offset that would eventually compute for this segment\n      // either way.\n      const timestampOffset =\n          reference.startTime - (tsParser.getStartTime()[contentType] || 0);\n      const metadata = tsParser.getMetadata();\n      if (metadata.length) {\n        this.onMetadata_(metadata, timestampOffset,\n            reference ? reference.endTime : null);\n      }\n    } else {\n      if (shaka.media.MediaSourceEngine.RAW_FORMATS.includes(mimeType)) {\n        const frames = shaka.util.Id3Utils.getID3Frames(uint8ArrayData);\n        if (frames.length && reference) {\n          /** @private {shaka.extern.ID3Metadata} */\n          const metadata = {\n            cueTime: reference.startTime,\n            data: uint8ArrayData,\n            frames: frames,\n            dts: reference.startTime,\n            pts: reference.startTime,\n          };\n          this.onMetadata_([metadata], /* offset= */ 0, reference.endTime);\n        }\n      }\n    }\n\n    if (this.transmuxers_[contentType]) {\n      // When seeked we should reset the transmuxer captionstreams\n      // so it does not ignores the captions from previous segments\n      if (seeked) {\n        this.transmuxers_[contentType].resetCaptions();\n      }\n\n      const transmuxedData =\n          await this.transmuxers_[contentType].transmux(data);\n      // For HLS CEA-608/708 CLOSED-CAPTIONS, text data is embedded in\n      // the video stream, so textEngine may not have been initialized.\n      if (!this.textEngine_) {\n        this.reinitText('text/vtt', this.sequenceMode_);\n      }\n      // This doesn't work for native TS support (ex. Edge/Chromecast),\n      // since no transmuxing is needed for native TS.\n      if (transmuxedData.captions && transmuxedData.captions.length) {\n        const videoOffset =\n        this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n        const closedCaptions = this.textEngine_\n            .convertMuxjsCaptionsToShakaCaptions(transmuxedData.captions);\n        this.textEngine_.storeAndAppendClosedCaptions(\n            closedCaptions,\n            reference ? reference.startTime : null,\n            reference ? reference.endTime : null,\n            videoOffset);\n      }\n\n      data = transmuxedData.data;\n    } else if (hasClosedCaptions && contentType == ContentType.VIDEO) {\n      if (!this.textEngine_) {\n        this.reinitText('text/vtt', this.sequenceMode_);\n      }\n      if (!this.captionParser_) {\n        this.captionParser_ = this.getCaptionParser(mimeType);\n      }\n      // If it is the init segment for closed captions, initialize the closed\n      // caption parser.\n      if (!reference) {\n        this.captionParser_.init(data);\n      } else {\n        const closedCaptions = this.captionParser_.parseFrom(data);\n        if (closedCaptions.length) {\n          const videoOffset =\n            this.sourceBuffers_[ContentType.VIDEO].timestampOffset;\n          this.textEngine_.storeAndAppendClosedCaptions(\n              closedCaptions,\n              reference.startTime,\n              reference.endTime,\n              videoOffset);\n        }\n      }\n    }\n\n    data = this.workAroundBrokenPlatforms_(\n        data, reference ? reference.startTime : null, contentType);\n\n    const sourceBuffer = this.sourceBuffers_[contentType];\n    const SEQUENCE = shaka.media.MediaSourceEngine.SourceBufferMode_.SEQUENCE;\n\n    if (this.sequenceMode_ && sourceBuffer.mode != SEQUENCE && reference) {\n      // This is the first media segment to be appended to a SourceBuffer in\n      // sequence mode.  We set the mode late so that we can trick MediaSource\n      // into extracting a timestamp for us to align text segments in sequence\n      // mode.\n\n      const duration = this.mediaSource_.duration;\n\n      // Timestamps can only be reliably extracted from video, not audio.\n      // Packed audio formats do not have internal timestamps at all.\n      // Prefer video for this when available.\n      const isBestSourceBufferForTimestamps =\n          contentType == ContentType.VIDEO ||\n          !(ContentType.VIDEO in this.sourceBuffers_);\n      if (isBestSourceBufferForTimestamps) {\n        // Append the segment in segments mode first, with offset of 0 and an\n        // open append window.\n        const originalRange =\n            [sourceBuffer.appendWindowStart, sourceBuffer.appendWindowEnd];\n        sourceBuffer.appendWindowStart = 0;\n        sourceBuffer.appendWindowEnd = Infinity;\n\n        const originalOffset = sourceBuffer.timestampOffset;\n        sourceBuffer.timestampOffset = 0;\n\n        await this.enqueueOperation_(\n            contentType, () => this.append_(contentType, data));\n        // If the input buffer passed to SourceBuffer#appendBuffer() does not\n        // contain a complete media segment, the call will exit while the\n        // SourceBuffer's append state is\n        // still PARSING_MEDIA_SEGMENT. Reset the parser state by calling\n        // abort() to safely reset timestampOffset to 'originalOffset'.\n        // https://www.w3.org/TR/media-source-2/#sourcebuffer-segment-parser-loop\n        await this.enqueueOperation_(\n            contentType, () => this.abort_(contentType));\n\n        // Reset the offset and append window.\n        sourceBuffer.timestampOffset = originalOffset;\n        sourceBuffer.appendWindowStart = originalRange[0];\n        sourceBuffer.appendWindowEnd = originalRange[1];\n\n        // Now get the timestamp of the segment and compute the offset for text\n        // segments.\n        const mediaStartTime = shaka.media.TimeRangesUtils.bufferStart(\n            this.getBuffered_(contentType));\n        const textOffset = (reference.startTime || 0) - (mediaStartTime || 0);\n        this.textSequenceModeOffset_.resolve(textOffset);\n\n        // Clear the buffer.\n        await this.enqueueOperation_(\n            contentType,\n            () => this.remove_(contentType, 0, duration));\n\n        // Finally, flush the buffer in case of choppy video start on HLS fMP4.\n        if (contentType == ContentType.VIDEO) {\n          await this.enqueueOperation_(\n              contentType,\n              () => this.flush_(contentType));\n        }\n      }\n\n      // Now switch to sequence mode and fall through to our normal operations.\n      sourceBuffer.mode = SEQUENCE;\n\n      // When we change the buffer mode the duration is lost, so we need to set\n      // it explicitly.\n      await this.setDuration(duration);\n    }\n\n    if (reference && this.sequenceMode_ && contentType != ContentType.TEXT) {\n      // In sequence mode, for non-text streams, if we just cleared the buffer\n      // and are either performing an unbuffered seek or handling an automatic\n      // adaptation, we need to set a new timestampOffset on the sourceBuffer.\n      if (seeked || adaptation) {\n        const timestampOffset = reference.startTime;\n        // The logic to call abort() before setting the timestampOffset is\n        // extended during unbuffered seeks or automatic adaptations; it is\n        // possible for the append state to be PARSING_MEDIA_SEGMENT from the\n        // previous SourceBuffer#appendBuffer() call.\n        this.enqueueOperation_(contentType, () => this.abort_(contentType));\n        this.enqueueOperation_(\n            contentType,\n            () => this.setTimestampOffset_(contentType, timestampOffset));\n      }\n    }\n\n    let bufferedBefore = null;\n\n    await this.enqueueOperation_(contentType, () => {\n      if (goog.DEBUG && reference) {\n        bufferedBefore = this.getBuffered_(contentType);\n      }\n      this.append_(contentType, data);\n    });\n\n    if (goog.DEBUG && reference) {\n      const bufferedAfter = this.getBuffered_(contentType);\n      const newBuffered = shaka.media.TimeRangesUtils.computeAddedRange(\n          bufferedBefore, bufferedAfter);\n      if (newBuffered) {\n        const segmentDuration = reference.endTime - reference.startTime;\n        // Check end times instead of start times.  We may be overwriting a\n        // buffer and only the end changes, and that would be fine.\n        // Also, exclude tiny segments.  Sometimes alignment segments as small\n        // as 33ms are seen in Google DAI content.  For such tiny segments,\n        // half a segment duration would be no issue.\n        const offset = Math.abs(newBuffered.end - reference.endTime);\n        if (segmentDuration > 0.100 && offset > segmentDuration / 2) {\n          shaka.log.error('Possible encoding problem detected!',\n              'Unexpected buffered range for reference', reference,\n              'from URIs', reference.getUris(),\n              'should be', {start: reference.startTime, end: reference.endTime},\n              'but got', newBuffered);\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the selected closed captions Id and language.\n   *\n   * @param {string} id\n   */\n  setSelectedClosedCaptionId(id) {\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n    const videoBufferEndTime = this.bufferEnd(VIDEO) || 0;\n    this.textEngine_.setSelectedClosedCaptionId(id, videoBufferEndTime);\n  }\n\n  /** Disable embedded closed captions. */\n  clearSelectedClosedCaptionId() {\n    if (this.textEngine_) {\n      this.textEngine_.setSelectedClosedCaptionId('', 0);\n    }\n  }\n\n  /**\n   * Enqueue an operation to remove data from the SourceBuffer.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @return {!Promise}\n   */\n  async remove(contentType, startTime, endTime) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      await this.textEngine_.remove(startTime, endTime);\n    } else {\n      await this.enqueueOperation_(\n          contentType,\n          () => this.remove_(contentType, startTime, endTime));\n    }\n  }\n\n  /**\n   * Enqueue an operation to clear the SourceBuffer.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!Promise}\n   */\n  async clear(contentType) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      if (!this.textEngine_) {\n        return;\n      }\n      await this.textEngine_.remove(0, Infinity);\n    } else {\n      // Note that not all platforms allow clearing to Infinity.\n      await this.enqueueOperation_(\n          contentType,\n          () => this.remove_(contentType, 0, this.mediaSource_.duration));\n    }\n  }\n\n  /**\n   * Fully reset the state of the caption parser owned by MediaSourceEngine.\n   */\n  resetCaptionParser() {\n    if (this.captionParser_) {\n      this.captionParser_.reset();\n    }\n  }\n\n  /**\n   * Enqueue an operation to flush the SourceBuffer.\n   * This is a workaround for what we believe is a Chromecast bug.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!Promise}\n   */\n  async flush(contentType) {\n    // Flush the pipeline.  Necessary on Chromecast, even though we have removed\n    // everything.\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      // Nothing to flush for text.\n      return;\n    }\n    await this.enqueueOperation_(\n        contentType,\n        () => this.flush_(contentType));\n  }\n\n  /**\n   * Sets the timestamp offset and append window end for the given content type.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset The timestamp offset.  Segments which start\n   *   at time t will be inserted at time t + timestampOffset instead.  This\n   *   value does not affect segments which have already been inserted.\n   * @param {number} appendWindowStart The timestamp to set the append window\n   *   start to.  For future appends, frames/samples with timestamps less than\n   *   this value will be dropped.\n   * @param {number} appendWindowEnd The timestamp to set the append window end\n   *   to.  For future appends, frames/samples with timestamps greater than this\n   *   value will be dropped.\n   * @param {boolean} sequenceMode  If true, the timestampOffset will not be\n   *   applied in this step.\n   * @return {!Promise}\n   */\n  async setStreamProperties(\n      contentType, timestampOffset, appendWindowStart, appendWindowEnd,\n      sequenceMode) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    if (contentType == ContentType.TEXT) {\n      if (!sequenceMode) {\n        this.textEngine_.setTimestampOffset(timestampOffset);\n      }\n      this.textEngine_.setAppendWindow(appendWindowStart, appendWindowEnd);\n      return;\n    }\n\n    await Promise.all([\n      // Queue an abort() to help MSE splice together overlapping segments.\n      // We set appendWindowEnd when we change periods in DASH content, and the\n      // period transition may result in overlap.\n      //\n      // An abort() also helps with MPEG2-TS.  When we append a TS segment, we\n      // always enter a PARSING_MEDIA_SEGMENT state and we can't change the\n      // timestamp offset.  By calling abort(), we reset the state so we can\n      // set it.\n      this.enqueueOperation_(\n          contentType,\n          () => this.abort_(contentType)),\n      // Don't set the timestampOffset here when in sequenceMode, since we\n      // use timestampOffset for a different purpose in that mode (e.g. to\n      // indicate where the current segment is).\n      sequenceMode ? Promise.resolve() : this.enqueueOperation_(\n          contentType,\n          () => this.setTimestampOffset_(contentType, timestampOffset)),\n      this.enqueueOperation_(\n          contentType,\n          () => this.setAppendWindow_(\n              contentType, appendWindowStart, appendWindowEnd)),\n    ]);\n  }\n\n  /**\n   * Adjust timestamp offset to maintain AV sync across discontinuities.\n   * Only used in sequence mode.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset\n   * @return {!Promise}\n   */\n  async resync(contentType, timestampOffset) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(this.sequenceMode_,\n        'resync only used with sequence mode!');\n\n    if (contentType == ContentType.TEXT) {\n      // This operation is for audio and video only.\n      return;\n    }\n\n    // Queue an abort() to help MSE splice together overlapping segments.\n    // We set appendWindowEnd when we change periods in DASH content, and the\n    // period transition may result in overlap.\n    //\n    // An abort() also helps with MPEG2-TS.  When we append a TS segment, we\n    // always enter a PARSING_MEDIA_SEGMENT state and we can't change the\n    // timestamp offset.  By calling abort(), we reset the state so we can\n    // set it.\n    this.enqueueOperation_(\n        contentType,\n        () => this.abort_(contentType));\n    await this.enqueueOperation_(\n        contentType,\n        () => this.setTimestampOffset_(contentType, timestampOffset));\n  }\n\n  /**\n   * @param {string=} reason Valid reasons are 'network' and 'decode'.\n   * @return {!Promise}\n   * @see http://w3c.github.io/media-source/#idl-def-EndOfStreamError\n   */\n  async endOfStream(reason) {\n    await this.enqueueBlockingOperation_(() => {\n      // If endOfStream() has already been called on the media source,\n      // don't call it again.\n      if (this.ended()) {\n        return;\n      }\n      // Tizen won't let us pass undefined, but it will let us omit the\n      // argument.\n      if (reason) {\n        this.mediaSource_.endOfStream(reason);\n      } else {\n        this.mediaSource_.endOfStream();\n      }\n    });\n  }\n\n  /**\n   * @param {number} duration\n   * @return {!Promise}\n   */\n  async setDuration(duration) {\n    await this.enqueueBlockingOperation_(() => {\n      // Reducing the duration causes the MSE removal algorithm to run, which\n      // triggers an 'updateend' event to fire.  To handle this scenario, we\n      // have to insert a dummy operation into the beginning of each queue,\n      // which the 'updateend' handler will remove.\n      if (duration < this.mediaSource_.duration) {\n        for (const contentType in this.sourceBuffers_) {\n          const dummyOperation = {\n            start: () => {},\n            p: new shaka.util.PublicPromise(),\n          };\n          this.queues_[contentType].unshift(dummyOperation);\n        }\n      }\n\n      this.mediaSource_.duration = duration;\n    });\n  }\n\n  /**\n   * Get the current MediaSource duration.\n   *\n   * @return {number}\n   */\n  getDuration() {\n    return this.mediaSource_.duration;\n  }\n\n  /**\n   * Append data to the SourceBuffer.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {BufferSource} data\n   * @private\n   */\n  append_(contentType, data) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Append only video data to the LCEVC Dil.\n    if (contentType == ContentType.VIDEO && this.lcevcDil_) {\n      // Append video buffers to the LCEVC Dil for parsing and storing\n      // of LCEVC data.\n      this.lcevcDil_.appendBuffer(data);\n    }\n\n    // This will trigger an 'updateend' event.\n    this.sourceBuffers_[contentType].appendBuffer(data);\n  }\n\n  /**\n   * Remove data from the SourceBuffer.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} startTime relative to the start of the presentation\n   * @param {number} endTime relative to the start of the presentation\n   * @private\n   */\n  remove_(contentType, startTime, endTime) {\n    if (endTime <= startTime) {\n      // Ignore removal of inverted or empty ranges.\n      // Fake 'updateend' event to resolve the operation.\n      this.onUpdateEnd_(contentType);\n      return;\n    }\n\n    // This will trigger an 'updateend' event.\n    this.sourceBuffers_[contentType].remove(startTime, endTime);\n  }\n\n  /**\n   * Call abort() on the SourceBuffer.\n   * This resets MSE's last_decode_timestamp on all track buffers, which should\n   * trigger the splicing logic for overlapping segments.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  abort_(contentType) {\n    // Save the append window, which is reset on abort().\n    const appendWindowStart =\n        this.sourceBuffers_[contentType].appendWindowStart;\n    const appendWindowEnd = this.sourceBuffers_[contentType].appendWindowEnd;\n\n    // This will not trigger an 'updateend' event, since nothing is happening.\n    // This is only to reset MSE internals, not to abort an actual operation.\n    this.sourceBuffers_[contentType].abort();\n\n    // Restore the append window.\n    this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n    this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Nudge the playhead to force the media pipeline to be flushed.\n   * This seems to be necessary on Chromecast to get new content to replace old\n   * content.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  flush_(contentType) {\n    // Never use flush_ if there's data.  It causes a hiccup in playback.\n    goog.asserts.assert(\n        this.video_.buffered.length == 0, 'MediaSourceEngine.flush_ should ' +\n        'only be used after clearing all data!');\n\n    // Seeking forces the pipeline to be flushed.\n    this.video_.currentTime -= 0.001;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Set the SourceBuffer's timestamp offset.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} timestampOffset\n   * @private\n   */\n  setTimestampOffset_(contentType, timestampOffset) {\n    // Work around for\n    // https://github.com/shaka-project/shaka-player/issues/1281:\n    // TODO(https://bit.ly/2ttKiBU): follow up when this is fixed in Edge\n    if (timestampOffset < 0) {\n      // Try to prevent rounding errors in Edge from removing the first\n      // keyframe.\n      timestampOffset += 0.001;\n    }\n\n    this.sourceBuffers_[contentType].timestampOffset = timestampOffset;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * Set the SourceBuffer's append window end.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @private\n   */\n  setAppendWindow_(contentType, appendWindowStart, appendWindowEnd) {\n    // You can't set start > end, so first set start to 0, then set the new\n    // end, then set the new start.  That way, there are no intermediate\n    // states which are invalid.\n    this.sourceBuffers_[contentType].appendWindowStart = 0;\n    this.sourceBuffers_[contentType].appendWindowEnd = appendWindowEnd;\n    this.sourceBuffers_[contentType].appendWindowStart = appendWindowStart;\n\n    // Fake an 'updateend' event to resolve the operation.\n    this.onUpdateEnd_(contentType);\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  onError_(contentType) {\n    const operation = this.queues_[contentType][0];\n    goog.asserts.assert(operation, 'Spurious error event!');\n    goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n        'SourceBuffer should not be updating on error!');\n    const code = this.video_.error ? this.video_.error.code : 0;\n    operation.p.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.MEDIA,\n        shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED,\n        code));\n    // Do not pop from queue.  An 'updateend' event will fire next, and to\n    // avoid synchronizing these two event handlers, we will allow that one to\n    // pop from the queue as normal.  Note that because the operation has\n    // already been rejected, the call to resolve() in the 'updateend' handler\n    // will have no effect.\n  }\n\n  /**\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  onUpdateEnd_(contentType) {\n    const operation = this.queues_[contentType][0];\n    goog.asserts.assert(operation, 'Spurious updateend event!');\n    if (!operation) {\n      return;\n    }\n    goog.asserts.assert(!this.sourceBuffers_[contentType].updating,\n        'SourceBuffer should not be updating on updateend!');\n    operation.p.resolve();\n    this.popFromQueue_(contentType);\n  }\n\n  /**\n   * Enqueue an operation and start it if appropriate.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @param {function()} start\n   * @return {!Promise}\n   * @private\n   */\n  enqueueOperation_(contentType, start) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const operation = {\n      start: start,\n      p: new shaka.util.PublicPromise(),\n    };\n    this.queues_[contentType].push(operation);\n\n    if (this.queues_[contentType].length == 1) {\n      this.startOperation_(contentType);\n    }\n    return operation.p;\n  }\n\n  /**\n   * Enqueue an operation which must block all other operations on all\n   * SourceBuffers.\n   *\n   * @param {function()} run\n   * @return {!Promise}\n   * @private\n   */\n  async enqueueBlockingOperation_(run) {\n    this.destroyer_.ensureNotDestroyed();\n\n    /** @type {!Array.<!shaka.util.PublicPromise>} */\n    const allWaiters = [];\n\n    // Enqueue a 'wait' operation onto each queue.\n    // This operation signals its readiness when it starts.\n    // When all wait operations are ready, the real operation takes place.\n    for (const contentType in this.sourceBuffers_) {\n      const ready = new shaka.util.PublicPromise();\n      const operation = {\n        start: () => ready.resolve(),\n        p: ready,\n      };\n\n      this.queues_[contentType].push(operation);\n      allWaiters.push(ready);\n\n      if (this.queues_[contentType].length == 1) {\n        operation.start();\n      }\n    }\n\n    // Return a Promise to the real operation, which waits to begin until\n    // there are no other in-progress operations on any SourceBuffers.\n    try {\n      await Promise.all(allWaiters);\n    } catch (error) {\n      // One of the waiters failed, which means we've been destroyed.\n      goog.asserts.assert(\n          this.destroyer_.destroyed(), 'Should be destroyed by now');\n      // We haven't popped from the queue.  Canceled waiters have been removed\n      // by destroy.  What's left now should just be resolved waiters.  In\n      // uncompiled mode, we will maintain good hygiene and make sure the\n      // assert at the end of destroy passes.  In compiled mode, the queues\n      // are wiped in destroy.\n      if (goog.DEBUG) {\n        for (const contentType in this.sourceBuffers_) {\n          if (this.queues_[contentType].length) {\n            goog.asserts.assert(\n                this.queues_[contentType].length == 1,\n                'Should be at most one item in queue!');\n            goog.asserts.assert(\n                allWaiters.includes(this.queues_[contentType][0].p),\n                'The item in queue should be one of our waiters!');\n            this.queues_[contentType].shift();\n          }\n        }\n      }\n      throw error;\n    }\n\n    if (goog.DEBUG) {\n      // If we did it correctly, nothing is updating.\n      for (const contentType in this.sourceBuffers_) {\n        goog.asserts.assert(\n            this.sourceBuffers_[contentType].updating == false,\n            'SourceBuffers should not be updating after a blocking op!');\n      }\n    }\n\n    // Run the real operation, which is synchronous.\n    try {\n      run();\n    } catch (exception) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n          exception);\n    } finally {\n      // Unblock the queues.\n      for (const contentType in this.sourceBuffers_) {\n        this.popFromQueue_(contentType);\n      }\n    }\n  }\n\n  /**\n   * Pop from the front of the queue and start a new operation.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  popFromQueue_(contentType) {\n    // Remove the in-progress operation, which is now complete.\n    this.queues_[contentType].shift();\n    this.startOperation_(contentType);\n  }\n\n  /**\n   * Starts the next operation in the queue.\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @private\n   */\n  startOperation_(contentType) {\n    // Retrieve the next operation, if any, from the queue and start it.\n    const next = this.queues_[contentType][0];\n    if (next) {\n      try {\n        next.start();\n      } catch (exception) {\n        if (exception.name == 'QuotaExceededError') {\n          next.p.reject(new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MEDIA,\n              shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR,\n              contentType));\n        } else {\n          next.p.reject(new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MEDIA,\n              shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW,\n              exception));\n        }\n        this.popFromQueue_(contentType);\n      }\n    }\n  }\n\n  /**\n   * @return {!shaka.extern.TextDisplayer}\n   */\n  getTextDisplayer() {\n    goog.asserts.assert(\n        this.textDisplayer_,\n        'TextDisplayer should only be null when this is destroyed');\n\n    return this.textDisplayer_;\n  }\n\n  /**\n   * @param {!shaka.extern.TextDisplayer} textDisplayer\n   */\n  setTextDisplayer(textDisplayer) {\n    const oldTextDisplayer = this.textDisplayer_;\n    this.textDisplayer_ = textDisplayer;\n    if (oldTextDisplayer) {\n      textDisplayer.setTextVisibility(oldTextDisplayer.isTextVisible());\n      oldTextDisplayer.destroy();\n    }\n    if (this.textEngine_) {\n      this.textEngine_.setDisplayer(textDisplayer);\n    }\n  }\n\n  /**\n   * @param {boolean} segmentRelativeVttTiming\n   */\n  setSegmentRelativeVttTiming(segmentRelativeVttTiming) {\n    this.segmentRelativeVttTiming_ = segmentRelativeVttTiming;\n  }\n\n  /**\n   * Apply platform-specific transformations to this segment to work around\n   * issues in the platform.\n   *\n   * @param {!BufferSource} segment\n   * @param {?number} startTime\n   * @param {shaka.util.ManifestParserUtils.ContentType} contentType\n   * @return {!BufferSource}\n   * @private\n   */\n  workAroundBrokenPlatforms_(segment, startTime, contentType) {\n    const isInitSegment = startTime == null;\n    const encryptionExpected = this.expectedEncryption_[contentType];\n\n    // If:\n    //   1. this is an init segment,\n    //   2. and encryption is expected,\n    //   3. and the platform requires encryption in all init segments,\n    //   4. and the content is MP4 (mimeType == \"video/mp4\" or \"audio/mp4\"),\n    // then insert fake encryption metadata for init segments that lack it.\n    // The MP4 requirement is because we can currently only do this\n    // transformation on MP4 containers.\n    // See: https://github.com/shaka-project/shaka-player/issues/2759\n    if (isInitSegment &&\n        encryptionExpected &&\n        shaka.util.Platform.requiresEncryptionInfoInAllInitSegments() &&\n        shaka.util.MimeUtils.getContainerType(\n            this.sourceBufferTypes_[contentType]) == 'mp4') {\n      shaka.log.debug('Forcing fake encryption information in init segment.');\n      segment = shaka.media.ContentWorkarounds.fakeEncryption(segment);\n    }\n\n    return segment;\n  }\n\n  /**\n   * Update LCEVC DIL object when ready for LCEVC Decodes\n   * @param {?shaka.lcevc.Dil} lcevcDil\n   */\n  updateLcevcDil(lcevcDil) {\n    this.lcevcDil_ = lcevcDil;\n  }\n};\n\n\n/**\n * Internal reference to window.URL.createObjectURL function to avoid\n * compatibility issues with other libraries and frameworks such as React\n * Native. For use in unit tests only, not meant for external use.\n *\n * @type {function(?):string}\n */\nshaka.media.MediaSourceEngine.createObjectURL = window.URL.createObjectURL;\n\n\n/**\n * @typedef {{\n *   start: function(),\n *   p: !shaka.util.PublicPromise\n * }}\n *\n * @summary An operation in queue.\n * @property {function()} start\n *   The function which starts the operation.\n * @property {!shaka.util.PublicPromise} p\n *   The PublicPromise which is associated with this operation.\n */\nshaka.media.MediaSourceEngine.Operation;\n\n\n/**\n * @enum {string}\n * @private\n */\nshaka.media.MediaSourceEngine.SourceBufferMode_ = {\n  SEQUENCE: 'sequence',\n  SEGMENTS: 'segments',\n};\n\n\n/**\n * MIME types of raw formats.\n *\n * @const {!Array.<string>}\n */\nshaka.media.MediaSourceEngine.RAW_FORMATS = [\n  'audio/aac',\n  'audio/ac3',\n  'audio/ec3',\n  'audio/mpeg',\n];\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.PresentationTimeline');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.SegmentReference');\n\n\n/**\n * PresentationTimeline.\n * @export\n */\nshaka.media.PresentationTimeline = class {\n  /**\n   * @param {?number} presentationStartTime The wall-clock time, in seconds,\n   *   when the presentation started or will start. Only required for live.\n   * @param {number} presentationDelay The delay to give the presentation, in\n   *   seconds.  Only required for live.\n   * @param {boolean=} autoCorrectDrift Whether to account for drift when\n   *   determining the availability window.\n   *\n   * @see {shaka.extern.Manifest}\n   * @see {@tutorial architecture}\n   */\n  constructor(presentationStartTime, presentationDelay,\n      autoCorrectDrift = true) {\n    /** @private {?number} */\n    this.presentationStartTime_ = presentationStartTime;\n\n    /** @private {number} */\n    this.presentationDelay_ = presentationDelay;\n\n    /** @private {number} */\n    this.duration_ = Infinity;\n\n    /** @private {number} */\n    this.segmentAvailabilityDuration_ = Infinity;\n\n    /**\n     * The maximum segment duration (in seconds).  Can be based on explicitly-\n     * known segments or on signalling in the manifest.\n     *\n     * @private {number}\n     */\n    this.maxSegmentDuration_ = 1;\n\n    /**\n     * The minimum segment start time (in seconds, in the presentation timeline)\n     * for segments we explicitly know about.\n     *\n     * This is null if we have no explicit descriptions of segments, such as in\n     * DASH when using SegmentTemplate w/ duration.\n     *\n     * @private {?number}\n     */\n    this.minSegmentStartTime_ = null;\n\n    /**\n     * The maximum segment end time (in seconds, in the presentation timeline)\n     * for segments we explicitly know about.\n     *\n     * This is null if we have no explicit descriptions of segments, such as in\n     * DASH when using SegmentTemplate w/ duration.  When this is non-null, the\n     * presentation start time is calculated from the segment end times.\n     *\n     * @private {?number}\n     */\n    this.maxSegmentEndTime_ = null;\n\n    /** @private {number} */\n    this.clockOffset_ = 0;\n\n    /** @private {boolean} */\n    this.static_ = true;\n\n    /** @private {number} */\n    this.userSeekStart_ = 0;\n\n    /** @private {boolean} */\n    this.autoCorrectDrift_ = autoCorrectDrift;\n\n    /**\n     * For low latency Dash, availabilityTimeOffset indicates a segment is\n     * available for download earlier than its availability start time.\n     * This field is the minimum availabilityTimeOffset value among the\n     * segments. We reduce the distance from live edge by this value.\n     *\n     * @private {number}\n     */\n    this.availabilityTimeOffset_ = 0;\n\n    /** @private {boolean} */\n    this.startTimeLocked_ = false;\n  }\n\n\n  /**\n   * @return {number} The presentation's duration in seconds.\n   *   Infinity indicates that the presentation continues indefinitely.\n   * @export\n   */\n  getDuration() {\n    return this.duration_;\n  }\n\n\n  /**\n   * @return {number} The presentation's max segment duration in seconds.\n   * @export\n   */\n  getMaxSegmentDuration() {\n    return this.maxSegmentDuration_;\n  }\n\n\n  /**\n   * Sets the presentation's start time.\n   *\n   * @param {number} presentationStartTime The wall-clock time, in seconds,\n   *   when the presentation started or will start. Only required for live.\n   * @export\n   */\n  setPresentationStartTime(presentationStartTime) {\n    goog.asserts.assert(presentationStartTime >= 0,\n        'presentationStartTime must be >= 0');\n    this.presentationStartTime_ = presentationStartTime;\n  }\n\n\n  /**\n   * Sets the presentation's duration.\n   *\n   * @param {number} duration The presentation's duration in seconds.\n   *   Infinity indicates that the presentation continues indefinitely.\n   * @export\n   */\n  setDuration(duration) {\n    goog.asserts.assert(duration > 0, 'duration must be > 0');\n    this.duration_ = duration;\n  }\n\n\n  /**\n   * @return {?number} The presentation's start time in seconds.\n   * @export\n   */\n  getPresentationStartTime() {\n    return this.presentationStartTime_;\n  }\n\n\n  /**\n   * Sets the clock offset, which is the difference between the client's clock\n   * and the server's clock, in milliseconds (i.e., serverTime = Date.now() +\n   * clockOffset).\n   *\n   * @param {number} offset The clock offset, in ms.\n   * @export\n   */\n  setClockOffset(offset) {\n    this.clockOffset_ = offset;\n  }\n\n\n  /**\n   * Sets the presentation's static flag.\n   *\n   * @param {boolean} isStatic If true, the presentation is static, meaning all\n   *   segments are available at once.\n   * @export\n   */\n  setStatic(isStatic) {\n    // NOTE: the argument name is not \"static\" because that's a keyword in ES6\n    this.static_ = isStatic;\n  }\n\n\n  /**\n   * Sets the presentation's segment availability duration. The segment\n   * availability duration should only be set for live.\n   *\n   * @param {number} segmentAvailabilityDuration The presentation's new segment\n   *   availability duration in seconds.\n   * @export\n   */\n  setSegmentAvailabilityDuration(segmentAvailabilityDuration) {\n    goog.asserts.assert(segmentAvailabilityDuration >= 0,\n        'segmentAvailabilityDuration must be >= 0');\n    this.segmentAvailabilityDuration_ = segmentAvailabilityDuration;\n  }\n\n\n  /**\n   * Sets the presentation delay in seconds.\n   *\n   * @param {number} delay\n   * @export\n   */\n  setDelay(delay) {\n    // NOTE: This is no longer used internally, but is exported.\n    // So we cannot remove it without deprecating it and waiting one release\n    // cycle, or else we risk breaking custom manifest parsers.\n    goog.asserts.assert(delay >= 0, 'delay must be >= 0');\n    this.presentationDelay_ = delay;\n  }\n\n\n  /**\n   * Gets the presentation delay in seconds.\n   * @return {number}\n   * @export\n   */\n  getDelay() {\n    return this.presentationDelay_;\n  }\n\n\n  /**\n   * Gives PresentationTimeline an array of segments so it can size and position\n   * the segment availability window, and account for missing segment\n   * information.  These segments do not necessarily need to all be from the\n   * same stream.\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references\n   * @export\n   */\n  notifySegments(references) {\n    if (references.length == 0) {\n      return;\n    }\n\n    let firstReferenceStartTime = references[0].startTime;\n    let lastReferenceEndTime = references[0].endTime;\n    for (const reference of references) {\n      firstReferenceStartTime = Math.min(\n          firstReferenceStartTime, reference.startTime);\n      lastReferenceEndTime = Math.max(lastReferenceEndTime, reference.endTime);\n      this.maxSegmentDuration_ = Math.max(\n          this.maxSegmentDuration_, reference.endTime - reference.startTime);\n    }\n    this.notifyMinSegmentStartTime(firstReferenceStartTime);\n    this.maxSegmentEndTime_ =\n        Math.max(this.maxSegmentEndTime_, lastReferenceEndTime);\n\n    if (this.presentationStartTime_ != null && this.autoCorrectDrift_ &&\n        !this.startTimeLocked_) {\n      // Since we have explicit segment end times, calculate a presentation\n      // start based on them.  This start time accounts for drift.\n      // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n      const now = (Date.now() + this.clockOffset_) / 1000.0;\n      this.presentationStartTime_ =\n          now - this.maxSegmentEndTime_ - this.maxSegmentDuration_;\n    }\n\n    shaka.log.v1('notifySegments:',\n        'maxSegmentDuration=' + this.maxSegmentDuration_);\n  }\n\n\n  /**\n   * Lock the presentation timeline's start time.  After this is called, no\n   * further adjustments to presentationStartTime_ will be permitted.\n   *\n   * This should be called after all Periods have been parsed, and all calls to\n   * notifySegments() from the initial manifest parse have been made.\n   *\n   * Without this, we can get assertion failures in SegmentIndex for certain\n   * DAI content.  If DAI adds ad segments to the manifest faster than\n   * real-time, adjustments to presentationStartTime_ can cause availability\n   * windows to jump around on updates.\n   *\n   * @export\n   */\n  lockStartTime() {\n    this.startTimeLocked_ = true;\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's minimum segment start time.\n   *\n   * @param {number} startTime\n   * @export\n   */\n  notifyMinSegmentStartTime(startTime) {\n    if (this.minSegmentStartTime_ == null) {\n      // No data yet, and Math.min(null, startTime) is always 0.  So just store\n      // startTime.\n      this.minSegmentStartTime_ = startTime;\n    } else {\n      this.minSegmentStartTime_ =\n          Math.min(this.minSegmentStartTime_, startTime);\n    }\n  }\n\n\n  /**\n   * Gives PresentationTimeline a Stream's maximum segment duration so it can\n   * size and position the segment availability window.  This function should be\n   * called once for each Stream (no more, no less), but does not have to be\n   * called if notifySegments() is called instead for a particular stream.\n   *\n   * @param {number} maxSegmentDuration The maximum segment duration for a\n   *   particular stream.\n   * @export\n   */\n  notifyMaxSegmentDuration(maxSegmentDuration) {\n    this.maxSegmentDuration_ = Math.max(\n        this.maxSegmentDuration_, maxSegmentDuration);\n\n    shaka.log.v1('notifyNewSegmentDuration:',\n        'maxSegmentDuration=' + this.maxSegmentDuration_);\n  }\n\n\n  /**\n   * Offsets the segment times by the given amount.\n   *\n   * @param {number} offset The number of seconds to offset by.  A positive\n   *   number adjusts the segment times forward.\n   * @export\n   */\n  offset(offset) {\n    if (this.minSegmentStartTime_ != null) {\n      this.minSegmentStartTime_ += offset;\n    }\n    if (this.maxSegmentEndTime_ != null) {\n      this.maxSegmentEndTime_ += offset;\n    }\n  }\n\n\n  /**\n   * @return {boolean} True if the presentation is live; otherwise, return\n   *   false.\n   * @export\n   */\n  isLive() {\n    return this.duration_ == Infinity &&\n           !this.static_;\n  }\n\n\n  /**\n   * @return {boolean} True if the presentation is in progress (meaning not\n   *   live, but also not completely available); otherwise, return false.\n   * @export\n   */\n  isInProgress() {\n    return this.duration_ != Infinity &&\n           !this.static_;\n  }\n\n\n  /**\n   * Gets the presentation's current segment availability start time.  Segments\n   * ending at or before this time should be assumed to be unavailable.\n   *\n   * @return {number} The current segment availability start time, in seconds,\n   *   relative to the start of the presentation.\n   * @export\n   */\n  getSegmentAvailabilityStart() {\n    goog.asserts.assert(this.segmentAvailabilityDuration_ >= 0,\n        'The availability duration should be positive');\n\n    const end = this.getSegmentAvailabilityEnd();\n    const start = end - this.segmentAvailabilityDuration_;\n    return Math.max(this.userSeekStart_, start);\n  }\n\n\n  /**\n   * Sets the start time of the user-defined seek range.  This is only used for\n   * VOD content.\n   *\n   * @param {number} time\n   * @export\n   */\n  setUserSeekStart(time) {\n    this.userSeekStart_ = time;\n  }\n\n\n  /**\n   * Gets the presentation's current segment availability end time.  Segments\n   * starting after this time should be assumed to be unavailable.\n   *\n   * @return {number} The current segment availability end time, in seconds,\n   *   relative to the start of the presentation.  For VOD, the availability\n   *   end time is the content's duration.  If the Player's playRangeEnd\n   *   configuration is used, this can override the duration.\n   * @export\n   */\n  getSegmentAvailabilityEnd() {\n    if (!this.isLive() && !this.isInProgress()) {\n      // It's a static manifest (can also be a dynamic->static conversion)\n      if (this.maxSegmentEndTime_) {\n        // If we know segment times, use the min of that and duration.\n        // Note that the playRangeEnd configuration changes this.duration_.\n        // See https://github.com/shaka-project/shaka-player/issues/4026\n        return Math.min(this.maxSegmentEndTime_, this.duration_);\n      } else {\n        // If we don't have segment times, use duration.\n        return this.duration_;\n      }\n    }\n    // Can be either live or \"in-progress recording\" (live with known duration)\n    return Math.min(this.getLiveEdge_() + this.availabilityTimeOffset_,\n        this.duration_);\n  }\n\n\n  /**\n   * Gets the seek range start time, offset by the given amount.  This is used\n   * to ensure that we don't \"fall\" back out of the seek window while we are\n   * buffering.\n   *\n   * @param {number} offset The offset to add to the start time for live\n   *   streams.\n   * @return {number} The current seek start time, in seconds, relative to the\n   *   start of the presentation.\n   * @export\n   */\n  getSafeSeekRangeStart(offset) {\n    // The earliest known segment time, ignoring segment availability duration.\n    const earliestSegmentTime =\n        Math.max(this.minSegmentStartTime_, this.userSeekStart_);\n\n    // For VOD, the offset and end time are ignored, and we just return the\n    // earliest segment time.  All segments are \"safe\" in VOD.  However, we\n    // should round up to the nearest millisecond to avoid issues like\n    // https://github.com/shaka-project/shaka-player/issues/2831, in which we\n    // tried to seek repeatedly to catch up to the seek range, and never\n    // actually \"arrived\" within it.  The video's currentTime is not as\n    // accurate as the JS number representing the earliest segment time for\n    // some content.\n    if (this.segmentAvailabilityDuration_ == Infinity) {\n      return Math.ceil(earliestSegmentTime * 1e3) / 1e3;\n    }\n\n    // AKA the live edge for live streams.\n    const availabilityEnd = this.getSegmentAvailabilityEnd();\n\n    // The ideal availability start, not considering known segments.\n    const availabilityStart =\n        availabilityEnd - this.segmentAvailabilityDuration_;\n\n    // Add the offset to the availability start to ensure that we don't fall\n    // outside the availability window while we buffer; we don't need to add the\n    // offset to earliestSegmentTime since that won't change over time.\n    // Also see: https://github.com/shaka-project/shaka-player/issues/692\n    const desiredStart =\n        Math.min(availabilityStart + offset, this.getSeekRangeEnd());\n    return Math.max(earliestSegmentTime, desiredStart);\n  }\n\n\n  /**\n   * Gets the seek range start time.\n   *\n   * @return {number}\n   * @export\n   */\n  getSeekRangeStart() {\n    return this.getSafeSeekRangeStart(/* offset= */ 0);\n  }\n\n\n  /**\n   * Gets the seek range end.\n   *\n   * @return {number}\n   * @export\n   */\n  getSeekRangeEnd() {\n    const useDelay = this.isLive() || this.isInProgress();\n    const delay = useDelay ? this.presentationDelay_ : 0;\n    return Math.max(0, this.getSegmentAvailabilityEnd() - delay);\n  }\n\n\n  /**\n   * True if the presentation start time is being used to calculate the live\n   * edge.\n   * Using the presentation start time means that the stream may be subject to\n   * encoder drift.  At runtime, we will avoid using the presentation start time\n   * whenever possible.\n   *\n   * @return {boolean}\n   * @export\n   */\n  usingPresentationStartTime() {\n    // If it's VOD, IPR, or an HLS \"event\", we are not using the presentation\n    // start time.\n    if (this.presentationStartTime_ == null) {\n      return false;\n    }\n\n    // If we have explicit segment times, we're not using the presentation\n    // start time.\n    if (this.maxSegmentEndTime_ != null && this.autoCorrectDrift_) {\n      return false;\n    }\n\n    return true;\n  }\n\n\n  /**\n   * @return {number} The current presentation time in seconds.\n   * @private\n   */\n  getLiveEdge_() {\n    goog.asserts.assert(this.presentationStartTime_ != null,\n        'Cannot compute timeline live edge without start time');\n    // Date.now() is in milliseconds, from which we compute \"now\" in seconds.\n    const now = (Date.now() + this.clockOffset_) / 1000.0;\n    return Math.max(\n        0, now - this.maxSegmentDuration_ - this.presentationStartTime_);\n  }\n\n  /**\n   * Sets the presentation's segment availability time offset. This should be\n   * only set for Low Latency Dash.\n   * The segments are available earlier for download than the availability start\n   * time, so we can move closer to the live edge.\n   *\n   * @param {number} offset\n   * @export\n   */\n  setAvailabilityTimeOffset(offset) {\n    this.availabilityTimeOffset_ = offset;\n  }\n\n  /**\n   * Debug only: assert that the timeline parameters make sense for the type\n   * of presentation (VOD, IPR, live).\n   */\n  assertIsValid() {\n    if (goog.DEBUG) {\n      if (this.isLive()) {\n        // Implied by isLive(): infinite and dynamic.\n        // Live streams should have a start time.\n        goog.asserts.assert(this.presentationStartTime_ != null,\n            'Detected as live stream, but does not match our model of live!');\n      } else if (this.isInProgress()) {\n        // Implied by isInProgress(): finite and dynamic.\n        // IPR streams should have a start time, and segments should not expire.\n        goog.asserts.assert(this.presentationStartTime_ != null &&\n                            this.segmentAvailabilityDuration_ == Infinity,\n        'Detected as IPR stream, but does not match our model of IPR!');\n      } else {  // VOD\n        // VOD segments should not expire and the presentation should be finite\n        // and static.\n        goog.asserts.assert(this.segmentAvailabilityDuration_ == Infinity &&\n                            this.duration_ != Infinity &&\n                            this.static_,\n        'Detected as VOD stream, but does not match our model of VOD!');\n      }\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.StallDetector');\ngoog.provide('shaka.media.StallDetector.Implementation');\ngoog.provide('shaka.media.StallDetector.MediaElementImplementation');\n\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Detect when we get stuck so that the\n * player can respond.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.StallDetector = class {\n  /**\n   * @param {shaka.media.StallDetector.Implementation} implementation\n   * @param {number} stallThresholdSeconds\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   */\n  constructor(implementation, stallThresholdSeconds, onEvent) {\n    /** @private {?function(!Event)} */\n    this.onEvent_ = onEvent;\n    /** @private {shaka.media.StallDetector.Implementation} */\n    this.implementation_ = implementation;\n    /** @private {boolean} */\n    this.wasMakingProgress_ = implementation.shouldBeMakingProgress();\n    /** @private {number} */\n    this.value_ = implementation.getPresentationSeconds();\n    /** @private {number} */\n    this.lastUpdateSeconds_ = implementation.getWallSeconds();\n    /** @private {boolean} */\n    this.didJump_ = false;\n    /** @private {number} */\n    this.stallsDetected_ = 0;\n\n    /**\n     * The amount of time in seconds that we must have the same value of\n     * |value_| before we declare it as a stall.\n     *\n     * @private {number}\n     */\n    this.stallThresholdSeconds_ = stallThresholdSeconds;\n\n    /** @private {function(number, number)} */\n    this.onStall_ = () => {};\n  }\n\n  /** @override */\n  release() {\n    // Drop external references to make things easier on the GC.\n    this.implementation_ = null;\n    this.onEvent_ = null;\n    this.onStall_ = () => {};\n  }\n\n  /**\n   * Set the callback that should be called when a stall is detected. Calling\n   * this will override any previous calls to |onStall|.\n   *\n   * @param {function(number, number)} doThis\n   */\n  onStall(doThis) {\n    this.onStall_ = doThis;\n  }\n\n  /**\n   * Returns the number of playback stalls detected.\n   */\n  getStallsDetected() {\n    return this.stallsDetected_;\n  }\n\n  /**\n   * Have the detector update itself and fire the \"on stall\" callback if a stall\n   * was detected.\n   *\n   * @return {boolean} True if action was taken.\n   */\n  poll() {\n    const impl = this.implementation_;\n\n    const shouldBeMakingProgress = impl.shouldBeMakingProgress();\n    const value = impl.getPresentationSeconds();\n    const wallTimeSeconds = impl.getWallSeconds();\n\n    const acceptUpdate = this.value_ != value ||\n                         this.wasMakingProgress_ != shouldBeMakingProgress;\n\n    if (acceptUpdate) {\n      this.lastUpdateSeconds_ = wallTimeSeconds;\n      this.value_ = value;\n      this.wasMakingProgress_ = shouldBeMakingProgress;\n      this.didJump_ = false;\n    }\n\n    const stallSeconds = wallTimeSeconds - this.lastUpdateSeconds_;\n\n    const triggerCallback = stallSeconds >= this.stallThresholdSeconds_ &&\n                            shouldBeMakingProgress && !this.didJump_;\n\n    if (triggerCallback) {\n      this.onStall_(this.value_, stallSeconds);\n      this.didJump_ = true;\n      // If the onStall_ method updated the current time, update our stored\n      // value so we don't think that was an update.\n      this.value_ = impl.getPresentationSeconds();\n      this.stallsDetected_++;\n      this.onEvent_(new shaka.util.FakeEvent(\n          shaka.util.FakeEvent.EventName.StallDetected));\n    }\n\n    return triggerCallback;\n  }\n};\n\n/**\n * @interface\n */\nshaka.media.StallDetector.Implementation = class {\n  /**\n   * Check if the presentation time should be changing. This will return |true|\n   * when we expect the presentation time to change.\n   *\n   * @return {boolean}\n   */\n  shouldBeMakingProgress() {}\n\n  /**\n   * Get the presentation time in seconds.\n   *\n   * @return {number}\n   */\n  getPresentationSeconds() {}\n\n  /**\n   * Get the time wall time in seconds.\n   *\n   * @return {number}\n   */\n  getWallSeconds() {}\n};\n\n\n/**\n * Some platforms/browsers can get stuck in the middle of a buffered range (e.g.\n * when seeking in a background tab). Force a seek to help get it going again.\n *\n * @implements {shaka.media.StallDetector.Implementation}\n * @final\n */\nshaka.media.StallDetector.MediaElementImplementation = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {!HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n  }\n\n  /** @override */\n  shouldBeMakingProgress() {\n    // If we are not trying to play, the lack of change could be misidentified\n    // as a stall.\n    if (this.mediaElement_.paused) {\n      return false;\n    }\n    if (this.mediaElement_.playbackRate == 0) {\n      return false;\n    }\n\n    // If we have don't have enough content, we are not stalled, we are\n    // buffering.\n    if (this.mediaElement_.buffered.length == 0) {\n      return false;\n    }\n\n    return shaka.media.StallDetector.MediaElementImplementation.hasContentFor_(\n        this.mediaElement_.buffered,\n        /* timeInSeconds= */ this.mediaElement_.currentTime);\n  }\n\n  /** @override */\n  getPresentationSeconds() {\n    return this.mediaElement_.currentTime;\n  }\n\n  /** @override */\n  getWallSeconds() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * Check if we have buffered enough content to play at |timeInSeconds|. Ignore\n   * the end of the buffered range since it may not play any more on all\n   * platforms.\n   *\n   * @param {!TimeRanges} buffered\n   * @param {number} timeInSeconds\n   * @return {boolean}\n   * @private\n   */\n  static hasContentFor_(buffered, timeInSeconds) {\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    for (const {start, end} of TimeRangesUtils.getBufferedInfo(buffered)) {\n      // Can be as much as 100ms before the range\n      if (timeInSeconds < start - 0.1) {\n        continue;\n      }\n      // Must be at least 500ms inside the range\n      if (timeInSeconds > end - 0.5) {\n        continue;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.GapJumpingController');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * GapJumpingController handles jumping gaps that appear within the content.\n * This will only jump gaps between two buffered ranges, so we should not have\n * to worry about the availability window.\n *\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.GapJumpingController = class {\n  /**\n   * @param {!HTMLMediaElement} video\n   * @param {!shaka.media.PresentationTimeline} timeline\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {shaka.media.StallDetector} stallDetector\n   *   The stall detector is used to keep the playhead moving while in a\n   *   playable region. The gap jumping controller takes ownership over the\n   *   stall detector.\n   *   If no stall detection logic is desired, |null| may be provided.\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   */\n  constructor(video, timeline, config, stallDetector, onEvent) {\n    /** @private {?function(!Event)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {?shaka.media.PresentationTimeline} */\n    this.timeline_ = timeline;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {boolean} */\n    this.seekingEventReceived_ = false;\n\n    /** @private {number} */\n    this.prevReadyState_ = video.readyState;\n\n    /** @private {number} */\n    this.gapsJumped_ = 0;\n\n    /**\n     * The stall detector tries to keep the playhead moving forward. It is\n     * managed by the gap-jumping controller to avoid conflicts. On some\n     * platforms, the stall detector is not wanted, so it may be null.\n     *\n     * @private {shaka.media.StallDetector}\n     */\n    this.stallDetector_ = stallDetector;\n\n    /** @private {boolean} */\n    this.hadSegmentAppended_ = false;\n\n    this.eventManager_.listen(video, 'waiting', () => this.onPollGapJump_());\n\n    /**\n     * We can't trust |readyState| or 'waiting' events on all platforms. To make\n     * up for this, we poll the current time. If we think we are in a gap, jump\n     * out of it.\n     *\n     * See: https://bit.ly/2McuXxm and https://bit.ly/2K5xmJO\n     *\n     * @private {?shaka.util.Timer}\n     */\n    this.gapJumpTimer_ = new shaka.util.Timer(() => {\n      this.onPollGapJump_();\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.gapJumpTimer_ != null) {\n      this.gapJumpTimer_.stop();\n      this.gapJumpTimer_ = null;\n    }\n\n    if (this.stallDetector_) {\n      this.stallDetector_.release();\n      this.stallDetector_ = null;\n    }\n\n    this.onEvent_ = null;\n    this.timeline_ = null;\n    this.video_ = null;\n  }\n\n\n  /**\n   * Called when a segment is appended by StreamingEngine, but not when a clear\n   * is pending. This means StreamingEngine will continue buffering forward from\n   * what is buffered.  So we know about any gaps before the start.\n   */\n  onSegmentAppended() {\n    this.hadSegmentAppended_ = true;\n    this.onPollGapJump_();\n  }\n\n\n  /** Called when a seek has started. */\n  onSeeking() {\n    this.seekingEventReceived_ = true;\n    this.hadSegmentAppended_ = false;\n  }\n\n\n  /**\n   * Returns the total number of playback gaps jumped.\n   * @return {number}\n   */\n  getGapsJumped() {\n    return this.gapsJumped_;\n  }\n\n\n  /**\n   * Called on a recurring timer to check for gaps in the media.  This is also\n   * called in a 'waiting' event.\n   *\n   * @private\n   */\n  onPollGapJump_() {\n    // Don't gap jump before the video is ready to play.\n    if (this.video_.readyState == 0) {\n      return;\n    }\n    // Do not gap jump if seeking has begun, but the seeking event has not\n    // yet fired for this particular seek.\n    if (this.video_.seeking) {\n      if (!this.seekingEventReceived_) {\n        return;\n      }\n    } else {\n      this.seekingEventReceived_ = false;\n    }\n    // Don't gap jump while paused, so that you don't constantly jump ahead\n    // while paused on a livestream.  We make an exception for time 0, since we\n    // may be _required_ to seek on startup before play can begin, but only if\n    // autoplay is enabled.\n    if (this.video_.paused && (this.video_.currentTime != 0 ||\n      (!this.video_.autoplay && this.video_.currentTime == 0))) {\n      return;\n    }\n\n\n    // When the ready state changes, we have moved on, so we should fire the\n    // large gap event if we see one.\n    if (this.video_.readyState != this.prevReadyState_) {\n      this.prevReadyState_ = this.video_.readyState;\n    }\n\n    if (this.stallDetector_ && this.stallDetector_.poll()) {\n      // Some action was taken by StallDetector, so don't do anything yet.\n      return;\n    }\n\n\n    const currentTime = this.video_.currentTime;\n    const buffered = this.video_.buffered;\n    const gapDetectionThreshold = this.config_.gapDetectionThreshold;\n\n    const gapIndex = shaka.media.TimeRangesUtils.getGapIndex(\n        buffered, currentTime, gapDetectionThreshold);\n\n    // The current time is unbuffered or is too far from a gap.\n    if (gapIndex == null) {\n      return;\n    }\n\n    // If we are before the first buffered range, this could be an unbuffered\n    // seek.  So wait until a segment is appended so we are sure it is a gap.\n    if (gapIndex == 0 && !this.hadSegmentAppended_) {\n      return;\n    }\n\n    // StreamingEngine can buffer past the seek end, but still don't allow\n    // seeking past it.\n    const jumpTo = buffered.start(gapIndex);\n    const seekEnd = this.timeline_.getSeekRangeEnd();\n    if (jumpTo >= seekEnd) {\n      return;\n    }\n\n    const jumpSize = jumpTo - currentTime;\n\n    // If we jump to exactly the gap start, we may detect a small gap due to\n    // rounding errors or browser bugs.  We can ignore these extremely small\n    // gaps since the browser should play through them for us.\n    if (jumpSize < shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE) {\n      return;\n    }\n\n    if (gapIndex == 0) {\n      shaka.log.info(\n          'Jumping forward', jumpSize,\n          'seconds because of gap before start time of', jumpTo);\n    } else {\n      shaka.log.info(\n          'Jumping forward', jumpSize, 'seconds because of gap starting at',\n          buffered.end(gapIndex - 1), 'and ending at', jumpTo);\n    }\n\n    this.video_.currentTime = jumpTo;\n    this.gapsJumped_++;\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.util.FakeEvent.EventName.GapJumped));\n  }\n};\n\n\n/**\n * The limit, in seconds, for the gap size that we will assume the browser will\n * handle for us.\n * @const\n */\nshaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE = 0.001;\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.MediaReadyState');\n\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Lazy');\n\n\nshaka.util.MediaReadyState = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {number} readyState\n   * @param {shaka.util.EventManager} eventManager\n   * @param {function()} callback\n   */\n  static waitForReadyState(mediaElement, readyState, eventManager, callback) {\n    if (readyState == HTMLMediaElement.HAVE_NOTHING ||\n      mediaElement.readyState >= readyState) {\n      callback();\n    } else {\n      const MediaReadyState = shaka.util.MediaReadyState;\n      const eventName =\n          MediaReadyState.READY_STATES_TO_EVENT_NAMES_.value().get(readyState);\n      eventManager.listenOnce(mediaElement, eventName, callback);\n    }\n  }\n};\n\n/**\n * @const {!shaka.util.Lazy.<!Map.<number, string>>}\n * @private\n */\nshaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_ =\n    new shaka.util.Lazy(() => new Map([\n      [HTMLMediaElement.HAVE_METADATA, 'loadedmetadata'],\n      [HTMLMediaElement.HAVE_CURRENT_DATA, 'loadeddata'],\n      [HTMLMediaElement.HAVE_FUTURE_DATA, 'canplay'],\n      [HTMLMediaElement.HAVE_ENOUGH_DATA, 'canplaythrough'],\n    ]));\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.VideoWrapper');\ngoog.provide('shaka.media.VideoWrapper.PlayheadMover');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * Creates a new VideoWrapper that manages setting current time and playback\n * rate.  This handles seeks before content is loaded and ensuring the video\n * time is set properly.  This doesn't handle repositioning within the\n * presentation window.\n *\n * @implements {shaka.util.IReleasable}\n */\nshaka.media.VideoWrapper = class {\n  /**\n   * @param {!HTMLMediaElement} video\n   * @param {function()} onSeek Called when the video seeks.\n   * @param {number} startTime The time to start at.\n   */\n  constructor(video, onSeek, startTime) {\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {number} */\n    this.startTime_ = startTime;\n\n    /** @private {boolean} */\n    this.started_ = false;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {shaka.media.VideoWrapper.PlayheadMover} */\n    this.mover_ = new shaka.media.VideoWrapper.PlayheadMover(\n        /* mediaElement= */ video,\n        /* maxAttempts= */ 10);\n\n    // Before we can set the start time, we must check if the video element is\n    // ready. If the video element is not ready, we cannot set the time. To work\n    // around this, we will wait for the \"loadedmetadata\" event which tells us\n    // that the media element is now ready.\n    shaka.util.MediaReadyState.waitForReadyState(this.video_,\n        HTMLMediaElement.HAVE_METADATA,\n        this.eventManager_,\n        () => {\n          this.setStartTime_(this.startTime_);\n        });\n  }\n\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.mover_ != null) {\n      this.mover_.release();\n      this.mover_ = null;\n    }\n\n    this.onSeek_ = () => {};\n    this.video_ = null;\n  }\n\n\n  /**\n   * Gets the video's current (logical) position.\n   *\n   * @return {number}\n   */\n  getTime() {\n    return this.started_ ? this.video_.currentTime : this.startTime_;\n  }\n\n\n  /**\n   * Sets the current time of the video.\n   *\n   * @param {number} time\n   */\n  setTime(time) {\n    if (this.video_.readyState > 0) {\n      this.mover_.moveTo(time);\n    } else {\n      shaka.util.MediaReadyState.waitForReadyState(this.video_,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_,\n          () => {\n            this.setStartTime_(this.startTime_);\n          });\n    }\n  }\n\n\n  /**\n   * Set the start time for the content. The given start time will be ignored if\n   * the content does not start at 0.\n   *\n   * @param {number} startTime\n   * @private\n   */\n  setStartTime_(startTime) {\n    // If we start close enough to our intended start time, then we won't do\n    // anything special.\n    if (Math.abs(this.video_.currentTime - startTime) < 0.001) {\n      this.startListeningToSeeks_();\n      return;\n    }\n\n    // We will need to delay adding our normal seeking listener until we have\n    // seen the first seek event. We will force the first seek event later in\n    // this method.\n    this.eventManager_.listenOnce(this.video_, 'seeking', () => {\n      this.startListeningToSeeks_();\n    });\n\n    // If the currentTime != 0, it indicates that the user has seeked after\n    // calling |Player.load|, meaning that |currentTime| is more meaningful than\n    // |startTime|.\n    //\n    // Seeking to the current time is a work around for Issue 1298. If we don't\n    // do this, the video may get stuck and not play.\n    //\n    // TODO: Need further investigation why it happens. Before and after\n    // setting the current time, video.readyState is 1, video.paused is true,\n    // and video.buffered's TimeRanges length is 0.\n    // See: https://github.com/shaka-project/shaka-player/issues/1298\n    this.mover_.moveTo(\n        this.video_.currentTime == 0 ?\n        startTime :\n        this.video_.currentTime);\n  }\n\n\n  /**\n   * Add the listener for seek-events. This will call the externally-provided\n   * |onSeek| callback whenever the media element seeks.\n   *\n   * @private\n   */\n  startListeningToSeeks_() {\n    goog.asserts.assert(\n        this.video_.readyState > 0,\n        'The media element should be ready before we listen for seeking.');\n\n    // Now that any startup seeking is complete, we can trust the video element\n    // for currentTime.\n    this.started_ = true;\n\n    this.eventManager_.listen(this.video_, 'seeking', () => this.onSeek_());\n  }\n};\n\n/**\n * A class used to move the playhead away from its current time.  Sometimes,\n * Edge ignores re-seeks. After changing the current time, check every 100ms,\n * retrying if the change was not accepted.\n *\n * Delay stats over 100 runs of a re-seeking integration test:\n *   Edge   -   0ms -   2%\n *   Edge   - 100ms -  40%\n *   Edge   - 200ms -  32%\n *   Edge   - 300ms -  24%\n *   Edge   - 400ms -   2%\n *   Chrome -   0ms - 100%\n *\n * TODO: File a bug on Edge about this.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.VideoWrapper.PlayheadMover = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   *    The media element that the mover can manipulate.\n   *\n   * @param {number} maxAttempts\n   *    To prevent us from infinitely trying to change the current time, the\n   *    mover accepts a max attempts value. At most, the mover will check if the\n   *    video moved |maxAttempts| times. If this is zero of negative, no\n   *    attempts will be made.\n   */\n  constructor(mediaElement, maxAttempts) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {number} */\n    this.maxAttempts_ = maxAttempts;\n\n    /** @private {number} */\n    this.remainingAttempts_ = 0;\n\n    /** @private {number} */\n    this.originTime_ = 0;\n\n    /** @private {number} */\n    this.targetTime_ = 0;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => this.onTick_());\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /**\n   * Try forcing the media element to move to |timeInSeconds|. If a previous\n   * call to |moveTo| is still in progress, this will override it.\n   *\n   * @param {number} timeInSeconds\n   */\n  moveTo(timeInSeconds) {\n    this.originTime_ = this.mediaElement_.currentTime;\n    this.targetTime_ = timeInSeconds;\n\n    this.remainingAttempts_ = this.maxAttempts_;\n\n    // Set the time and then start the timer. The timer will check if the set\n    // was successful, and retry if not.\n    this.mediaElement_.currentTime = timeInSeconds;\n    this.timer_.tickEvery(/* seconds= */ 0.1);\n  }\n\n  /**\n   * @private\n   */\n  onTick_() {\n    // Sigh... We ran out of retries...\n    if (this.remainingAttempts_ <= 0) {\n      shaka.log.warning([\n        'Failed to move playhead from', this.originTime_,\n        'to', this.targetTime_,\n      ].join(' '));\n\n      this.timer_.stop();\n      return;\n    }\n\n    // Yay! We were successful.\n    if (this.mediaElement_.currentTime != this.originTime_) {\n      this.timer_.stop();\n      return;\n    }\n\n    // Sigh... Try again...\n    this.mediaElement_.currentTime = this.targetTime_;\n    this.remainingAttempts_--;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MediaSourcePlayhead');\ngoog.provide('shaka.media.Playhead');\ngoog.provide('shaka.media.SrcEqualsPlayhead');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.GapJumpingController');\ngoog.require('shaka.media.StallDetector');\ngoog.require('shaka.media.StallDetector.MediaElementImplementation');\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.media.VideoWrapper');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.Timer');\ngoog.requireType('shaka.media.PresentationTimeline');\n\n\n/**\n * Creates a Playhead, which manages the video's current time.\n *\n * The Playhead provides mechanisms for setting the presentation's start time,\n * restricting seeking to valid time ranges, and stopping playback for startup\n * and re-buffering.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.Playhead = class {\n  /**\n   * Called when the Player is ready to begin playback. Anything that depends\n   * on setStartTime() should be done here, not in the constructor.\n   *\n   * @see https://github.com/shaka-project/shaka-player/issues/4244\n   */\n  ready() {}\n\n  /**\n   * Set the start time. If the content has already started playback, this will\n   * be ignored.\n   *\n   * @param {number} startTime\n   */\n  setStartTime(startTime) {}\n\n  /**\n   * Get the number of playback stalls detected by the StallDetector.\n   *\n   * @return {number}\n   */\n  getStallsDetected() {}\n\n  /**\n   * Get the number of playback gaps jumped by the GapJumpingController.\n   *\n   * @return {number}\n   */\n  getGapsJumped() {}\n\n  /**\n   * Get the current playhead position. The position will be restricted to valid\n   * time ranges.\n   *\n   * @return {number}\n   */\n  getTime() {}\n\n  /**\n   * Notify the playhead that the buffered ranges have changed.\n   */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that only relies on the media element.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.SrcEqualsPlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n    /** @private {boolean} */\n    this.started_ = false;\n    /** @private {?number} */\n    this.startTime_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  ready() {\n    goog.asserts.assert(\n        this.mediaElement_ != null,\n        'Playhead should not be released before calling ready()',\n    );\n\n    // We listen for the loaded-data-event so that we know when we can\n    // interact with |currentTime|.\n    const onLoaded = () => {\n      if (this.startTime_ == null || this.startTime_ == 0) {\n        this.started_ = true;\n      } else {\n        // Startup is complete only when the video element acknowledges the\n        // seek.\n        this.eventManager_.listenOnce(this.mediaElement_, 'seeking', () => {\n          this.started_ = true;\n        });\n\n        const currentTime = this.mediaElement_.currentTime;\n        // Using the currentTime allows using a negative number in Live HLS\n        const newTime = Math.max(0, currentTime + this.startTime_);\n        this.mediaElement_.currentTime = newTime;\n      }\n    };\n\n    shaka.util.MediaReadyState.waitForReadyState(this.mediaElement_,\n        HTMLMediaElement.HAVE_CURRENT_DATA,\n        this.eventManager_, () => {\n          onLoaded();\n        });\n  }\n\n  /** @override */\n  release() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    this.mediaElement_ = null;\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    // If we have already started playback, ignore updates to the start time.\n    // This is just to make things consistent.\n    this.startTime_ = this.started_ ? this.startTime_ : startTime;\n  }\n\n  /** @override */\n  getTime() {\n    // If we have not started playback yet, return the start time. However once\n    // we start playback we assume that we can always return the current time.\n    const time = this.started_ ?\n                 this.mediaElement_.currentTime :\n                 this.startTime_;\n\n    // In the case that we have not started playback, but the start time was\n    // never set, we don't know what the start time should be. To ensure we\n    // always return a number, we will default back to 0.\n    return time || 0;\n  }\n\n  /** @override */\n  getStallsDetected() {\n    return 0;\n  }\n\n  /** @override */\n  getGapsJumped() {\n    return 0;\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {}\n};\n\n\n/**\n * A playhead implementation that relies on the media element and a manifest.\n * When provided with a manifest, we can provide more accurate control than\n * the SrcEqualsPlayhead.\n *\n * TODO: Clean up and simplify Playhead.  There are too many layers of, methods\n *       for, and conditions on timestamp adjustment.\n *\n * @implements {shaka.media.Playhead}\n * @final\n */\nshaka.media.MediaSourcePlayhead = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {?number} startTime\n   *     The playhead's initial position in seconds. If null, defaults to the\n   *     start of the presentation for VOD and the live-edge for live.\n   * @param {function()} onSeek\n   *     Called when the user agent seeks to a time within the presentation\n   *     timeline.\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   */\n  constructor(mediaElement, manifest, config, startTime, onSeek, onEvent) {\n    /**\n     * The seek range must be at least this number of seconds long. If it is\n     * smaller than this, change it to be this big so we don't repeatedly seek\n     * to keep within a zero-width window.\n     *\n     * This is 3s long, to account for the weaker hardware on platforms like\n     * Chromecast.\n     *\n     * @private {number}\n     */\n    this.minSeekRange_ = 3.0;\n\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /** @private {shaka.media.PresentationTimeline} */\n    this.timeline_ = manifest.presentationTimeline;\n\n    /** @private {number} */\n    this.minBufferTime_ = manifest.minBufferTime || 0;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = config;\n\n    /** @private {function()} */\n    this.onSeek_ = onSeek;\n\n    /** @private {?number} */\n    this.lastCorrectiveSeek_ = null;\n\n    /** @private {shaka.media.StallDetector} */\n    this.stallDetector_ =\n        this.createStallDetector_(mediaElement, config, onEvent);\n\n    /** @private {shaka.media.GapJumpingController} */\n    this.gapController_ = new shaka.media.GapJumpingController(\n        mediaElement,\n        manifest.presentationTimeline,\n        config,\n        this.stallDetector_,\n        onEvent);\n\n    /** @private {shaka.media.VideoWrapper} */\n    this.videoWrapper_ = new shaka.media.VideoWrapper(\n        mediaElement,\n        () => this.onSeeking_(),\n        this.getStartTime_(startTime));\n\n    /** @type {shaka.util.Timer} */\n    this.checkWindowTimer_ = new shaka.util.Timer(() => {\n      this.onPollWindow_();\n    });\n  }\n\n  /** @override */\n  ready() {\n    this.checkWindowTimer_.tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    if (this.videoWrapper_) {\n      this.videoWrapper_.release();\n      this.videoWrapper_ = null;\n    }\n\n    if (this.gapController_) {\n      this.gapController_.release();\n      this.gapController_= null;\n    }\n\n    if (this.checkWindowTimer_) {\n      this.checkWindowTimer_.stop();\n      this.checkWindowTimer_ = null;\n    }\n\n    this.config_ = null;\n    this.timeline_ = null;\n    this.videoWrapper_ = null;\n    this.mediaElement_ = null;\n\n    this.onSeek_ = () => {};\n  }\n\n  /** @override */\n  setStartTime(startTime) {\n    this.videoWrapper_.setTime(startTime);\n  }\n\n  /** @override */\n  getTime() {\n    const time = this.videoWrapper_.getTime();\n\n    // Although we restrict the video's currentTime elsewhere, clamp it here to\n    // ensure timing issues don't cause us to return a time outside the segment\n    // availability window.  E.g., the user agent seeks and calls this function\n    // before we receive the 'seeking' event.\n    //\n    // We don't buffer when the livestream video is paused and the playhead time\n    // is out of the seek range; thus, we do not clamp the current time when the\n    // video is paused.\n    // https://github.com/shaka-project/shaka-player/issues/1121\n    if (this.mediaElement_.readyState > 0 && !this.mediaElement_.paused) {\n      return this.clampTime_(time);\n    }\n\n    return time;\n  }\n\n  /** @override */\n  getStallsDetected() {\n    return this.stallDetector_ ? this.stallDetector_.getStallsDetected() : 0;\n  }\n\n  /** @override */\n  getGapsJumped() {\n    return this.gapController_.getGapsJumped();\n  }\n\n  /**\n   * Gets the playhead's initial position in seconds.\n   *\n   * @param {?number} startTime\n   * @return {number}\n   * @private\n   */\n  getStartTime_(startTime) {\n    if (startTime == null) {\n      if (this.timeline_.getDuration() < Infinity) {\n        // If the presentation is VOD, or if the presentation is live but has\n        // finished broadcasting, then start from the beginning.\n        startTime = this.timeline_.getSeekRangeStart();\n      } else {\n        // Otherwise, start near the live-edge.\n        startTime = this.timeline_.getSeekRangeEnd();\n      }\n    } else if (startTime < 0) {\n      // For live streams, if the startTime is negative, start from a certain\n      // offset time from the live edge.  If the offset from the live edge is\n      // not available, start from the current available segment start point\n      // instead, handled by clampTime_().\n      startTime = this.timeline_.getSeekRangeEnd() + startTime;\n    }\n\n    return this.clampSeekToDuration_(this.clampTime_(startTime));\n  }\n\n  /** @override */\n  notifyOfBufferingChange() {\n    this.gapController_.onSegmentAppended();\n  }\n\n  /**\n   * Called on a recurring timer to keep the playhead from falling outside the\n   * availability window.\n   *\n   * @private\n   */\n  onPollWindow_() {\n    // Don't catch up to the seek range when we are paused or empty.\n    // The definition of \"seeking\" says that we are seeking until the buffered\n    // data intersects with the playhead.  If we fall outside of the seek range,\n    // it doesn't matter if we are in a \"seeking\" state.  We can and should go\n    // ahead and catch up while seeking.\n    if (this.mediaElement_.readyState == 0 || this.mediaElement_.paused) {\n      return;\n    }\n\n    const currentTime = this.videoWrapper_.getTime();\n    let seekStart = this.timeline_.getSeekRangeStart();\n    const seekEnd = this.timeline_.getSeekRangeEnd();\n\n    if (seekEnd - seekStart < this.minSeekRange_) {\n      seekStart = seekEnd - this.minSeekRange_;\n    }\n\n    if (currentTime < seekStart) {\n      // The seek range has moved past the playhead.  Move ahead to catch up.\n      const targetTime = this.reposition_(currentTime);\n      shaka.log.info('Jumping forward ' + (targetTime - currentTime) +\n                     ' seconds to catch up with the seek range.');\n      this.mediaElement_.currentTime = targetTime;\n    }\n  }\n\n  /**\n   * Handles when a seek happens on the video.\n   *\n   * @private\n   */\n  onSeeking_() {\n    this.gapController_.onSeeking();\n    const currentTime = this.videoWrapper_.getTime();\n    const targetTime = this.reposition_(currentTime);\n\n    const gapLimit = shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE;\n    if (Math.abs(targetTime - currentTime) > gapLimit) {\n      // You can only seek like this every so often. This is to prevent an\n      // infinite loop on systems where changing currentTime takes a significant\n      // amount of time (e.g. Chromecast).\n      const time = Date.now() / 1000;\n      if (!this.lastCorrectiveSeek_ || this.lastCorrectiveSeek_ < time - 1) {\n        this.lastCorrectiveSeek_ = time;\n        this.videoWrapper_.setTime(targetTime);\n        return;\n      }\n    }\n\n    shaka.log.v1('Seek to ' + currentTime);\n    this.onSeek_();\n  }\n\n  /**\n   * Clamp seek times and playback start times so that we never seek to the\n   * presentation duration.  Seeking to or starting at duration does not work\n   * consistently across browsers.\n   *\n   * @see https://github.com/shaka-project/shaka-player/issues/979\n   * @param {number} time\n   * @return {number} The adjusted seek time.\n   * @private\n   */\n  clampSeekToDuration_(time) {\n    const duration = this.timeline_.getDuration();\n    if (time >= duration) {\n      goog.asserts.assert(this.config_.durationBackoff >= 0,\n          'Duration backoff must be non-negative!');\n      return duration - this.config_.durationBackoff;\n    }\n    return time;\n  }\n\n  /**\n   * Computes a new playhead position that's within the presentation timeline.\n   *\n   * @param {number} currentTime\n   * @return {number} The time to reposition the playhead to.\n   * @private\n   */\n  reposition_(currentTime) {\n    goog.asserts.assert(\n        this.config_,\n        'Cannot reposition playhead when it has beeen destroyed');\n\n    /** @type {function(number)} */\n    const isBuffered = (playheadTime) => shaka.media.TimeRangesUtils.isBuffered(\n        this.mediaElement_.buffered, playheadTime);\n\n    const rebufferingGoal = Math.max(\n        this.minBufferTime_,\n        this.config_.rebufferingGoal);\n\n    const safeSeekOffset = this.config_.safeSeekOffset;\n\n    let start = this.timeline_.getSeekRangeStart();\n    const end = this.timeline_.getSeekRangeEnd();\n    const duration = this.timeline_.getDuration();\n\n    if (end - start < this.minSeekRange_) {\n      start = end - this.minSeekRange_;\n    }\n\n    // With live content, the beginning of the availability window is moving\n    // forward.  This means we cannot seek to it since we will \"fall\" outside\n    // the window while we buffer.  So we define a \"safe\" region that is far\n    // enough away.  For VOD, |safe == start|.\n    const safe = this.timeline_.getSafeSeekRangeStart(rebufferingGoal);\n\n    // These are the times to seek to rather than the exact destinations.  When\n    // we seek, we will get another event (after a slight delay) and these steps\n    // will run again.  So if we seeked directly to |start|, |start| would move\n    // on the next call and we would loop forever.\n    const seekStart = this.timeline_.getSafeSeekRangeStart(safeSeekOffset);\n    const seekSafe = this.timeline_.getSafeSeekRangeStart(\n        rebufferingGoal + safeSeekOffset);\n\n    if (currentTime >= duration) {\n      shaka.log.v1('Playhead past duration.');\n      return this.clampSeekToDuration_(currentTime);\n    }\n\n    if (currentTime > end) {\n      shaka.log.v1('Playhead past end.');\n      return end;\n    }\n\n    if (currentTime < start) {\n      if (isBuffered(seekStart)) {\n        shaka.log.v1('Playhead before start & start is buffered');\n        return seekStart;\n      } else {\n        shaka.log.v1('Playhead before start & start is unbuffered');\n        return seekSafe;\n      }\n    }\n\n    if (currentTime >= safe || isBuffered(currentTime)) {\n      shaka.log.v1('Playhead in safe region or in buffered region.');\n      return currentTime;\n    } else {\n      shaka.log.v1('Playhead outside safe region & in unbuffered region.');\n      return seekSafe;\n    }\n  }\n\n  /**\n   * Clamps the given time to the seek range.\n   *\n   * @param {number} time The time in seconds.\n   * @return {number} The clamped time in seconds.\n   * @private\n   */\n  clampTime_(time) {\n    const start = this.timeline_.getSeekRangeStart();\n    if (time < start) {\n      return start;\n    }\n\n    const end = this.timeline_.getSeekRangeEnd();\n    if (time > end) {\n      return end;\n    }\n\n    return time;\n  }\n\n  /**\n   * Create and configure a stall detector using the player's streaming\n   * configuration settings. If the player is configured to have no stall\n   * detector, this will return |null|.\n   *\n   * @param {!HTMLMediaElement} mediaElement\n   * @param {shaka.extern.StreamingConfiguration} config\n   * @param {function(!Event)} onEvent\n   *     Called when an event is raised to be sent to the application.\n   * @return {shaka.media.StallDetector}\n   * @private\n   */\n  createStallDetector_(mediaElement, config, onEvent) {\n    if (!config.stallEnabled) {\n      return null;\n    }\n\n    // Cache the values from the config so that changes to the config won't\n    // change the initialized behaviour.\n    const threshold = config.stallThreshold;\n    const skip = config.stallSkip;\n\n    // When we see a stall, we will try to \"jump-start\" playback by moving the\n    // playhead forward.\n    const detector = new shaka.media.StallDetector(\n        new shaka.media.StallDetector.MediaElementImplementation(mediaElement),\n        threshold, onEvent);\n\n    detector.onStall((at, duration) => {\n      shaka.log.debug(`Stall detected at ${at} for ${duration} seconds.`);\n\n      if (skip) {\n        shaka.log.debug(`Seeking forward ${skip} seconds to break stall.`);\n        mediaElement.currentTime += skip;\n      } else {\n        shaka.log.debug('Pausing and unpausing to break stall.');\n        mediaElement.pause();\n        mediaElement.play();\n      }\n    });\n\n    return detector;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.MetaSegmentIndex');\ngoog.provide('shaka.media.SegmentIndex');\ngoog.provide('shaka.media.SegmentIterator');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * SegmentIndex.\n *\n * @implements {shaka.util.IReleasable}\n * @implements {Iterable.<!shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.SegmentIndex = class {\n  /**\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   */\n  constructor(references) {\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(references);\n    }\n\n    /** @protected {!Array.<!shaka.media.SegmentReference>} */\n    this.references = references;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = null;\n\n    /**\n     * The number of references that have been removed from the front of the\n     * array.  Used to create stable positions in the find/get APIs.\n     *\n     * @protected {number}\n     */\n    this.numEvicted = 0;\n\n    /** @private {boolean} */\n    this.immutable_ = false;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    if (this.immutable_) {\n      return;\n    }\n\n    this.references = [];\n\n    if (this.timer_) {\n      this.timer_.stop();\n    }\n    this.timer_ = null;\n  }\n\n\n  /**\n   * Marks the index as immutable.  Segments cannot be added or removed after\n   * this point.  This doesn't affect the references themselves.  This also\n   * makes the destroy/release methods do nothing.\n   *\n   * This is mainly for testing.\n   *\n   * @export\n   */\n  markImmutable() {\n    this.immutable_ = true;\n  }\n\n\n  /**\n   * Iterates over all top-level segment references in this segment index.\n   * @param {function(!shaka.media.SegmentReference)} fn\n   */\n  forEachTopLevelReference(fn) {\n    for (const reference of this.references) {\n      fn(reference);\n    }\n  }\n\n\n  /**\n   * Return the earliest reference, or null if empty.\n   * @return {shaka.media.SegmentReference}\n   */\n  earliestReference() {\n    return this.references[0] || null;\n  }\n\n\n  /**\n   * Drop the first N references.\n   * Used in early HLS synchronization, and does not count as eviction.\n   * @param {number} n\n   */\n  dropFirstReferences(n) {\n    this.references.splice(0, n);\n  }\n\n\n  /**\n   * Finds the position of the segment for the given time, in seconds, relative\n   * to the start of the presentation.  Returns the position of the segment\n   * with the largest end time if more than one segment is known for the given\n   * time.\n   *\n   * @param {number} time\n   * @return {?number} The position of the segment, or null if the position of\n   *   the segment could not be determined.\n   * @export\n   */\n  find(time) {\n    // For live streams, searching from the end is faster.  For VOD, it balances\n    // out either way.  In both cases, references.length is small enough that\n    // the difference isn't huge.\n    const lastReferenceIndex = this.references.length - 1;\n    for (let i = lastReferenceIndex; i >= 0; --i) {\n      const r = this.references[i];\n      const start = r.startTime;\n      // A rounding error can cause /time/ to equal e.endTime or fall in between\n      // the references by a fraction of a second. To account for this, we use\n      // the start of the next segment as /end/, unless this is the last\n      // reference, in which case we use its end time as /end/.\n      const end = i < lastReferenceIndex ?\n        this.references[i + 1].startTime : r.endTime;\n      // Note that a segment ends immediately before the end time.\n      if ((time >= start) && (time < end)) {\n        return i + this.numEvicted;\n      }\n    }\n    if (this.references.length && time < this.references[0].startTime) {\n      return this.numEvicted;\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Gets the SegmentReference for the segment at the given position.\n   *\n   * @param {number} position The position of the segment as returned by find().\n   * @return {shaka.media.SegmentReference} The SegmentReference, or null if\n   *   no such SegmentReference exists.\n   * @export\n   */\n  get(position) {\n    if (this.references.length == 0) {\n      return null;\n    }\n\n    const index = position - this.numEvicted;\n    if (index < 0 || index >= this.references.length) {\n      return null;\n    }\n\n    return this.references[index];\n  }\n\n\n  /**\n   * Offset all segment references by a fixed amount.\n   *\n   * @param {number} offset The amount to add to each segment's start and end\n   *   times.\n   * @export\n   */\n  offset(offset) {\n    if (!this.immutable_) {\n      for (const ref of this.references) {\n        ref.offset(offset);\n      }\n    }\n  }\n\n\n  /**\n   * Merges the given SegmentReferences.  Supports extending the original\n   * references only.  Will replace old references with equivalent new ones, and\n   * keep any unique old ones.\n   *\n   * Used, for example, by the DASH and HLS parser, where manifests may not list\n   * all available references, so we must keep available references in memory to\n   * fill the availability window.\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   */\n  merge(references) {\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(references);\n    }\n    if (this.immutable_) {\n      return;\n    }\n\n    if (!references.length) {\n      return;\n    }\n\n    // Partial segments are used for live edge, and should be removed when they\n    // get older. Remove the old SegmentReferences after the first new\n    // reference's start time.\n    // Use times rounded to the millisecond for filtering purposes, so that\n    // tiny rounding errors will not result in duplicate segments in the index.\n    const firstStartTime = Math.round(references[0].startTime * 1000) / 1000;\n    this.references = this.references.filter((r) => {\n      return (Math.round(r.startTime * 1000) / 1000) < firstStartTime;\n    });\n\n    this.references.push(...references);\n\n    if (goog.DEBUG) {\n      shaka.media.SegmentIndex.assertCorrectReferences_(this.references);\n    }\n  }\n\n  /**\n   * Merges the given SegmentReferences and evicts the ones that end before the\n   * given time.  Supports extending the original references only.\n   * Will not replace old references or interleave new ones.\n   * Used, for example, by the DASH and HLS parser, where manifests may not list\n   * all available references, so we must keep available references in memory to\n   * fill the availability window.\n   *\n   * @param {!Array.<!shaka.media.SegmentReference>} references The list of\n   *   SegmentReferences, which must be sorted first by their start times\n   *   (ascending) and second by their end times (ascending).\n   * @param {number} windowStart The start of the availability window to filter\n   *   out the references that are no longer available.\n   * @export\n   */\n  mergeAndEvict(references, windowStart) {\n    // Filter out the references that are no longer available to avoid\n    // repeatedly evicting them and messing up eviction count.\n    references = references.filter((r) => {\n      return r.endTime > windowStart &&\n          (this.references.length == 0 ||\n           r.endTime > this.references[0].startTime);\n    });\n\n    const oldFirstRef = this.references[0];\n    this.merge(references);\n    const newFirstRef = this.references[0];\n\n    if (oldFirstRef) {\n      // We don't compare the actual ref, since the object could legitimately be\n      // replaced with an equivalent.  Even the URIs could change due to\n      // load-balancing actions taken by the server.  However, if the time\n      // changes, its not an equivalent reference.\n      goog.asserts.assert(oldFirstRef.startTime == newFirstRef.startTime,\n          'SegmentIndex.merge should not change the first reference time!');\n    }\n\n    this.evict(windowStart);\n  }\n\n  /**\n   * Removes all SegmentReferences that end before the given time.\n   *\n   * @param {number} time The time in seconds.\n   * @export\n   */\n  evict(time) {\n    if (this.immutable_) {\n      return;\n    }\n\n    const oldSize = this.references.length;\n\n    this.references = this.references.filter((ref) => ref.endTime > time);\n\n    const newSize = this.references.length;\n    const diff = oldSize - newSize;\n    // Tracking the number of evicted refs will keep their \"positions\" stable\n    // for the caller.\n    this.numEvicted += diff;\n  }\n\n\n  /**\n   * Drops references that start after windowEnd, or end before windowStart,\n   * and contracts the last reference so that it ends at windowEnd.\n   *\n   * Do not call on the last period of a live presentation (unknown duration).\n   * It is okay to call on the other periods of a live presentation, where the\n   * duration is known and another period has been added.\n   *\n   * @param {number} windowStart\n   * @param {?number} windowEnd\n   * @param {boolean=} isNew Whether this is a new SegmentIndex and we shouldn't\n   *   update the number of evicted elements.\n   * @export\n   */\n  fit(windowStart, windowEnd, isNew = false) {\n    goog.asserts.assert(windowEnd != null,\n        'Content duration must be known for static content!');\n    goog.asserts.assert(windowEnd != Infinity,\n        'Content duration must be finite for static content!');\n    if (this.immutable_) {\n      return;\n    }\n\n    // Trim out references we will never use.\n    while (this.references.length) {\n      const lastReference = this.references[this.references.length - 1];\n      if (lastReference.startTime >= windowEnd) {\n        this.references.pop();\n      } else {\n        break;\n      }\n    }\n\n    while (this.references.length) {\n      const firstReference = this.references[0];\n      if (firstReference.endTime <= windowStart) {\n        this.references.shift();\n        if (!isNew) {\n          this.numEvicted++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (this.references.length == 0) {\n      return;\n    }\n\n    // Adjust the last SegmentReference.\n    const lastReference = this.references[this.references.length - 1];\n    this.references[this.references.length - 1] =\n        new shaka.media.SegmentReference(\n            lastReference.startTime,\n            /* endTime= */ windowEnd,\n            lastReference.getUrisInner,\n            lastReference.startByte,\n            lastReference.endByte,\n            lastReference.initSegmentReference,\n            lastReference.timestampOffset,\n            lastReference.appendWindowStart,\n            lastReference.appendWindowEnd,\n            lastReference.partialReferences,\n            lastReference.tilesLayout,\n            lastReference.tileDuration,\n            lastReference.syncTime,\n            lastReference.status,\n            lastReference.hlsAes128Key,\n        );\n  }\n\n\n  /**\n   * Updates the references every so often.  Stops when the references list\n   * returned by the callback is null.\n   *\n   * @param {number} interval The interval in seconds.\n   * @param {function():Array.<shaka.media.SegmentReference>} updateCallback\n   * @export\n   */\n  updateEvery(interval, updateCallback) {\n    goog.asserts.assert(!this.timer_, 'SegmentIndex timer already started!');\n    if (this.immutable_) {\n      return;\n    }\n    if (this.timer_) {\n      this.timer_.stop();\n    }\n\n    this.timer_ = new shaka.util.Timer(() => {\n      const references = updateCallback();\n      if (references) {\n        this.references.push(...references);\n      } else {\n        this.timer_.stop();\n        this.timer_ = null;\n      }\n    });\n    this.timer_.tickEvery(interval);\n  }\n\n\n  /** @return {!shaka.media.SegmentIterator} */\n  [Symbol.iterator]() {\n    const iter = this.getIteratorForTime(0);\n    goog.asserts.assert(iter != null, 'Iterator for 0 should never be null!');\n    return iter;\n  }\n\n  /**\n   * Returns a new iterator that initially points to the segment that contains\n   * the given time.  Like the normal iterator, next() must be called first to\n   * get to the first element. Returns null if we do not find a segment at the\n   * requested time.\n   *\n   * @param {number} time\n   * @return {?shaka.media.SegmentIterator}\n   * @export\n   */\n  getIteratorForTime(time) {\n    let index = this.find(time);\n    if (index == null) {\n      return null;\n    } else {\n      index--;\n    }\n    // +1 so we can get the element we'll eventually point to so we can see if\n    // we need to use a partial segment index.\n    const ref = this.get(index + 1);\n\n    let partialSegmentIndex = -1;\n    if (ref && ref.hasPartialSegments()) {\n      // Look for a partial SegmentReference.\n      for (let i = ref.partialReferences.length - 1; i >= 0; --i) {\n        const r = ref.partialReferences[i];\n        // Note that a segment ends immediately before the end time.\n        if ((time >= r.startTime) && (time < r.endTime)) {\n          // Call to next() should move the partial segment, not the full\n          // segment.\n          index++;\n          partialSegmentIndex = i - 1;\n          break;\n        }\n      }\n    }\n    return new shaka.media.SegmentIterator(this, index, partialSegmentIndex);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.references.length == 0;\n  }\n\n  /**\n   * Create a SegmentIndex for a single segment of the given start time and\n   * duration at the given URIs.\n   *\n   * @param {number} startTime\n   * @param {number} duration\n   * @param {!Array.<string>} uris\n   * @return {!shaka.media.SegmentIndex}\n   * @export\n   */\n  static forSingleSegment(startTime, duration, uris) {\n    const reference = new shaka.media.SegmentReference(\n        /* startTime= */ startTime,\n        /* endTime= */ startTime + duration,\n        /* getUris= */ () => uris,\n        /* startByte= */ 0,\n        /* endByte= */ null,\n        /* initSegmentReference= */ null,\n        /* presentationTimeOffset= */ startTime,\n        /* appendWindowStart= */ startTime,\n        /* appendWindowEnd= */ startTime + duration);\n    return new shaka.media.SegmentIndex([reference]);\n  }\n};\n\n\nif (goog.DEBUG) {\n  /**\n   * Asserts that the given SegmentReferences are sorted.\n   *\n   * @param {!Array.<shaka.media.SegmentReference>} references\n   * @private\n   */\n  shaka.media.SegmentIndex.assertCorrectReferences_ = (references) => {\n    goog.asserts.assert(references.every((r2, i) => {\n      if (i == 0) {\n        return true;\n      }\n      const r1 = references[i - 1];\n      if (r1.startTime < r2.startTime) {\n        return true;\n      } else if (r1.startTime > r2.startTime) {\n        return false;\n      } else {\n        if (r1.endTime <= r2.endTime) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }), 'SegmentReferences are incorrect');\n  };\n}\n\n\n/**\n * An iterator over a SegmentIndex's references.\n *\n * @implements {Iterator.<shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.SegmentIterator = class {\n  /**\n   * @param {shaka.media.SegmentIndex} segmentIndex\n   * @param {number} index\n   * @param {number} partialSegmentIndex\n   */\n  constructor(segmentIndex, index, partialSegmentIndex) {\n    /** @private {shaka.media.SegmentIndex} */\n    this.segmentIndex_ = segmentIndex;\n\n    /** @private {number} */\n    this.currentPosition_ = index;\n\n    /** @private {number} */\n    this.currentPartialPosition_ = partialSegmentIndex;\n  }\n\n  /**\n   * @return {number}\n   * @export\n   */\n  currentPosition() {\n    return this.currentPosition_;\n  }\n\n  /**\n   * @return {shaka.media.SegmentReference}\n   * @export\n   */\n  current() {\n    let ref = this.segmentIndex_.get(this.currentPosition_);\n\n    // When we advance past the end of partial references in next(), then add\n    // new references in merge(), the pointers may not make sense any more.\n    // This adjusts the invalid pointer values to point to the next newly added\n    // segment or partial segment.\n    if (ref && ref.hasPartialSegments() && ref.getUris().length &&\n        this.currentPartialPosition_ >= ref.partialReferences.length) {\n      this.currentPosition_++;\n      this.currentPartialPosition_ = 0;\n      ref = this.segmentIndex_.get(this.currentPosition_);\n    }\n\n    // If the regular segment contains partial segments, get the current\n    // partial SegmentReference.\n    if (ref && ref.hasPartialSegments()) {\n      const partial = ref.partialReferences[this.currentPartialPosition_];\n      return partial;\n    }\n    return ref;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  next() {\n    const ref = this.segmentIndex_.get(this.currentPosition_);\n\n    if (ref && ref.hasPartialSegments()) {\n      // If the regular segment contains partial segments, move to the next\n      // partial SegmentReference.\n      this.currentPartialPosition_++;\n      // If the current regular segment has been published completely (has a\n      // valid Uri), and we've reached the end of its partial segments list,\n      // move to the next regular segment.\n      // If the Partial Segments list is still on the fly, do not move to\n      // the next regular segment.\n      if (ref.getUris().length &&\n          this.currentPartialPosition_ == ref.partialReferences.length) {\n        this.currentPosition_++;\n        this.currentPartialPosition_ = 0;\n      }\n    } else {\n      // If the regular segment doesn't contain partial segments, move to the\n      // next regular segment.\n      this.currentPosition_++;\n      this.currentPartialPosition_ = 0;\n    }\n\n    const res = this.current();\n\n    return {\n      'value': res,\n      'done': !res,\n    };\n  }\n};\n\n\n/**\n * A meta-SegmentIndex composed of multiple other SegmentIndexes.\n * Used in constructing multi-Period Streams for DASH.\n *\n * @extends shaka.media.SegmentIndex\n * @implements {shaka.util.IReleasable}\n * @implements {Iterable.<!shaka.media.SegmentReference>}\n * @export\n */\nshaka.media.MetaSegmentIndex = class extends shaka.media.SegmentIndex {\n  /** */\n  constructor() {\n    super([]);\n\n    /** @private {!Array.<!shaka.media.SegmentIndex>} */\n    this.indexes_ = [];\n  }\n\n  /**\n   * Append a SegmentIndex to this MetaSegmentIndex.  This effectively stitches\n   * the underlying Stream onto the end of the multi-Period Stream represented\n   * by this MetaSegmentIndex.\n   *\n   * @param {!shaka.media.SegmentIndex} segmentIndex\n   */\n  appendSegmentIndex(segmentIndex) {\n    goog.asserts.assert(\n        this.indexes_.length == 0 || segmentIndex.numEvicted == 0,\n        'Should not append a new segment index with already-evicted segments');\n    this.indexes_.push(segmentIndex);\n  }\n\n  /**\n   * Create a clone of this MetaSegmentIndex containing all the same indexes.\n   *\n   * @return {!shaka.media.MetaSegmentIndex}\n   */\n  clone() {\n    const clone = new shaka.media.MetaSegmentIndex();\n    // Be careful to clone the Array.  We don't want to share the reference with\n    // our clone and affect each other accidentally.\n    clone.indexes_ = this.indexes_.slice();\n    return clone;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    for (const index of this.indexes_) {\n      index.release();\n    }\n\n    this.indexes_ = [];\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  find(time) {\n    let numPassedInEarlierIndexes = 0;\n\n    for (const index of this.indexes_) {\n      const position = index.find(time);\n\n      if (position != null) {\n        return position + numPassedInEarlierIndexes;\n      }\n\n      numPassedInEarlierIndexes += index.numEvicted + index.references.length;\n    }\n\n    return null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  get(position) {\n    let numPassedInEarlierIndexes = 0;\n    let sawSegments = false;\n\n    for (const index of this.indexes_) {\n      goog.asserts.assert(\n          !sawSegments || index.numEvicted == 0,\n          'Should not see evicted segments after available segments');\n      const reference = index.get(position - numPassedInEarlierIndexes);\n\n      if (reference) {\n        return reference;\n      }\n\n      numPassedInEarlierIndexes += index.numEvicted + index.references.length;\n      sawSegments = sawSegments || index.references.length != 0;\n    }\n\n    return null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  offset(offset) {\n    // offset() is only used by HLS, and MetaSegmentIndex is only used for DASH.\n    goog.asserts.assert(\n        false, 'offset() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  merge(references) {\n    // merge() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'merge() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  evict(time) {\n    // evict() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'evict() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  mergeAndEvict(references, windowStart) {\n    // mergeAndEvict() is only used internally by the DASH and HLS parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'mergeAndEvict() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  fit(windowStart, windowEnd) {\n    // fit() is only used internally by manifest parsers on SegmentIndexes, but\n    // never on MetaSegmentIndex.\n    goog.asserts.assert(false, 'fit() should not be used in MetaSegmentIndex!');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  updateEvery(interval, updateCallback) {\n    // updateEvery() is only used internally by the DASH parser on\n    // SegmentIndexes, but never on MetaSegmentIndex.\n    goog.asserts.assert(\n        false, 'updateEvery() should not be used in MetaSegmentIndex!');\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.PlayRateController');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n/**\n * The play rate controller controls the playback rate on the media element.\n * This provides some missing functionality (e.g. negative playback rate). If\n * the playback rate on the media element can change outside of the controller,\n * the playback controller will need to be updated to stay in-sync.\n *\n * TODO: Try not to manage buffering above the browser with playbackRate=0.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayRateController = class {\n  /**\n   * @param {shaka.media.PlayRateController.Harness} harness\n   */\n  constructor(harness) {\n    /** @private {?shaka.media.PlayRateController.Harness} */\n    this.harness_ = harness;\n\n    /** @private {boolean} */\n    this.isBuffering_ = false;\n\n    /** @private {number} */\n    this.rate_ = this.harness_.getRate();\n\n    /** @private {number} */\n    this.pollRate_ = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.timer_ = new shaka.util.Timer(() => {\n      this.harness_.movePlayhead(this.rate_ * this.pollRate_);\n    });\n  }\n\n  /** @override */\n  release() {\n    if (this.timer_) {\n      this.timer_.stop();\n      this.timer_ = null;\n    }\n\n    this.harness_ = null;\n  }\n\n  /**\n   * Sets the buffering flag, which controls the effective playback rate.\n   *\n   * @param {boolean} isBuffering If true, forces playback rate to 0 internally.\n   */\n  setBuffering(isBuffering) {\n    this.isBuffering_ = isBuffering;\n    this.apply_();\n  }\n\n  /**\n   * Set the playback rate. This rate will only be used as provided when the\n   * player is not buffering. You should never set the rate to 0.\n   *\n   * @param {number} rate\n   */\n  set(rate) {\n    goog.asserts.assert(rate != 0, 'Should never set rate of 0 explicitly!');\n    this.rate_ = rate;\n    this.apply_();\n  }\n\n  /**\n   * Get the real rate of the playback. This means that if we are using trick\n   * play, this will report the trick play rate. If playback is occurring as\n   * normal, this will report 1.\n   *\n   * @return {number}\n   */\n  getRealRate() {\n    return this.rate_;\n  }\n\n  /**\n   * Get the default play rate of the playback.\n   *\n   * @return {number}\n   */\n  getDefaultRate() {\n    return this.harness_.getDefaultRate();\n  }\n\n  /**\n   * Reapply the effects of |this.rate_| and |this.active_| to the media\n   * element. This will only update the rate via the harness if the desired rate\n   * has changed.\n   *\n   * @private\n   */\n  apply_() {\n    // Always stop the timer. We may not start it again.\n    this.timer_.stop();\n\n    /** @type {number} */\n    const rate = this.calculateCurrentRate_();\n\n    shaka.log.v1('Changing effective playback rate to', rate);\n\n    if (rate >= 0) {\n      try {\n        this.applyRate_(rate);\n        return;\n      } catch (e) {\n        // Fall through to the next clause.\n        //\n        // Fast forward is accomplished through setting video.playbackRate.\n        // If the play rate value is not supported by the browser (too big),\n        // the browsers will throw.\n        // Use this as a cue to fall back to fast forward through repeated\n        // seeking, which is what we do for rewind as well.\n      }\n    }\n\n    // When moving backwards or forwards in large steps,\n    // set the playback rate to 0 so that we can manually\n    // seek backwards with out fighting the playhead.\n    this.timer_.tickEvery(this.pollRate_);\n    this.applyRate_(0);\n  }\n\n  /**\n   * Calculate the rate that the controller wants the media element to have\n   * based on the current state of the controller.\n   *\n   * @return {number}\n   * @private\n   */\n  calculateCurrentRate_() {\n    return this.isBuffering_ ? 0 : this.rate_;\n  }\n\n  /**\n   * If the new rate is different than the media element's playback rate, this\n   * will change the playback rate. If the rate does not need to change, it will\n   * not be set. This will avoid unnecessary ratechange events.\n   *\n   * @param {number} newRate\n   * @return {boolean}\n   * @private\n   */\n  applyRate_(newRate) {\n    const oldRate = this.harness_.getRate();\n\n    if (oldRate != newRate) {\n      this.harness_.setRate(newRate);\n    }\n\n    return oldRate != newRate;\n  }\n};\n\n\n/**\n * @typedef {{\n *   getRate: function():number,\n *   getDefaultRate: function():number,\n *   setRate: function(number),\n *   movePlayhead: function(number)\n * }}\n *\n * @description\n *   A layer of abstraction between the controller and what it is controlling.\n *   In tests this will be implemented with spies. In production this will be\n *   implemented using a media element.\n *\n * @property {function():number} getRate\n *   Get the current playback rate being seen by the user.\n *\n * @property {function():number} getDefaultRate\n *   Get the default playback rate that the user should see.\n *\n * @property {function(number)} setRate\n *   Set the playback rate that the user should see.\n *\n * @property {function(number)} movePlayhead\n *   Move the playhead N seconds. If N is positive, the playhead will move\n *   forward abs(N) seconds. If N is negative, the playhead will move backwards\n *   abs(N) seconds.\n */\nshaka.media.PlayRateController.Harness;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.IPlayheadObserver');\ngoog.provide('shaka.media.PlayheadObserverManager');\n\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A playhead observer is a system that watches for meaningful changes in state\n * that are dependent on playhead information. The observer is responsible for\n * managing its own listeners.\n *\n * @extends {shaka.util.IReleasable}\n * @interface\n */\nshaka.media.IPlayheadObserver = class {\n  /**\n   * Check again (using an update playhead summary) if an event should be fired.\n   * If an event should be fired, fire it.\n   *\n   * @param {number} positionInSeconds\n   * @param {boolean} wasSeeking\n   */\n  poll(positionInSeconds, wasSeeking) {}\n};\n\n\n/**\n * The playhead observer manager is responsible for owning playhead observer\n * instances and polling them when needed. Destroying the manager will destroy\n * all observers managed by the manager.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.PlayheadObserverManager = class {\n  /**\n   * @param {!HTMLMediaElement} mediaElement\n   */\n  constructor(mediaElement) {\n    /** @private {HTMLMediaElement} */\n    this.mediaElement_ = mediaElement;\n\n    /**\n     * The set of all observers that this manager is responsible for updating.\n     * We are using a set to ensure that we don't double update an observer if\n     * it is accidentally added twice.\n     *\n     * @private {!Set.<shaka.media.IPlayheadObserver>}\n     */\n    this.observers_ = new Set();\n\n    /**\n     * To fire events semi-accurately, poll the observers 4 times a second. This\n     * should be frequent enough to trigger an event close enough to its actual\n     * occurrence without the user noticing a delay.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.pollingLoop_ = new shaka.util.Timer(() => {\n      this.pollAllObservers_(/* seeking= */ false);\n    }).tickEvery(/* seconds= */ 0.25);\n  }\n\n  /** @override */\n  release() {\n    // We need to stop the loop or else we may try to use a released resource.\n    this.pollingLoop_.stop();\n\n    for (const observer of this.observers_) {\n      observer.release();\n    }\n\n    this.observers_.clear();\n  }\n\n  /**\n   * Have the playhead observer manager manage a new observer. This will ensure\n   * that observers are only tracked once within the manager. After this call,\n   * the manager will be responsible for the life cycle of |observer|.\n   *\n   * @param {!shaka.media.IPlayheadObserver} observer\n   */\n  manage(observer) {\n    this.observers_.add(observer);\n  }\n\n  /**\n   * Notify all the observers that we just seeked.\n   */\n  notifyOfSeek() {\n    this.pollAllObservers_(/* seeking= */ true);\n  }\n\n  /**\n   * @param {boolean} seeking\n   * @private\n   */\n  pollAllObservers_(seeking) {\n    for (const observer of this.observers_) {\n      observer.poll(\n          this.mediaElement_.currentTime,\n          seeking);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.QualityObserver');\n\ngoog.require('shaka.media.IPlayheadObserver');\ngoog.require('shaka.log');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\n\n/**\n * Monitors the quality of content being appended to the source buffers and\n * fires 'qualitychange' events when the media quality at the playhead changes.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.QualityObserver = class extends shaka.util.FakeEventTarget {\n  /**\n   * Creates a new QualityObserver.\n   *\n   * @param {!function():!shaka.extern.BufferedInfo} getBufferedInfo\n   *   Buffered info is needed to purge QualityChanges that are no\n   *   longer relevant.\n   */\n  constructor(getBufferedInfo) {\n    super();\n\n    /**\n     * @private {!Map.<string,!shaka.media.QualityObserver.ContentTypeState>}\n     */\n    this.contentTypeStates_ = new Map();\n\n    /** @private function():!shaka.extern.BufferedInfo */\n    this.getBufferedInfo_ = getBufferedInfo;\n  }\n\n  /** @override */\n  release() {\n    this.contentTypeStates_.clear();\n    super.release();\n  }\n\n  /**\n   * Get the ContenTypeState for a contentType, creating a new\n   * one if necessary.\n   *\n   * @param {!string} contentType\n   *  The contend type e.g. \"video\" or \"audio\".\n   * @return {!shaka.media.QualityObserver.ContentTypeState}\n   * @private\n   */\n  getContentTypeState_(contentType) {\n    let contentTypeState = this.contentTypeStates_.get(contentType);\n    if (!contentTypeState) {\n      contentTypeState = {\n        qualityChangePositions: [],\n        currentQuality: null,\n        contentType: contentType,\n      };\n      this.contentTypeStates_.set(contentType, contentTypeState);\n    }\n    return contentTypeState;\n  }\n\n  /**\n   * Adds a QualityChangePosition for the contentType identified by\n   * the mediaQuality.contentType.\n   *\n   * @param {!shaka.extern.MediaQualityInfo} mediaQuality\n   * @param {!number} position\n   *  Position in seconds of the quality change.\n   */\n  addMediaQualityChange(mediaQuality, position) {\n    const contentTypeState =\n      this.getContentTypeState_(mediaQuality.contentType);\n\n    // Remove unneeded QualityChangePosition(s) before adding the new one\n    this.purgeQualityChangePositions_(contentTypeState);\n\n    const newChangePosition = {\n      mediaQuality: mediaQuality,\n      position: position,\n    };\n\n    const changePositions = contentTypeState.qualityChangePositions;\n    const insertBeforeIndex = changePositions.findIndex(\n        (qualityChange) => (qualityChange.position >= position));\n\n    if (insertBeforeIndex >= 0) {\n      const duplicatePositions =\n        (changePositions[insertBeforeIndex].position == position) ? 1 : 0;\n      changePositions.splice(\n          insertBeforeIndex, duplicatePositions, newChangePosition);\n    } else {\n      changePositions.push(newChangePosition);\n    }\n  }\n\n  /**\n   * Determines the media quality at a specific position in the source buffer.\n   *\n   * @param {!number} position\n   *  Position in seconds\n   * @param {!shaka.media.QualityObserver.ContentTypeState} contentTypeState\n   * @return {?shaka.extern.MediaQualityInfo}\n   * @private\n   */\n  static getMediaQualityAtPosition_(position, contentTypeState) {\n    // The qualityChangePositions must be ordered by position ascending\n    // Find the last QualityChangePosition prior to the position\n    const changePositions = contentTypeState.qualityChangePositions;\n    for (let i = changePositions.length - 1; i >= 0; i--) {\n      const qualityChange = changePositions[i];\n      if (qualityChange.position <= position) {\n        return qualityChange.mediaQuality;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Determines if two MediaQualityInfo objects are the same or not.\n   *\n   * @param {?shaka.extern.MediaQualityInfo} mq1\n   * @param {?shaka.extern.MediaQualityInfo} mq2\n   * @return {boolean}\n   * @private\n   */\n  static mediaQualitiesAreTheSame_(mq1, mq2) {\n    if (mq1 === mq2) {\n      return true;\n    }\n    if (!mq1 || !mq2) {\n      return false;\n    }\n    return (mq1.bandwidth == mq2.bandwidth) &&\n      (mq1.audioSamplingRate == mq2.audioSamplingRate) &&\n      (mq1.codecs == mq2.codecs) &&\n      (mq1.contentType == mq2.contentType) &&\n      (mq1.frameRate == mq2.frameRate) &&\n      (mq1.height == mq2.height) &&\n      (mq1.mimeType == mq2.mimeType) &&\n      (mq1.channelsCount == mq2.channelsCount) &&\n      (mq1.pixelAspectRatio == mq2.pixelAspectRatio) &&\n      (mq1.width == mq2.width);\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    for (const contentTypeState of this.contentTypeStates_.values()) {\n      const qualityAtPosition =\n        shaka.media.QualityObserver.getMediaQualityAtPosition_(\n            positionInSeconds, contentTypeState);\n      if (qualityAtPosition &&\n          !shaka.media.QualityObserver.mediaQualitiesAreTheSame_(\n              contentTypeState.currentQuality, qualityAtPosition)) {\n        if (this.positionIsBuffered_(\n            positionInSeconds, qualityAtPosition.contentType)) {\n          contentTypeState.currentQuality = qualityAtPosition;\n\n          shaka.log.debug('Media quality changed at position ' +\n            positionInSeconds + ' ' + JSON.stringify(qualityAtPosition));\n\n          const event = new shaka.util.FakeEvent('qualitychange', new Map([\n            ['quality', qualityAtPosition],\n            ['position', positionInSeconds],\n          ]));\n          this.dispatchEvent(event);\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine if a position is buffered for a given content type.\n   *\n   * @param {!number} position\n   * @param {!string} contentType\n   * @private\n   */\n  positionIsBuffered_(position, contentType) {\n    const bufferedInfo = this.getBufferedInfo_();\n    const bufferedRanges = bufferedInfo[contentType];\n    if (bufferedRanges && bufferedRanges.length > 0) {\n      const bufferStart = bufferedRanges[0].start;\n      const bufferEnd = bufferedRanges[bufferedRanges.length - 1].end;\n      if (position >= bufferStart && position < bufferEnd) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Removes the QualityChangePosition(s) that are not relevant to the buffered\n   * content of the specified contentType. Note that this function is\n   * invoked just before adding the quality change info associated with\n   * the next media segment to be appended.\n   *\n   * @param {!shaka.media.QualityObserver.ContentTypeState} contentTypeState\n   * @private\n   */\n  purgeQualityChangePositions_(contentTypeState) {\n    const bufferedInfo = this.getBufferedInfo_();\n    const bufferedRanges = bufferedInfo[contentTypeState.contentType];\n\n    if (bufferedRanges && bufferedRanges.length > 0) {\n      const bufferStart = bufferedRanges[0].start;\n      const bufferEnd = bufferedRanges[bufferedRanges.length - 1].end;\n      const oldChangePositions = contentTypeState.qualityChangePositions;\n      contentTypeState.qualityChangePositions =\n        oldChangePositions.filter(\n            (qualityChange, index) => {\n              // Remove all but last quality change before bufferStart.\n              if ((qualityChange.position <= bufferStart) &&\n                (index + 1 < oldChangePositions.length) &&\n                (oldChangePositions[index + 1].position <= bufferStart)) {\n                return false;\n              }\n              // Remove all quality changes after bufferEnd.\n              if (qualityChange.position >= bufferEnd) {\n                return false;\n              }\n              return true;\n            });\n    } else {\n      // Nothing is buffered; so remove all quality changes.\n      contentTypeState.qualityChangePositions = [];\n    }\n  }\n};\n\n/**\n  * @typedef {{\n  *   mediaQuality: !shaka.extern.MediaQualityInfo,\n  *   position: !number\n  * }}\n  *\n  * @description\n  * Identifies the position of a media quality change in the\n  * source buffer.\n  *\n  * @property {shaka.extern.MediaQualityInfo} !mediaQuality\n  *   The new media quality for content after position in the source buffer.\n  * @property {number} !position\n  *   A position in seconds in the source buffer\n  */\nshaka.media.QualityObserver.QualityChangePosition;\n\n/**\n  * @typedef {{\n  *  qualityChangePositions:\n  *   !Array.<shaka.media.QualityObserver.QualityChangePosition>,\n  *  currentQuality: ?shaka.extern.MediaQualityInfo,\n  *  contentType: !string\n  * }}\n  *\n  * @description\n  * Contains media quality information for a specific content type\n  * e.g video or audio.\n  *\n  * @property {!Array.<shaka.media.QualityObserver.QualityChangePosition>}\n  * qualityChangePositions\n  *   Quality changes ordered by position ascending.\n  * @property {?shaka.media.MediaQualityInfo} currentMediaQuality\n  *   The media quality at the playhead position.\n  * @property {string} contentType\n  *   The contentType e.g. 'video' or 'audio'\n  */\nshaka.media.QualityObserver.ContentTypeState;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.RegionTimeline');\n\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * The region timeline is a set of unique timeline region info entries. When\n * a new entry is added, the 'regionadd' event will be fired.  When an entry is\n * deleted, the 'regionremove' event will be fired.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.media.RegionTimeline = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!function():{start: number, end: number}} getSeekRange\n   */\n  constructor(getSeekRange) {\n    super();\n\n    /** @private {!Set.<shaka.extern.TimelineRegionInfo>} */\n    this.regions_ = new Set();\n\n    /** @private {!function():{start: number, end: number}} */\n    this.getSeekRange_ = getSeekRange;\n\n    /**\n     * Make sure all of the regions we're tracking are within the\n     * seek range or further in the future. We don't want to store\n     * regions that fall before the start of the seek range.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.filterTimer_ = new shaka.util.Timer(() => {\n      this.filterBySeekRange_();\n    }).tickEvery(\n        /* seconds= */ shaka.media.RegionTimeline.REGION_FILTER_INTERVAL);\n  }\n\n  /** @override */\n  release() {\n    this.regions_.clear();\n    this.filterTimer_.stop();\n    super.release();\n  }\n\n  /**\n   * @param {shaka.extern.TimelineRegionInfo} region\n   */\n  addRegion(region) {\n    const similarRegion = this.findSimilarRegion_(region);\n\n    // Make sure we don't add duplicate regions. We keep track of this here\n    // instead of making the parser track it.\n    if (similarRegion == null) {\n      this.regions_.add(region);\n      const event = new shaka.util.FakeEvent('regionadd', new Map([\n        ['region', region],\n      ]));\n      this.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @private\n   */\n  filterBySeekRange_() {\n    const seekRange = this.getSeekRange_();\n    for (const region of this.regions_) {\n      // Only consider the seek range start here.\n      // Future regions might become relevant eventually,\n      // but regions that are in the past and can't ever be\n      // seeked to will never come up again, and there's no\n      // reson to store or process them.\n      if (region.endTime < seekRange.start) {\n        this.regions_.delete(region);\n        const event = new shaka.util.FakeEvent('regionremove', new Map([\n          ['region', region],\n        ]));\n        this.dispatchEvent(event);\n      }\n    }\n  }\n\n  /**\n   * Find a region in the timeline that has the same scheme id uri, event id,\n   * start time and end time. If these four parameters match, we assume it\n   * to be the same region. If no similar region can be found, |null| will be\n   * returned.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @return {?shaka.extern.TimelineRegionInfo}\n   * @private\n   */\n  findSimilarRegion_(region) {\n    for (const existing of this.regions_) {\n      // The same scheme ID and time range means that it is similar-enough to\n      // be the same region.\n      const isSimilar = existing.schemeIdUri == region.schemeIdUri &&\n                        existing.id == region.id &&\n                        existing.startTime == region.startTime &&\n                        existing.endTime == region.endTime;\n\n      if (isSimilar) {\n        return existing;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get an iterable for all the regions in the timeline. This will allow\n   * others to see what regions are in the timeline while not being able to\n   * change the collection.\n   *\n   * @return {!Iterable.<shaka.extern.TimelineRegionInfo>}\n   */\n  regions() {\n    return this.regions_;\n  }\n};\n\n/** @const {number} */\nshaka.media.RegionTimeline.REGION_FILTER_INTERVAL = 2; // in seconds\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.RegionObserver');\n\ngoog.require('shaka.media.IPlayheadObserver');\ngoog.require('shaka.media.RegionTimeline');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\n\n\n/**\n * The region observer watches a region timeline and playhead, and fires events\n * ('enter', 'exit', 'skip') as the playhead moves.\n *\n * @implements {shaka.media.IPlayheadObserver}\n * @final\n */\nshaka.media.RegionObserver = class extends shaka.util.FakeEventTarget {\n  /**\n   * Create a region observer for the given timeline. The observer does not\n   * own the timeline, only uses it. This means that the observer should NOT\n   * destroy the timeline.\n   *\n   * @param {!shaka.media.RegionTimeline} timeline\n   */\n  constructor(timeline) {\n    super();\n\n    /** @private {shaka.media.RegionTimeline} */\n    this.timeline_ = timeline;\n\n    /**\n     * A mapping between a region and where we previously were relative to it.\n     * When the value here differs from what we calculate, it means we moved and\n     * should fire an event.\n     *\n     * @private {!Map.<shaka.extern.TimelineRegionInfo,\n     *                 shaka.media.RegionObserver.RelativePosition_>}\n     */\n    this.oldPosition_ = new Map();\n\n    // To make the rules easier to read, alias all the relative positions.\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n    const BEFORE_THE_REGION = RelativePosition.BEFORE_THE_REGION;\n    const IN_THE_REGION = RelativePosition.IN_THE_REGION;\n    const AFTER_THE_REGION = RelativePosition.AFTER_THE_REGION;\n\n    /**\n     * A read-only collection of rules for what to do when we change position\n     * relative to a region.\n     *\n     * @private {!Iterable.<shaka.media.RegionObserver.Rule_>}\n     */\n    this.rules_ = [\n      {\n        weWere: null,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('enter', region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('enter', region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: IN_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('enter', region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('exit', region, seeking),\n      },\n      {\n        weWere: IN_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('exit', region, seeking),\n      },\n      {\n        weWere: BEFORE_THE_REGION,\n        weAre: AFTER_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('skip', region, seeking),\n      },\n      {\n        weWere: AFTER_THE_REGION,\n        weAre: BEFORE_THE_REGION,\n        invoke: (region, seeking) => this.onEvent_('skip', region, seeking),\n      },\n    ];\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(this.timeline_, 'regionremove', (event) => {\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = event['region'];\n      this.oldPosition_.delete(region);\n    });\n  }\n\n  /** @override */\n  release() {\n    this.timeline_ = null;\n\n    // Clear our maps so that we are not holding onto any more information than\n    // needed.\n    this.oldPosition_.clear();\n\n    this.eventManager_.release();\n    this.eventManager_ = null;\n\n    super.release();\n  }\n\n  /** @override */\n  poll(positionInSeconds, wasSeeking) {\n    const RegionObserver = shaka.media.RegionObserver;\n\n    for (const region of this.timeline_.regions()) {\n      const previousPosition = this.oldPosition_.get(region);\n      const currentPosition = RegionObserver.determinePositionRelativeTo_(\n          region, positionInSeconds);\n\n      // We will only use |previousPosition| and |currentPosition|, so we can\n      // update our state now.\n      this.oldPosition_.set(region, currentPosition);\n\n      for (const rule of this.rules_) {\n        if (rule.weWere == previousPosition && rule.weAre == currentPosition) {\n          rule.invoke(region, wasSeeking);\n        }\n      }\n    }\n  }\n\n  /**\n   * Dispatch events of the given type.  All event types in this class have the\n   * same parameters: region and seeking.\n   *\n   * @param {string} eventType\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @param {boolean} seeking\n   * @private\n   */\n  onEvent_(eventType, region, seeking) {\n    const event = new shaka.util.FakeEvent(eventType, new Map([\n      ['region', region],\n      ['seeking', seeking],\n    ]));\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Get the relative position of the playhead to |region| when the playhead is\n   * at |seconds|. We treat the region's start and end times as inclusive\n   * bounds.\n   *\n   * @param {shaka.extern.TimelineRegionInfo} region\n   * @param {number} seconds\n   * @return {shaka.media.RegionObserver.RelativePosition_}\n   * @private\n   */\n  static determinePositionRelativeTo_(region, seconds) {\n    const RelativePosition = shaka.media.RegionObserver.RelativePosition_;\n\n    if (seconds < region.startTime) {\n      return RelativePosition.BEFORE_THE_REGION;\n    }\n\n    if (seconds > region.endTime) {\n      return RelativePosition.AFTER_THE_REGION;\n    }\n\n    return RelativePosition.IN_THE_REGION;\n  }\n};\n\n/**\n * An enum of relative positions between the playhead and a region. Each is\n * phrased so that it works in \"The playhead is X\" where \"X\" is any value in\n * the enum.\n *\n * @enum {number}\n * @private\n */\nshaka.media.RegionObserver.RelativePosition_ = {\n  BEFORE_THE_REGION: 1,\n  IN_THE_REGION: 2,\n  AFTER_THE_REGION: 3,\n};\n\n/**\n * All region observer events (onEnter, onExit, and onSkip) will be passed the\n * region that the playhead is interacting with and whether or not the playhead\n * moving is part of a seek event.\n *\n * @typedef {function(shaka.extern.TimelineRegionInfo, boolean)}\n */\nshaka.media.RegionObserver.EventListener;\n\n/**\n * @typedef {{\n *    weWere: ?shaka.media.RegionObserver.RelativePosition_,\n *    weAre: ?shaka.media.RegionObserver.RelativePosition_,\n *    invoke: shaka.media.RegionObserver.EventListener\n * }}\n *\n * @private\n */\nshaka.media.RegionObserver.Rule_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Networking');\n\ngoog.require('shaka.net.NetworkingEngine');\n\n\n/**\n * A collection of shared utilities that bridge the gap between our networking\n * code and the other parts of our code base. This is to allow\n * |shaka.net.NetworkingEngine| to remain general.\n *\n * @final\n */\nshaka.util.Networking = class {\n  /**\n   * Create a request message for a segment. Providing |start| and |end|\n   * will set the byte range. A non-zero start must be provided for |end| to\n   * be used.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} start\n   * @param {?number} end\n   * @param {shaka.extern.RetryParameters} retryParameters\n   * @param {?function(BufferSource):!Promise=} streamDataCallback\n   * @return {shaka.extern.Request}\n   */\n  static createSegmentRequest(uris, start, end, retryParameters,\n      streamDataCallback) {\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        uris, retryParameters, streamDataCallback);\n\n    if (start == 0 && end == null) {\n      // This is a request for the entire segment.  The Range header is not\n      // required.  Note that some web servers don't accept Range headers, so\n      // don't set one if it's not strictly required.\n    } else {\n      if (end) {\n        request.headers['Range'] = 'bytes=' + start + '-' + end;\n      } else {\n        request.headers['Range'] = 'bytes=' + start + '-';\n      }\n    }\n\n    return request;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.media.StreamingEngine');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.SegmentIterator');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.Backoff');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.DelayedTick');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Id3Utils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Networking');\n\n\n/**\n * @summary Creates a Streaming Engine.\n * The StreamingEngine is responsible for setting up the Manifest's Streams\n * (i.e., for calling each Stream's createSegmentIndex() function), for\n * downloading segments, for co-ordinating audio, video, and text buffering.\n * The StreamingEngine provides an interface to switch between Streams, but it\n * does not choose which Streams to switch to.\n *\n * The StreamingEngine does not need to be notified about changes to the\n * Manifest's SegmentIndexes; however, it does need to be notified when new\n * Variants are added to the Manifest.\n *\n * To start the StreamingEngine the owner must first call configure(), followed\n * by one call to switchVariant(), one optional call to switchTextStream(), and\n * finally a call to start().  After start() resolves, switch*() can be used\n * freely.\n *\n * The owner must call seeked() each time the playhead moves to a new location\n * within the presentation timeline; however, the owner may forego calling\n * seeked() when the playhead moves outside the presentation timeline.\n *\n * @implements {shaka.util.IDestroyable}\n */\nshaka.media.StreamingEngine = class {\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.media.StreamingEngine.PlayerInterface} playerInterface\n   */\n  constructor(manifest, playerInterface) {\n    /** @private {?shaka.media.StreamingEngine.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = manifest;\n\n    /** @private {?shaka.extern.StreamingConfiguration} */\n    this.config_ = null;\n\n    /** @private {number} */\n    this.bufferingGoalScale_ = 1;\n\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentTextStream_ = null;\n\n    /** @private {boolean} */\n    this.parsedPrftEventRaised_ = false;\n\n    /**\n     * Maps a content type, e.g., 'audio', 'video', or 'text', to a MediaState.\n     *\n     * @private {!Map.<shaka.util.ManifestParserUtils.ContentType,\n     *                 !shaka.media.StreamingEngine.MediaState_>}\n     */\n    this.mediaStates_ = new Map();\n\n    /**\n     * Set to true once the initial media states have been created.\n     *\n     * @private {boolean}\n     */\n    this.startupComplete_ = false;\n\n    /**\n     * Used for delay and backoff of failure callbacks, so that apps do not\n     * retry instantly.\n     *\n     * @private {shaka.net.Backoff}\n     */\n    this.failureCallbackBackoff_ = null;\n\n    /**\n     * Set to true on fatal error.  Interrupts fetchAndAppend_().\n     *\n     * @private {boolean}\n     */\n    this.fatalError_ = false;\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async doDestroy_() {\n    const aborts = [];\n\n    for (const state of this.mediaStates_.values()) {\n      this.cancelUpdate_(state);\n      aborts.push(this.abortOperations_(state));\n    }\n\n    await Promise.all(aborts);\n\n    this.mediaStates_.clear();\n\n    this.playerInterface_ = null;\n    this.manifest_ = null;\n    this.config_ = null;\n  }\n\n  /**\n   * Called by the Player to provide an updated configuration any time it\n   * changes. Must be called at least once before start().\n   *\n   * @param {shaka.extern.StreamingConfiguration} config\n   */\n  configure(config) {\n    this.config_ = config;\n\n    // Create separate parameters for backoff during streaming failure.\n\n    /** @type {shaka.extern.RetryParameters} */\n    const failureRetryParams = {\n      // The term \"attempts\" includes the initial attempt, plus all retries.\n      // In order to see a delay, there would have to be at least 2 attempts.\n      maxAttempts: Math.max(config.retryParameters.maxAttempts, 2),\n      baseDelay: config.retryParameters.baseDelay,\n      backoffFactor: config.retryParameters.backoffFactor,\n      fuzzFactor: config.retryParameters.fuzzFactor,\n      timeout: 0,  // irrelevant\n      stallTimeout: 0, // irrelevant\n      connectionTimeout: 0, // irrelevant\n    };\n\n    // We don't want to ever run out of attempts.  The application should be\n    // allowed to retry streaming infinitely if it wishes.\n    const autoReset = true;\n    this.failureCallbackBackoff_ =\n        new shaka.net.Backoff(failureRetryParams, autoReset);\n  }\n\n\n  /**\n   * Initialize and start streaming.\n   *\n   * By calling this method, StreamingEngine will start streaming the variant\n   * chosen by a prior call to switchVariant(), and optionally, the text stream\n   * chosen by a prior call to switchTextStream().  Once the Promise resolves,\n   * switch*() may be called freely.\n   *\n   * @return {!Promise}\n   */\n  async start() {\n    goog.asserts.assert(this.config_,\n        'StreamingEngine configure() must be called before init()!');\n\n    // Setup the initial set of Streams and then begin each update cycle.\n    await this.initStreams_();\n    this.destroyer_.ensureNotDestroyed();\n\n    shaka.log.debug('init: completed initial Stream setup');\n    this.startupComplete_ = true;\n  }\n\n  /**\n   * Get the current variant we are streaming.  Returns null if nothing is\n   * streaming.\n   * @return {?shaka.extern.Variant}\n   */\n  getCurrentVariant() {\n    return this.currentVariant_;\n  }\n\n  /**\n   * Get the text stream we are streaming.  Returns null if there is no text\n   * streaming.\n   * @return {?shaka.extern.Stream}\n   */\n  getCurrentTextStream() {\n    return this.currentTextStream_;\n  }\n\n  /**\n   * Start streaming text, creating a new media state.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {!Promise}\n   * @private\n   */\n  async loadNewTextStream_(stream) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(!this.mediaStates_.has(ContentType.TEXT),\n        'Should not call loadNewTextStream_ while streaming text!');\n\n    try {\n      // Clear MediaSource's buffered text, so that the new text stream will\n      // properly replace the old buffered text.\n      // TODO: Should this happen in unloadTextStream() instead?\n      await this.playerInterface_.mediaSourceEngine.clear(ContentType.TEXT);\n    } catch (error) {\n      if (this.playerInterface_) {\n        this.playerInterface_.onError(error);\n      }\n    }\n\n    const mimeType = shaka.util.MimeUtils.getFullType(\n        stream.mimeType, stream.codecs);\n    this.playerInterface_.mediaSourceEngine.reinitText(\n        mimeType, this.manifest_.sequenceMode);\n\n    const textDisplayer =\n        this.playerInterface_.mediaSourceEngine.getTextDisplayer();\n    const streamText =\n        textDisplayer.isTextVisible() || this.config_.alwaysStreamText;\n\n    if (streamText) {\n      const state = this.createMediaState_(stream);\n      this.mediaStates_.set(ContentType.TEXT, state);\n      this.scheduleUpdate_(state, 0);\n    }\n  }\n\n\n  /**\n   * Stop fetching text stream when the user chooses to hide the captions.\n   */\n  unloadTextStream() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const state = this.mediaStates_.get(ContentType.TEXT);\n    if (state) {\n      this.cancelUpdate_(state);\n      this.abortOperations_(state).catch(() => {});\n      this.mediaStates_.delete(ContentType.TEXT);\n    }\n    this.currentTextStream_ = null;\n  }\n\n  /**\n   * Set trick play on or off.\n   * If trick play is on, related trick play streams will be used when possible.\n   * @param {boolean} on\n   */\n  setTrickPlay(on) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const mediaState = this.mediaStates_.get(ContentType.VIDEO);\n    if (!mediaState) {\n      return;\n    }\n\n    const stream = mediaState.stream;\n    if (!stream) {\n      return;\n    }\n\n    shaka.log.debug('setTrickPlay', on);\n    if (on) {\n      const trickModeVideo = stream.trickModeVideo;\n      if (!trickModeVideo) {\n        return;  // Can't engage trick play.\n      }\n\n      const normalVideo = mediaState.restoreStreamAfterTrickPlay;\n      if (normalVideo) {\n        return;  // Already in trick play.\n      }\n\n      shaka.log.debug('Engaging trick mode stream', trickModeVideo);\n      this.switchInternal_(trickModeVideo, /* clearBuffer= */ false,\n          /* safeMargin= */ 0, /* force= */ false);\n\n      mediaState.restoreStreamAfterTrickPlay = stream;\n    } else {\n      const normalVideo = mediaState.restoreStreamAfterTrickPlay;\n      if (!normalVideo) {\n        return;\n      }\n\n      shaka.log.debug('Restoring non-trick-mode stream', normalVideo);\n      mediaState.restoreStreamAfterTrickPlay = null;\n      this.switchInternal_(normalVideo, /* clearBuffer= */ true,\n          /* safeMargin= */ 0, /* force= */ false);\n    }\n  }\n\n\n  /**\n   * @param {shaka.extern.Variant} variant\n   * @param {boolean=} clearBuffer\n   * @param {number=} safeMargin\n   * @param {boolean=} force\n   *   If true, reload the variant even if it did not change.\n   * @param {boolean=} adaptation\n   *   If true, update the media state to indicate MediaSourceEngine should\n   *   reset the timestamp offset to ensure the new track segments are correctly\n   *   placed on the timeline.\n   */\n  switchVariant(\n      variant, clearBuffer = false, safeMargin = 0, force = false,\n      adaptation = false) {\n    this.currentVariant_ = variant;\n\n    if (!this.startupComplete_) {\n      // The selected variant will be used in start().\n      return;\n    }\n\n    if (variant.video) {\n      this.switchInternal_(\n          variant.video, /* clearBuffer= */ clearBuffer,\n          /* safeMargin= */ safeMargin, /* force= */ force,\n          /* adaptation= */ adaptation);\n    }\n    if (variant.audio) {\n      this.switchInternal_(\n          variant.audio, /* clearBuffer= */ clearBuffer,\n          /* safeMargin= */ safeMargin, /* force= */ force,\n          /* adaptation= */ adaptation);\n    }\n  }\n\n\n  /**\n   * @param {shaka.extern.Stream} textStream\n   */\n  switchTextStream(textStream) {\n    this.currentTextStream_ = textStream;\n\n    if (!this.startupComplete_) {\n      // The selected text stream will be used in start().\n      return;\n    }\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    goog.asserts.assert(textStream && textStream.type == ContentType.TEXT,\n        'Wrong stream type passed to switchTextStream!');\n\n    this.switchInternal_(\n        textStream, /* clearBuffer= */ true,\n        /* safeMargin= */ 0, /* force= */ false);\n  }\n\n\n  /** Reload the current text stream. */\n  reloadTextStream() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const mediaState = this.mediaStates_.get(ContentType.TEXT);\n    if (mediaState) { // Don't reload if there's no text to begin with.\n      this.switchInternal_(\n          mediaState.stream, /* clearBuffer= */ true,\n          /* safeMargin= */ 0, /* force= */ true);\n    }\n  }\n\n\n  /**\n   * Switches to the given Stream. |stream| may be from any Variant.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @param {boolean} clearBuffer\n   * @param {number} safeMargin\n   * @param {boolean} force\n   *   If true, reload the text stream even if it did not change.\n   * @param {boolean=} adaptation\n   *   If true, update the media state to indicate MediaSourceEngine should\n   *   reset the timestamp offset to ensure the new track segments are correctly\n   *   placed on the timeline.\n   * @private\n   */\n  switchInternal_(stream, clearBuffer, safeMargin, force, adaptation) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const type = /** @type {!ContentType} */(stream.type);\n    const mediaState = this.mediaStates_.get(type);\n\n    if (!mediaState && stream.type == ContentType.TEXT) {\n      this.loadNewTextStream_(stream);\n      return;\n    }\n\n    goog.asserts.assert(mediaState, 'switch: expected mediaState to exist');\n    if (!mediaState) {\n      return;\n    }\n\n    if (mediaState.restoreStreamAfterTrickPlay) {\n      shaka.log.debug('switch during trick play mode', stream);\n\n      // Already in trick play mode, so stick with trick mode tracks if\n      // possible.\n      if (stream.trickModeVideo) {\n        // Use the trick mode stream, but revert to the new selection later.\n        mediaState.restoreStreamAfterTrickPlay = stream;\n        stream = stream.trickModeVideo;\n        shaka.log.debug('switch found trick play stream', stream);\n      } else {\n        // There is no special trick mode video for this stream!\n        mediaState.restoreStreamAfterTrickPlay = null;\n        shaka.log.debug('switch found no special trick play stream');\n      }\n    }\n\n    if (mediaState.stream == stream && !force) {\n      const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n      shaka.log.debug('switch: Stream ' + streamTag + ' already active');\n      return;\n    }\n\n    if (stream.type == ContentType.TEXT) {\n      // Mime types are allowed to change for text streams.\n      // Reinitialize the text parser, but only if we are going to fetch the\n      // init segment again.\n      const fullMimeType = shaka.util.MimeUtils.getFullType(\n          stream.mimeType, stream.codecs);\n      this.playerInterface_.mediaSourceEngine.reinitText(\n          fullMimeType, this.manifest_.sequenceMode);\n    }\n\n    // Releases the segmentIndex of the old stream.\n    if (mediaState.stream.closeSegmentIndex) {\n      mediaState.stream.closeSegmentIndex();\n    }\n\n    mediaState.stream = stream;\n    mediaState.segmentIterator = null;\n    mediaState.adaptation = !!adaptation;\n\n    const streamTag = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.debug('switch: switching to Stream ' + streamTag);\n\n    if (clearBuffer) {\n      if (mediaState.clearingBuffer) {\n        // We are already going to clear the buffer, but make sure it is also\n        // flushed.\n        mediaState.waitingToFlushBuffer = true;\n      } else if (mediaState.performingUpdate) {\n        // We are performing an update, so we have to wait until it's finished.\n        // onUpdate_() will call clearBuffer_() when the update has finished.\n        // We need to save the safe margin because its value will be needed when\n        // clearing the buffer after the update.\n        mediaState.waitingToClearBuffer = true;\n        mediaState.clearBufferSafeMargin = safeMargin;\n        mediaState.waitingToFlushBuffer = true;\n      } else {\n        // Cancel the update timer, if any.\n        this.cancelUpdate_(mediaState);\n        // Clear right away.\n        this.clearBuffer_(mediaState, /* flush= */ true, safeMargin)\n            .catch((error) => {\n              if (this.playerInterface_) {\n                goog.asserts.assert(error instanceof shaka.util.Error,\n                    'Wrong error type!');\n                this.playerInterface_.onError(error);\n              }\n            });\n      }\n    }\n\n    this.makeAbortDecision_(mediaState).catch((error) => {\n      if (this.playerInterface_) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        this.playerInterface_.onError(error);\n      }\n    });\n  }\n\n\n  /**\n   * Decide if it makes sense to abort the current operation, and abort it if\n   * so.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  async makeAbortDecision_(mediaState) {\n    // If the operation is completed, it will be set to null, and there's no\n    // need to abort the request.\n    if (!mediaState.operation) {\n      return;\n    }\n\n    const originalStream = mediaState.stream;\n    const originalOperation = mediaState.operation;\n\n    if (!originalStream.segmentIndex) {\n      // Create the new segment index so the time taken is accounted for when\n      // deciding whether to abort.\n      await originalStream.createSegmentIndex();\n    }\n\n    if (mediaState.operation != originalOperation) {\n      // The original operation completed while we were getting a segment index,\n      // so there's nothing to do now.\n      return;\n    }\n\n    if (mediaState.stream != originalStream) {\n      // The stream changed again while we were getting a segment index.  We\n      // can't carry out this check, since another one might be in progress by\n      // now.\n      return;\n    }\n\n    goog.asserts.assert(mediaState.stream.segmentIndex,\n        'Segment index should exist by now!');\n\n    if (this.shouldAbortCurrentRequest_(mediaState)) {\n      shaka.log.info('Aborting current segment request.');\n      mediaState.operation.abort();\n    }\n  }\n\n  /**\n   * Returns whether we should abort the current request.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {boolean}\n   * @private\n   */\n  shouldAbortCurrentRequest_(mediaState) {\n    goog.asserts.assert(mediaState.operation,\n        'Abort logic requires an ongoing operation!');\n    goog.asserts.assert(mediaState.stream && mediaState.stream.segmentIndex,\n        'Abort logic requires a segment index');\n\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const bufferEnd =\n        this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n\n    // The next segment to append from the current stream.  This doesn't\n    // account for a pending network request and will likely be different from\n    // that since we just switched.\n    const timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n    const index = mediaState.stream.segmentIndex.find(timeNeeded);\n    const newSegment =\n        index == null ? null : mediaState.stream.segmentIndex.get(index);\n\n    let newSegmentSize = newSegment ? newSegment.getSize() : null;\n    if (newSegment && !newSegmentSize) {\n      // compute approximate segment size using stream bandwidth\n      const duration = newSegment.getEndTime() - newSegment.getStartTime();\n      const bandwidth = mediaState.stream.bandwidth || 0;\n      // bandwidth is in bits per second, and the size is in bytes\n      newSegmentSize = duration * bandwidth / 8;\n    }\n\n    if (!newSegmentSize) {\n      return false;\n    }\n\n    // When switching, we'll need to download the init segment.\n    const init = newSegment.initSegmentReference;\n    if (init) {\n      newSegmentSize += init.getSize() || 0;\n    }\n\n    const bandwidthEstimate = this.playerInterface_.getBandwidthEstimate();\n\n    // The estimate is in bits per second, and the size is in bytes.  The time\n    // remaining is in seconds after this calculation.\n    const timeToFetchNewSegment = (newSegmentSize * 8) / bandwidthEstimate;\n\n    // If the new segment can be finished in time without risking a buffer\n    // underflow, we should abort the old one and switch.\n    const bufferedAhead = (bufferEnd || 0) - presentationTime;\n    const safetyBuffer = Math.max(\n        this.manifest_.minBufferTime || 0,\n        this.config_.rebufferingGoal);\n    const safeBufferedAhead = bufferedAhead - safetyBuffer;\n    if (timeToFetchNewSegment < safeBufferedAhead) {\n      return true;\n    }\n\n    // If the thing we want to switch to will be done more quickly than what\n    // we've got in progress, we should abort the old one and switch.\n    const bytesRemaining = mediaState.operation.getBytesRemaining();\n    if (bytesRemaining > newSegmentSize) {\n      return true;\n    }\n\n    // Otherwise, complete the operation in progress.\n    return false;\n  }\n\n\n  /**\n   * Notifies the StreamingEngine that the playhead has moved to a valid time\n   * within the presentation timeline.\n   */\n  seeked() {\n    if (!this.playerInterface_) {\n      // Already destroyed.\n      return;\n    }\n\n    const presentationTime = this.playerInterface_.getPresentationTime();\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const newTimeIsBuffered = (type) => {\n      return this.playerInterface_.mediaSourceEngine.isBuffered(\n          type, presentationTime);\n    };\n\n    let streamCleared = false;\n    for (const type of this.mediaStates_.keys()) {\n      const mediaState = this.mediaStates_.get(type);\n      const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n      // Always clear the iterator since we need to start streaming from the\n      // new time.  This also happens in clearBuffer_, but if we don't clear,\n      // we still want to reset the iterator.\n      mediaState.segmentIterator = null;\n\n      if (!newTimeIsBuffered(type)) {\n        const bufferEnd =\n            this.playerInterface_.mediaSourceEngine.bufferEnd(type);\n        const somethingBuffered = bufferEnd != null;\n\n        // Don't clear the buffer unless something is buffered.  This extra\n        // check prevents extra, useless calls to clear the buffer.\n        if (somethingBuffered || mediaState.performingUpdate) {\n          this.forceClearBuffer_(mediaState);\n          streamCleared = true;\n        }\n\n        // If there is an operation in progress, stop it now.\n        if (mediaState.operation) {\n          mediaState.operation.abort();\n          shaka.log.debug(logPrefix, 'Aborting operation due to seek');\n          mediaState.operation = null;\n        }\n\n        // The pts has shifted from the seek, invalidating captions currently\n        // in the text buffer. Thus, clear and reset the caption parser.\n        if (type === ContentType.TEXT) {\n          this.playerInterface_.mediaSourceEngine.resetCaptionParser();\n        }\n\n        // Mark the media state as having seeked, so that the new buffers know\n        // that they will need to be at a new position (for sequence mode).\n        mediaState.seeked = true;\n      }\n    }\n\n    if (!streamCleared) {\n      shaka.log.debug(\n          '(all): seeked: buffered seek: presentationTime=' + presentationTime);\n    }\n  }\n\n\n  /**\n   * Clear the buffer for a given stream.  Unlike clearBuffer_, this will handle\n   * cases where a MediaState is performing an update.  After this runs, the\n   * MediaState will have a pending update.\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  forceClearBuffer_(mediaState) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    if (mediaState.clearingBuffer) {\n      // We're already clearing the buffer, so we don't need to clear the\n      // buffer again.\n      shaka.log.debug(logPrefix, 'clear: already clearing the buffer');\n      return;\n    }\n\n    if (mediaState.waitingToClearBuffer) {\n      // May not be performing an update, but an update will still happen.\n      // See: https://github.com/shaka-project/shaka-player/issues/334\n      shaka.log.debug(logPrefix, 'clear: already waiting');\n      return;\n    }\n\n    if (mediaState.performingUpdate) {\n      // We are performing an update, so we have to wait until it's finished.\n      // onUpdate_() will call clearBuffer_() when the update has finished.\n      shaka.log.debug(logPrefix, 'clear: currently updating');\n      mediaState.waitingToClearBuffer = true;\n      // We can set the offset to zero to remember that this was a call to\n      // clearAllBuffers.\n      mediaState.clearBufferSafeMargin = 0;\n      return;\n    }\n\n    const type = mediaState.type;\n    if (this.playerInterface_.mediaSourceEngine.bufferStart(type) == null) {\n      // Nothing buffered.\n      shaka.log.debug(logPrefix, 'clear: nothing buffered');\n      if (mediaState.updateTimer == null) {\n        // Note: an update cycle stops when we buffer to the end of the\n        // presentation, or when we raise an error.\n        this.scheduleUpdate_(mediaState, 0);\n      }\n      return;\n    }\n\n    // An update may be scheduled, but we can just cancel it and clear the\n    // buffer right away. Note: clearBuffer_() will schedule the next update.\n    shaka.log.debug(logPrefix, 'clear: handling right now');\n    this.cancelUpdate_(mediaState);\n    this.clearBuffer_(mediaState, /* flush= */ false, 0).catch((error) => {\n      if (this.playerInterface_) {\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        this.playerInterface_.onError(error);\n      }\n    });\n  }\n\n\n  /**\n   * Initializes the initial streams and media states.  This will schedule\n   * updates for the given types.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async initStreams_() {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    goog.asserts.assert(this.config_,\n        'StreamingEngine configure() must be called before init()!');\n\n    if (!this.currentVariant_) {\n      shaka.log.error('init: no Streams chosen');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STREAMING,\n          shaka.util.Error.Code.STREAMING_ENGINE_STARTUP_INVALID_STATE);\n    }\n\n    /**\n     * @type {!Map.<shaka.util.ManifestParserUtils.ContentType,\n     *              shaka.extern.Stream>}\n     */\n    const streamsByType = new Map();\n    /** @type {!Set.<shaka.extern.Stream>} */\n    const streams = new Set();\n\n    if (this.currentVariant_.audio) {\n      streamsByType.set(ContentType.AUDIO, this.currentVariant_.audio);\n      streams.add(this.currentVariant_.audio);\n    }\n\n    if (this.currentVariant_.video) {\n      streamsByType.set(ContentType.VIDEO, this.currentVariant_.video);\n      streams.add(this.currentVariant_.video);\n    }\n\n    if (this.currentTextStream_) {\n      streamsByType.set(ContentType.TEXT, this.currentTextStream_);\n      streams.add(this.currentTextStream_);\n    }\n\n    // Init MediaSourceEngine.\n    const mediaSourceEngine = this.playerInterface_.mediaSourceEngine;\n    const forceTransmux = this.config_.forceTransmux;\n\n    await mediaSourceEngine.init(streamsByType, forceTransmux,\n        this.manifest_.sequenceMode);\n    this.destroyer_.ensureNotDestroyed();\n\n    this.updateDuration();\n\n    for (const type of streamsByType.keys()) {\n      const stream = streamsByType.get(type);\n      if (!this.mediaStates_.has(type)) {\n        const mediaState = this.createMediaState_(stream);\n        this.mediaStates_.set(type, mediaState);\n        this.scheduleUpdate_(mediaState, 0);\n      }\n    }\n  }\n\n\n  /**\n   * Creates a media state.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.media.StreamingEngine.MediaState_}\n   * @private\n   */\n  createMediaState_(stream) {\n    return /** @type {shaka.media.StreamingEngine.MediaState_} */ ({\n      stream,\n      type: stream.type,\n      segmentIterator: null,\n      lastSegmentReference: null,\n      lastInitSegmentReference: null,\n      lastTimestampOffset: null,\n      lastAppendWindowStart: null,\n      lastAppendWindowEnd: null,\n      restoreStreamAfterTrickPlay: null,\n      endOfStream: false,\n      performingUpdate: false,\n      updateTimer: null,\n      waitingToClearBuffer: false,\n      clearBufferSafeMargin: 0,\n      waitingToFlushBuffer: false,\n      clearingBuffer: false,\n      // The playhead might be seeking on startup, if a start time is set, so\n      // start \"seeked\" as true.\n      seeked: true,\n      needsResync: false,\n      recovering: false,\n      hasError: false,\n      operation: null,\n    });\n  }\n\n\n  /**\n   * Sets the MediaSource's duration.\n   */\n  updateDuration() {\n    const duration = this.manifest_.presentationTimeline.getDuration();\n    if (duration < Infinity) {\n      this.playerInterface_.mediaSourceEngine.setDuration(duration);\n    } else {\n      // Not all platforms support infinite durations, so set a finite duration\n      // so we can append segments and so the user agent can seek.\n      this.playerInterface_.mediaSourceEngine.setDuration(Math.pow(2, 32));\n    }\n  }\n\n\n  /**\n   * Called when |mediaState|'s update timer has expired.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @suppress {suspiciousCode} The compiler assumes that updateTimer can't\n   *   change during the await, and so complains about the null check.\n   * @private\n   */\n  async onUpdate_(mediaState) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // Sanity check.\n    goog.asserts.assert(\n        !mediaState.performingUpdate && (mediaState.updateTimer != null),\n        logPrefix + ' unexpected call to onUpdate_()');\n    if (mediaState.performingUpdate || (mediaState.updateTimer == null)) {\n      return;\n    }\n\n    goog.asserts.assert(\n        !mediaState.clearingBuffer, logPrefix +\n        ' onUpdate_() should not be called when clearing the buffer');\n    if (mediaState.clearingBuffer) {\n      return;\n    }\n\n    mediaState.updateTimer = null;\n\n    // Handle pending buffer clears.\n    if (mediaState.waitingToClearBuffer) {\n      // Note: clearBuffer_() will schedule the next update.\n      shaka.log.debug(logPrefix, 'skipping update and clearing the buffer');\n      await this.clearBuffer_(\n          mediaState, mediaState.waitingToFlushBuffer,\n          mediaState.clearBufferSafeMargin);\n      return;\n    }\n\n    // Make sure the segment index exists. If not, create the segment index.\n    if (!mediaState.stream.segmentIndex) {\n      const thisStream = mediaState.stream;\n\n      await mediaState.stream.createSegmentIndex();\n\n      if (thisStream != mediaState.stream) {\n        // We switched streams while in the middle of this async call to\n        // createSegmentIndex.  Abandon this update and schedule a new one if\n        // there's not already one pending.\n        // Releases the segmentIndex of the old stream.\n        if (thisStream.closeSegmentIndex) {\n          goog.asserts.assert(!mediaState.stream.segmentIndex,\n              'mediastate.stream should not have segmentIndex yet.');\n          thisStream.closeSegmentIndex();\n        }\n        if (!mediaState.performingUpdate && !mediaState.updateTimer) {\n          this.scheduleUpdate_(mediaState, 0);\n        }\n        return;\n      }\n    }\n\n    // Update the MediaState.\n    try {\n      const delay = this.update_(mediaState);\n      if (delay != null) {\n        this.scheduleUpdate_(mediaState, delay);\n        mediaState.hasError = false;\n      }\n    } catch (error) {\n      await this.handleStreamingError_(error);\n      return;\n    }\n\n    const mediaStates = Array.from(this.mediaStates_.values());\n\n    // Check if we've buffered to the end of the presentation.  We delay adding\n    // the audio and video media states, so it is possible for the text stream\n    // to be the only state and buffer to the end.  So we need to wait until we\n    // have completed startup to determine if we have reached the end.\n    if (this.startupComplete_ &&\n        mediaStates.every((ms) => ms.endOfStream)) {\n      shaka.log.v1(logPrefix, 'calling endOfStream()...');\n      await this.playerInterface_.mediaSourceEngine.endOfStream();\n      this.destroyer_.ensureNotDestroyed();\n\n      // If the media segments don't reach the end, then we need to update the\n      // timeline duration to match the final media duration to avoid\n      // buffering forever at the end.\n      // We should only do this if the duration needs to shrink.\n      // Growing it by less than 1ms can actually cause buffering on\n      // replay, as in https://github.com/shaka-project/shaka-player/issues/979\n      // On some platforms, this can spuriously be 0, so ignore this case.\n      // https://github.com/shaka-project/shaka-player/issues/1967,\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      if (duration != 0 &&\n          duration < this.manifest_.presentationTimeline.getDuration()) {\n        this.manifest_.presentationTimeline.setDuration(duration);\n      }\n    }\n  }\n\n\n  /**\n   * Updates the given MediaState.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {?number} The number of seconds to wait until updating again or\n   *   null if another update does not need to be scheduled.\n   * @private\n   */\n  update_(mediaState) {\n    goog.asserts.assert(this.manifest_, 'manifest_ should not be null');\n    goog.asserts.assert(this.config_, 'config_ should not be null');\n\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Do not schedule update for closed captions text mediastate, since closed\n    // captions are embedded in video streams.\n    if (shaka.media.StreamingEngine.isEmbeddedText_(mediaState)) {\n      this.playerInterface_.mediaSourceEngine.setSelectedClosedCaptionId(\n          mediaState.stream.originalId || '');\n      return null;\n    } else if (mediaState.type == ContentType.TEXT) {\n      // Disable embedded captions if not desired (e.g. if transitioning from\n      // embedded to not-embedded captions).\n      this.playerInterface_.mediaSourceEngine.clearSelectedClosedCaptionId();\n    }\n\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // Compute how far we've buffered ahead of the playhead.\n    const presentationTime = this.playerInterface_.getPresentationTime();\n\n    // Get the next timestamp we need.\n    const timeNeeded = this.getTimeNeeded_(mediaState, presentationTime);\n    shaka.log.v2(logPrefix, 'timeNeeded=' + timeNeeded);\n\n    // Get the amount of content we have buffered, accounting for drift.  This\n    // is only used to determine if we have meet the buffering goal.  This\n    // should be the same method that PlayheadObserver uses.\n    const bufferedAhead =\n        this.playerInterface_.mediaSourceEngine.bufferedAheadOf(\n            mediaState.type, presentationTime);\n\n    shaka.log.v2(logPrefix,\n        'update_:',\n        'presentationTime=' + presentationTime,\n        'bufferedAhead=' + bufferedAhead);\n\n    const unscaledBufferingGoal = Math.max(\n        this.manifest_.minBufferTime || 0,\n        this.config_.rebufferingGoal,\n        this.config_.bufferingGoal);\n\n    const scaledBufferingGoal =\n        unscaledBufferingGoal * this.bufferingGoalScale_;\n\n    // Check if we've buffered to the end of the presentation.\n    const timeUntilEnd =\n        this.manifest_.presentationTimeline.getDuration() - timeNeeded;\n    const oneMicrosecond = 1e-6;\n\n    const bufferEnd =\n      this.playerInterface_.mediaSourceEngine.bufferEnd(mediaState.type);\n\n    if (timeUntilEnd < oneMicrosecond && !!bufferEnd) {\n      // We shouldn't rebuffer if the playhead is close to the end of the\n      // presentation.\n      shaka.log.debug(logPrefix, 'buffered to end of presentation');\n      mediaState.endOfStream = true;\n\n      if (mediaState.type == ContentType.VIDEO) {\n        // Since the text stream of CEA closed captions doesn't have update\n        // timer, we have to set the text endOfStream based on the video\n        // stream's endOfStream state.\n        const textState = this.mediaStates_.get(ContentType.TEXT);\n        if (textState &&\n            shaka.media.StreamingEngine.isEmbeddedText_(textState)) {\n          textState.endOfStream = true;\n        }\n      }\n      return null;\n    }\n    mediaState.endOfStream = false;\n\n    // If we've buffered to the buffering goal then schedule an update.\n    if (bufferedAhead >= scaledBufferingGoal) {\n      shaka.log.v2(logPrefix, 'buffering goal met');\n\n      // Do not try to predict the next update.  Just poll according to\n      // configuration (seconds). The playback rate can change at any time, so\n      // any prediction we make now could be terribly invalid soon.\n      return this.config_.updateIntervalSeconds / 2;\n    }\n\n    const reference = this.getSegmentReferenceNeeded_(\n        mediaState, presentationTime, bufferEnd);\n    if (!reference) {\n      // The segment could not be found, does not exist, or is not available.\n      // In any case just try again... if the manifest is incomplete or is not\n      // being updated then we'll idle forever; otherwise, we'll end up getting\n      // a SegmentReference eventually.\n      return this.config_.updateIntervalSeconds;\n    }\n\n    // Do not let any one stream get far ahead of any other.\n    let minTimeNeeded = Infinity;\n    const mediaStates = Array.from(this.mediaStates_.values());\n    for (const otherState of mediaStates) {\n      // Do not consider embedded captions in this calculation.  It could lead\n      // to hangs in streaming.\n      if (shaka.media.StreamingEngine.isEmbeddedText_(otherState)) {\n        continue;\n      }\n      // If there is no next segment, ignore this stream.  This happens with\n      // text when there's a Period with no text in it.\n      if (otherState.segmentIterator && !otherState.segmentIterator.current()) {\n        continue;\n      }\n\n      const timeNeeded = this.getTimeNeeded_(otherState, presentationTime);\n      minTimeNeeded = Math.min(minTimeNeeded, timeNeeded);\n    }\n\n    const maxSegmentDuration =\n        this.manifest_.presentationTimeline.getMaxSegmentDuration();\n    const maxRunAhead = maxSegmentDuration *\n        shaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_;\n    if (timeNeeded >= minTimeNeeded + maxRunAhead) {\n      // Wait and give other media types time to catch up to this one.\n      // For example, let video buffering catch up to audio buffering before\n      // fetching another audio segment.\n      shaka.log.v2(logPrefix, 'waiting for other streams to buffer');\n      return this.config_.updateIntervalSeconds;\n    }\n\n    const p = this.fetchAndAppend_(mediaState, presentationTime, reference);\n    p.catch(() => {});  // TODO(#1993): Handle asynchronous errors.\n    return null;\n  }\n\n\n  /**\n   * Gets the next timestamp needed. Returns the playhead's position if the\n   * buffer is empty; otherwise, returns the time at which the last segment\n   * appended ends.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @return {number} The next timestamp needed.\n   * @private\n   */\n  getTimeNeeded_(mediaState, presentationTime) {\n    // Get the next timestamp we need. We must use |lastSegmentReference|\n    // to determine this and not the actual buffer for two reasons:\n    //   1. Actual segments end slightly before their advertised end times, so\n    //      the next timestamp we need is actually larger than |bufferEnd|.\n    //   2. There may be drift (the timestamps in the segments are ahead/behind\n    //      of the timestamps in the manifest), but we need drift-free times\n    //      when comparing times against the presentation timeline.\n    if (!mediaState.lastSegmentReference) {\n      return presentationTime;\n    }\n\n    return mediaState.lastSegmentReference.endTime;\n  }\n\n\n  /**\n   * Gets the SegmentReference of the next segment needed.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {?number} bufferEnd\n   * @return {shaka.media.SegmentReference} The SegmentReference of the\n   *   next segment needed. Returns null if a segment could not be found, does\n   *   not exist, or is not available.\n   * @private\n   */\n  getSegmentReferenceNeeded_(mediaState, presentationTime, bufferEnd) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    goog.asserts.assert(\n        mediaState.stream.segmentIndex,\n        'segment index should have been generated already');\n\n    if (mediaState.segmentIterator) {\n      // Something is buffered from the same Stream.  Use the current position\n      // in the segment index.  This is updated via next() after each segment is\n      // appended.\n      return mediaState.segmentIterator.current();\n    } else if (mediaState.lastSegmentReference || bufferEnd) {\n      // Something is buffered from another Stream.\n      const time = mediaState.lastSegmentReference ?\n          mediaState.lastSegmentReference.endTime :\n          bufferEnd;\n      goog.asserts.assert(time != null, 'Should have a time to search');\n      shaka.log.v1(\n          logPrefix, 'looking up segment from new stream endTime:', time);\n\n      // Using a new iterator means we need to resync the stream in sequence\n      // mode.  The buffered range might not align perfectly with the last\n      // segment end time, so we may end up repeating a segment.  Resyncing\n      // makes this safe to do.\n      mediaState.needsResync = true;\n      mediaState.segmentIterator =\n          mediaState.stream.segmentIndex.getIteratorForTime(time);\n      const ref = mediaState.segmentIterator &&\n          mediaState.segmentIterator.next().value;\n      if (ref == null) {\n        shaka.log.warning(logPrefix, 'cannot find segment', 'endTime:', time);\n      }\n      return ref;\n    } else {\n      // Nothing is buffered.  Start at the playhead time.\n\n      // If there's positive drift then we need to adjust the lookup time, and\n      // may wind up requesting the previous segment to be safe.\n      // inaccurateManifestTolerance should be 0 for low latency streaming.\n      const inaccurateTolerance = this.config_.inaccurateManifestTolerance;\n      const lookupTime = Math.max(presentationTime - inaccurateTolerance, 0);\n\n      shaka.log.v1(logPrefix, 'looking up segment',\n          'lookupTime:', lookupTime,\n          'presentationTime:', presentationTime);\n\n      let ref = null;\n      if (inaccurateTolerance) {\n        mediaState.segmentIterator =\n            mediaState.stream.segmentIndex.getIteratorForTime(lookupTime);\n        ref = mediaState.segmentIterator &&\n            mediaState.segmentIterator.next().value;\n      }\n      if (!ref) {\n        // If we can't find a valid segment with the drifted time, look for a\n        // segment with the presentation time.\n        mediaState.segmentIterator =\n            mediaState.stream.segmentIndex.getIteratorForTime(presentationTime);\n        ref = mediaState.segmentIterator &&\n            mediaState.segmentIterator.next().value;\n      }\n      if (ref == null) {\n        shaka.log.warning(logPrefix, 'cannot find segment',\n            'lookupTime:', lookupTime,\n            'presentationTime:', presentationTime);\n      }\n      return ref;\n    }\n  }\n\n\n  /**\n   * Fetches and appends the given segment. Sets up the given MediaState's\n   * associated SourceBuffer and evicts segments if either are required\n   * beforehand. Schedules another update after completing successfully.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {!shaka.media.SegmentReference} reference\n   * @private\n   */\n  async fetchAndAppend_(mediaState, presentationTime, reference) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const StreamingEngine = shaka.media.StreamingEngine;\n    const logPrefix = StreamingEngine.logPrefix_(mediaState);\n\n    shaka.log.v1(logPrefix,\n        'fetchAndAppend_:',\n        'presentationTime=' + presentationTime,\n        'reference.startTime=' + reference.startTime,\n        'reference.endTime=' + reference.endTime);\n\n    // Subtlety: The playhead may move while asynchronous update operations are\n    // in progress, so we should avoid calling playhead.getTime() in any\n    // callbacks. Furthermore, switch() or seeked() may be called at any time,\n    // so we store the old iterator.  This allows the mediaState to change and\n    // we'll update the old iterator.\n    const stream = mediaState.stream;\n    const iter = mediaState.segmentIterator;\n\n    mediaState.performingUpdate = true;\n\n    try {\n      if (reference.getStatus() ==\n          shaka.media.SegmentReference.Status.MISSING) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.SEGMENT_MISSING);\n      }\n      await this.initSourceBuffer_(mediaState, reference);\n      this.destroyer_.ensureNotDestroyed();\n      if (this.fatalError_) {\n        return;\n      }\n\n      shaka.log.v2(logPrefix, 'fetching segment');\n      const isMP4 = stream.mimeType == 'video/mp4' ||\n              stream.mimeType == 'audio/mp4';\n      const isReadableStreamSupported = window.ReadableStream;\n      // Enable MP4 low latency streaming with ReadableStream chunked data.\n      // Disabled when AES-128 is present, as we cannot decrypt part of a\n      // segment.\n      if (this.config_.lowLatencyMode && isReadableStreamSupported && isMP4 &&\n          !reference.hlsAes128Key) {\n        let remaining = new Uint8Array(0);\n        let processingResult = false;\n        let callbackCalled = false;\n        const streamDataCallback = async (data) => {\n          if (processingResult) {\n            // If the fallback result processing was triggered, don't also\n            // append the buffer here.  In theory this should never happen,\n            // but it does on some older TVs.\n            return;\n          }\n          callbackCalled = true;\n          this.destroyer_.ensureNotDestroyed();\n          if (this.fatalError_) {\n            return;\n          }\n          // Append the data with complete boxes.\n          // Every time streamDataCallback gets called, append the new data to\n          // the remaining data.\n          // Find the last fully completed Mdat box, and slice the data into two\n          // parts: the first part with completed Mdat boxes, and the second\n          // part with an incomplete box.\n          // Append the first part, and save the second part as remaining data,\n          // and handle it with the next streamDataCallback call.\n          remaining = this.concatArray_(remaining, data);\n          let sawMDAT = false;\n          let offset = 0;\n          new shaka.util.Mp4Parser()\n              .box('mdat', (box) => {\n                offset = box.size + box.start;\n                sawMDAT = true;\n              })\n              .parse(remaining, /* partialOkay= */ false,\n                  /* isChunkedData= */ true);\n          if (sawMDAT) {\n            const dataToAppend = remaining.subarray(0, offset);\n            remaining = remaining.subarray(offset);\n            await this.append_(\n                mediaState, presentationTime, stream, reference, dataToAppend);\n          }\n        };\n\n        const result =\n            await this.fetch_(mediaState, reference, streamDataCallback);\n        if (!callbackCalled) {\n          // In some environments, we might be forced to use network plugins\n          // that don't support streamDataCallback. In those cases, as a\n          // fallback, append the buffer here.\n          processingResult = true;\n          this.destroyer_.ensureNotDestroyed();\n          if (this.fatalError_) {\n            return;\n          }\n\n          // If the text stream gets switched between fetch_() and append_(),\n          // the new text parser is initialized, but the new init segment is\n          // not fetched yet.  That would cause an error in\n          // TextParser.parseMedia().\n          // See http://b/168253400\n          if (mediaState.waitingToClearBuffer) {\n            shaka.log.info(logPrefix, 'waitingToClearBuffer, skip append');\n            mediaState.performingUpdate = false;\n            this.scheduleUpdate_(mediaState, 0);\n            return;\n          }\n\n          await this.append_(\n              mediaState, presentationTime, stream, reference, result);\n        }\n      } else {\n        if (this.config_.lowLatencyMode && !isReadableStreamSupported) {\n          shaka.log.warning('Low latency streaming mode is enabled, but ' +\n            'ReadableStream is not supported by the browser.');\n        }\n        const fetchSegment = this.fetch_(mediaState, reference);\n        let result = await fetchSegment;\n        this.destroyer_.ensureNotDestroyed();\n        if (this.fatalError_) {\n          return;\n        }\n        if (reference.hlsAes128Key) {\n          goog.asserts.assert(iter, 'mediaState.segmentIterator should exist');\n          result = await this.aes128Decrypt_(result, reference, iter);\n        }\n        this.destroyer_.ensureNotDestroyed();\n\n        // If the text stream gets switched between fetch_() and append_(), the\n        // new text parser is initialized, but the new init segment is not\n        // fetched yet.  That would cause an error in TextParser.parseMedia().\n        // See http://b/168253400\n        if (mediaState.waitingToClearBuffer) {\n          shaka.log.info(logPrefix, 'waitingToClearBuffer, skip append');\n          mediaState.performingUpdate = false;\n          this.scheduleUpdate_(mediaState, 0);\n          return;\n        }\n\n        await this.append_(\n            mediaState, presentationTime, stream, reference, result);\n      }\n\n      this.destroyer_.ensureNotDestroyed();\n      if (this.fatalError_) {\n        return;\n      }\n      // move to next segment after appending the current segment.\n      mediaState.lastSegmentReference = reference;\n      const newRef = iter.next().value;\n      shaka.log.v2(logPrefix, 'advancing to next segment', newRef);\n\n      mediaState.performingUpdate = false;\n      mediaState.recovering = false;\n\n      const info = this.playerInterface_.mediaSourceEngine.getBufferedInfo();\n      const buffered = info[mediaState.type];\n      // Convert the buffered object to a string capture its properties on\n      // WebOS.\n      shaka.log.v1(logPrefix, 'finished fetch and append',\n          JSON.stringify(buffered));\n\n      if (!mediaState.waitingToClearBuffer) {\n        this.playerInterface_.onSegmentAppended(\n            reference.startTime, reference.endTime, mediaState.type);\n      }\n\n      // Update right away.\n      this.scheduleUpdate_(mediaState, 0);\n    } catch (error) {\n      this.destroyer_.ensureNotDestroyed(error);\n      if (this.fatalError_) {\n        return;\n      }\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      mediaState.performingUpdate = false;\n\n      if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        // If the network slows down, abort the current fetch request and start\n        // a new one, and ignore the error message.\n        mediaState.performingUpdate = false;\n        this.cancelUpdate_(mediaState);\n        this.scheduleUpdate_(mediaState, 0);\n      } else if (mediaState.type == ContentType.TEXT &&\n          this.config_.ignoreTextStreamFailures) {\n        if (error.code == shaka.util.Error.Code.BAD_HTTP_STATUS) {\n          shaka.log.warning(logPrefix,\n              'Text stream failed to download. Proceeding without it.');\n        } else {\n          shaka.log.warning(logPrefix,\n              'Text stream failed to parse. Proceeding without it.');\n        }\n        this.mediaStates_.delete(ContentType.TEXT);\n      } else if (error.code == shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR) {\n        this.handleQuotaExceeded_(mediaState, error);\n      } else {\n        shaka.log.error(logPrefix, 'failed fetch and append: code=' +\n            error.code);\n        mediaState.hasError = true;\n\n        error.severity = shaka.util.Error.Severity.CRITICAL;\n        await this.handleStreamingError_(error);\n      }\n    }\n  }\n\n  /**\n   * @param {!BufferSource} rawResult\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {!shaka.media.SegmentIterator} iter\n   * @return {!Promise.<!BufferSource>} finalResult\n   * @private\n   */\n  async aes128Decrypt_(rawResult, reference, iter) {\n    const key = reference.hlsAes128Key;\n    if (!key.cryptoKey) {\n      goog.asserts.assert(key.fetchKey, 'If AES-128 cryptoKey was not ' +\n          'preloaded, fetchKey function should be provided');\n      await key.fetchKey();\n      goog.asserts.assert(key.cryptoKey, 'AES-128 cryptoKey should now be set');\n    }\n    let iv = key.iv;\n    if (!iv) {\n      iv = shaka.util.BufferUtils.toUint8(new ArrayBuffer(16));\n      let sequence = key.firstMediaSequenceNumber + iter.currentPosition();\n      for (let i = iv.byteLength - 1; i >= 0; i--) {\n        iv[i] = sequence & 0xff;\n        sequence >>= 8;\n      }\n    }\n    return window.crypto.subtle.decrypt(\n        {name: 'AES-CBC', iv}, key.cryptoKey, rawResult);\n  }\n\n\n  /**\n   * Clear per-stream error states and retry any failed streams.\n   * @param {number} delaySeconds\n   * @return {boolean} False if unable to retry.\n   */\n  retry(delaySeconds) {\n    if (this.destroyer_.destroyed()) {\n      shaka.log.error('Unable to retry after StreamingEngine is destroyed!');\n      return false;\n    }\n\n    if (this.fatalError_) {\n      shaka.log.error('Unable to retry after StreamingEngine encountered a ' +\n                      'fatal error!');\n      return false;\n    }\n\n    for (const mediaState of this.mediaStates_.values()) {\n      const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n      // Only schedule an update if it has an error, but it's not mid-update\n      // and there is not already an update scheduled.\n      if (mediaState.hasError && !mediaState.performingUpdate &&\n          !mediaState.updateTimer) {\n        shaka.log.info(logPrefix, 'Retrying after failure...');\n        mediaState.hasError = false;\n        this.scheduleUpdate_(mediaState, delaySeconds);\n      }\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Append the data to the remaining data.\n   * @param {!Uint8Array} remaining\n   * @param {!Uint8Array} data\n   * @return {!Uint8Array}\n   * @private\n   */\n  concatArray_(remaining, data) {\n    const result = new Uint8Array(remaining.length + data.length);\n    result.set(remaining);\n    result.set(data, remaining.length);\n    return result;\n  }\n\n\n  /**\n   * Handles a QUOTA_EXCEEDED_ERROR.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {!shaka.util.Error} error\n   * @private\n   */\n  handleQuotaExceeded_(mediaState, error) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // The segment cannot fit into the SourceBuffer. Ideally, MediaSource would\n    // have evicted old data to accommodate the segment; however, it may have\n    // failed to do this if the segment is very large, or if it could not find\n    // a suitable time range to remove.\n    //\n    // We can overcome the latter by trying to append the segment again;\n    // however, to avoid continuous QuotaExceededErrors we must reduce the size\n    // of the buffer going forward.\n    //\n    // If we've recently reduced the buffering goals, wait until the stream\n    // which caused the first QuotaExceededError recovers. Doing this ensures\n    // we don't reduce the buffering goals too quickly.\n\n    const mediaStates = Array.from(this.mediaStates_.values());\n    const waitingForAnotherStreamToRecover = mediaStates.some((ms) => {\n      return ms != mediaState && ms.recovering;\n    });\n\n    if (!waitingForAnotherStreamToRecover) {\n      // Reduction schedule: 80%, 60%, 40%, 20%, 16%, 12%, 8%, 4%, fail.\n      // Note: percentages are used for comparisons to avoid rounding errors.\n      const percentBefore = Math.round(100 * this.bufferingGoalScale_);\n      if (percentBefore > 20) {\n        this.bufferingGoalScale_ -= 0.2;\n      } else if (percentBefore > 4) {\n        this.bufferingGoalScale_ -= 0.04;\n      } else {\n        shaka.log.error(\n            logPrefix, 'MediaSource threw QuotaExceededError too many times');\n        mediaState.hasError = true;\n        this.fatalError_ = true;\n        this.playerInterface_.onError(error);\n        return;\n      }\n      const percentAfter = Math.round(100 * this.bufferingGoalScale_);\n      shaka.log.warning(\n          logPrefix,\n          'MediaSource threw QuotaExceededError:',\n          'reducing buffering goals by ' + (100 - percentAfter) + '%');\n      mediaState.recovering = true;\n    } else {\n      shaka.log.debug(\n          logPrefix,\n          'MediaSource threw QuotaExceededError:',\n          'waiting for another stream to recover...');\n    }\n\n    // QuotaExceededError gets thrown if evication didn't help to make room\n    // for a segment. We want to wait for a while (4 seconds is just an\n    // arbitrary number) before updating to give the playhead a chance to\n    // advance, so we don't immidiately throw again.\n    this.scheduleUpdate_(mediaState, 4);\n  }\n\n\n  /**\n   * Sets the given MediaState's associated SourceBuffer's timestamp offset,\n   * append window, and init segment if they have changed. If an error occurs\n   * then neither the timestamp offset or init segment are unset, since another\n   * call to switch() will end up superseding them.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {!shaka.media.SegmentReference} reference\n   * @return {!Promise}\n   * @private\n   */\n  async initSourceBuffer_(mediaState, reference) {\n    const StreamingEngine = shaka.media.StreamingEngine;\n    const logPrefix = StreamingEngine.logPrefix_(mediaState);\n\n    /** @type {!Array.<!Promise>} */\n    const operations = [];\n\n    // Rounding issues can cause us to remove the first frame of a Period, so\n    // reduce the window start time slightly.\n    const appendWindowStart = Math.max(0,\n        reference.appendWindowStart -\n        StreamingEngine.APPEND_WINDOW_START_FUDGE_);\n    const appendWindowEnd =\n        reference.appendWindowEnd + StreamingEngine.APPEND_WINDOW_END_FUDGE_;\n\n    goog.asserts.assert(\n        reference.startTime <= appendWindowEnd,\n        logPrefix + ' segment should start before append window end');\n\n    const timestampOffset = reference.timestampOffset;\n    if (timestampOffset != mediaState.lastTimestampOffset ||\n        appendWindowStart != mediaState.lastAppendWindowStart ||\n        appendWindowEnd != mediaState.lastAppendWindowEnd) {\n      shaka.log.v1(logPrefix, 'setting timestamp offset to ' + timestampOffset);\n      shaka.log.v1(logPrefix,\n          'setting append window start to ' + appendWindowStart);\n      shaka.log.v1(logPrefix,\n          'setting append window end to ' + appendWindowEnd);\n\n      const setProperties = async () => {\n        try {\n          mediaState.lastAppendWindowStart = appendWindowStart;\n          mediaState.lastAppendWindowEnd = appendWindowEnd;\n          mediaState.lastTimestampOffset = timestampOffset;\n\n          await this.playerInterface_.mediaSourceEngine.setStreamProperties(\n              mediaState.type, timestampOffset, appendWindowStart,\n              appendWindowEnd, this.manifest_.sequenceMode);\n        } catch (error) {\n          mediaState.lastAppendWindowStart = null;\n          mediaState.lastAppendWindowEnd = null;\n          mediaState.lastTimestampOffset = null;\n\n          throw error;\n        }\n      };\n      operations.push(setProperties());\n    }\n\n    if (!shaka.media.InitSegmentReference.equal(\n        reference.initSegmentReference, mediaState.lastInitSegmentReference)) {\n      mediaState.lastInitSegmentReference = reference.initSegmentReference;\n\n      if (reference.initSegmentReference) {\n        shaka.log.v1(logPrefix, 'fetching init segment');\n\n        const fetchInit =\n            this.fetch_(mediaState, reference.initSegmentReference);\n        const append = async () => {\n          try {\n            const initSegment = await fetchInit;\n            this.destroyer_.ensureNotDestroyed();\n\n            const parser = new shaka.util.Mp4Parser();\n            const Mp4Parser = shaka.util.Mp4Parser;\n            parser.box('moov', Mp4Parser.children)\n                .box('trak', Mp4Parser.children)\n                .box('mdia', Mp4Parser.children)\n                .fullBox('mdhd', (box) => {\n                  this.parseMDHD_(reference, box);\n                })\n                .parse(initSegment);\n\n            shaka.log.v1(logPrefix, 'appending init segment');\n            const hasClosedCaptions = mediaState.stream.closedCaptions &&\n                mediaState.stream.closedCaptions.size > 0;\n            await this.playerInterface_.beforeAppendSegment(\n                mediaState.type, initSegment);\n            await this.playerInterface_.mediaSourceEngine.appendBuffer(\n                mediaState.type, initSegment, /* reference= */ null,\n                hasClosedCaptions);\n          } catch (error) {\n            mediaState.lastInitSegmentReference = null;\n            throw error;\n          }\n        };\n        this.playerInterface_.onInitSegmentAppended(\n            reference.startTime, reference.initSegmentReference);\n        operations.push(append());\n      }\n    }\n\n    if (this.manifest_.sequenceMode) {\n      // Across discontinuity bounds, we should resync timestamps for\n      // sequence mode playbacks.  The next segment appended should\n      // land at its theoretical timestamp from the segment index.\n      const lastDiscontinuitySequence =\n          mediaState.lastSegmentReference ?\n              mediaState.lastSegmentReference.discontinuitySequence : null;\n      if (reference.discontinuitySequence != lastDiscontinuitySequence ||\n          mediaState.needsResync) {\n        mediaState.needsResync = false;\n        operations.push(this.playerInterface_.mediaSourceEngine.resync(\n            mediaState.type, reference.startTime));\n      }\n    }\n\n    await Promise.all(operations);\n  }\n\n\n  /**\n   * Appends the given segment and evicts content if required to append.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @param {shaka.extern.Stream} stream\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {BufferSource} segment\n   * @return {!Promise}\n   * @private\n   */\n  async append_(mediaState, presentationTime, stream, reference, segment) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    const hasClosedCaptions = stream.closedCaptions &&\n        stream.closedCaptions.size > 0;\n\n    let parser;\n    const hasEmsg = ((stream.emsgSchemeIdUris != null &&\n      stream.emsgSchemeIdUris.length > 0) ||\n      this.config_.dispatchAllEmsgBoxes);\n    const shouldParsePrftBox =\n      (this.config_.parsePrftBox && !this.parsedPrftEventRaised_);\n\n    if (hasEmsg || shouldParsePrftBox) {\n      parser = new shaka.util.Mp4Parser();\n    }\n\n    if (hasEmsg) {\n      parser\n          .fullBox(\n              'emsg',\n              (box) => this.parseEMSG_(\n                  reference, stream.emsgSchemeIdUris, box));\n    }\n\n    if (shouldParsePrftBox) {\n      parser\n          .fullBox(\n              'prft',\n              (box) => this.parsePrft_(\n                  reference, box));\n    }\n\n    if (hasEmsg || shouldParsePrftBox) {\n      parser.parse(segment);\n    }\n\n    await this.evict_(mediaState, presentationTime);\n    this.destroyer_.ensureNotDestroyed();\n\n    // 'seeked' or 'adaptation' triggered logic applies only to this\n    // appendBuffer() call.\n    const seeked = mediaState.seeked;\n    mediaState.seeked = false;\n    const adaptation = mediaState.adaptation;\n    mediaState.adaptation = false;\n\n    await this.playerInterface_.beforeAppendSegment(mediaState.type, segment);\n    await this.playerInterface_.mediaSourceEngine.appendBuffer(\n        mediaState.type,\n        segment,\n        reference,\n        hasClosedCaptions,\n        seeked,\n        adaptation);\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v2(logPrefix, 'appended media segment');\n  }\n\n\n  /**\n   * Parse the EMSG box from a MP4 container.\n   *\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {?Array.<string>} emsgSchemeIdUris Array of emsg\n   *     scheme_id_uri for which emsg boxes should be parsed.\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   * https://dashif-documents.azurewebsites.net/Events/master/event.html#emsg-format\n   * aligned(8) class DASHEventMessageBox\n   *    extends FullBox(emsg, version, flags = 0){\n   * if (version==0) {\n   *   string scheme_id_uri;\n   *   string value;\n   *   unsigned int(32) timescale;\n   *   unsigned int(32) presentation_time_delta;\n   *   unsigned int(32) event_duration;\n   *   unsigned int(32) id;\n   * } else if (version==1) {\n   *   unsigned int(32) timescale;\n   *   unsigned int(64) presentation_time;\n   *   unsigned int(32) event_duration;\n   *   unsigned int(32) id;\n   *   string scheme_id_uri;\n   *   string value;\n   * }\n   * unsigned int(8) message_data[];\n   */\n  parseEMSG_(reference, emsgSchemeIdUris, box) {\n    let timescale;\n    let id;\n    let eventDuration;\n    let schemeId;\n    let startTime;\n    let presentationTimeDelta;\n    let value;\n\n    if (box.version === 0) {\n      schemeId = box.reader.readTerminatedString();\n      value = box.reader.readTerminatedString();\n      timescale = box.reader.readUint32();\n      presentationTimeDelta = box.reader.readUint32();\n      eventDuration = box.reader.readUint32();\n      id = box.reader.readUint32();\n      startTime = reference.startTime + (presentationTimeDelta / timescale);\n    } else {\n      timescale = box.reader.readUint32();\n      const pts = box.reader.readUint64();\n      startTime = (pts / timescale) + reference.timestampOffset;\n      presentationTimeDelta = startTime - reference.startTime;\n      eventDuration = box.reader.readUint32();\n      id = box.reader.readUint32();\n      schemeId = box.reader.readTerminatedString();\n      value = box.reader.readTerminatedString();\n    }\n    const messageData = box.reader.readBytes(\n        box.reader.getLength() - box.reader.getPosition());\n\n\n    // See DASH sec. 5.10.3.3.1\n    // If a DASH client detects an event message box with a scheme that is not\n    // defined in MPD, the client is expected to ignore it.\n    if ((emsgSchemeIdUris && emsgSchemeIdUris.includes(schemeId)) ||\n        this.config_.dispatchAllEmsgBoxes) {\n      // See DASH sec. 5.10.4.1\n      // A special scheme in DASH used to signal manifest updates.\n      if (schemeId == 'urn:mpeg:dash:event:2012') {\n        this.playerInterface_.onManifestUpdate();\n      } else if (schemeId == 'https://aomedia.org/emsg/ID3') {\n        // See https://aomediacodec.github.io/id3-emsg/\n        const frames = shaka.util.Id3Utils.getID3Frames(messageData);\n        if (frames.length && reference) {\n          /** @private {shaka.extern.ID3Metadata} */\n          const metadata = {\n            cueTime: reference.startTime,\n            data: messageData,\n            frames: frames,\n            dts: reference.startTime,\n            pts: reference.startTime,\n          };\n          this.playerInterface_.onMetadata(\n              [metadata], /* offset= */ 0, reference.endTime);\n        }\n      } else {\n        /** @type {shaka.extern.EmsgInfo} */\n        const emsg = {\n          startTime: startTime,\n          endTime: startTime + (eventDuration / timescale),\n          schemeIdUri: schemeId,\n          value: value,\n          timescale: timescale,\n          presentationTimeDelta: presentationTimeDelta,\n          eventDuration: eventDuration,\n          id: id,\n          messageData: messageData,\n        };\n\n        // Dispatch an event to notify the application about the emsg box.\n        const eventName = shaka.util.FakeEvent.EventName.Emsg;\n        const data = (new Map()).set('detail', emsg);\n        const event = new shaka.util.FakeEvent(eventName, data);\n        this.playerInterface_.onEvent(event);\n      }\n    }\n  }\n\n  /**\n   * Parse MDHD box.\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   */\n  parseMDHD_(reference, box) {\n    const parsedMDHDBox = shaka.util.Mp4BoxParsers.parseMDHD(\n        box.reader || 0, box.version || 0);\n    reference.initSegmentReference.timescale = parsedMDHDBox.timescale;\n  }\n\n  /**\n   * Parse PRFT box.\n   * @param {!shaka.media.SegmentReference} reference\n   * @param {!shaka.extern.ParsedBox} box\n   * @private\n   */\n  parsePrft_(reference, box) {\n    if (this.parsedPrftEventRaised_ ||\n      !reference.initSegmentReference.timescale) {\n      return;\n    }\n    box.reader.readUint32(); // Ignore referenceTrackId\n    const ntpTimestampSec = box.reader.readUint32();\n    const ntpTimestampFrac = box.reader.readUint32();\n    const ntpTimestamp = ntpTimestampSec * 1000 +\n        ntpTimestampFrac / 2**32 * 1000;\n\n    let mediaTime;\n    if (box.version === 0) {\n      mediaTime = box.reader.readUint32();\n    } else {\n      try {\n        mediaTime = box.reader.readUint64();\n      } catch (e) {\n        shaka.log.warning('parsePrft_: parsing mediatime resulted in a '+\n          'MEDIA.JS_INTEGER_OVERFLOW exception');\n        this.parsedPrftEventRaised_ = true;\n        return;\n      }\n    }\n\n    const timescale = reference.initSegmentReference.timescale;\n    const wallClockTime = this.convertNtp(ntpTimestamp);\n    const programStartDate = new Date(wallClockTime -\n      (mediaTime / timescale) * 1000);\n    const prftInfo = {\n      wallClockTime,\n      programStartDate,\n    };\n\n    const eventName = shaka.util.FakeEvent.EventName.Prft;\n    const data = (new Map()).set('detail', prftInfo);\n    const event = new shaka.util.FakeEvent(\n        eventName, data);\n    this.playerInterface_.onEvent(event);\n    this.parsedPrftEventRaised_ = true;\n  }\n\n\n  /**\n     * Convert Ntp ntpTimeStamp to UTC Time\n     *\n     * @param {number} ntpTimeStamp\n     * @return {number} utcTime\n     */\n  convertNtp(ntpTimeStamp) {\n    const start = new Date(Date.UTC(1900, 0, 1, 0, 0, 0));\n    return new Date(start.getTime() + ntpTimeStamp).getTime();\n  }\n\n  /**\n   * Evicts media to meet the max buffer behind limit.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} presentationTime\n   * @private\n   */\n  async evict_(mediaState, presentationTime) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n    shaka.log.v2(logPrefix, 'checking buffer length');\n\n    // Use the max segment duration, if it is longer than the bufferBehind, to\n    // avoid accidentally clearing too much data when dealing with a manifest\n    // with a long keyframe interval.\n    const bufferBehind = Math.max(this.config_.bufferBehind,\n        this.manifest_.presentationTimeline.getMaxSegmentDuration());\n\n    const startTime =\n        this.playerInterface_.mediaSourceEngine.bufferStart(mediaState.type);\n    if (startTime == null) {\n      shaka.log.v2(logPrefix,\n          'buffer behind okay because nothing buffered:',\n          'presentationTime=' + presentationTime,\n          'bufferBehind=' + bufferBehind);\n      return;\n    }\n    const bufferedBehind = presentationTime - startTime;\n\n    const overflow = bufferedBehind - bufferBehind;\n    // See: https://github.com/shaka-project/shaka-player/issues/2982\n    if (overflow <= 0.01) {\n      shaka.log.v2(logPrefix,\n          'buffer behind okay:',\n          'presentationTime=' + presentationTime,\n          'bufferedBehind=' + bufferedBehind,\n          'bufferBehind=' + bufferBehind,\n          'underflow=' + Math.abs(overflow));\n      return;\n    }\n\n    shaka.log.v1(logPrefix,\n        'buffer behind too large:',\n        'presentationTime=' + presentationTime,\n        'bufferedBehind=' + bufferedBehind,\n        'bufferBehind=' + bufferBehind,\n        'overflow=' + overflow);\n\n    await this.playerInterface_.mediaSourceEngine.remove(mediaState.type,\n        startTime, startTime + overflow);\n\n    this.destroyer_.ensureNotDestroyed();\n    shaka.log.v1(logPrefix, 'evicted ' + overflow + ' seconds');\n  }\n\n\n  /**\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {boolean}\n   * @private\n   */\n  static isEmbeddedText_(mediaState) {\n    const MimeUtils = shaka.util.MimeUtils;\n    const CEA608_MIME = MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE;\n    const CEA708_MIME = MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE;\n    return mediaState &&\n        mediaState.type == shaka.util.ManifestParserUtils.ContentType.TEXT &&\n        (mediaState.stream.mimeType == CEA608_MIME ||\n         mediaState.stream.mimeType == CEA708_MIME);\n  }\n\n\n  /**\n   * Fetches the given segment.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {(!shaka.media.InitSegmentReference|!shaka.media.SegmentReference)}\n   *   reference\n   * @param {?function(BufferSource):!Promise=} streamDataCallback\n   *\n   * @return {!Promise.<BufferSource>}\n   * @private\n   * @suppress {strictMissingProperties}\n   */\n  async fetch_(mediaState, reference, streamDataCallback) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        reference.getUris(),\n        reference.startByte,\n        reference.endByte,\n        this.config_.retryParameters,\n        streamDataCallback);\n\n    shaka.log.v2('fetching: reference=', reference);\n\n    const stream = mediaState.stream;\n    this.playerInterface_.modifySegmentRequest(\n        request,\n        {\n          type: stream.type,\n          init: reference instanceof shaka.media.InitSegmentReference,\n          duration: reference.endTime - reference.startTime,\n          mimeType: stream.mimeType,\n          codecs: stream.codecs,\n          bandwidth: stream.bandwidth,\n        },\n    );\n\n    const op = this.playerInterface_.netEngine.request(requestType, request);\n    mediaState.operation = op;\n    const response = await op.promise;\n    mediaState.operation = null;\n    return response.data;\n  }\n\n\n  /**\n   * Clears the buffer and schedules another update.\n   * The optional parameter safeMargin allows to retain a certain amount\n   * of buffer, which can help avoiding rebuffering events.\n   * The value of the safe margin should be provided by the ABR manager.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {boolean} flush\n   * @param {number} safeMargin\n   * @private\n   */\n  async clearBuffer_(mediaState, flush, safeMargin) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    goog.asserts.assert(\n        !mediaState.performingUpdate && (mediaState.updateTimer == null),\n        logPrefix + ' unexpected call to clearBuffer_()');\n\n    mediaState.waitingToClearBuffer = false;\n    mediaState.waitingToFlushBuffer = false;\n    mediaState.clearBufferSafeMargin = 0;\n    mediaState.clearingBuffer = true;\n    mediaState.lastSegmentReference = null;\n    mediaState.lastInitSegmentReference = null;\n    mediaState.segmentIterator = null;\n\n    shaka.log.debug(logPrefix, 'clearing buffer');\n\n    if (safeMargin) {\n      const presentationTime = this.playerInterface_.getPresentationTime();\n      const duration = this.playerInterface_.mediaSourceEngine.getDuration();\n      await this.playerInterface_.mediaSourceEngine.remove(\n          mediaState.type, presentationTime + safeMargin, duration);\n    } else {\n      await this.playerInterface_.mediaSourceEngine.clear(mediaState.type);\n      this.destroyer_.ensureNotDestroyed();\n\n      if (flush) {\n        await this.playerInterface_.mediaSourceEngine.flush(\n            mediaState.type);\n      }\n    }\n    this.destroyer_.ensureNotDestroyed();\n\n    shaka.log.debug(logPrefix, 'cleared buffer');\n    mediaState.clearingBuffer = false;\n    mediaState.endOfStream = false;\n    // Since the clear operation was async, check to make sure we're not doing\n    // another update and we don't have one scheduled yet.\n    if (!mediaState.performingUpdate && !mediaState.updateTimer) {\n      this.scheduleUpdate_(mediaState, 0);\n    }\n  }\n\n\n  /**\n   * Schedules |mediaState|'s next update.\n   *\n   * @param {!shaka.media.StreamingEngine.MediaState_} mediaState\n   * @param {number} delay The delay in seconds.\n   * @private\n   */\n  scheduleUpdate_(mediaState, delay) {\n    const logPrefix = shaka.media.StreamingEngine.logPrefix_(mediaState);\n\n    // If the text's update is canceled and its mediaState is deleted, stop\n    // scheduling another update.\n    const type = mediaState.type;\n    if (type == shaka.util.ManifestParserUtils.ContentType.TEXT &&\n          !this.mediaStates_.has(type)) {\n      shaka.log.v1(logPrefix, 'Text stream is unloaded. No update is needed.');\n      return;\n    }\n\n    shaka.log.v2(logPrefix, 'updating in ' + delay + ' seconds');\n    goog.asserts.assert(mediaState.updateTimer == null,\n        logPrefix + ' did not expect update to be scheduled');\n\n    mediaState.updateTimer = new shaka.util.DelayedTick(async () => {\n      try {\n        await this.onUpdate_(mediaState);\n      } catch (error) {\n        if (this.playerInterface_) {\n          this.playerInterface_.onError(error);\n        }\n      }\n    }).tickAfter(delay);\n  }\n\n\n  /**\n   * If |mediaState| is scheduled to update, stop it.\n   *\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @private\n   */\n  cancelUpdate_(mediaState) {\n    if (mediaState.updateTimer == null) {\n      return;\n    }\n\n    mediaState.updateTimer.stop();\n    mediaState.updateTimer = null;\n  }\n\n\n  /**\n   * If |mediaState| holds any in-progress operations, abort them.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async abortOperations_(mediaState) {\n    if (mediaState.operation) {\n      await mediaState.operation.abort();\n    }\n  }\n\n  /**\n   * Handle streaming errors by delaying, then notifying the application by\n   * error callback and by streaming failure callback.\n   *\n   * @param {!shaka.util.Error} error\n   * @return {!Promise}\n   * @private\n   */\n  async handleStreamingError_(error) {\n    // If we invoke the callback right away, the application could trigger a\n    // rapid retry cycle that could be very unkind to the server.  Instead,\n    // use the backoff system to delay and backoff the error handling.\n    await this.failureCallbackBackoff_.attempt();\n    this.destroyer_.ensureNotDestroyed();\n\n    // First fire an error event.\n    this.playerInterface_.onError(error);\n\n    // If the error was not handled by the application, call the failure\n    // callback.\n    if (!error.handled) {\n      this.config_.failureCallback(error);\n    }\n  }\n\n  /**\n   * @param {shaka.media.StreamingEngine.MediaState_} mediaState\n   * @return {string} A log prefix of the form ($CONTENT_TYPE:$STREAM_ID), e.g.,\n   *   \"(audio:5)\" or \"(video:hd)\".\n   * @private\n   */\n  static logPrefix_(mediaState) {\n    return '(' + mediaState.type + ':' + mediaState.stream.id + ')';\n  }\n};\n\n\n/**\n * @typedef {{\n *   getPresentationTime: function():number,\n *   getBandwidthEstimate: function():number,\n *   modifySegmentRequest: function(shaka.extern.Request,\n *     shaka.util.CmcdManager.SegmentInfo),\n *   mediaSourceEngine: !shaka.media.MediaSourceEngine,\n *   netEngine: shaka.net.NetworkingEngine,\n *   onError: function(!shaka.util.Error),\n *   onEvent: function(!Event),\n *   onManifestUpdate: function(),\n *   onSegmentAppended: function(number, number,\n *     !shaka.util.ManifestParserUtils.ContentType),\n *   onInitSegmentAppended: function(!number,!shaka.media.InitSegmentReference),\n *   beforeAppendSegment: function(\n *     shaka.util.ManifestParserUtils.ContentType,!BufferSource):Promise,\n *   onMetadata: !function(!Array.<shaka.extern.ID3Metadata>, number, ?number)\n * }}\n *\n * @property {function():number} getPresentationTime\n *   Get the position in the presentation (in seconds) of the content that the\n *   viewer is seeing on screen right now.\n * @property {function():number} getBandwidthEstimate\n *   Get the estimated bandwidth in bits per second.\n * @property {function(shaka.extern.Request,\n *   shaka.extern.Cmcd.SegmentInfo)} modifySegmentRequest\n *   The request modifier\n * @property {!shaka.media.MediaSourceEngine} mediaSourceEngine\n *   The MediaSourceEngine. The caller retains ownership.\n * @property {shaka.net.NetworkingEngine} netEngine\n *   The NetworkingEngine instance to use. The caller retains ownership.\n * @property {function(!shaka.util.Error)} onError\n *   Called when an error occurs. If the error is recoverable (see\n *   {@link shaka.util.Error}) then the caller may invoke either\n *   StreamingEngine.switch*() or StreamingEngine.seeked() to attempt recovery.\n * @property {function(!Event)} onEvent\n *   Called when an event occurs that should be sent to the app.\n * @property {function()} onManifestUpdate\n *   Called when an embedded 'emsg' box should trigger a manifest update.\n * @property {function(number, number,\n *   !shaka.util.ManifestParserUtils.ContentType)} onSegmentAppended\n *   Called after a segment is successfully appended to a MediaSource.\n *   The parameters are the start and end time.\n * @property\n *  {function(!number, !shaka.media.InitSegmentReference)} onInitSegmentAppended\n *   Called when an init segment is appended to a MediaSource.\n * @property {!function(shaka.util.ManifestParserUtils.ContentType,\n *   !BufferSource):Promise} beforeAppendSegment\n *   A function called just before appending to the source buffer.\n * @property\n *  {!function(!Array.<shaka.extern.ID3Metadata>, number, ?number)} onMetadata\n *   Called when an ID3 is found in a EMSG.\n */\nshaka.media.StreamingEngine.PlayerInterface;\n\n\n/**\n * @typedef {{\n *   type: shaka.util.ManifestParserUtils.ContentType,\n *   stream: shaka.extern.Stream,\n *   segmentIterator: shaka.media.SegmentIterator,\n *   lastSegmentReference: shaka.media.SegmentReference,\n *   lastInitSegmentReference: shaka.media.InitSegmentReference,\n *   lastTimestampOffset: ?number,\n *   lastAppendWindowStart: ?number,\n *   lastAppendWindowEnd: ?number,\n *   restoreStreamAfterTrickPlay: ?shaka.extern.Stream,\n *   endOfStream: boolean,\n *   performingUpdate: boolean,\n *   updateTimer: shaka.util.DelayedTick,\n *   waitingToClearBuffer: boolean,\n *   waitingToFlushBuffer: boolean,\n *   clearBufferSafeMargin: number,\n *   clearingBuffer: boolean,\n *   seeked: boolean,\n *   needsResync: boolean,\n *   adaptation: boolean,\n *   recovering: boolean,\n *   hasError: boolean,\n *   operation: shaka.net.NetworkingEngine.PendingRequest\n * }}\n *\n * @description\n * Contains the state of a logical stream, i.e., a sequence of segmented data\n * for a particular content type. At any given time there is a Stream object\n * associated with the state of the logical stream.\n *\n * @property {shaka.util.ManifestParserUtils.ContentType} type\n *   The stream's content type, e.g., 'audio', 'video', or 'text'.\n * @property {shaka.extern.Stream} stream\n *   The current Stream.\n * @property {shaka.media.SegmentIndexIterator} segmentIterator\n *   An iterator through the segments of |stream|.\n * @property {shaka.media.SegmentReference} lastSegmentReference\n *   The SegmentReference of the last segment that was appended.\n * @property {shaka.media.InitSegmentReference} lastInitSegmentReference\n *   The InitSegmentReference of the last init segment that was appended.\n * @property {?number} lastTimestampOffset\n *   The last timestamp offset given to MediaSourceEngine for this type.\n * @property {?number} lastAppendWindowStart\n *   The last append window start given to MediaSourceEngine for this type.\n * @property {?number} lastAppendWindowEnd\n *   The last append window end given to MediaSourceEngine for this type.\n * @property {?shaka.extern.Stream} restoreStreamAfterTrickPlay\n *   The Stream to restore after trick play mode is turned off.\n * @property {boolean} endOfStream\n *   True indicates that the end of the buffer has hit the end of the\n *   presentation.\n * @property {boolean} performingUpdate\n *   True indicates that an update is in progress.\n * @property {shaka.util.DelayedTick} updateTimer\n *   A timer used to update the media state.\n * @property {boolean} waitingToClearBuffer\n *   True indicates that the buffer must be cleared after the current update\n *   finishes.\n * @property {boolean} waitingToFlushBuffer\n *   True indicates that the buffer must be flushed after it is cleared.\n * @property {number} clearBufferSafeMargin\n *   The amount of buffer to retain when clearing the buffer after the update.\n * @property {boolean} clearingBuffer\n *   True indicates that the buffer is being cleared.\n * @property {boolean} seeked\n *   True indicates that the presentation just seeked.\n * @property {boolean} adaptation\n *   True indicates that the presentation just automatically switched variants.\n * @property {boolean} needsResync\n *   True indicates that the stream needs to be resynced in sequence mode,\n *   regardless of discontinuity sequence.\n * @property {boolean} recovering\n *   True indicates that the last segment was not appended because it could not\n *   fit in the buffer.\n * @property {boolean} hasError\n *   True indicates that the stream has encountered an error and has stopped\n *   updating.\n * @property {shaka.net.NetworkingEngine.PendingRequest} operation\n *   Operation with the number of bytes to be downloaded.\n */\nshaka.media.StreamingEngine.MediaState_;\n\n\n/**\n * The fudge factor for appendWindowStart.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the keyframe at the start\n * of the Period.\n *\n * NOTE: This was increased as part of the solution to\n * https://github.com/shaka-project/shaka-player/issues/1281\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_ = 0.1;\n\n\n/**\n * The fudge factor for appendWindowEnd.  By adjusting the window backward, we\n * avoid rounding errors that could cause us to remove the last few samples of\n * the Period.  This rounding error could then create an artificial gap and a\n * stutter when the gap-jumping logic takes over.\n *\n * https://github.com/shaka-project/shaka-player/issues/1597\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_ = 0.01;\n\n\n/**\n * The maximum number of segments by which a stream can get ahead of other\n * streams.\n *\n * Introduced to keep StreamingEngine from letting one media type get too far\n * ahead of another.  For example, audio segments are typically much smaller\n * than video segments, so in the time it takes to fetch one video segment, we\n * could fetch many audio segments.  This doesn't help with buffering, though,\n * since the intersection of the two buffered ranges is what counts.\n *\n * @const {number}\n * @private\n */\nshaka.media.StreamingEngine.MAX_RUN_AHEAD_SEGMENTS_ = 1;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.routing.Walker');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.routing.Node');\ngoog.require('shaka.routing.Payload');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\ngoog.requireType('shaka.util.AbortableOperation');\n\n\n/**\n * The walker moves through a graph node-by-node executing asynchronous work\n * as it enters each node.\n *\n * The walker accepts requests for where it should go next. Requests are queued\n * and executed in FIFO order. If the current request can be interrupted, it\n * will be cancelled and the next request started.\n *\n * A request says \"I want to change where we are going\". When the walker is\n * ready to change destinations, it will resolve the request, allowing the\n * destination to differ based on the current state and not the state when\n * the request was appended.\n *\n * Example (from shaka.Player):\n *  When we unload, we need to either go to the attached or detached state based\n *  on whether or not we have a video element.\n *\n *  When we are asked to unload, we don't know what other pending requests may\n *  be ahead of us (there could be attach requests or detach requests). We need\n *  to wait until its our turn to know if:\n *    - we should go to the attach state because we have a media element\n *    - we should go to the detach state because we don't have a media element\n *\n * The walker allows the caller to specify if a route can or cannot be\n * interrupted. This is to allow potentially dependent routes to wait until\n * other routes have finished.\n *\n * Example (from shaka.Player):\n *  A request to load content depends on an attach request finishing. We don't\n *  want load request to interrupt an attach request. By marking the attach\n *  request as non-interruptible we ensure that calling load before attach\n *  finishes will work.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.routing.Walker = class {\n  /**\n   * Create a new walker that starts at |startingAt| and with |startingWith|.\n   * The instance of |startingWith| will be the one that the walker holds and\n   * uses for its life. No one else should reference it.\n   *\n   * The per-instance behaviour for the walker is provided via |implementation|\n   * which is used to connect this walker with the \"outside world\".\n   *\n   * @param {shaka.routing.Node} startingAt\n   * @param {shaka.routing.Payload} startingWith\n   * @param {shaka.routing.Walker.Implementation} implementation\n   */\n  constructor(startingAt, startingWith, implementation) {\n    /** @private {?shaka.routing.Walker.Implementation} */\n    this.implementation_ = implementation;\n\n    /** @private {shaka.routing.Node} */\n    this.currentlyAt_ = startingAt;\n\n    /** @private {shaka.routing.Payload} */\n    this.currentlyWith_ = startingWith;\n\n    /**\n     * When we run out of work to do, we will set this promise so that when\n     * new work is added (and this is not null) it can be resolved. The only\n     * time when this should be non-null is when we are waiting for more work.\n     *\n     * @private {?shaka.util.PublicPromise}\n     */\n    this.waitForWork_ = null;\n\n    /** @private {!Array.<shaka.routing.Walker.Request_>} */\n    this.requests_ = [];\n\n    /** @private {?shaka.routing.Walker.ActiveRoute_} */\n    this.currentRoute_ = null;\n\n    /** @private {?shaka.util.AbortableOperation} */\n    this.currentStep_ = null;\n\n    /**\n     * Hold a reference to the main loop's promise so that we know when it has\n     * exited. This will determine when |destroy| can resolve. Purposely make\n     * the main loop start next interpreter cycle so that the constructor will\n     * finish before it starts.\n     *\n     * @private {!Promise}\n     */\n    this.mainLoopPromise_ = Promise.resolve().then(() => this.mainLoop_());\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => this.doDestroy_());\n  }\n\n  /**\n   * Get the current routing payload.\n   *\n   * @return {shaka.routing.Payload}\n   */\n  getCurrentPayload() {\n    return this.currentlyWith_;\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /** @private */\n  async doDestroy_() {\n    // If we are executing a current step, we want to interrupt it so that we\n    // can force the main loop to terminate.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // If we are waiting for more work, we want to wake-up the main loop so that\n    // it can exit on its own.\n    this.unblockMainLoop_();\n\n    // Wait for the main loop to terminate so that an async operation won't\n    // try and use state that we released.\n    await this.mainLoopPromise_;\n\n    // Any routes that we are not going to finish, we need to cancel. If we\n    // don't do this, those listening will be left hanging.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n    }\n    for (const request of this.requests_) {\n      request.listeners.onCancel();\n    }\n\n    // Release anything that could hold references to anything outside of this\n    // class.\n    this.currentRoute_ = null;\n    this.requests_ = [];\n    this.implementation_ = null;\n  }\n\n  /**\n   * Ask the walker to start a new route. When the walker is ready to start a\n   * new route, it will call |create| and |create| will provide the walker with\n   * a new route to execute.\n   *\n   * If any previous calls to |startNewRoute| created non-interruptible routes,\n   * |create| won't be called until all previous non-interruptible routes have\n   * finished.\n   *\n   * This method will return a collection of listeners that the caller can hook\n   * into. Any listener that the caller is interested should be assigned\n   * immediately after calling |startNewRoute| or else they could miss the event\n   * they want to listen for.\n   *\n   * @param {function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n   * @return {shaka.routing.Walker.Listeners}\n   */\n  startNewRoute(create) {\n    const listeners = {\n      onStart: () => {},\n      onEnd: () => {},\n      onCancel: () => {},\n      onError: (error) => {},\n      onSkip: () => {},\n      onEnter: () => {},\n    };\n\n    this.requests_.push({\n      create: create,\n      listeners: listeners,\n    });\n\n    // If we are in the middle of a step, try to abort it. If this is successful\n    // the main loop will error and the walker will enter recovery mode.\n    if (this.currentStep_) {\n      this.currentStep_.abort();\n    }\n\n    // Tell the main loop that new work is available. If the main loop was not\n    // blocked, this will be a no-op.\n    this.unblockMainLoop_();\n\n    return listeners;\n  }\n\n  /**\n   * @return {!Promise}\n   * @private\n   */\n  async mainLoop_() {\n    while (!this.destroyer_.destroyed()) {\n      // eslint-disable-next-line no-await-in-loop\n      await this.doOneThing_();\n    }\n  }\n\n  /**\n   * Do one thing to move the walker closer to its destination. This can be:\n   *   1. Starting a new route.\n   *   2. Taking one more step/finishing a route.\n   *   3. Wait for a new route.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  doOneThing_() {\n    if (this.tryNewRoute_()) {\n      return Promise.resolve();\n    }\n\n    if (this.currentRoute_) {\n      return this.takeNextStep_();\n    }\n\n    goog.asserts.assert(this.waitForWork_ == null,\n        'We should not have a promise yet.');\n\n    // We have no more work to do. We will wait until new work has been provided\n    // via request route or until we are destroyed.\n\n    this.implementation_.onIdle(this.currentlyAt_);\n\n    // Wait on a new promise so that we can be resolved by |waitForWork|. This\n    // avoids us acting like a busy-wait.\n    this.waitForWork_ = new shaka.util.PublicPromise();\n    return this.waitForWork_;\n  }\n\n  /**\n   * Check if the walker can start a new route. There are a couple ways this can\n   * happen:\n   *  1. We have a new request but no current route\n   *  2. We have a new request and our current route can be interrupted\n   *\n   * @return {boolean}\n   *    |true| when a new route was started (regardless of reason) and |false|\n   *    when no new route was started.\n   *\n   * @private\n   */\n  tryNewRoute_() {\n    goog.asserts.assert(\n        this.currentStep_ == null,\n        'We should never have a current step between taking steps.');\n\n    if (this.requests_.length == 0) {\n      return false;\n    }\n\n    // If the current route cannot be interrupted, we can't start a new route.\n    if (this.currentRoute_ && !this.currentRoute_.interruptible) {\n      return false;\n    }\n\n    // Stop any previously active routes. Even if we don't pick-up a new route,\n    // this route should stop.\n    if (this.currentRoute_) {\n      this.currentRoute_.listeners.onCancel();\n      this.currentRoute_ = null;\n    }\n\n    // Create and start the next route. We may not take any steps because it may\n    // be interrupted by the next request.\n    const request = this.requests_.shift();\n    const newRoute = request.create(this.currentlyWith_);\n\n    // Based on the current state of |payload|, a new route may not be\n    // possible. In these cases |create| will return |null| to signal that\n    // we should just stop the current route and move onto the next request\n    // (in the next main loop iteration).\n    if (newRoute) {\n      request.listeners.onStart();\n\n      // Convert the route created from the request's create method to an\n      // active route.\n      this.currentRoute_ = {\n        node: newRoute.node,\n        payload: newRoute.payload,\n        interruptible: newRoute.interruptible,\n        listeners: request.listeners,\n      };\n    } else {\n      request.listeners.onSkip();\n    }\n\n    return true;\n  }\n\n\n  /**\n   * Move forward one step on our current route. This assumes that we have a\n   * current route. A couple things can happen when moving forward:\n   *  1. An error - if an error occurs, it will signal an error occurred,\n   *     attempt to recover, and drop the route.\n   *  2. Move - if no error occurs, we will move forward. When we arrive at\n   *     our destination, it will signal the end and drop the route.\n   *\n   * In the event of an error or arriving at the destination, we drop the\n   * current route. This allows us to pick-up a new route next time the main\n   * loop iterates.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async takeNextStep_() {\n    goog.asserts.assert(\n        this.currentRoute_,\n        'We need a current route to take the next step.');\n\n    // Figure out where we are supposed to go next.\n    this.currentlyAt_ = this.implementation_.getNext(\n        this.currentlyAt_,\n        this.currentlyWith_,\n        this.currentRoute_.node,\n        this.currentRoute_.payload);\n\n    this.currentRoute_.listeners.onEnter(this.currentlyAt_);\n\n    // Enter the new node, this is where things can go wrong since it is\n    // possible for \"supported errors\" to occur - errors that the code using\n    // the walker can't predict but can recover from.\n    try {\n      // TODO: This is probably a false-positive.  See eslint/eslint#11687.\n      // eslint-disable-next-line require-atomic-updates\n      this.currentStep_ = this.implementation_.enterNode(\n          /* node= */ this.currentlyAt_,\n          /* has= */ this.currentlyWith_,\n          /* wants= */ this.currentRoute_.payload);\n\n      await this.currentStep_.promise;\n      this.currentStep_ = null;\n\n      // If we are at the end of the route, we need to signal it and clear the\n      // route so that we will pick-up a new route next iteration.\n      if (this.currentlyAt_ == this.currentRoute_.node) {\n        this.currentRoute_.listeners.onEnd();\n        this.currentRoute_ = null;\n      }\n    } catch (error) {\n      if (error.code == shaka.util.Error.Code.OPERATION_ABORTED) {\n        goog.asserts.assert(\n            this.currentRoute_.interruptible,\n            'Do not put abortable steps in non-interruptible routes!');\n        this.currentRoute_.listeners.onCancel();\n      } else {\n        // There was an error with this route, so we going to abandon it and\n        // resolve the error. We don't reset the payload because the payload may\n        // still contain useful information.\n        this.currentRoute_.listeners.onError(error);\n      }\n\n      // The route and step are done. Clear them before we handle the error or\n      // else we may attempt to abort |currentStep_| when handling the error.\n      this.currentRoute_ = null;\n      this.currentStep_ = null;\n\n      // Still need to handle error because aborting an operation could leave us\n      // in an unexpected state.\n      this.currentlyAt_ = await this.implementation_.handleError(\n          this.currentlyWith_,\n          error);\n    }\n  }\n\n  /**\n   * If the main loop is blocked waiting for new work, then resolve the promise\n   * so that the next iteration of the main loop can execute.\n   *\n   * @private\n   */\n  unblockMainLoop_() {\n    if (this.waitForWork_) {\n      this.waitForWork_.resolve();\n      this.waitForWork_ = null;\n    }\n  }\n};\n\n/**\n * @typedef {{\n *   getNext: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Node,\n *       shaka.routing.Payload):shaka.routing.Node,\n *   enterNode: function(\n *       shaka.routing.Node,\n *       shaka.routing.Payload,\n *       shaka.routing.Payload):!shaka.util.AbortableOperation,\n *   handleError: function(\n *       shaka.routing.Payload,\n *       !Error):!Promise.<shaka.routing.Node>,\n *   onIdle: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   There are some parts of the walker that will be per-instance. This type\n *   provides those per-instance parts.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Node,\n *     shaka.routing.Payload):shaka.routing.Node getNext\n *   Get the next node that the walker should move to. This method will be\n *   passed (in this order) the current node, current payload, destination\n *   node, and destination payload.\n *\n * @property {function(\n *     shaka.routing.Node,\n *     shaka.routing.Payload,\n *     shaka.routing.Payload):!Promise} enterNode\n *   When the walker moves into a node, it will call |enterNode| and allow the\n *   implementation to change the current payload. This method will be passed\n *   (in this order) the node the walker is entering, the current payload, and\n *   the destination payload. This method should NOT modify the destination\n *   payload.\n *\n * @property {function(\n *     shaka.routing.Payload,\n *     !Error):!Promise.<shaka.routing.Node> handleError\n *   This is the callback for when |enterNode| fails. It is passed the current\n *   payload and the error. If a step is aborted, the error will be\n *   OPERATION_ABORTED. It should reset all external dependences, modify the\n *   payload, and return the new current node. Calls to |handleError| should\n *   always resolve and the walker should always be able to continue operating.\n *\n * @property {function(shaka.routing.Node)} onIdle\n *   This is the callback for when the walker has finished processing all route\n *   requests and needs to wait for more work. |onIdle| will be passed the\n *   current node.  After |onIdle| has been called, the walker will block until\n *   a new request is made, or the walker is destroyed.\n */\nshaka.routing.Walker.Implementation;\n\n/**\n * @typedef {{\n *   onStart: function(),\n *   onEnd: function(),\n *   onCancel: function(),\n *   onError: function(!Error),\n *   onSkip: function(),\n *   onEnter: function(shaka.routing.Node)\n * }}\n *\n * @description\n *   The collection of callbacks that the walker will call while executing a\n *   route. By setting these immediately after calling |startNewRoute|\n *   the user can react to route-specific events.\n *\n * @property {function()} onStart\n *   The callback for when the walker has accepted the route and will soon take\n *   the first step unless interrupted. Either |onStart| or |onSkip| will be\n *   called.\n *\n * @property {function()} onEnd\n *   The callback for when the walker has reached the end of the route. For\n *   every route that had |onStart| called, either |onEnd|, |onCancel|, or\n *   |onError| will be called.\n *\n * @property {function()} onCancel\n *   The callback for when the walker is stopping a route before getting to the\n *   end. This will be called either when a new route is interrupting the route,\n *   or the walker is being destroyed mid-route. |onCancel| will only be called\n *   when a route has been interrupted by another route or the walker is being\n *   destroyed.\n *\n * @property {function()} onError\n *   The callback for when the walker failed to execute the route because an\n *   unexpected error occurred. The walker will enter a recovery mode and the\n *   route will be abandoned.\n *\n * @property {function()} onSkip\n *   The callback for when the walker was ready to start the route, but the\n *   create-method returned |null|.\n *\n * @property {function()} onEnter\n *   The callback for when the walker enters a node. This will allow us to\n *   track the progress of the walker within a per-route scope.\n */\nshaka.routing.Walker.Listeners;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean\n * }}\n *\n * @description\n *   The public description of where the walker should go. This is created\n *   when the callback given to |startNewRoute| is called by the walker.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n */\nshaka.routing.Walker.Route;\n\n/**\n * @typedef {{\n *   node: shaka.routing.Node,\n *   payload: shaka.routing.Payload,\n *   interruptible: boolean,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The active route is the walker's internal representation of a route. It\n *   is the union of |shaka.routing.Walker.Request_| and the\n *   |shaka.routing.Walker.Route| created by |shaka.routing.Walker.Request_|.\n *\n * @property {shaka.routing.Node} node\n *   The node that the walker should move towards. This will be passed to\n *   |shaka.routing.Walker.Implementation.getNext| to help determine where to\n *   go next.\n *\n * @property {shaka.routing.Payload| payload\n *   The payload that the walker should have once it arrives at |node|. This\n *   will be passed to the |shaka.routing.Walker.Implementation.getNext| to\n *   help determine where to go next.\n *\n * @property {boolean} interruptible\n *   Whether or not this route can be interrupted by another request. When\n *   |true| this route will be interrupted so that a pending request can be\n *   resolved. When |false|, the route will be allowed to finished before\n *   resolving the next request.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The listeners that the walker can used to communicate with whoever\n *   requested the route.\n *\n * @private\n */\nshaka.routing.Walker.ActiveRoute_;\n\n/**\n * @typedef {{\n *   create: function(shaka.routing.Payload):?shaka.routing.Walker.Route,\n *   listeners: shaka.routing.Walker.Listeners\n * }}\n *\n * @description\n *   The request is how users can talk to the walker. They can give the walker\n *   a request and when the walker is ready, it will resolve the request by\n *   calling |create|.\n *\n * @property {\n *     function(shaka.routing.Payload):?shaka.routing.Walker.Route} create\n *   The function called when the walker is ready to start a new route. This can\n *   return |null| to say that the request was not possible and should be\n *   skipped.\n *\n * @property {shaka.routing.Walker.Listeners} listeners\n *   The collection of callbacks that the walker will use to talk to whoever\n *   provided the request.\n *\n * @private\n */\nshaka.routing.Walker.Request_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Utils');\n\ngoog.require('shaka.text.Cue');\n\n\nshaka.text.Utils = class {\n  /**\n   * Flatten nested cue payloads recursively.  If a cue has nested cues,\n   * their contents should be combined and replace the payload of the parent.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @return {string}\n   * @private\n   */\n  static flattenPayload_(cue) {\n    // Handle styles (currently bold/italics/underline).\n    // TODO: add support for color rendering.\n    const openStyleTags = [];\n    const bold = cue.fontWeight >= shaka.text.Cue.fontWeight.BOLD;\n    const italics = cue.fontStyle == shaka.text.Cue.fontStyle.ITALIC;\n    const underline = cue.textDecoration.includes(\n        shaka.text.Cue.textDecoration.UNDERLINE);\n    if (bold) {\n      openStyleTags.push('b');\n    }\n    if (italics) {\n      openStyleTags.push('i');\n    }\n    if (underline) {\n      openStyleTags.push('u');\n    }\n\n    // Prefix opens tags, suffix closes tags in reverse order of opening.\n    const prefixStyleTags = openStyleTags.reduce((acc, tag) => {\n      return `${acc}<${tag}>`;\n    }, '');\n    const suffixStyleTags = openStyleTags.reduceRight((acc, tag) => {\n      return `${acc}</${tag}>`;\n    }, '');\n\n    if (cue.lineBreak) {\n      // This is a vertical lineBreak, so insert a newline.\n      return '\\n';\n    } else if (cue.nestedCues.length) {\n      return cue.nestedCues.map(shaka.text.Utils.flattenPayload_).join('');\n    } else {\n      // This is a real cue.\n      return prefixStyleTags + cue.payload + suffixStyleTags;\n    }\n  }\n\n  /**\n   * We don't want to modify the array or objects passed in, since we don't\n   * technically own them.  So we build a new array and replace certain items\n   * in it if they need to be flattened.\n   * We also don't want to flatten the text payloads starting at a container\n   * element; otherwise, for containers encapsulating multiple caption lines,\n   * the lines would merge into a single cue. This is undesirable when a\n   * subset of the captions are outside of the append time window. To fix\n   * this, we only call flattenPayload() starting at elements marked as\n   * isContainer = false.\n   *\n   * @param {!Array.<!shaka.text.Cue>} cues\n   * @param {!Array.<!shaka.text.Cue>} result\n   * @return {!Array.<!shaka.text.Cue>}\n   */\n  static getCuesToFlatten(cues, result) {\n    for (const cue of cues) {\n      if (cue.isContainer) {\n        // Recurse to find the actual text payload cues.\n        shaka.text.Utils.getCuesToFlatten(cue.nestedCues, result);\n      } else {\n        // Flatten the payload.\n        const flatCue = cue.clone();\n        flatCue.nestedCues = [];\n        flatCue.payload = shaka.text.Utils.flattenPayload_(cue);\n        result.push(flatCue);\n      }\n    }\n    return result;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.text.SimpleTextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.Utils');\n\n\n/**\n * A text displayer plugin using the browser's native VTTCue interface.\n *\n * @implements {shaka.extern.TextDisplayer}\n * @export\n */\nshaka.text.SimpleTextDisplayer = class {\n  /** @param {HTMLMediaElement} video */\n  constructor(video) {\n    /** @private {TextTrack} */\n    this.textTrack_ = null;\n\n    // TODO: Test that in all cases, the built-in CC controls in the video\n    // element are toggling our TextTrack.\n\n    // If the video element has TextTracks, disable them.  If we see one that\n    // was created by a previous instance of Shaka Player, reuse it.\n    for (const track of Array.from(video.textTracks)) {\n      // NOTE: There is no API available to remove a TextTrack from a video\n      // element.\n      track.mode = 'disabled';\n\n      if (track.label == shaka.Player.TextTrackLabel) {\n        this.textTrack_ = track;\n      }\n    }\n\n    if (!this.textTrack_) {\n      // As far as I can tell, there is no observable difference between setting\n      // kind to 'subtitles' or 'captions' when creating the TextTrack object.\n      // The individual text tracks from the manifest will still have their own\n      // kinds which can be displayed in the app's UI.\n      this.textTrack_ = video.addTextTrack(\n          'subtitles', shaka.Player.TextTrackLabel);\n    }\n    this.textTrack_.mode = 'hidden';\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  remove(start, end) {\n    // Check that the displayer hasn't been destroyed.\n    if (!this.textTrack_) {\n      return false;\n    }\n\n    const removeInRange = (cue) => {\n      const inside = cue.startTime < end && cue.endTime > start;\n      return inside;\n    };\n\n    shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeInRange);\n\n    return true;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  append(cues) {\n    const flattenedCues = shaka.text.Utils.getCuesToFlatten(cues, []);\n\n    // Convert cues.\n    const textTrackCues = [];\n    const cuesInTextTrack = this.textTrack_.cues ?\n                            Array.from(this.textTrack_.cues) : [];\n\n    for (const inCue of flattenedCues) {\n      // When a VTT cue spans a segment boundary, the cue will be duplicated\n      // into two segments.\n      // To avoid displaying duplicate cues, if the current textTrack cues\n      // list already contains the cue, skip it.\n      const containsCue = cuesInTextTrack.some((cueInTextTrack) => {\n        if (cueInTextTrack.startTime == inCue.startTime &&\n            cueInTextTrack.endTime == inCue.endTime &&\n            cueInTextTrack.text == inCue.payload) {\n          return true;\n        }\n        return false;\n      });\n\n      if (!containsCue) {\n        const cue =\n            shaka.text.SimpleTextDisplayer.convertToTextTrackCue_(inCue);\n        if (cue) {\n          textTrackCues.push(cue);\n        }\n      }\n    }\n\n    // Sort the cues based on start/end times.  Make a copy of the array so\n    // we can get the index in the original ordering.  Out of order cues are\n    // rejected by Edge.  See https://bit.ly/2K9VX3s\n    const sortedCues = textTrackCues.slice().sort((a, b) => {\n      if (a.startTime != b.startTime) {\n        return a.startTime - b.startTime;\n      } else if (a.endTime != b.endTime) {\n        return a.endTime - b.startTime;\n      } else {\n        // The browser will display cues with identical time ranges from the\n        // bottom up.  Reversing the order of equal cues means the first one\n        // parsed will be at the top, as you would expect.\n        // See https://github.com/shaka-project/shaka-player/issues/848 for\n        // more info.\n        // However, this ordering behavior is part of VTTCue's \"line\" field.\n        // Some platforms don't have a real VTTCue and use a polyfill instead.\n        // When VTTCue is polyfilled or does not support \"line\", we should _not_\n        // reverse the order.  This occurs on legacy Edge.\n        // eslint-disable-next-line no-restricted-syntax\n        if ('line' in VTTCue.prototype) {\n          // Native VTTCue\n          return textTrackCues.indexOf(b) - textTrackCues.indexOf(a);\n        } else {\n          // Polyfilled VTTCue\n          return textTrackCues.indexOf(a) - textTrackCues.indexOf(b);\n        }\n      }\n    });\n\n    for (const cue of sortedCues) {\n      this.textTrack_.addCue(cue);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    if (this.textTrack_) {\n      const removeIt = (cue) => true;\n      shaka.text.SimpleTextDisplayer.removeWhere_(this.textTrack_, removeIt);\n\n      // NOTE: There is no API available to remove a TextTrack from a video\n      // element.\n      this.textTrack_.mode = 'disabled';\n    }\n\n    this.textTrack_ = null;\n    return Promise.resolve();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isTextVisible() {\n    return this.textTrack_.mode == 'showing';\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setTextVisibility(on) {\n    this.textTrack_.mode = on ? 'showing' : 'hidden';\n  }\n\n  /**\n   * @param {!shaka.extern.Cue} shakaCue\n   * @return {TextTrackCue}\n   * @private\n   */\n  static convertToTextTrackCue_(shakaCue) {\n    if (shakaCue.startTime >= shakaCue.endTime) {\n      // Edge will throw in this case.\n      // See issue #501\n      shaka.log.warning('Invalid cue times: ' + shakaCue.startTime +\n                        ' - ' + shakaCue.endTime);\n      return null;\n    }\n\n    const Cue = shaka.text.Cue;\n    /** @type {VTTCue} */\n    const vttCue = new VTTCue(\n        shakaCue.startTime,\n        shakaCue.endTime,\n        shakaCue.payload);\n\n    // NOTE: positionAlign and lineAlign settings are not supported by Chrome\n    // at the moment, so setting them will have no effect.\n    // The bug on chromium to implement them:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=633690\n\n    vttCue.lineAlign = shakaCue.lineAlign;\n    vttCue.positionAlign = shakaCue.positionAlign;\n    if (shakaCue.size) {\n      vttCue.size = shakaCue.size;\n    }\n\n    try {\n      // Safari 10 seems to throw on align='center'.\n      vttCue.align = shakaCue.textAlign;\n    } catch (exception) {}\n\n    if (shakaCue.textAlign == 'center' && vttCue.align != 'center') {\n      // We want vttCue.position = 'auto'. By default, |position| is set to\n      // \"auto\". If we set it to \"auto\" safari will throw an exception, so we\n      // must rely on the default value.\n      vttCue.align = 'middle';\n    }\n\n    if (shakaCue.writingMode ==\n            Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n      vttCue.vertical = 'lr';\n    } else if (shakaCue.writingMode ==\n             Cue.writingMode.VERTICAL_RIGHT_TO_LEFT) {\n      vttCue.vertical = 'rl';\n    }\n\n    // snapToLines flag is true by default\n    if (shakaCue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n      vttCue.snapToLines = false;\n    }\n\n    if (shakaCue.line != null) {\n      vttCue.line = shakaCue.line;\n    }\n\n    if (shakaCue.position != null) {\n      vttCue.position = shakaCue.position;\n    }\n\n    return vttCue;\n  }\n\n  /**\n   * Iterate over all the cues in a text track and remove all those for which\n   * |predicate(cue)| returns true.\n   *\n   * @param {!TextTrack} track\n   * @param {function(!TextTrackCue):boolean} predicate\n   * @private\n   */\n  static removeWhere_(track, predicate) {\n    // Since |track.cues| can be null if |track.mode| is \"disabled\", force it to\n    // something other than \"disabled\".\n    //\n    // If the track is already showing, then we should keep it as showing. But\n    // if it something else, we will use hidden so that we don't \"flash\" cues on\n    // the screen.\n    const oldState = track.mode;\n    const tempState = oldState == 'showing' ? 'showing' : 'hidden';\n\n    track.mode = tempState;\n\n    goog.asserts.assert(\n        track.cues,\n        'Cues should be accessible when mode is set to \"' + tempState + '\".');\n\n    // Create a copy of the list to avoid errors while iterating.\n    for (const cue of Array.from(track.cues)) {\n      if (cue && predicate(cue)) {\n        track.removeCue(cue);\n      }\n    }\n\n    track.mode = oldState;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.util.Dom');\n\ngoog.require('goog.asserts');\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/** @export */\nshaka.util.Dom = class {\n  /**\n   * Creates an element, and cast the type from Element to HTMLElement.\n   *\n   * @param {string} tagName\n   * @return {!HTMLElement}\n   */\n  static createHTMLElement(tagName) {\n    const element =\n      /** @type {!HTMLElement} */ (document.createElement(tagName));\n    return element;\n  }\n\n\n  /**\n   * Create a \"button\" element with the correct type.\n   *\n   * The compiler is very picky about the use of the \"disabled\" property on\n   * HTMLElement, since it is only defined on certain subclasses of that.  This\n   * method merely creates a button and casts it to the correct type.\n   *\n   * @return {!HTMLButtonElement}\n   */\n  static createButton() {\n    const button = document.createElement('button');\n    button.setAttribute('type', 'button');\n    return /** @type {!HTMLButtonElement} */ (button);\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLElement}\n   */\n  static asHTMLElement(original) {\n    return /** @type {!HTMLElement}*/ (original);\n  }\n\n\n  /**\n   * Cast a Node/Element to an HTMLMediaElement\n   *\n   * @param {!Node|!Element} original\n   * @return {!HTMLMediaElement}\n   */\n  static asHTMLMediaElement(original) {\n    return /** @type {!HTMLMediaElement}*/ (original);\n  }\n\n\n  /**\n   * Returns the element with a given class name.\n   * Assumes the class name to be unique for a given parent.\n   *\n   * @param {string} className\n   * @param {!HTMLElement} parent\n   * @return {!HTMLElement}\n   */\n  static getElementByClassName(className, parent) {\n    const elements = parent.getElementsByClassName(className);\n    goog.asserts.assert(elements.length == 1,\n        'Should only be one element with class name ' + className);\n\n    return shaka.util.Dom.asHTMLElement(elements[0]);\n  }\n\n  /**\n   * Remove all of the child nodes of an element.\n   * @param {!Element} element\n   * @export\n   */\n  static removeAllChildren(element) {\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n  }\n};\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.text.UITextDisplayer');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.util.Dom');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * The text displayer plugin for the Shaka Player UI.  Can also be used directly\n * by providing an appropriate container element.\n *\n * @implements {shaka.extern.TextDisplayer}\n * @final\n * @export\n */\nshaka.text.UITextDisplayer = class {\n  /**\n   * Constructor.\n   * @param {HTMLMediaElement} video\n   * @param {HTMLElement} videoContainer\n   */\n  constructor(video, videoContainer) {\n    goog.asserts.assert(videoContainer, 'videoContainer should be valid.');\n\n    /** @private {boolean} */\n    this.isTextVisible_ = false;\n\n    /** @private {!Array.<!shaka.text.Cue>} */\n    this.cues_ = [];\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {HTMLElement} */\n    this.videoContainer_ = videoContainer;\n\n    /** @type {HTMLElement} */\n    this.textContainer_ = shaka.util.Dom.createHTMLElement('div');\n    this.textContainer_.classList.add('shaka-text-container');\n\n    // Set the subtitles text-centered by default.\n    this.textContainer_.style.textAlign = 'center';\n\n    // Set the captions in the middle horizontally by default.\n    this.textContainer_.style.display = 'flex';\n    this.textContainer_.style.flexDirection = 'column';\n    this.textContainer_.style.alignItems = 'center';\n\n    // Set the captions at the bottom by default.\n    this.textContainer_.style.justifyContent = 'flex-end';\n\n    this.videoContainer_.appendChild(this.textContainer_);\n\n    /**\n     * The captions' update period in seconds.\n     * @private {number}\n     */\n    const updatePeriod = 0.25;\n\n    /** @private {shaka.util.Timer} */\n    this.captionsTimer_ = new shaka.util.Timer(() => {\n      this.updateCaptions_();\n    }).tickEvery(updatePeriod);\n\n    /**\n     * Maps cues to cue elements. Specifically points out the wrapper element of\n     * the cue (e.g. the HTML element to put nested cues inside).\n     * @private {Map.<!shaka.extern.Cue, !{\n     *   cueElement: !HTMLElement,\n     *   regionElement: HTMLElement,\n     *   wrapper: !HTMLElement\n     * }>}\n     */\n    this.currentCuesMap_ = new Map();\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(document, 'fullscreenchange', () => {\n      this.updateCaptions_(/* forceUpdate= */ true);\n    });\n\n    /** @private {ResizeObserver} */\n    this.resizeObserver_ = null;\n    if ('ResizeObserver' in window) {\n      this.resizeObserver_ = new ResizeObserver(() => {\n        this.updateCaptions_(/* forceUpdate= */ true);\n      });\n      this.resizeObserver_.observe(this.textContainer_);\n    }\n\n    /** @private {Map.<string, !HTMLElement>} */\n    this.regionElements_ = new Map();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  append(cues) {\n    // Clone the cues list for performace optimization. We can avoid the cues\n    // list growing during the comparisons for duplicate cues.\n    // See: https://github.com/shaka-project/shaka-player/issues/3018\n    const cuesList = [...this.cues_];\n    for (const cue of cues) {\n      // When a VTT cue spans a segment boundary, the cue will be duplicated\n      // into two segments.\n      // To avoid displaying duplicate cues, if the current cue list already\n      // contains the cue, skip it.\n      const containsCue = cuesList.some(\n          (cueInList) => shaka.text.Cue.equal(cueInList, cue));\n      if (!containsCue) {\n        this.cues_.push(cue);\n      }\n    }\n\n    this.updateCaptions_();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    // Remove the text container element from the UI.\n    this.videoContainer_.removeChild(this.textContainer_);\n    this.textContainer_ = null;\n\n    this.isTextVisible_ = false;\n    this.cues_ = [];\n    if (this.captionsTimer_) {\n      this.captionsTimer_.stop();\n    }\n\n    this.currentCuesMap_.clear();\n\n    // Tear-down the event manager to ensure messages stop moving around.\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    if (this.resizeObserver_) {\n      this.resizeObserver_.disconnect();\n      this.resizeObserver_ = null;\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  remove(start, end) {\n    // Return false if destroy() has been called.\n    if (!this.textContainer_) {\n      return false;\n    }\n\n    // Remove the cues out of the time range.\n    const oldNumCues = this.cues_.length;\n    this.cues_ = this.cues_.filter(\n        (cue) => cue.startTime < start || cue.endTime >= end);\n    // If anything was actually removed in this process, force the captions to\n    // update. This makes sure that the currently-displayed cues will stop\n    // displaying if removed (say, due to the user changing languages).\n    const forceUpdate = oldNumCues > this.cues_.length;\n    this.updateCaptions_(forceUpdate);\n\n    return true;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  isTextVisible() {\n    return this.isTextVisible_;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setTextVisibility(on) {\n    this.isTextVisible_ = on;\n  }\n\n  /**\n   * @private\n   */\n  isElementUnderTextContainer_(elemToCheck) {\n    while (elemToCheck != null) {\n      if (elemToCheck == this.textContainer_) {\n        return true;\n      }\n      elemToCheck = elemToCheck.parentElement;\n    }\n    return false;\n  }\n\n  /**\n   * @param {!Array.<!shaka.extern.Cue>} cues\n   * @param {!HTMLElement} container\n   * @param {number} currentTime\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @private\n   */\n  updateCuesRecursive_(cues, container, currentTime, parents) {\n    // Set to true if the cues have changed in some way, which will require\n    // DOM changes. E.g. if a cue was added or removed.\n    let updateDOM = false;\n    /**\n     * The elements to remove from the DOM.\n     * Some of these elements may be added back again, if their corresponding\n     * cue is in toPlant.\n     * These elements are only removed if updateDOM is true.\n     * @type {!Array.<!HTMLElement>}\n     */\n    const toUproot = [];\n    /**\n     * The cues whose corresponding elements should be in the DOM.\n     * Some of these might be new, some might have been displayed beforehand.\n     * These will only be added if updateDOM is true.\n     * @type {!Array.<!shaka.extern.Cue>}\n     */\n    const toPlant = [];\n    for (const cue of cues) {\n      parents.push(cue);\n\n      let cueRegistry = this.currentCuesMap_.get(cue);\n      const shouldBeDisplayed =\n          cue.startTime <= currentTime && cue.endTime > currentTime;\n      let wrapper = cueRegistry ? cueRegistry.wrapper : null;\n\n      if (cueRegistry) {\n        // If the cues are replanted, all existing cues should be uprooted,\n        // even ones which are going to be planted again.\n        toUproot.push(cueRegistry.cueElement);\n\n        // Also uproot all displayed region elements.\n        if (cueRegistry.regionElement) {\n          toUproot.push(cueRegistry.regionElement);\n        }\n\n        // If the cue should not be displayed, remove it entirely.\n        if (!shouldBeDisplayed) {\n          // Since something has to be removed, we will need to update the DOM.\n          updateDOM = true;\n          this.currentCuesMap_.delete(cue);\n          cueRegistry = null;\n        }\n      }\n\n      if (shouldBeDisplayed) {\n        toPlant.push(cue);\n        if (!cueRegistry) {\n          // The cue has to be made!\n          this.createCue_(cue, parents);\n          cueRegistry = this.currentCuesMap_.get(cue);\n          wrapper = cueRegistry.wrapper;\n          updateDOM = true;\n        } else if (!this.isElementUnderTextContainer_(wrapper)) {\n          // We found that the wrapper needs to be in the DOM\n          updateDOM = true;\n        }\n      }\n\n      // Recursively check the nested cues, to see if they need to be added or\n      // removed.\n      // If wrapper is null, that means that the cue is not only not being\n      // displayed currently, it also was not removed this tick. So it's\n      // guaranteed that the children will neither need to be added nor removed.\n      if (cue.nestedCues.length > 0 && wrapper) {\n        this.updateCuesRecursive_(\n            cue.nestedCues, wrapper, currentTime, parents);\n      }\n\n      const topCue = parents.pop();\n      goog.asserts.assert(topCue == cue, 'Parent cues should be kept in order');\n    }\n\n    if (updateDOM) {\n      for (const element of toUproot) {\n        // NOTE: Because we uproot shared region elements, too, we might hit an\n        // element here that has no parent because we've already processed it.\n        if (element.parentElement) {\n          element.parentElement.removeChild(element);\n        }\n      }\n      toPlant.sort((a, b) => {\n        if (a.startTime != b.startTime) {\n          return a.startTime - b.startTime;\n        } else {\n          return a.endTime - b.endTime;\n        }\n      });\n      for (const cue of toPlant) {\n        const cueRegistry = this.currentCuesMap_.get(cue);\n        goog.asserts.assert(cueRegistry, 'cueRegistry should exist.');\n        if (cueRegistry.regionElement) {\n          container.appendChild(cueRegistry.regionElement);\n          cueRegistry.regionElement.appendChild(cueRegistry.cueElement);\n        } else {\n          container.appendChild(cueRegistry.cueElement);\n        }\n      }\n    }\n  }\n\n  /**\n   * Display the current captions.\n   * @param {boolean=} forceUpdate\n   * @private\n   */\n  updateCaptions_(forceUpdate = false) {\n    if (!this.textContainer_) {\n      return;\n    }\n\n    const currentTime = this.video_.currentTime;\n    if (!this.isTextVisible_ || forceUpdate) {\n      // Remove child elements from all regions.\n      for (const regionElement of this.regionElements_.values()) {\n        shaka.util.Dom.removeAllChildren(regionElement);\n      }\n      // Remove all top-level elements in the text container.\n      shaka.util.Dom.removeAllChildren(this.textContainer_);\n      // Clear the element maps.\n      this.currentCuesMap_.clear();\n      this.regionElements_.clear();\n    }\n    if (this.isTextVisible_) {\n      // Log currently attached cue elements for verification, later.\n      const previousCuesMap = new Map();\n      for (const cue of this.currentCuesMap_.keys()) {\n        previousCuesMap.set(cue, this.currentCuesMap_.get(cue));\n      }\n\n      // Update the cues.\n      this.updateCuesRecursive_(\n          this.cues_, this.textContainer_, currentTime, /* parents= */ []);\n\n      if (goog.DEBUG) {\n        // Previously, we had an issue (#2076) where cues sometimes were not\n        // properly removed from the DOM. It is not clear if this issue still\n        // happens, so the previous fix for it has been changed to an assert.\n        for (const cue of previousCuesMap.keys()) {\n          if (!this.currentCuesMap_.has(cue)) {\n            // TODO: If the problem does not appear again, then we should remove\n            // this assert (and the previousCuesMap code) in Shaka v4.\n            const cueElement = previousCuesMap.get(cue).cueElement;\n            goog.asserts.assert(\n                !cueElement.parentNode, 'Cue was not properly removed!');\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Compute a unique internal id:\n   * Regions can reuse the id but have different dimensions, we need to\n   * consider those differences\n   * @param {shaka.extern.CueRegion} region\n   * @private\n   */\n  generateRegionId_(region) {\n    const percentageUnit = shaka.text.CueRegion.units.PERCENTAGE;\n    const heightUnit = region.heightUnits == percentageUnit ? '%' : 'px';\n    const viewportAnchorUnit =\n        region.viewportAnchorUnits == percentageUnit ? '%' : 'px';\n    const uniqueRegionId = `${region.id}_${\n      region.width}x${region.height}${heightUnit}-${\n      region.viewportAnchorX}x${region.viewportAnchorY}${viewportAnchorUnit}`;\n\n    return uniqueRegionId;\n  }\n\n  /**\n   * Get or create a region element corresponding to the cue region.  These are\n   * cached by ID.\n   *\n   * @param {!shaka.extern.Cue} cue\n   * @return {!HTMLElement}\n   * @private\n   */\n  getRegionElement_(cue) {\n    const region = cue.region;\n\n    const regionId = this.generateRegionId_(region);\n    if (this.regionElements_.has(regionId)) {\n      return this.regionElements_.get(regionId);\n    }\n\n    const regionElement = shaka.util.Dom.createHTMLElement('span');\n\n    const percentageUnit = shaka.text.CueRegion.units.PERCENTAGE;\n    const heightUnit = region.heightUnits == percentageUnit ? '%' : 'px';\n    const widthUnit = region.widthUnits == percentageUnit ? '%' : 'px';\n    const viewportAnchorUnit =\n        region.viewportAnchorUnits == percentageUnit ? '%' : 'px';\n\n    regionElement.id = 'shaka-text-region---' + regionId;\n    regionElement.classList.add('shaka-text-region');\n\n    regionElement.style.height = region.height + heightUnit;\n    regionElement.style.width = region.width + widthUnit;\n    regionElement.style.position = 'absolute';\n    regionElement.style.top = region.viewportAnchorY + viewportAnchorUnit;\n    regionElement.style.left = region.viewportAnchorX + viewportAnchorUnit;\n\n    regionElement.style.display = 'flex';\n    regionElement.style.flexDirection = 'column';\n    regionElement.style.alignItems = 'center';\n\n    if (cue.displayAlign == shaka.text.Cue.displayAlign.BEFORE) {\n      regionElement.style.justifyContent = 'flex-start';\n    } else if (cue.displayAlign == shaka.text.Cue.displayAlign.CENTER) {\n      regionElement.style.justifyContent = 'center';\n    } else {\n      regionElement.style.justifyContent = 'flex-end';\n    }\n\n    this.regionElements_.set(regionId, regionElement);\n    return regionElement;\n  }\n\n  /**\n   * Creates the object for a cue.\n   *\n   * @param {!shaka.extern.Cue} cue\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @private\n   */\n  createCue_(cue, parents) {\n    const isNested = parents.length > 1;\n    let type = isNested ? 'span' : 'div';\n    if (cue.lineBreak) {\n      type = 'br';\n    }\n\n    const needWrapper = !isNested && cue.nestedCues.length > 0;\n\n    // Nested cues are inline elements.  Top-level cues are block elements.\n    const cueElement = shaka.util.Dom.createHTMLElement(type);\n    if (type != 'br') {\n      this.setCaptionStyles_(cueElement, cue, parents, needWrapper);\n    }\n\n    let regionElement = null;\n    if (cue.region && cue.region.id) {\n      regionElement = this.getRegionElement_(cue);\n    }\n\n    let wrapper = cueElement;\n    if (needWrapper) {\n      // Create a wrapper element which will serve to contain all children into\n      // a single item.  This ensures that nested span elements appear\n      // horizontally and br elements occupy no vertical space.\n      wrapper = shaka.util.Dom.createHTMLElement('span');\n      wrapper.classList.add('shaka-text-wrapper');\n      wrapper.style.backgroundColor = cue.backgroundColor;\n      cueElement.appendChild(wrapper);\n    }\n\n    this.currentCuesMap_.set(cue, {cueElement, wrapper, regionElement});\n  }\n\n  /**\n   * @param {!HTMLElement} cueElement\n   * @param {!shaka.extern.Cue} cue\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @param {boolean} hasWrapper\n   * @private\n   */\n  setCaptionStyles_(cueElement, cue, parents, hasWrapper) {\n    const Cue = shaka.text.Cue;\n    const inherit =\n        (cb) => shaka.text.UITextDisplayer.inheritProperty_(parents, cb);\n    const style = cueElement.style;\n    const isLeaf = cue.nestedCues.length == 0;\n    const isNested = parents.length > 1;\n\n    // TODO: wrapLine is not yet supported.  Lines always wrap.\n\n    // White space should be preserved if emitted by the text parser.  It's the\n    // job of the parser to omit any whitespace that should not be displayed.\n    // Using 'pre-wrap' means that whitespace is preserved even at the end of\n    // the text, but that lines which overflow can still be broken.\n    style.whiteSpace = 'pre-wrap';\n\n    // Using 'break-spaces' would be better, as it would preserve even trailing\n    // spaces, but that only shipped in Chrome 76.  As of July 2020, Safari\n    // still has not implemented break-spaces, and the original Chromecast will\n    // never have this feature since it no longer gets firmware updates.\n    // So we need to replace trailing spaces with non-breaking spaces.\n    const text = cue.payload.replace(/\\s+$/g, (match) => {\n      const nonBreakingSpace = '\\xa0';\n      return nonBreakingSpace.repeat(match.length);\n    });\n\n    style.webkitTextStrokeColor = cue.textStrokeColor;\n    style.webkitTextStrokeWidth = cue.textStrokeWidth;\n    style.color = cue.color;\n    style.direction = cue.direction;\n    style.opacity = cue.opacity;\n    style.paddingLeft = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.linePadding, cue, this.videoContainer_);\n    style.paddingRight =\n        shaka.text.UITextDisplayer.convertLengthValue_(\n            cue.linePadding, cue, this.videoContainer_);\n    style.textShadow = cue.textShadow;\n\n    if (cue.backgroundImage) {\n      style.backgroundImage = 'url(\\'' + cue.backgroundImage + '\\')';\n      style.backgroundRepeat = 'no-repeat';\n      style.backgroundSize = 'contain';\n      style.backgroundPosition = 'center';\n\n      // Quoting https://www.w3.org/TR/ttml-imsc1.2/:\n      // \"The width and height (in pixels) of the image resource referenced by\n      // smpte:backgroundImage SHALL be equal to the width and height expressed\n      // by the tts:extent attribute of the region in which the div element is\n      // presented\".\n      style.width = '100%';\n      style.height = '100%';\n    } else {\n      // If we have both text and nested cues, then style everything; otherwise\n      // place the text in its own <span> so the background doesn't fill the\n      // whole region.\n      let elem;\n      if (cue.nestedCues.length) {\n        elem = cueElement;\n      } else {\n        elem = shaka.util.Dom.createHTMLElement('span');\n        cueElement.appendChild(elem);\n      }\n\n      if (cue.border) {\n        elem.style.border = cue.border;\n      }\n      if (!hasWrapper) {\n        const bgColor = inherit((c) => c.backgroundColor);\n        if (bgColor) {\n          elem.style.backgroundColor = bgColor;\n        } else if (text) {\n          // If there is no background, default to a semi-transparent black.\n          // Only do this for the text itself.\n          elem.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';\n        }\n      }\n      if (text) {\n        elem.textContent = text;\n      }\n    }\n\n    // The displayAlign attribute specifies the vertical alignment of the\n    // captions inside the text container. Before means at the top of the\n    // text container, and after means at the bottom.\n    if (isNested && !parents[parents.length - 1].isContainer) {\n      style.display = 'inline';\n    } else {\n      style.display = 'flex';\n      style.flexDirection = 'column';\n      style.alignItems = 'center';\n\n      if (cue.displayAlign == Cue.displayAlign.BEFORE) {\n        style.justifyContent = 'flex-start';\n      } else if (cue.displayAlign == Cue.displayAlign.CENTER) {\n        style.justifyContent = 'center';\n      } else {\n        style.justifyContent = 'flex-end';\n      }\n    }\n\n    if (!isLeaf) {\n      style.margin = '0';\n    }\n\n    style.fontFamily = cue.fontFamily;\n    style.fontWeight = cue.fontWeight.toString();\n    style.fontStyle = cue.fontStyle;\n    style.letterSpacing = cue.letterSpacing;\n    style.fontSize = shaka.text.UITextDisplayer.convertLengthValue_(\n        cue.fontSize, cue, this.videoContainer_);\n\n    // The line attribute defines the positioning of the text container inside\n    // the video container.\n    // - The line offsets the text container from the top, the right or left of\n    //   the video viewport as defined by the writing direction.\n    // - The value of the line is either as a number of lines, or a percentage\n    //   of the video viewport height or width.\n    // The lineAlign is an alignment for the text container's line.\n    // - The Start alignment means the text containers top side (for horizontal\n    //   cues), left side (for vertical growing right), or right side (for\n    //   vertical growing left) is aligned at the line.\n    // - The Center alignment means the text container is centered at the line\n    //   (to be implemented).\n    // - The End Alignment means The text containers bottom side (for\n    //   horizontal cues), right side (for vertical growing right), or left side\n    //   (for vertical growing left) is aligned at the line.\n    // TODO: Implement line alignment with line number.\n    // TODO: Implement lineAlignment of 'CENTER'.\n    if (cue.line != null) {\n      if (cue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {\n        style.position = 'absolute';\n        if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n          style.width = '100%';\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            style.top = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            style.bottom = (100 - cue.line) + '%';\n          }\n        } else if (cue.writingMode == Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {\n          style.height = '100%';\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            style.left = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            style.right = (100 - cue.line) + '%';\n          }\n        } else {\n          style.height = '100%';\n          if (cue.lineAlign == Cue.lineAlign.START) {\n            style.right = cue.line + '%';\n          } else if (cue.lineAlign == Cue.lineAlign.END) {\n            style.left = (100 - cue.line) + '%';\n          }\n        }\n      }\n    }\n\n    style.lineHeight = cue.lineHeight;\n\n    // The position defines the indent of the text container in the\n    // direction defined by the writing direction.\n    if (cue.position != null) {\n      if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n        style.paddingLeft = cue.position;\n      } else {\n        style.paddingTop = cue.position;\n      }\n    }\n\n    // The positionAlign attribute is an alignment for the text container in\n    // the dimension of the writing direction.\n    if (cue.positionAlign == Cue.positionAlign.LEFT) {\n      style.cssFloat = 'left';\n    } else if (cue.positionAlign == Cue.positionAlign.RIGHT) {\n      style.cssFloat = 'right';\n    }\n\n    style.textAlign = cue.textAlign;\n    style.textDecoration = cue.textDecoration.join(' ');\n    style.writingMode = cue.writingMode;\n\n    // Old versions of Chromium, which may be found in certain versions of Tizen\n    // and WebOS, may require the prefixed version: webkitWritingMode.\n    // https://caniuse.com/css-writing-mode\n    // However, testing shows that Tizen 3, at least, has a 'writingMode'\n    // property, but the setter for it does nothing.  Therefore we need to\n    // detect that and fall back to the prefixed version in this case, too.\n    if (!('writingMode' in document.documentElement.style) ||\n        style.writingMode != cue.writingMode) {\n      // Note that here we do not bother to check for webkitWritingMode support\n      // explicitly.  We try the unprefixed version, then fall back to the\n      // prefixed version unconditionally.\n      style.webkitWritingMode = cue.writingMode;\n    }\n\n    // The size is a number giving the size of the text container, to be\n    // interpreted as a percentage of the video, as defined by the writing\n    // direction.\n    if (cue.size) {\n      if (cue.writingMode == Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM) {\n        style.width = cue.size + '%';\n      } else {\n        style.height = cue.size + '%';\n      }\n    }\n  }\n\n  /**\n   * Returns info about provided lengthValue\n   * @example 100px => { value: 100, unit: 'px' }\n   * @param {?string} lengthValue\n   *\n   * @return {?{ value: number, unit: string }}\n   * @private\n   */\n  static getLengthValueInfo_(lengthValue) {\n    const matches = new RegExp(/(\\d*\\.?\\d+)([a-z]+|%+)/).exec(lengthValue);\n\n    if (!matches) {\n      return null;\n    }\n\n    return {\n      value: Number(matches[1]),\n      unit: matches[2],\n    };\n  }\n\n  /**\n   * Converts length value to an absolute value in pixels.\n   * If lengthValue is already an absolute value it will not\n   * be modified. Relative lengthValue will be converted to an\n   * absolute value in pixels based on Computed Cell Size\n   *\n   * @param {string} lengthValue\n   * @param {!shaka.extern.Cue} cue\n   * @param {HTMLElement} videoContainer\n   * @return {string}\n   * @private\n  */\n  static convertLengthValue_(lengthValue, cue, videoContainer) {\n    const lengthValueInfo =\n        shaka.text.UITextDisplayer.getLengthValueInfo_(lengthValue);\n\n    if (!lengthValueInfo) {\n      return lengthValue;\n    }\n\n    const {unit, value} = lengthValueInfo;\n\n    switch (unit) {\n      case '%':\n        return shaka.text.UITextDisplayer.getAbsoluteLengthInPixels_(\n            value / 100, cue, videoContainer);\n      case 'c':\n        return shaka.text.UITextDisplayer.getAbsoluteLengthInPixels_(\n            value, cue, videoContainer);\n      default:\n        return lengthValue;\n    }\n  }\n\n  /**\n   * Returns computed absolute length value in pixels based on cell\n   * and a video container size\n   * @param {number} value\n   * @param {!shaka.extern.Cue} cue\n   * @param {HTMLElement} videoContainer\n   * @return {string}\n   *\n   * @private\n   * */\n  static getAbsoluteLengthInPixels_(value, cue, videoContainer) {\n    const containerHeight = videoContainer.clientHeight;\n\n    return (containerHeight * value / cue.cellResolution.rows) + 'px';\n  }\n\n  /**\n   * Inherits a property from the parent Cue elements.  If the value is falsy,\n   * it is assumed to be inherited from the parent. This returns null if the\n   * value isn't found.\n   *\n   * @param {!Array.<!shaka.extern.Cue>} parents\n   * @param {function(!shaka.extern.Cue):?T} cb\n   * @return {?T}\n   * @template T\n   * @private\n   */\n  static inheritProperty_(parents, cb) {\n    for (let i = parents.length - 1; i >= 0; i--) {\n      const val = cb(parents[i]);\n      if (val || val === 0) {\n        return val;\n      }\n    }\n    return null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.CmcdManager');\n\ngoog.require('goog.Uri');\ngoog.require('shaka.log');\n\n\n/**\n * @summary\n * A CmcdManager maintains CMCD state as well as a collection of utility\n * functions.\n */\nshaka.util.CmcdManager = class {\n  /**\n   * @param {shaka.util.CmcdManager.PlayerInterface} playerInterface\n   * @param {shaka.extern.CmcdConfiguration} config\n   */\n  constructor(playerInterface, config) {\n    /** @private {shaka.util.CmcdManager.PlayerInterface} */\n    this.playerInterface_ = playerInterface;\n\n    /** @private {?shaka.extern.CmcdConfiguration} */\n    this.config_ = config;\n\n    /**\n     * Session ID\n     *\n     * @private {string}\n     */\n    this.sid_ = '';\n\n    /**\n     * Streaming format\n     *\n     * @private {(shaka.util.CmcdManager.StreamingFormat|undefined)}\n     */\n    this.sf_ = undefined;\n\n    /**\n     * @private {boolean}\n     */\n    this.playbackStarted_ = false;\n\n    /**\n    * @private {boolean}\n    */\n    this.buffering_ = true;\n\n    /**\n     * @private {boolean}\n     */\n    this.starved_ = false;\n  }\n\n  /**\n   * Set the buffering state\n   *\n   * @param {boolean} buffering\n   */\n  setBuffering(buffering) {\n    if (!buffering && !this.playbackStarted_) {\n      this.playbackStarted_ = true;\n    }\n\n    if (this.playbackStarted_ && buffering) {\n      this.starved_ = true;\n    }\n\n    this.buffering_ = buffering;\n  }\n\n  /**\n   * Apply CMCD data to a manifest request.\n   *\n   * @param {!shaka.extern.Request} request\n   *   The request to apply CMCD data to\n   * @param {shaka.util.CmcdManager.ManifestInfo} manifestInfo\n   *   The manifest format\n   */\n  applyManifestData(request, manifestInfo) {\n    try {\n      if (!this.config_.enabled) {\n        return;\n      }\n\n      this.sf_ = manifestInfo.format;\n\n      this.apply_(request, {\n        ot: shaka.util.CmcdManager.ObjectType.MANIFEST,\n        su: !this.playbackStarted_,\n      });\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_MANIFEST_ERROR',\n          'Could not generate manifest CMCD data.', error);\n    }\n  }\n\n  /**\n   * Apply CMCD data to a segment request\n   *\n   * @param {!shaka.extern.Request} request\n   * @param {shaka.util.CmcdManager.SegmentInfo} segmentInfo\n   */\n  applySegmentData(request, segmentInfo) {\n    try {\n      if (!this.config_.enabled) {\n        return;\n      }\n\n      const data = {\n        d: segmentInfo.duration * 1000,\n        st: this.getStreamType_(),\n      };\n\n      data.ot = this.getObjectType_(segmentInfo);\n\n      const ObjectType = shaka.util.CmcdManager.ObjectType;\n      const isMedia = data.ot === ObjectType.VIDEO ||\n                      data.ot === ObjectType.AUDIO ||\n                      data.ot === ObjectType.MUXED ||\n                      data.ot === ObjectType.TIMED_TEXT;\n\n      if (isMedia) {\n        data.bl = this.getBufferLength_(segmentInfo.type);\n      }\n\n      if (segmentInfo.bandwidth) {\n        data.br = segmentInfo.bandwidth / 1000;\n      }\n\n      if (isMedia && data.ot !== ObjectType.TIMED_TEXT) {\n        data.tb = this.getTopBandwidth_(data.ot) / 1000;\n      }\n\n      this.apply_(request, data);\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_SEGMENT_ERROR',\n          'Could not generate segment CMCD data.', error);\n    }\n  }\n\n  /**\n   * Apply CMCD data to a text request\n   *\n   * @param {!shaka.extern.Request} request\n   */\n  applyTextData(request) {\n    try {\n      if (!this.config_.enabled) {\n        return;\n      }\n\n      this.apply_(request, {\n        ot: shaka.util.CmcdManager.ObjectType.CAPTION,\n        su: true,\n      });\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_TEXT_ERROR',\n          'Could not generate text CMCD data.', error);\n    }\n  }\n\n  /**\n   * Apply CMCD data to streams loaded via src=.\n   *\n   * @param {string} uri\n   * @param {string} mimeType\n   * @return {string}\n   */\n  appendSrcData(uri, mimeType) {\n    try {\n      if (!this.config_.enabled) {\n        return uri;\n      }\n\n      const data = this.createData_();\n      data.ot = this.getObjectTypeFromMimeType_(mimeType);\n      data.su = true;\n\n      const query = shaka.util.CmcdManager.toQuery(data);\n\n      return shaka.util.CmcdManager.appendQueryToUri(uri, query);\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_SRC_ERROR',\n          'Could not generate src CMCD data.', error);\n      return uri;\n    }\n  }\n\n  /**\n   * Apply CMCD data to side car text track uri.\n   *\n   * @param {string} uri\n   * @return {string}\n   */\n  appendTextTrackData(uri) {\n    try {\n      if (!this.config_.enabled) {\n        return uri;\n      }\n\n      const data = this.createData_();\n      data.ot = shaka.util.CmcdManager.ObjectType.CAPTION;\n      data.su = true;\n\n      const query = shaka.util.CmcdManager.toQuery(data);\n\n      return shaka.util.CmcdManager.appendQueryToUri(uri, query);\n    } catch (error) {\n      shaka.log.warnOnce('CMCD_TEXT_TRACK_ERROR',\n          'Could not generate text track CMCD data.', error);\n      return uri;\n    }\n  }\n\n  /**\n   * Create baseline CMCD data\n   *\n   * @return {CmcdData}\n   * @private\n   */\n  createData_() {\n    if (!this.sid_) {\n      this.sid_ = this.config_.sessionId || window.crypto.randomUUID();\n    }\n    return {\n      v: shaka.util.CmcdManager.Version,\n      sf: this.sf_,\n      sid: this.sid_,\n      cid: this.config_.contentId,\n      mtp: this.playerInterface_.getBandwidthEstimate() / 1000,\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   *\n   * @param {!shaka.extern.Request} request The request to apply CMCD data to\n   * @param {!CmcdData} data The data object\n   * @param {boolean} useHeaders Send data via request headers\n   * @private\n   */\n  apply_(request, data = {}, useHeaders = this.config_.useHeaders) {\n    if (!this.config_.enabled) {\n      return;\n    }\n\n    // apply baseline data\n    Object.assign(data, this.createData_());\n\n    data.pr = this.playerInterface_.getPlaybackRate();\n\n    const isVideo = data.ot === shaka.util.CmcdManager.ObjectType.VIDEO ||\n      data.ot === shaka.util.CmcdManager.ObjectType.MUXED;\n\n    if (this.starved_ && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved_ = false;\n    }\n\n    if (data.su == null) {\n      data.su = this.buffering_;\n    }\n\n    // TODO: Implement rtp, nrr, nor, dl\n\n    if (useHeaders) {\n      const headers = shaka.util.CmcdManager.toHeaders(data);\n      if (!Object.keys(headers).length) {\n        return;\n      }\n\n      Object.assign(request.headers, headers);\n    } else {\n      const query = shaka.util.CmcdManager.toQuery(data);\n      if (!query) {\n        return;\n      }\n\n      request.uris = request.uris.map((uri) => {\n        return shaka.util.CmcdManager.appendQueryToUri(uri, query);\n      });\n    }\n  }\n\n  /**\n   * The CMCD object type.\n   *\n   * @param {shaka.util.CmcdManager.SegmentInfo} segmentInfo\n   * @private\n   */\n  getObjectType_(segmentInfo) {\n    const type = segmentInfo.type;\n\n    if (segmentInfo.init) {\n      return shaka.util.CmcdManager.ObjectType.INIT;\n    }\n\n    if (type == 'video') {\n      if (segmentInfo.codecs.includes(',')) {\n        return shaka.util.CmcdManager.ObjectType.MUXED;\n      }\n      return shaka.util.CmcdManager.ObjectType.VIDEO;\n    }\n\n    if (type == 'audio') {\n      return shaka.util.CmcdManager.ObjectType.AUDIO;\n    }\n\n    if (type == 'text') {\n      if (segmentInfo.mimeType === 'application/mp4') {\n        return shaka.util.CmcdManager.ObjectType.TIMED_TEXT;\n      }\n      return shaka.util.CmcdManager.ObjectType.CAPTION;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * The CMCD object type from mimeType.\n   *\n   * @param {!string} mimeType\n   * @return {(shaka.util.CmcdManager.ObjectType|undefined)}\n   * @private\n   */\n  getObjectTypeFromMimeType_(mimeType) {\n    switch (mimeType) {\n      case 'video/webm':\n      case 'video/mp4':\n        return shaka.util.CmcdManager.ObjectType.MUXED;\n\n      case 'application/x-mpegurl':\n        return shaka.util.CmcdManager.ObjectType.MANIFEST;\n\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   *\n   * @param {string} type\n   * @return {number}\n   * @private\n   */\n  getBufferLength_(type) {\n    const ranges = this.playerInterface_.getBufferedInfo()[type];\n\n    if (!ranges.length) {\n      return NaN;\n    }\n\n    const start = this.playerInterface_.getCurrentTime();\n    const range = ranges.find((r) => r.start <= start && r.end >= start);\n\n    if (!range) {\n      return NaN;\n    }\n\n    return (range.end - start) * 1000;\n  }\n\n  /**\n   * Get the stream type\n   *\n   * @return {shaka.util.CmcdManager.StreamType}\n   * @private\n   */\n  getStreamType_() {\n    const isLive = this.playerInterface_.isLive();\n    if (isLive) {\n      return shaka.util.CmcdManager.StreamType.LIVE;\n    } else {\n      return shaka.util.CmcdManager.StreamType.VOD;\n    }\n  }\n\n  /**\n   * Get the highest bandwidth for a given type.\n   *\n   * @param {string} type\n   * @return {number}\n   * @private\n   */\n  getTopBandwidth_(type) {\n    const variants = this.playerInterface_.getVariantTracks();\n    if (!variants.length) {\n      return NaN;\n    }\n\n    let top = variants[0];\n\n    for (const variant of variants) {\n      if (variant.type === 'variant' && variant.bandwidth > top.bandwidth) {\n        top = variant;\n      }\n    }\n\n    const ObjectType = shaka.util.CmcdManager.ObjectType;\n\n    switch (type) {\n      case ObjectType.VIDEO:\n        return top.videoBandwidth || NaN;\n\n      case ObjectType.AUDIO:\n        return top.audioBandwidth || NaN;\n\n      default:\n        return top.bandwidth;\n    }\n  }\n\n  /**\n   * Serialize a CMCD data object according to the rules defined in the\n   * section 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   *\n   * @param {CmcdData} data The CMCD data object\n   * @return {string}\n   */\n  static serialize(data) {\n    const results = [];\n    const isValid = (value) =>\n      !Number.isNaN(value) && value != null && value !== '' && value !== false;\n    const toRounded = (value) => Math.round(value);\n    const toHundred = (value) => toRounded(value / 100) * 100;\n    const toUrlSafe = (value) => encodeURIComponent(value);\n    const formatters = {\n      br: toRounded,\n      d: toRounded,\n      bl: toHundred,\n      dl: toHundred,\n      mtp: toHundred,\n      nor: toUrlSafe,\n      rtp: toHundred,\n      tb: toRounded,\n    };\n\n    const keys = Object.keys(data || {}).sort();\n\n    for (const key of keys) {\n      let value = data[key];\n\n      // ignore invalid values\n      if (!isValid(value)) {\n        continue;\n      }\n\n      // Version should only be reported if not equal to 1.\n      if (key === 'v' && value === 1) {\n        continue;\n      }\n\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        continue;\n      }\n\n      // Certain values require special formatting\n      const formatter = formatters[key];\n      if (formatter) {\n        value = formatter(value);\n      }\n\n      // Serialize the key/value pair\n      const type = typeof value;\n      let result;\n\n      if (type === 'string' && key !== 'ot' && key !== 'sf' && key !== 'st') {\n        result = `${key}=${JSON.stringify(value)}`;\n      } else if (type === 'boolean') {\n        result = key;\n      } else if (type === 'symbol') {\n        result = `${key}=${value.description}`;\n      } else {\n        result = `${key}=${value}`;\n      }\n\n      results.push(result);\n    }\n\n    return results.join(',');\n  }\n\n  /**\n   * Convert a CMCD data object to request headers according to the rules\n   * defined in the section 2.1 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   *\n   * @param {CmcdData} data The CMCD data object\n   * @return {!Object}\n   */\n  static toHeaders(data) {\n    const keys = Object.keys(data);\n    const headers = {};\n    const headerNames = ['Object', 'Request', 'Session', 'Status'];\n    const headerGroups = [{}, {}, {}, {}];\n    const headerMap = {\n      br: 0, d: 0, ot: 0, tb: 0,\n      bl: 1, dl: 1, mtp: 1, nor: 1, nrr: 1, su: 1,\n      cid: 2, pr: 2, sf: 2, sid: 2, st: 2, v: 2,\n      bs: 3, rtp: 3,\n    };\n\n    for (const key of keys) {\n      // Unmapped fields are mapped to the Request header\n      const index = (headerMap[key] != null) ? headerMap[key] : 1;\n      headerGroups[index][key] = data[key];\n    }\n\n    for (let i = 0; i < headerGroups.length; i++) {\n      const value = shaka.util.CmcdManager.serialize(headerGroups[i]);\n      if (value) {\n        headers[`CMCD-${headerNames[i]}`] = value;\n      }\n    }\n\n    return headers;\n  }\n\n  /**\n   * Convert a CMCD data object to query args according to the rules\n   * defined in the section 2.2 and 3.2 of\n   * [CTA-5004](https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf).\n   *\n   * @param {CmcdData} data The CMCD data object\n   * @return {string}\n   */\n  static toQuery(data) {\n    return shaka.util.CmcdManager.serialize(data);\n  }\n\n  /**\n   * Append query args to a uri.\n   *\n   * @param {string} uri\n   * @param {string} query\n   * @return {string}\n   */\n  static appendQueryToUri(uri, query) {\n    if (!query) {\n      return uri;\n    }\n\n    if (uri.includes('offline:')) {\n      return uri;\n    }\n\n    const url = new goog.Uri(uri);\n    url.getQueryData().set('CMCD', query);\n    return url.toString();\n  }\n};\n\n\n/**\n * @typedef {{\n *   getBandwidthEstimate: function():number,\n *   getBufferedInfo: function():shaka.extern.BufferedInfo,\n *   getCurrentTime: function():number,\n *   getVariantTracks: function():Array.<shaka.extern.Track>,\n *   getPlaybackRate: function():number,\n *   isLive: function():boolean\n * }}\n *\n * @property {function():number} getBandwidthEstimate\n *   Get the estimated bandwidth in bits per second.\n * @property {function():shaka.extern.BufferedInfo} getBufferedInfo\n *   Get information about what the player has buffered.\n * @property {function():number} getCurrentTime\n *   Get the current time\n * @property {function():Array.<shaka.extern.Track>} getVariantTracks\n *   Get the variant tracks\n * @property {function():number} getPlaybackRate\n *   Get the playback rate\n * @property {function():boolean} isLive\n *   Get if the player is playing live content.\n */\nshaka.util.CmcdManager.PlayerInterface;\n\n\n/**\n * @typedef {{\n *   type: string,\n *   init: boolean,\n *   duration: number,\n *   mimeType: string,\n *   codecs: string,\n *   bandwidth: (number|undefined)\n * }}\n *\n * @property {string} type\n *   The media type\n * @property {boolean} init\n *   Flag indicating whether the segment is an init segment\n * @property {number} duration\n *   The duration of the segment in seconds\n * @property {string} mimeType\n *   The segment's mime type\n * @property {string} codecs\n *   The segment's codecs\n * @property {(number|undefined)} bandwidth\n *   The segment's variation bandwidth\n *\n * @export\n */\nshaka.util.CmcdManager.SegmentInfo;\n\n\n/**\n * @typedef {{\n *   format: shaka.util.CmcdManager.StreamingFormat\n * }}\n *\n * @property {shaka.util.CmcdManager.StreamingFormat} format\n *   The manifest's stream format\n *\n * @export\n */\nshaka.util.CmcdManager.ManifestInfo;\n\n\n/**\n * @enum {string}\n */\nshaka.util.CmcdManager.ObjectType = {\n  MANIFEST: 'm',\n  AUDIO: 'a',\n  VIDEO: 'v',\n  MUXED: 'av',\n  INIT: 'i',\n  CAPTION: 'c',\n  TIMED_TEXT: 'tt',\n  KEY: 'k',\n  OTHER: 'o',\n};\n\n\n/**\n * @enum {string}\n */\nshaka.util.CmcdManager.StreamType = {\n  VOD: 'v',\n  LIVE: 'l',\n};\n\n\n/**\n * @enum {string}\n * @export\n */\nshaka.util.CmcdManager.StreamingFormat = {\n  DASH: 'd',\n  HLS: 'h',\n  SMOOTH: 's',\n  OTHER: 'o',\n};\n\n\n/**\n * The CMCD spec version\n * @const {number}\n */\nshaka.util.CmcdManager.Version = 1;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.WebVttGenerator');\n\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.Utils');\n\n\n/**\n * @summary Manage the conversion to WebVTT.\n * @export\n */\nshaka.text.WebVttGenerator = class {\n  /**\n   * @param {!Array.<!shaka.text.Cue>} cues\n   * @param {!Array.<!shaka.extern.AdCuePoint>} adCuePoints\n   * @return {string}\n   */\n  static convert(cues, adCuePoints) {\n    const webvttTimeString = (time) => {\n      let newTime = time;\n      for (const adCuePoint of adCuePoints) {\n        if (adCuePoint.end && adCuePoint.start < time) {\n          const offset = adCuePoint.end - adCuePoint.start;\n          newTime += offset;\n        }\n      }\n      const hours = Math.floor(newTime / 3600);\n      const minutes = Math.floor(newTime / 60 % 60);\n      const seconds = Math.floor(newTime % 60);\n      const milliseconds = Math.floor(newTime * 1000 % 1000);\n      return (hours < 10 ? '0' : '') + hours + ':' +\n          (minutes < 10 ? '0' : '') + minutes + ':' +\n          (seconds < 10 ? '0' : '') + seconds + '.' +\n          (milliseconds < 100 ? (milliseconds < 10 ? '00' : '0') : '') +\n          milliseconds;\n    };\n\n    const flattenedCues = shaka.text.Utils.getCuesToFlatten(cues, []);\n\n    let webvttString = 'WEBVTT\\n\\n';\n    for (const cue of flattenedCues) {\n      const webvttSettings = (cue) => {\n        const settings = [];\n        const Cue = shaka.text.Cue;\n        switch (cue.textAlign) {\n          case Cue.textAlign.LEFT:\n            settings.push('align:left');\n            break;\n          case Cue.textAlign.RIGHT:\n            settings.push('align:right');\n            break;\n          case Cue.textAlign.CENTER:\n            settings.push('align:middle');\n            break;\n          case Cue.textAlign.START:\n            settings.push('align:start');\n            break;\n          case Cue.textAlign.END:\n            settings.push('align:end');\n            break;\n        }\n        switch (cue.writingMode) {\n          case Cue.writingMode.VERTICAL_LEFT_TO_RIGHT:\n            settings.push('vertical:lr');\n            break;\n          case Cue.writingMode.VERTICAL_RIGHT_TO_LEFT:\n            settings.push('vertical:rl');\n            break;\n        }\n\n        if (settings.length) {\n          return ' ' + settings.join(' ');\n        }\n        return '';\n      };\n      webvttString += webvttTimeString(cue.startTime) + ' --> ' +\n          webvttTimeString(cue.endTime) + webvttSettings(cue) + '\\n';\n      webvttString += cue.payload + '\\n\\n';\n    }\n    return webvttString;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.ConfigUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.ObjectUtils');\n\n\n/** @export */\nshaka.util.ConfigUtils = class {\n  /**\n   * @param {!Object} destination\n   * @param {!Object} source\n   * @param {!Object} template supplies default values\n   * @param {!Object} overrides\n   *   Supplies override type checking.  When the current path matches\n   *   the key in this object, each sub-value must match the type in this\n   *   object. If this contains an Object, it is used as the template.\n   * @param {string} path to this part of the config\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, source, template, overrides, path) {\n    goog.asserts.assert(destination, 'Destination config must not be null!');\n\n    /**\n     * @type {boolean}\n     * If true, don't validate the keys in the next level.\n     */\n    const ignoreKeys = path in overrides;\n\n    let isValid = true;\n\n    for (const k in source) {\n      const subPath = path + '.' + k;\n      const subTemplate = ignoreKeys ? overrides[path] : template[k];\n\n      // The order of these checks is important.\n      if (!ignoreKeys && !(k in template)) {\n        shaka.log.alwaysError('Invalid config, unrecognized key ' + subPath);\n        isValid = false;\n      } else if (source[k] === undefined) {\n        // An explicit 'undefined' value causes the key to be deleted from the\n        // destination config and replaced with a default from the template if\n        // possible.\n        if (subTemplate === undefined || ignoreKeys) {\n          // There is nothing in the template, so delete.\n          delete destination[k];\n        } else {\n          // There is something in the template, so go back to that.\n          destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n        }\n      } else if (subTemplate.constructor == Object &&\n                 source[k] &&\n                 source[k].constructor == Object) {\n        // These are plain Objects with no other constructor.\n\n        if (!destination[k]) {\n          // Initialize the destination with the template so that normal\n          // merging and type-checking can happen.\n          destination[k] = shaka.util.ObjectUtils.cloneObject(subTemplate);\n        }\n\n        const subMergeValid = shaka.util.ConfigUtils.mergeConfigObjects(\n            destination[k], source[k], subTemplate, overrides, subPath);\n        isValid = isValid && subMergeValid;\n      } else if (typeof source[k] != typeof subTemplate ||\n                 source[k] == null ||\n                 // Function cosntructors are not informative, and differ\n                 // between sync and async functions.  So don't look at\n                 // constructor for function types.\n                 (typeof source[k] != 'function' &&\n                  source[k].constructor != subTemplate.constructor)) {\n        // The source is the wrong type.  This check allows objects to be\n        // nulled, but does not allow null for any non-object fields.\n        shaka.log.alwaysError('Invalid config, wrong type for ' + subPath);\n        isValid = false;\n      } else if (typeof template[k] == 'function' &&\n                 template[k].length != source[k].length) {\n        shaka.log.alwaysWarn(\n            'Unexpected number of arguments for ' + subPath);\n        destination[k] = source[k];\n      } else {\n        destination[k] = source[k];\n      }\n    }\n\n    return isValid;\n  }\n\n\n  /**\n   * Convert config from ('fieldName', value) format to a partial config object.\n   *\n   * E. g. from ('manifest.retryParameters.maxAttempts', 1) to\n   * { manifest: { retryParameters: { maxAttempts: 1 }}}.\n   *\n   * @param {string} fieldName\n   * @param {*} value\n   * @return {!Object}\n   * @export\n   */\n  static convertToConfigObject(fieldName, value) {\n    const configObject = {};\n    let last = configObject;\n    let searchIndex = 0;\n    let nameStart = 0;\n    while (true) {  // eslint-disable-line no-constant-condition\n      const idx = fieldName.indexOf('.', searchIndex);\n      if (idx < 0) {\n        break;\n      }\n      if (idx == 0 || fieldName[idx - 1] != '\\\\') {\n        const part = fieldName.substring(nameStart, idx).replace(/\\\\\\./g, '.');\n        last[part] = {};\n        last = last[part];\n        nameStart = idx + 1;\n      }\n      searchIndex = idx + 1;\n    }\n\n    last[fieldName.substring(nameStart).replace(/\\\\\\./g, '.')] = value;\n    return configObject;\n  }\n\n  /**\n   * Reference the input parameters so the compiler doesn't remove them from\n   * the calling function.  Return whatever value is specified.\n   *\n   * This allows an empty or default implementation of a config callback that\n   * still bears the complete function signature even in compiled mode.\n   *\n   * The caller should look something like this:\n   *\n   *   const callback = (a, b, c, d) => {\n   *     return referenceParametersAndReturn(\n             [a, b, c, d],\n             a);  // Can be anything, doesn't need to be one of the parameters\n   *   };\n   *\n   * @param {!Array.<?>} parameters\n   * @param {T} returnValue\n   * @return {T}\n   * @template T\n   * @noinline\n   */\n  static referenceParametersAndReturn(parameters, returnValue) {\n    return parameters && returnValue;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.FairPlayUtils');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A set of FairPlay utility functions.\n * @export\n */\nshaka.util.FairPlayUtils = class {\n  /**\n   * Check if FairPlay is supported.\n   *\n   * @return {!Promise.<boolean>}\n   * @export\n   */\n  static async isFairPlaySupported() {\n    const config = {\n      initDataTypes: ['cenc', 'sinf', 'skd'],\n      videoCapabilities: [\n        {\n          contentType: 'video/mp4; codecs=\"avc1.42E01E\"',\n        },\n      ],\n    };\n    try {\n      await navigator.requestMediaKeySystemAccess('com.apple.fps', [config]);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n   * Using the default method, extract a content ID from the init data.  This is\n   * based on the FairPlay example documentation.\n   *\n   * @param {!BufferSource} initData\n   * @return {string}\n   * @export\n   */\n  static defaultGetContentId(initData) {\n    const uriString = shaka.util.StringUtils.fromBytesAutoDetect(initData);\n\n    // The domain of that URI is the content ID according to Apple's FPS\n    // sample.\n    const uri = new goog.Uri(uriString);\n    return uri.getDomain();\n  }\n\n  /**\n   * Transforms the init data buffer using the given data.  The format is:\n   *\n   * <pre>\n   * [4 bytes] initDataSize\n   * [initDataSize bytes] initData\n   * [4 bytes] contentIdSize\n   * [contentIdSize bytes] contentId\n   * [4 bytes] certSize\n   * [certSize bytes] cert\n   * </pre>\n   *\n   * @param {!BufferSource} initData\n   * @param {!BufferSource|string} contentId\n   * @param {?BufferSource} cert  The server certificate; this will throw if not\n   *   provided.\n   * @return {!Uint8Array}\n   * @export\n   */\n  static initDataTransform(initData, contentId, cert) {\n    if (!cert || !cert.byteLength) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.DRM,\n          shaka.util.Error.Code.SERVER_CERTIFICATE_REQUIRED);\n    }\n\n    // From that, we build a new init data to use in the session.  This is\n    // composed of several parts.  First, the init data as a UTF-16 sdk:// URL.\n    // Second, a 4-byte LE length followed by the content ID in UTF-16-LE.\n    // Third, a 4-byte LE length followed by the certificate.\n    /** @type {BufferSource} */\n    let contentIdArray;\n    if (typeof contentId == 'string') {\n      contentIdArray =\n          shaka.util.StringUtils.toUTF16(contentId, /* littleEndian= */ true);\n    } else {\n      contentIdArray = contentId;\n    }\n\n    // The init data we get is a UTF-8 string; convert that to a UTF-16 string.\n    const sdkUri = shaka.util.StringUtils.fromBytesAutoDetect(initData);\n    const utf16 =\n        shaka.util.StringUtils.toUTF16(sdkUri, /* littleEndian= */ true);\n\n    const rebuiltInitData = new Uint8Array(\n        12 + utf16.byteLength + contentIdArray.byteLength + cert.byteLength);\n\n    let offset = 0;\n    /** @param {BufferSource} array */\n    const append = (array) => {\n      rebuiltInitData.set(shaka.util.BufferUtils.toUint8(array), offset);\n      offset += array.byteLength;\n    };\n    /** @param {BufferSource} array */\n    const appendWithLength = (array) => {\n      const view = shaka.util.BufferUtils.toDataView(rebuiltInitData);\n      const value = array.byteLength;\n      view.setUint32(offset, value, /* littleEndian= */ true);\n      offset += 4;\n      append(array);\n    };\n\n    appendWithLength(utf16);\n    appendWithLength(contentIdArray);\n    appendWithLength(cert);\n\n    goog.asserts.assert(\n        offset == rebuiltInitData.length, 'Inconsistent init data length');\n    return rebuiltInitData;\n  }\n\n  /**\n   * Verimatrix initDataTransform configuration.\n   *\n   * @param {!Uint8Array} initData\n   * @param {string} initDataType\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @export\n   */\n  static verimatrixInitDataTransform(initData, initDataType, drmInfo) {\n    if (initDataType !== 'skd') {\n      return initData;\n    }\n    const StringUtils = shaka.util.StringUtils;\n    const FairPlayUtils = shaka.util.FairPlayUtils;\n    const cert = drmInfo.serverCertificate;\n    const initDataAsString = StringUtils.fromBytesAutoDetect(initData);\n    const contentId = initDataAsString.split('skd://').pop();\n    return FairPlayUtils.initDataTransform(initData, contentId, cert);\n  }\n\n  /**\n   * EZDRM initDataTransform configuration.\n   *\n   * @param {!Uint8Array} initData\n   * @param {string} initDataType\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @export\n   */\n  static ezdrmInitDataTransform(initData, initDataType, drmInfo) {\n    if (initDataType !== 'skd') {\n      return initData;\n    }\n    const StringUtils = shaka.util.StringUtils;\n    const FairPlayUtils = shaka.util.FairPlayUtils;\n    const cert = drmInfo.serverCertificate;\n    const initDataAsString = StringUtils.fromBytesAutoDetect(initData);\n    const contentId = initDataAsString.split(';').pop();\n    return FairPlayUtils.initDataTransform(initData, contentId, cert);\n  }\n\n  /**\n   * Conax initDataTransform configuration.\n   *\n   * @param {!Uint8Array} initData\n   * @param {string} initDataType\n   * @param {?shaka.extern.DrmInfo} drmInfo\n   * @export\n   */\n  static conaxInitDataTransform(initData, initDataType, drmInfo) {\n    if (initDataType !== 'skd') {\n      return initData;\n    }\n    const StringUtils = shaka.util.StringUtils;\n    const FairPlayUtils = shaka.util.FairPlayUtils;\n    const cert = drmInfo.serverCertificate;\n    const initDataAsString = StringUtils.fromBytesAutoDetect(initData);\n    const skdValue = initDataAsString.split('skd://').pop().split('?').shift();\n    const stringToArray = (string) => {\n      // 2 bytes for each char\n      const buffer = new ArrayBuffer(string.length * 2);\n      const array = new Uint16Array(buffer);\n      for (let i = 0, strLen = string.length; i < strLen; i++) {\n        array[i] = string.charCodeAt(i);\n      }\n      return array;\n    };\n    const contentId = stringToArray(window.atob(skdValue));\n    return FairPlayUtils.initDataTransform(initData, contentId, cert);\n  }\n\n  /**\n   * Verimatrix FairPlay request.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @export\n   */\n  static verimatrixFairPlayRequest(type, request) {\n    if (type !== shaka.net.NetworkingEngine.RequestType.LICENSE) {\n      return;\n    }\n    const body = /** @type {!(ArrayBuffer|ArrayBufferView)} */(request.body);\n    const originalPayload = shaka.util.BufferUtils.toUint8(body);\n    const base64Payload = shaka.util.Uint8ArrayUtils.toBase64(originalPayload);\n    request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    request.body = shaka.util.StringUtils.toUTF8('spc=' + base64Payload);\n  }\n\n  /**\n   * EZDRM FairPlay request.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @export\n   */\n  static ezdrmFairPlayRequest(type, request) {\n    if (type !== shaka.net.NetworkingEngine.RequestType.LICENSE) {\n      return;\n    }\n    request.headers['Content-Type'] = 'application/octet-stream';\n  }\n\n  /**\n   * Conax FairPlay request.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Request} request\n   * @export\n   */\n  static conaxFairPlayRequest(type, request) {\n    if (type !== shaka.net.NetworkingEngine.RequestType.LICENSE) {\n      return;\n    }\n    request.headers['Content-Type'] = 'application/octet-stream';\n  }\n\n  /**\n   * Common FairPlay response transform for some DRMs providers.\n   *\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @param {shaka.extern.Response} response\n   * @export\n   */\n  static commonFairPlayResponse(type, response) {\n    if (type !== shaka.net.NetworkingEngine.RequestType.LICENSE) {\n      return;\n    }\n\n    // In Apple's docs, responses can be of the form:\n    //   '\\n<ckc>base64encoded</ckc>\\n' or 'base64encoded'\n    // We have also seen responses in JSON format from some of our partners.\n    // In all of these text-based formats, the CKC data is base64-encoded.\n\n    let responseText;\n    try {\n      // Convert it to text for further processing.\n      responseText = shaka.util.StringUtils.fromUTF8(response.data);\n    } catch (error) {\n      // Assume it's not a text format of any kind and leave it alone.\n      return;\n    }\n\n    let licenseProcessing = false;\n\n    // Trim whitespace.\n    responseText = responseText.trim();\n\n    // Look for <ckc> wrapper and remove it.\n    if (responseText.substr(0, 5) === '<ckc>' &&\n        responseText.substr(-6) === '</ckc>') {\n      responseText = responseText.slice(5, -6);\n      licenseProcessing = true;\n    }\n\n    // Look for a JSON wrapper and remove it.\n    try {\n      const responseObject = /** @type {!Object} */(JSON.parse(responseText));\n      if (responseObject['ckc']) {\n        responseText = responseObject['ckc'];\n        licenseProcessing = true;\n      }\n      if (responseObject['CkcMessage']) {\n        responseText = responseObject['CkcMessage'];\n        licenseProcessing = true;\n      }\n      if (responseObject['License']) {\n        responseText = responseObject['License'];\n        licenseProcessing = true;\n      }\n    } catch (err) {\n      // It wasn't JSON.  Fall through with other transformations.\n    }\n\n    if (licenseProcessing) {\n      // Decode the base64-encoded data into the format the browser expects.\n      // It's not clear why FairPlay license servers don't just serve this\n      // directly.\n      response.data = shaka.util.BufferUtils.toArrayBuffer(\n          shaka.util.Uint8ArrayUtils.fromBase64(responseText));\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PlayerConfiguration');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.SimpleAbrManager');\ngoog.require('shaka.config.AutoShowText');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.FairPlayUtils');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @final\n * @export\n */\nshaka.util.PlayerConfiguration = class {\n  /**\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  static createDefault() {\n    // This is a relatively safe default in the absence of clues from the\n    // browser.  For slower connections, the default estimate may be too high.\n    const bandwidthEstimate = 1e6; // 1Mbps\n\n    let abrMaxHeight = Infinity;\n\n    // Some browsers implement the Network Information API, which allows\n    // retrieving information about a user's network connection.\n    if (navigator.connection) {\n      // If the user has checked a box in the browser to ask it to use less\n      // data, the browser will expose this intent via connection.saveData.\n      // When that is true, we will default the max ABR height to 360p. Apps\n      // can override this if they wish.\n      //\n      // The decision to use 360p was somewhat arbitrary. We needed a default\n      // limit, and rather than restrict to a certain bandwidth, we decided to\n      // restrict resolution. This will implicitly restrict bandwidth and\n      // therefore save data. We (Shaka+Chrome) judged that:\n      //   - HD would be inappropriate\n      //   - If a user is asking their browser to save data, 360p it reasonable\n      //   - 360p would not look terrible on small mobile device screen\n      // We also found that:\n      //   - YouTube's website on mobile defaults to 360p (as of 2018)\n      //   - iPhone 6, in portrait mode, has a physical resolution big enough\n      //     for 360p widescreen, but a little smaller than 480p widescreen\n      //     (https://apple.co/2yze4es)\n      // If the content's lowest resolution is above 360p, AbrManager will use\n      // the lowest resolution.\n      if (navigator.connection.saveData) {\n        abrMaxHeight = 360;\n      }\n    }\n\n    const drm = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // These will all be verified by special cases in mergeConfigObjects_():\n      servers: {},    // key is arbitrary key system ID, value must be string\n      clearKeys: {},  // key is arbitrary key system ID, value must be string\n      advanced: {},    // key is arbitrary key system ID, value is a record type\n      delayLicenseRequestUntilPlayed: false,\n      initDataTransform: (initData, initDataType, drmInfo) => {\n        const keySystem = drmInfo.keySystem;\n        if (keySystem == 'com.apple.fps.1_0' && initDataType == 'skd') {\n          const cert = drmInfo.serverCertificate;\n          const contentId =\n              shaka.util.FairPlayUtils.defaultGetContentId(initData);\n          initData = shaka.util.FairPlayUtils.initDataTransform(\n              initData, contentId, cert);\n        }\n        return initData;\n      },\n      logLicenseExchange: false,\n      updateExpirationTime: 1,\n      preferredKeySystems: [],\n      keySystemsMapping: {},\n      // The Xbox One browser does not detect DRM key changes signalled by a\n      // change in the PSSH in media segments. We need to parse PSSH from media\n      // segments to detect key changes.\n      parseInbandPsshEnabled: shaka.util.Platform.isXboxOne(),\n    };\n\n    const manifest = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      availabilityWindowOverride: NaN,\n      disableAudio: false,\n      disableVideo: false,\n      disableText: false,\n      disableThumbnails: false,\n      defaultPresentationDelay: 0,\n      segmentRelativeVttTiming: false,\n      dash: {\n        clockSyncUri: '',\n        ignoreDrmInfo: false,\n        disableXlinkProcessing: false,\n        xlinkFailGracefully: false,\n        ignoreMinBufferTime: false,\n        autoCorrectDrift: true,\n        initialSegmentLimit: 1000,\n        ignoreSuggestedPresentationDelay: false,\n        ignoreEmptyAdaptationSet: false,\n        ignoreMaxSegmentDuration: false,\n        keySystemsByURI: {\n          'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b':\n            'org.w3.clearkey',\n          'urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e':\n            'org.w3.clearkey',\n          'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed':\n            'com.widevine.alpha',\n          'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95':\n            'com.microsoft.playready',\n          'urn:uuid:79f0049a-4098-8642-ab92-e65be0885f95':\n            'com.microsoft.playready',\n          'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb':\n            'com.adobe.primetime',\n        },\n        manifestPreprocessor: (element) => {\n          return shaka.util.ConfigUtils.referenceParametersAndReturn(\n              [element],\n              element);\n        },\n        sequenceMode: false,\n      },\n      hls: {\n        ignoreTextStreamFailures: false,\n        ignoreImageStreamFailures: false,\n        defaultAudioCodec: 'mp4a.40.2',\n        defaultVideoCodec: 'avc1.42E01E',\n        ignoreManifestProgramDateTime: false,\n        mediaPlaylistFullMimeType:\n            'video/mp2t; codecs=\"avc1.42E01E, mp4a.40.2\"',\n        useSafariBehaviorForLive: true,\n        liveSegmentsDelay: 3,\n      },\n    };\n\n    const streaming = {\n      retryParameters: shaka.net.NetworkingEngine.defaultRetryParameters(),\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.  The operation can't just be a\n      // log message, because those are stripped in the compiled build.\n      failureCallback: (error) => {\n        shaka.log.error('Unhandled streaming error', error);\n        return shaka.util.ConfigUtils.referenceParametersAndReturn(\n            [error],\n            undefined);\n      },\n      // When low latency streaming is enabled, rebufferingGoal will default to\n      // 0.01 if not specified.\n      rebufferingGoal: 2,\n      bufferingGoal: 10,\n      bufferBehind: 30,\n      ignoreTextStreamFailures: false,\n      alwaysStreamText: false,\n      startAtSegmentBoundary: false,\n      gapDetectionThreshold: 0.5,\n      durationBackoff: 1,\n      forceTransmux: false,\n      // Offset by 5 seconds since Chromecast takes a few seconds to start\n      // playing after a seek, even when buffered.\n      safeSeekOffset: 5,\n      stallEnabled: true,\n      stallThreshold: 1 /* seconds */,\n      stallSkip: 0.1 /* seconds */,\n      useNativeHlsOnSafari: true,\n      // If we are within 2 seconds of the start of a live segment, fetch the\n      // previous one.  This allows for segment drift, but won't download an\n      // extra segment if we aren't close to the start.\n      // When low latency streaming is enabled,  inaccurateManifestTolerance\n      // will default to 0 if not specified.\n      inaccurateManifestTolerance: 2,\n      lowLatencyMode: false,\n      autoLowLatencyMode: false,\n      forceHTTPS: false,\n      preferNativeHls: false,\n      updateIntervalSeconds: 1,\n      dispatchAllEmsgBoxes: false,\n      observeQualityChanges: false,\n      maxDisabledTime: 30,\n      parsePrftBox: false,\n    };\n\n    // WebOS, Tizen, and Chromecast have long hardware pipelines that respond\n    // slowly to seeking.  Therefore we should not seek when we detect a stall\n    // on one of these platforms.  Instead, default stallSkip to 0 to force the\n    // stall detector to pause and play instead.\n    if (shaka.util.Platform.isWebOS() ||\n        shaka.util.Platform.isTizen() ||\n        shaka.util.Platform.isChromecast()) {\n      streaming.stallSkip = 0;\n    }\n\n    const offline = {\n      // We need to set this to a throw-away implementation for now as our\n      // default implementation will need to reference other fields in the\n      // config. We will set it to our intended implementation after we have\n      // the top-level object created.\n      // eslint-disable-next-line require-await\n      trackSelectionCallback: async (tracks) => tracks,\n\n      downloadSizeCallback: async (sizeEstimate) => {\n        if (navigator.storage && navigator.storage.estimate) {\n          const estimate = await navigator.storage.estimate();\n          // Limit to 95% of quota.\n          return estimate.usage + sizeEstimate < estimate.quota * 0.95;\n        } else {\n          return true;\n        }\n      },\n\n      // Need some operation in the callback or else closure may remove calls\n      // to the function as it would be a no-op.  The operation can't just be a\n      // log message, because those are stripped in the compiled build.\n      progressCallback: (content, progress) => {\n        return shaka.util.ConfigUtils.referenceParametersAndReturn(\n            [content, progress],\n            undefined);\n      },\n\n      // By default we use persistent licenses as forces errors to surface if\n      // a platform does not support offline licenses rather than causing\n      // unexpected behaviours when someone tries to plays downloaded content\n      // without a persistent license.\n      usePersistentLicense: true,\n\n      numberOfParallelDownloads: 5,\n    };\n\n    const abr = {\n      enabled: true,\n      useNetworkInformation: true,\n      defaultBandwidthEstimate: bandwidthEstimate,\n      switchInterval: 8,\n      bandwidthUpgradeTarget: 0.85,\n      bandwidthDowngradeTarget: 0.95,\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: abrMaxHeight,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minFrameRate: 0,\n        maxFrameRate: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n      advanced: {\n        minTotalBytes: 128e3,\n        minBytes: 16e3,\n        fastHalfLife: 2,\n        slowHalfLife: 5,\n      },\n      restrictToElementSize: false,\n      restrictToScreenSize: false,\n      ignoreDevicePixelRatio: false,\n    };\n\n    const cmcd = {\n      enabled: false,\n      sessionId: '',\n      contentId: '',\n      useHeaders: false,\n    };\n\n    const lcevc = {\n      enabled: false,\n      dynamicPerformanceScaling: true,\n      logLevel: 0,\n      drawLogo: false,\n    };\n\n    const mediaSource = {\n      sourceBufferExtraFeatures: '',\n    };\n\n    const AutoShowText = shaka.config.AutoShowText;\n\n    /** @type {shaka.extern.PlayerConfiguration} */\n    const config = {\n      drm: drm,\n      manifest: manifest,\n      streaming: streaming,\n      mediaSource: mediaSource,\n      offline: offline,\n      abrFactory: () => new shaka.abr.SimpleAbrManager(),\n      abr: abr,\n      autoShowText: AutoShowText.IF_SUBTITLES_MAY_BE_NEEDED,\n      preferredAudioLanguage: '',\n      preferredTextLanguage: '',\n      preferredVariantRole: '',\n      preferredTextRole: '',\n      preferredAudioChannelCount: 2,\n      preferredVideoCodecs: [],\n      preferredAudioCodecs: [],\n      preferForcedSubs: false,\n      preferredDecodingAttributes: [],\n      restrictions: {\n        minWidth: 0,\n        maxWidth: Infinity,\n        minHeight: 0,\n        maxHeight: Infinity,\n        minPixels: 0,\n        maxPixels: Infinity,\n        minFrameRate: 0,\n        maxFrameRate: Infinity,\n        minBandwidth: 0,\n        maxBandwidth: Infinity,\n      },\n      playRangeStart: 0,\n      playRangeEnd: Infinity,\n      textDisplayFactory: () => null,\n      cmcd: cmcd,\n      lcevc: lcevc,\n    };\n\n    // Add this callback so that we can reference the preferred audio language\n    // through the config object so that if it gets updated, we have the\n    // updated value.\n    // eslint-disable-next-line require-await\n    offline.trackSelectionCallback = async (tracks) => {\n      return shaka.util.PlayerConfiguration.defaultTrackSelect(\n          tracks, config.preferredAudioLanguage);\n    };\n\n    return config;\n  }\n\n  /**\n   * Merges the given configuration changes into the given destination.  This\n   * uses the default Player configurations as the template.\n   *\n   * @param {shaka.extern.PlayerConfiguration} destination\n   * @param {!Object} updates\n   * @param {shaka.extern.PlayerConfiguration=} template\n   * @return {boolean}\n   * @export\n   */\n  static mergeConfigObjects(destination, updates, template) {\n    const overrides = {\n      '.drm.keySystemsMapping': '',\n      '.drm.servers': '',\n      '.drm.clearKeys': '',\n      '.drm.advanced': {\n        distinctiveIdentifierRequired: false,\n        persistentStateRequired: false,\n        videoRobustness: '',\n        audioRobustness: '',\n        sessionType: '',\n        serverCertificate: new Uint8Array(0),\n        serverCertificateUri: '',\n        individualizationServer: '',\n      },\n    };\n    return shaka.util.ConfigUtils.mergeConfigObjects(\n        destination, updates,\n        template || shaka.util.PlayerConfiguration.createDefault(), overrides,\n        '');\n  }\n\n  /**\n   * @param {!Array.<shaka.extern.Track>} tracks\n   * @param {string} preferredAudioLanguage\n   * @return {!Array.<shaka.extern.Track>}\n   */\n  static defaultTrackSelect(tracks, preferredAudioLanguage) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const allVariants = tracks.filter((track) => track.type == 'variant');\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    let selectedVariants = [];\n\n    // Find the locale that best matches our preferred audio locale.\n    const closestLocale = LanguageUtils.findClosestLocale(\n        preferredAudioLanguage,\n        allVariants.map((variant) => variant.language));\n    // If we found a locale that was close to our preference, then only use\n    // variants that use that locale.\n    if (closestLocale) {\n      selectedVariants = allVariants.filter((variant) => {\n        const locale = LanguageUtils.normalize(variant.language);\n        return locale == closestLocale;\n      });\n    }\n\n    // If we failed to get a language match, go with primary.\n    if (selectedVariants.length == 0) {\n      selectedVariants = allVariants.filter((variant) => {\n        return variant.primary;\n      });\n    }\n\n    // Otherwise, there is no good way to choose the language, so we don't\n    // choose a language at all.\n    if (selectedVariants.length == 0) {\n      // Issue a warning, but only if the content has multiple languages.\n      // Otherwise, this warning would just be noise.\n      const languages = new Set(allVariants.map((track) => {\n        return track.language;\n      }));\n\n      if (languages.size > 1) {\n        shaka.log.warning('Could not choose a good audio track based on ' +\n                          'language preferences or primary tracks.  An ' +\n                          'arbitrary language will be stored!');\n      }\n\n      // Default back to all variants.\n      selectedVariants = allVariants;\n    }\n\n    // From previously selected variants, choose the SD ones (height <= 480).\n    const tracksByHeight = selectedVariants.filter((track) => {\n      return track.height && track.height <= 480;\n    });\n\n    // If variants don't have video or no video with height <= 480 was\n    // found, proceed with the previously selected tracks.\n    if (tracksByHeight.length) {\n      // Sort by resolution, then select all variants which match the height\n      // of the highest SD res.  There may be multiple audio bitrates for the\n      // same video resolution.\n      tracksByHeight.sort((a, b) => {\n        // The items in this list have already been screened for height, but the\n        // compiler doesn't know that.\n        goog.asserts.assert(a.height != null, 'Null height');\n        goog.asserts.assert(b.height != null, 'Null height');\n\n        return b.height - a.height;\n      });\n      selectedVariants = tracksByHeight.filter((track) => {\n        return track.height == tracksByHeight[0].height;\n      });\n    }\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const selectedTracks = [];\n\n    // If there are multiple matches at different audio bitrates, select the\n    // middle bandwidth one.\n    if (selectedVariants.length) {\n      const middleIndex = Math.floor(selectedVariants.length / 2);\n      selectedVariants.sort((a, b) => a.bandwidth - b.bandwidth);\n      selectedTracks.push(selectedVariants[middleIndex]);\n    }\n\n    // Since this default callback is used primarily by our own demo app and by\n    // app developers who haven't thought about which tracks they want, we\n    // should select all image/text tracks, regardless of language.  This makes\n    // for a better demo for us, and does not rely on user preferences for the\n    // unconfigured app.\n    for (const track of tracks) {\n      if (track.type == ContentType.TEXT || track.type == ContentType.IMAGE) {\n        selectedTracks.push(track);\n      }\n    }\n\n    return selectedTracks;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.StateHistory');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\n\n\n/**\n * This class is used to track the time spent in arbitrary states. When told of\n * a state, it will assume that state was active until a new state is provided.\n * When provided with identical states back-to-back, the existing entry will be\n * updated.\n *\n * @final\n */\nshaka.util.StateHistory = class {\n  /** */\n  constructor() {\n    /**\n     * The state that we think is still the current change. It is \"open\" for\n     * updating.\n     *\n     * @private {?shaka.extern.StateChange}\n     */\n    this.open_ = null;\n\n    /**\n     * The stats that are \"closed\" for updating. The \"open\" state becomes closed\n     * once we move to a new state.\n     *\n     * @private {!Array.<shaka.extern.StateChange>}\n     */\n    this.closed_ = [];\n  }\n\n  /**\n   * @param {string} state\n   */\n  update(state) {\n    // |open_| will only be |null| when we first call |update|.\n    if (this.open_ == null) {\n      this.start_(state);\n    } else {\n      this.update_(state);\n    }\n  }\n\n  /**\n   * Go through all entries in the history and count how much time was spend in\n   * the given state.\n   *\n   * @param {string} state\n   * @return {number}\n   */\n  getTimeSpentIn(state) {\n    let sum = 0;\n\n    if (this.open_ && this.open_.state == state) {\n      sum += this.open_.duration;\n    }\n\n    for (const entry of this.closed_) {\n      sum += entry.state == state ? entry.duration : 0;\n    }\n\n    return sum;\n  }\n\n  /**\n   * Get a copy of each state change entry in the history. A copy of each entry\n   * is created to break the reference to the internal data.\n   *\n   * @return {!Array.<shaka.extern.StateChange>}\n   */\n  getCopy() {\n    const clone = (entry) => {\n      return {\n        timestamp: entry.timestamp,\n        state: entry.state,\n        duration: entry.duration,\n      };\n    };\n\n    const copy = [];\n    for (const entry of this.closed_) {\n      copy.push(clone(entry));\n    }\n    if (this.open_) {\n      copy.push(clone(this.open_));\n    }\n\n    return copy;\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  start_(state) {\n    goog.asserts.assert(\n        this.open_ == null,\n        'There must be no open entry in order when we start');\n    shaka.log.v1('Changing Player state to', state);\n\n    this.open_ = {\n      timestamp: this.getNowInSeconds_(),\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * @param {string} state\n   * @private\n   */\n  update_(state) {\n    goog.asserts.assert(\n        this.open_,\n        'There must be an open entry in order to update it');\n\n    const currentTimeSeconds = this.getNowInSeconds_();\n\n    // Always update the duration so that it can always be as accurate as\n    // possible.\n    this.open_.duration = currentTimeSeconds - this.open_.timestamp;\n\n    // If the state has not changed, there is no need to add a new entry.\n    if (this.open_.state == state) {\n      return;\n    }\n\n    // We have changed states, so \"close\" the open state.\n    shaka.log.v1('Changing Player state to', state);\n    this.closed_.push(this.open_);\n    this.open_ = {\n      timestamp: currentTimeSeconds,\n      state: state,\n      duration: 0,\n    };\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.SwitchHistory');\n\n\n/**\n * This class is used to track changes in variant and text selections. This\n * class will make sure that redundant switches are not recorded in the history.\n *\n * @final\n */\nshaka.util.SwitchHistory = class {\n  /** */\n  constructor() {\n    /** @private {?shaka.extern.Variant} */\n    this.currentVariant_ = null;\n\n    /** @private {?shaka.extern.Stream} */\n    this.currentText_ = null;\n\n    /** @private {!Array.<shaka.extern.TrackChoice>} */\n    this.history_ = [];\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newVariant|. If\n   * we are already playing |newVariant|, this update will be ignored.\n   *\n   * @param {shaka.extern.Variant} newVariant\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentVariant(newVariant, fromAdaptation) {\n    if (this.currentVariant_ == newVariant) {\n      return;\n    }\n\n    this.currentVariant_ = newVariant;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newVariant.id,\n      type: 'variant',\n      fromAdaptation: fromAdaptation,\n      bandwidth: newVariant.bandwidth,\n    });\n  }\n\n  /**\n   * Update the history to show that we are currently playing |newText|. If we\n   * are already playing |newText|, this update will be ignored.\n   *\n   * @param {shaka.extern.Stream} newText\n   * @param {boolean} fromAdaptation\n   */\n  updateCurrentText(newText, fromAdaptation) {\n    if (this.currentText_ == newText) {\n      return;\n    }\n\n    this.currentText_ = newText;\n    this.history_.push({\n      timestamp: this.getNowInSeconds_(),\n      id: newText.id,\n      type: 'text',\n      fromAdaptation: fromAdaptation,\n      bandwidth: null,\n    });\n  }\n\n  /**\n   * Get a copy of the switch history. This will make sure to expose no internal\n   * references.\n   *\n   * @return {!Array.<shaka.extern.TrackChoice>}\n   */\n  getCopy() {\n    const copy = [];\n\n    for (const entry of this.history_) {\n      copy.push(this.clone_(entry));\n    }\n\n    return copy;\n  }\n\n  /**\n   * Get the system time in seconds.\n   *\n   * @return {number}\n   * @private\n   */\n  getNowInSeconds_() {\n    return Date.now() / 1000;\n  }\n\n  /**\n   * @param {shaka.extern.TrackChoice} entry\n   * @return {shaka.extern.TrackChoice}\n   * @private\n   */\n  clone_(entry) {\n    return {\n      timestamp: entry.timestamp,\n      id: entry.id,\n      type: entry.type,\n      fromAdaptation: entry.fromAdaptation,\n      bandwidth: entry.bandwidth,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.Stats');\n\ngoog.require('shaka.util.StateHistory');\ngoog.require('shaka.util.SwitchHistory');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.Stats| which is passed to the app.\n *\n * @final\n */\nshaka.util.Stats = class {\n  /** */\n  constructor() {\n    /** @private {number} */\n    this.width_ = NaN;\n    /** @private {number} */\n    this.height_ = NaN;\n\n    /** @private {number} */\n    this.totalDroppedFrames_ = NaN;\n    /** @private {number} */\n    this.totalDecodedFrames_ = NaN;\n    /** @private {number} */\n    this.totalCorruptedFrames_ = NaN;\n\n    /** @private {number} */\n    this.totalStallsDetected_ = NaN;\n    /** @private {number} */\n    this.totalGapsJumped_ = NaN;\n\n    /** @private {number} */\n    this.completionPercent_ = NaN;\n\n    /** @private {number} */\n    this.loadLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.manifestTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.drmTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.licenseTimeSeconds_ = NaN;\n\n    /** @private {number} */\n    this.liveLatencySeconds_ = NaN;\n\n    /** @private {number} */\n    this.maxSegmentDurationSeconds_ = NaN;\n\n    /** @private {number} */\n    this.currentStreamBandwidth_ = NaN;\n    /** @private {number} */\n    this.bandwidthEstimate_ = NaN;\n\n    /** @private {!shaka.util.StateHistory} */\n    this.stateHistory_ = new shaka.util.StateHistory();\n\n    /** @private {!shaka.util.SwitchHistory} */\n    this.switchHistory_ = new shaka.util.SwitchHistory();\n  }\n\n  /**\n   * Update the ratio of dropped frames to total frames. This will replace the\n   * previous values.\n   *\n   * @param {number} dropped\n   * @param {number} decoded\n   */\n  setDroppedFrames(dropped, decoded) {\n    this.totalDroppedFrames_ = dropped;\n    this.totalDecodedFrames_ = decoded;\n  }\n\n  /**\n   * Update corrupted frames. This will replace the previous values.\n   *\n   * @param {number} corrupted\n   */\n  setCorruptedFrames(corrupted) {\n    this.totalCorruptedFrames_ = corrupted;\n  }\n\n  /**\n   * Update number of stalls detected. This will replace the previous value.\n   *\n   * @param {number} stallsDetected\n   */\n  setStallsDetected(stallsDetected) {\n    this.totalStallsDetected_ = stallsDetected;\n  }\n\n  /**\n   * Update number of playback gaps jumped over. This will replace the previous\n   * value.\n   *\n   * @param {number} gapsJumped\n   */\n  setGapsJumped(gapsJumped) {\n    this.totalGapsJumped_ = gapsJumped;\n  }\n\n  /**\n   * Set the width and height of the video we are currently playing.\n   *\n   * @param {number} width\n   * @param {number} height\n   */\n  setResolution(width, height) {\n    this.width_ = width;\n    this.height_ = height;\n  }\n\n  /**\n   * Record the time it took between the user signalling \"I want to play this\"\n   * to \"I am now seeing this\".\n   *\n   * @param {number} seconds\n   */\n  setLoadLatency(seconds) {\n    this.loadLatencySeconds_ = seconds;\n  }\n\n  /**\n   * Record the time it took to download and parse the manifest.\n   *\n   * @param {number} seconds\n   */\n  setManifestTime(seconds) {\n    this.manifestTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the current completion percent. This is the \"high water mark\", so it\n   * will store the highest provided completion percent.\n   *\n   * @param {number} percent\n   */\n  setCompletionPercent(percent) {\n    if (isNaN(this.completionPercent_)) {\n      this.completionPercent_ = percent;\n    } else {\n      this.completionPercent_ = Math.max(this.completionPercent_, percent);\n    }\n  }\n\n  /**\n   * Record the time it took to download the first drm key.\n   *\n   * @param {number} seconds\n   */\n  setDrmTime(seconds) {\n    this.drmTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the cumulative time spent on license requests during this session.\n   *\n   * @param {number} seconds\n   */\n  setLicenseTime(seconds) {\n    this.licenseTimeSeconds_ = seconds;\n  }\n\n  /**\n   * Record the latency in live streams.\n   *\n   * @param {number} seconds\n   */\n  setLiveLatency(seconds) {\n    this.liveLatencySeconds_ = seconds;\n  }\n\n  /**\n   * Record the presentation's max segment duration.\n   *\n   * @param {number} seconds\n   */\n  setMaxSegmentDuration(seconds) {\n    this.maxSegmentDurationSeconds_ = seconds;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setCurrentStreamBandwidth(bandwidth) {\n    this.currentStreamBandwidth_ = bandwidth;\n  }\n\n  /**\n   * @param {number} bandwidth\n   */\n  setBandwidthEstimate(bandwidth) {\n    this.bandwidthEstimate_ = bandwidth;\n  }\n\n  /**\n   * @return {!shaka.util.StateHistory}\n   */\n  getStateHistory() {\n    return this.stateHistory_;\n  }\n\n  /**\n   * @return {!shaka.util.SwitchHistory}\n   */\n  getSwitchHistory() {\n    return this.switchHistory_;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  getBlob() {\n    return {\n      width: this.width_,\n      height: this.height_,\n      streamBandwidth: this.currentStreamBandwidth_,\n      decodedFrames: this.totalDecodedFrames_,\n      droppedFrames: this.totalDroppedFrames_,\n      corruptedFrames: this.totalCorruptedFrames_,\n      stallsDetected: this.totalStallsDetected_,\n      gapsJumped: this.totalGapsJumped_,\n      estimatedBandwidth: this.bandwidthEstimate_,\n      completionPercent: this.completionPercent_,\n      loadLatency: this.loadLatencySeconds_,\n      manifestTimeSeconds: this.manifestTimeSeconds_,\n      drmTimeSeconds: this.drmTimeSeconds_,\n      playTime: this.stateHistory_.getTimeSpentIn('playing'),\n      pauseTime: this.stateHistory_.getTimeSpentIn('paused'),\n      bufferingTime: this.stateHistory_.getTimeSpentIn('buffering'),\n      licenseTime: this.licenseTimeSeconds_,\n      liveLatency: this.liveLatencySeconds_,\n      maxSegmentDuration: this.maxSegmentDurationSeconds_,\n      stateHistory: this.stateHistory_.getCopy(),\n      switchHistory: this.switchHistory_.getCopy(),\n    };\n  }\n\n  /**\n   * Create an empty stats blob. This resembles the stats when we are not\n   * playing any content.\n   *\n   * @return {shaka.extern.Stats}\n   */\n  static getEmptyBlob() {\n    return {\n      width: NaN,\n      height: NaN,\n      streamBandwidth: NaN,\n      decodedFrames: NaN,\n      droppedFrames: NaN,\n      corruptedFrames: NaN,\n      stallsDetected: NaN,\n      gapsJumped: NaN,\n      estimatedBandwidth: NaN,\n      completionPercent: NaN,\n      loadLatency: NaN,\n      manifestTimeSeconds: NaN,\n      drmTimeSeconds: NaN,\n      playTime: NaN,\n      pauseTime: NaN,\n      bufferingTime: NaN,\n      licenseTime: NaN,\n      liveLatency: NaN,\n      maxSegmentDuration: NaN,\n      switchHistory: [],\n      stateHistory: [],\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.ads.AdsStats');\n\n\n/**\n * This class tracks all the various components (some optional) that are used to\n * populate |shaka.extern.AdsStats| which is passed to the app.\n *\n * @final\n */\nshaka.ads.AdsStats = class {\n  /** */\n  constructor() {\n    /** @private {!Array.<number>} */\n    this.loadTimes_ = [];\n    /** @private {number} */\n    this.started_ = 0;\n    /** @private {number} */\n    this.playedCompletely_ = 0;\n    /** @private {number} */\n    this.skipped_ = 0;\n  }\n\n  /**\n   * Record the time it took to get the final manifest.\n   *\n   * @param {number} seconds\n   */\n  addLoadTime(seconds) {\n    this.loadTimes_.push(seconds);\n  }\n\n  /**\n   * Increase the number of ads started by one.\n   */\n  incrementStarted() {\n    this.started_++;\n  }\n\n  /**\n   * Increase the number of ads played completely by one.\n   */\n  incrementPlayedCompletely() {\n    this.playedCompletely_++;\n  }\n\n  /**\n   * Increase the number of ads skipped by one.\n   */\n  incrementSkipped() {\n    this.skipped_++;\n  }\n\n  /**\n   * Create a stats blob that we can pass up to the app. This blob will not\n   * reference any internal data.\n   *\n   * @return {shaka.extern.AdsStats}\n   */\n  getBlob() {\n    return {\n      loadTimes: this.loadTimes_,\n      started: this.started_,\n      playedCompletely: this.playedCompletely_,\n      skipped: this.skipped_,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.ClientSideAd');\n\ngoog.require('shaka.util.EventManager');\n\n\n/**\n * @implements {shaka.extern.IAd}\n * @export\n */\nshaka.ads.ClientSideAd = class {\n  /**\n   * @param {!google.ima.Ad} imaAd\n   * @param {!google.ima.AdsManager} imaAdManager\n   * @param {HTMLMediaElement} video\n   */\n  constructor(imaAd, imaAdManager, video) {\n    /** @private {google.ima.Ad} */\n    this.ad_ = imaAd;\n\n    /** @private {google.ima.AdsManager} */\n    this.manager_ = imaAdManager;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {boolean} */\n    this.isPaused_ = false;\n\n    /** @private {number} */\n    this.volume_ = this.manager_.getVolume();\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    this.eventManager_.listen(this.manager_,\n        google.ima.AdEvent.Type.PAUSED, () => {\n          this.isPaused_ = true;\n        });\n\n    this.eventManager_.listen(this.manager_,\n        google.ima.AdEvent.Type.RESUMED, () => {\n          this.isPaused_ = false;\n        });\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getDuration() {\n    return this.ad_.getDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getMinSuggestedDuration() {\n    return this.ad_.getMinSuggestedDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getRemainingTime() {\n    return this.manager_.getRemainingTime();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isPaused() {\n    return this.isPaused_;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isSkippable() {\n    // IMA returns -1 for non-skippable ads. Any positive number is a genuine\n    // skip offset, meaning the ad is skippable.\n    return this.ad_.getSkipTimeOffset() >= 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTimeUntilSkippable() {\n    const skipOffset = this.ad_.getSkipTimeOffset();\n    const canSkipIn = this.getRemainingTime() - skipOffset;\n    return Math.max(canSkipIn, 0);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  canSkipNow() {\n    return this.manager_.getAdSkippableState();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  skip() {\n    return this.manager_.skip();\n  }\n\n  /**\n   * @param {boolean} paused\n   */\n  setPaused(paused) {\n    this.isPaused_ = paused;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  pause() {\n    return this.manager_.pause();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  play() {\n    return this.manager_.resume();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getVolume() {\n    return this.manager_.getVolume();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setVolume(volume) {\n    return this.manager_.setVolume(volume);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isMuted() {\n    return this.manager_.getVolume() == 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isLinear() {\n    return this.ad_.isLinear();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  resize(width, height) {\n    let isInFullscreen = false;\n    const video = /** @type {HTMLVideoElement} */(this.video_);\n    if (document.fullscreenEnabled) {\n      isInFullscreen = !!document.fullscreenElement;\n    } else if (video.webkitSupportsFullscreen) {\n      isInFullscreen = video.webkitDisplayingFullscreen;\n    }\n    const viewMode = isInFullscreen ?\n        google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n    this.manager_.resize(width, height, viewMode);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setMuted(muted) {\n    // Emulate the \"mute\" functionality, where current, pre-mute\n    // volume is saved and can be restored on unmute.\n    if (muted) {\n      this.volume_ = this.getVolume();\n      this.setVolume(0);\n    } else {\n      this.setVolume(this.volume_);\n    }\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getSequenceLength() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getTotalAds();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getPositionInSequence() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getAdPosition();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTitle() {\n    return this.ad_.getTitle();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getDescription() {\n    return this.ad_.getDescription();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    this.ad_ = null;\n    this.manager_ = null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.ads.ClientSideAdManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.ads.ClientSideAd');\ngoog.require('shaka.util.IReleasable');\n\n/**\n * A class responsible for client-side ad interactions.\n * @implements {shaka.util.IReleasable}\n */\nshaka.ads.ClientSideAdManager = class {\n  /**\n   * @param {HTMLElement} adContainer\n   * @param {HTMLMediaElement} video\n   * @param {string} locale\n   * @param {function(!shaka.util.FakeEvent)} onEvent\n   */\n  constructor(adContainer, video, locale, onEvent) {\n    /** @private {HTMLElement} */\n    this.adContainer_ = adContainer;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {ResizeObserver} */\n    this.resizeObserver_ = null;\n\n    /** @private {number} */\n    this.requestAdsStartTime_ = NaN;\n\n    /** @private {function(!shaka.util.FakeEvent)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {shaka.ads.ClientSideAd} */\n    this.ad_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    google.ima.settings.setLocale(locale);\n\n    const adDisplayContainer = new google.ima.AdDisplayContainer(\n        this.adContainer_,\n        this.video_);\n\n    // TODO: IMA: Must be done as the result of a user action on mobile\n    adDisplayContainer.initialize();\n\n    // IMA: This instance should be re-used for the entire lifecycle of\n    // the page.\n    this.adsLoader_ = new google.ima.AdsLoader(adDisplayContainer);\n\n    this.adsLoader_.getSettings().setPlayerType('shaka-player');\n    this.adsLoader_.getSettings().setPlayerVersion(shaka.Player.version);\n\n    /** @private {google.ima.AdsManager} */\n    this.imaAdsManager_ = null;\n\n    this.eventManager_.listenOnce(this.adsLoader_,\n        google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (e) => {\n          this.onAdsManagerLoaded_(\n              /** @type {!google.ima.AdsManagerLoadedEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.adsLoader_,\n        google.ima.AdErrorEvent.Type.AD_ERROR, (e) => {\n          this.onAdError_( /** @type {!google.ima.AdErrorEvent} */ (e));\n        });\n\n    // Notify the SDK when the video has ended, so it can play post-roll ads.\n    this.video_.onended = () => {\n      this.adsLoader_.contentComplete();\n    };\n  }\n\n  /**\n   * @param {!google.ima.AdsRequest} imaRequest\n   */\n  requestAds(imaRequest) {\n    goog.asserts.assert(\n        imaRequest.adTagUrl || imaRequest.adsResponse,\n        'The ad tag needs to be set up before requesting ads, ' +\n          'or adsResponse must be filled.');\n    this.requestAdsStartTime_ = Date.now() / 1000;\n    this.adsLoader_.requestAds(imaRequest);\n  }\n\n  /**\n   * Stop all currently playing ads.\n   */\n  stop() {\n    // this.imaAdsManager_ might not be set yet... if, for example, an ad\n    // blocker prevented the ads from ever loading.\n    if (this.imaAdsManager_) {\n      this.imaAdsManager_.stop();\n    }\n    if (this.adContainer_) {\n      shaka.util.Dom.removeAllChildren(this.adContainer_);\n    }\n  }\n\n  /** @override */\n  release() {\n    this.stop();\n    if (this.resizeObserver_) {\n      this.resizeObserver_.disconnect();\n    }\n    if (this.eventManager_) {\n      this.eventManager_.release();\n    }\n    if (this.imaAdsManager_) {\n      this.imaAdsManager_.destroy();\n    }\n    this.adsLoader_.destroy();\n  }\n\n  /**\n   * @param {!google.ima.AdErrorEvent} e\n   * @private\n   */\n  onAdError_(e) {\n    shaka.log.warning(\n        'There was an ad error from the IMA SDK: ' + e.getError());\n    shaka.log.warning('Resuming playback.');\n    this.onAdComplete_(/* adEvent= */ null);\n    // Remove ad breaks from the timeline\n    this.onEvent_(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.CUEPOINTS_CHANGED,\n            (new Map()).set('cuepoints', [])));\n  }\n\n\n  /**\n   * @param {!google.ima.AdsManagerLoadedEvent} e\n   * @private\n   */\n  onAdsManagerLoaded_(e) {\n    goog.asserts.assert(this.video_ != null, 'Video should not be null!');\n\n    const now = Date.now() / 1000;\n    const loadTime = now - this.requestAdsStartTime_;\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.ADS_LOADED,\n        (new Map()).set('loadTime', loadTime)));\n\n    this.imaAdsManager_ = e.getAdsManager(this.video_);\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.IMA_AD_MANAGER_LOADED,\n        (new Map()).set('imaAdManager', this.imaAdsManager_)));\n\n    const cuePointStarts = this.imaAdsManager_.getCuePoints();\n    if (cuePointStarts.length) {\n      /** @type {!Array.<!shaka.extern.AdCuePoint>} */\n      const cuePoints = [];\n      for (const start of cuePointStarts) {\n        /** @type {shaka.extern.AdCuePoint} */\n        const shakaCuePoint = {\n          start: start,\n          end: null,\n        };\n        cuePoints.push(shakaCuePoint);\n      }\n\n      this.onEvent_(new shaka.util.FakeEvent(\n          shaka.ads.AdManager.CUEPOINTS_CHANGED,\n          (new Map()).set('cuepoints', cuePoints)));\n    }\n\n    this.addImaEventListeners_();\n\n    try {\n      const viewMode = this.isFullScreenEnabled_() ?\n          google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n\n      this.imaAdsManager_.init(this.video_.offsetWidth,\n          this.video_.offsetHeight, viewMode);\n\n      // Wait on the 'loadeddata' event rather than the 'loadedmetadata' event\n      // because 'loadedmetadata' is sometimes called before the video resizes\n      // on some platforms (e.g. Safari).\n      this.eventManager_.listen(this.video_, 'loadeddata', () => {\n        const viewMode = this.isFullScreenEnabled_() ?\n            google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n        this.imaAdsManager_.resize(this.video_.offsetWidth,\n            this.video_.offsetHeight, viewMode);\n      });\n\n      if ('ResizeObserver' in window) {\n        this.resizeObserver_ = new ResizeObserver(() => {\n          const viewMode = this.isFullScreenEnabled_() ?\n              google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n          this.imaAdsManager_.resize(this.video_.offsetWidth,\n              this.video_.offsetHeight, viewMode);\n        });\n        this.resizeObserver_.observe(this.video_);\n      } else {\n        this.eventManager_.listen(document, 'fullscreenchange', () => {\n          const viewMode = this.isFullScreenEnabled_() ?\n              google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;\n          this.imaAdsManager_.resize(this.video_.offsetWidth,\n              this.video_.offsetHeight, viewMode);\n        });\n      }\n\n      // Single video and overlay ads will start at this time\n      // TODO (ismena): Need a better inderstanding of what this does.\n      // The docs say it's called to 'start playing the ads,' but I haven't\n      // seen the ads actually play until requestAds() is called.\n      // Note: We listen for a play event to avoid autoplay issues that might\n      // crash IMA.\n      this.video_.addEventListener('play', () => {\n        this.imaAdsManager_.start();\n      }, {once: true});\n    } catch (adError) {\n      // If there was a problem with the VAST response,\n      // we we won't be getting an ad. Hide ad UI if we showed it already\n      // and get back to the presentation.\n      this.onAdComplete_(/* adEvent= */ null);\n    }\n  }\n\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  isFullScreenEnabled_() {\n    if (document.fullscreenEnabled) {\n      return !!document.fullscreenElement;\n    } else {\n      const video = /** @type {HTMLVideoElement} */(this.video_);\n      if (video.webkitSupportsFullscreen) {\n        return video.webkitDisplayingFullscreen;\n      }\n    }\n    return false;\n  }\n\n\n  /**\n   * @private\n   */\n  addImaEventListeners_() {\n    /**\n     * @param {!Event} e\n     * @param {string} type\n     */\n    const convertEventAndSend = (e, type) => {\n      const data = (new Map()).set('originalEvent', e);\n      this.onEvent_(new shaka.util.FakeEvent(type, data));\n    };\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdErrorEvent.Type.AD_ERROR, (error) => {\n          this.onAdError_(/** @type {!google.ima.AdErrorEvent} */ (error));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, (e) => {\n          this.onAdStart_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.STARTED, (e) => {\n          this.onAdStart_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.FIRST_QUARTILE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_FIRST_QUARTILE);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.MIDPOINT, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_MIDPOINT);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.THIRD_QUARTILE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_THIRD_QUARTILE);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.COMPLETE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_COMPLETE);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, (e) => {\n          this.onAdComplete_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.ALL_ADS_COMPLETED, (e) => {\n          this.onAdComplete_(/** @type {!google.ima.AdEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.SKIPPED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_SKIPPED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.VOLUME_CHANGED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_VOLUME_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.VOLUME_MUTED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_MUTED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.PAUSED, (e) => {\n          if (this.ad_) {\n            this.ad_.setPaused(true);\n            convertEventAndSend(e, shaka.ads.AdManager.AD_PAUSED);\n          }\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.RESUMED, (e) => {\n          if (this.ad_) {\n            this.ad_.setPaused(false);\n            convertEventAndSend(e, shaka.ads.AdManager.AD_RESUMED);\n          }\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, (e) => {\n          if (this.ad_) {\n            convertEventAndSend(e, shaka.ads.AdManager.AD_SKIP_STATE_CHANGED);\n          }\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.CLICK, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_CLICKED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_PROGRESS, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_PROGRESS);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_BUFFERING, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_BUFFERING);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.IMPRESSION, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_IMPRESSION);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.DURATION_CHANGE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_DURATION_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.USER_CLOSE, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_CLOSED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LOADED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_LOADED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.ALL_ADS_COMPLETED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.ALL_ADS_COMPLETED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LINEAR_CHANGED, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_LINEAR_CHANGED);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_METADATA, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_METADATA);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.LOG, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_RECOVERABLE_ERROR);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.AD_BREAK_READY, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_BREAK_READY);\n        });\n\n    this.eventManager_.listen(this.imaAdsManager_,\n        google.ima.AdEvent.Type.INTERACTION, (e) => {\n          convertEventAndSend(e, shaka.ads.AdManager.AD_INTERACTION);\n        });\n  }\n\n  /**\n   * @param {!google.ima.AdEvent} e\n   * @private\n   */\n  onAdStart_(e) {\n    goog.asserts.assert(this.imaAdsManager_,\n        'Should have an ads manager at this point!');\n\n    const imaAd = e.getAd();\n    if (!imaAd) {\n      // Sometimes the IMA SDK will fire a CONTENT_PAUSE_REQUESTED or STARTED\n      // event with no associated ad object.\n      // We can't really play an ad in that situation, so just ignore the event.\n      shaka.log.alwaysWarn(\n          'The IMA SDK fired a ' + e.type + ' event with no associated ad. ' +\n          'Unable to play ad!');\n      return;\n    }\n\n    this.ad_ = new shaka.ads.ClientSideAd(imaAd,\n        this.imaAdsManager_, this.video_);\n    const data = new Map()\n        .set('ad', this.ad_)\n        .set('sdkAdObject', imaAd)\n        .set('originalEvent', e);\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.AD_STARTED, data));\n    if (this.ad_.isLinear()) {\n      this.adContainer_.setAttribute('ad-active', 'true');\n      this.video_.pause();\n    }\n  }\n\n  /**\n   * @param {?google.ima.AdEvent} e\n   * @private\n   */\n  onAdComplete_(e) {\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED,\n        (new Map()).set('originalEvent', e)));\n    if (this.ad_ && this.ad_.isLinear()) {\n      this.adContainer_.removeAttribute('ad-active');\n      this.video_.play();\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.AdManager');\n\ngoog.require('shaka.Player');\ngoog.require('shaka.ads.AdsStats');\ngoog.require('shaka.ads.ClientSideAdManager');\ngoog.require('shaka.ads.ServerSideAdManager');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IReleasable');\n\n\n/**\n * @event shaka.ads.AdManager.AdsLoadedEvent\n * @description Fired when a sequence of ads has been loaded.\n * @property {string} type\n *   'ads-loaded'\n * @property {number} loadTime\n *    The time it takes to load ads.\n * @exportDoc\n */\n\n/**\n * @event shaka.ads.AdManager.AdStartedEvent\n * @description Fired when an ad has started playing.\n * @property {string} type\n *   'ad-started'\n * @property {!shaka.extern.IAd} ad\n *    The ad that has started playing.\n * @property {Object} sdkAdObject\n *    The ad object in the SDK format, if there is one.\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdCompleteEvent\n * @description Fired when an ad has played through.\n * @property {string} type\n *   'ad-complete'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdSkippedEvent\n * @description Fired when an ad has been skipped.\n * @property {string} type\n *   'ad-skipped'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdFirstQuartileEvent\n * @description Fired when an ad has played through the first 1/4.\n * @property {string} type\n *   'ad-first-quartile'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMidpointEvent\n * @description Fired when an ad has played through its midpoint.\n * @property {string} type\n *   'ad-midpoint'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdThirdQuartileEvent\n * @description Fired when an ad has played through the third quartile.\n * @property {string} type\n *   'ad-third-quartile'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdStoppedEvent\n * @description Fired when an ad has stopped playing, was skipped,\n *   or was unable to proceed due to an error.\n * @property {string} type\n *   'ad-stopped'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdVolumeChangedEvent\n * @description Fired when an ad's volume changed.\n * @property {string} type\n *   'ad-volume-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMutedEvent\n * @description Fired when an ad was muted.\n * @property {string} type\n *   'ad-muted'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdPausedEvent\n * @description Fired when an ad was paused.\n * @property {string} type\n *   'ad-paused'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdResumedEvent\n * @description Fired when an ad was resumed after a pause.\n * @property {string} type\n *   'ad-resumed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdSkipStateChangedEvent\n * @description Fired when an ad's skip state changes (for example, when\n *  it becomes possible to skip the ad).\n * @property {string} type\n *   'ad-skip-state-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdResumedEvent\n * @description Fired when the ad cue points change, signalling ad breaks\n *  change.\n * @property {string} type\n *   'ad-cue-points-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdProgressEvent\n * @description Fired when there is an update to the current ad's progress.\n * @property {string} type\n *   'ad-progress'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdBufferingEvent\n * @description Fired when the ad has stalled playback to buffer.\n * @property {string} type\n *   'ad-buffering'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdImpressionEvent\n * @description Fired when the impression URL has been pinged.\n * @property {string} type\n *   'ad-impression'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClickEvent\n * @description Fired when the ad was clicked.\n * @property {string} type\n *   'ad-clicked'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdDurationChangedEvent\n * @description Fired when the ad's duration changes.\n * @property {string} type\n *   'ad-duration-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClosedEvent\n * @description Fired when the ad was closed by the user.\n * @property {string} type\n *   'ad-closed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdLoadedEvent\n * @description Fired when the ad data becomes available.\n * @property {string} type\n *   'ad-loaded'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AllAdsCompletedEvent\n * @description Fired when the ads manager is done playing all the ads.\n * @property {string} type\n *   'all-ads-completed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdLinearChangedEvent\n * @description Fired when the displayed ad changes from\n *   linear to nonlinear, or vice versa.\n * @property {string} type\n *   'ad-linear-changed'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdMetadataEvent\n * @description Fired when the ad's metadata becomes available.\n * @property {string} type\n *   'ad-metadata'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager#AdBreakReadyEvent\n * @description Fired when the client-side SDK is ready to play a\n *   VPAID ad or an ad rule.\n * @property {string} type\n *   'ad-break-ready'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdRecoverableErrorEvent\n * @description Fired when the a non-fatal error was encountered.\n *   The presentation will continue with the same or next ad playback\n *   depending on the error situation.\n * @property {string} type\n *   'ad-recoverable-error'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdInteractionEvent\n * @description Fired when an ad triggers the interaction callback.\n * @property {string} type\n *   'ad-interaction'\n * @property {Object} originalEvent\n *    The native SDK event, if available.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager#ImaAdManagerLoadedEvent\n * @description Fired when the native IMA ad manager becomes available.\n * @property {string} type\n *   'ima-ad-manager-loaded'\n * @property {!Object} imaAdManager\n *    The native IMA ad manager.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager#ImaStreamManagerLoadedEvent\n * @description Fired when the native IMA stream manager becomes available.\n * @property {string} type\n *   'ima-stream-manager-loaded'\n * @property {!Object} imaStreamManager\n *    The native IMA stream manager.\n * @exportDoc\n */\n\n\n/**\n * @event shaka.ads.AdManager.AdClickedEvent\n * @description Fired when the ad was clicked.\n * @property {string} type\n *   'ad-clicked'\n * @exportDoc\n */\n\n\n/**\n * A class responsible for ad-related interactions.\n * @implements {shaka.extern.IAdManager}\n * @implements {shaka.util.IReleasable}\n * @export\n */\nshaka.ads.AdManager = class extends shaka.util.FakeEventTarget {\n  /** */\n  constructor() {\n    super();\n    /** @private {shaka.ads.ClientSideAdManager} */\n    this.csAdManager_ = null;\n    /** @private {shaka.ads.ServerSideAdManager} */\n    this.ssAdManager_ = null;\n    /** @private {shaka.ads.AdsStats} */\n    this.stats_ = new shaka.ads.AdsStats();\n    /** @private {string} locale */\n    this.locale_ = navigator.language;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  setLocale(locale) {\n    this.locale_ = locale;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  initClientSide(adContainer, video) {\n    // Check that Client Side IMA SDK has been included\n    // NOTE: (window['google'] && google.ima) check for any\n    // IMA SDK, including SDK for Server Side ads.\n    // The 3rd check insures we have the right SDK:\n    // {google.ima.AdsLoader} is an object that's part of CS IMA SDK\n    // but not SS SDK.\n    if (!window['google'] || !google.ima || !google.ima.AdsLoader) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CS_IMA_SDK_MISSING);\n    }\n\n    if (this.csAdManager_) {\n      this.csAdManager_.release();\n    }\n\n    this.csAdManager_ = new shaka.ads.ClientSideAdManager(\n        adContainer, video, this.locale_,\n        (e) => {\n          const event = /** @type {!shaka.util.FakeEvent} */ (e);\n          if (event && event.type) {\n            switch (event.type) {\n              case shaka.ads.AdManager.ADS_LOADED: {\n                const loadTime = (/** @type {!Object} */ (e))['loadTime'];\n                this.stats_.addLoadTime(loadTime);\n                break;\n              }\n              case shaka.ads.AdManager.AD_STARTED:\n                this.stats_.incrementStarted();\n                break;\n              case shaka.ads.AdManager.AD_COMPLETE:\n                this.stats_.incrementPlayedCompletely();\n                break;\n              case shaka.ads.AdManager.AD_SKIPPED:\n                this.stats_.incrementSkipped();\n                break;\n            }\n          }\n          this.dispatchEvent(event);\n        });\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    if (this.csAdManager_) {\n      this.csAdManager_.release();\n      this.csAdManager_ = null;\n    }\n    if (this.ssAdManager_) {\n      this.ssAdManager_.release();\n      this.ssAdManager_ = null;\n    }\n    super.release();\n  }\n\n\n  /**\n  * @override\n  * @export\n  */\n  onAssetUnload() {\n    if (this.csAdManager_) {\n      this.csAdManager_.stop();\n    }\n    if (this.ssAdManager_) {\n      this.ssAdManager_.stop();\n    }\n\n    this.dispatchEvent(\n        new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n\n    this.stats_ = new shaka.ads.AdsStats();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  requestClientSideAds(imaRequest) {\n    if (!this.csAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    this.csAdManager_.requestAds(imaRequest);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  initServerSide(adContainer, video) {\n    // Check that Client Side IMA SDK has been included\n    // NOTE: (window['google'] && google.ima) check for any\n    // IMA SDK, including SDK for Server Side ads.\n    // The 3rd check insures we have the right SDK:\n    // {google.ima.dai} is an object that's part of DAI IMA SDK\n    // but not SS SDK.\n    if (!window['google'] || !google.ima || !google.ima.dai) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_IMA_SDK_MISSING);\n    }\n\n    if (this.ssAdManager_) {\n      this.ssAdManager_.release();\n    }\n\n    this.ssAdManager_ = new shaka.ads.ServerSideAdManager(\n        adContainer, video, this.locale_,\n        (e) => {\n          const event = /** @type {!shaka.util.FakeEvent} */ (e);\n          if (event && event.type) {\n            switch (event.type) {\n              case shaka.ads.AdManager.ADS_LOADED: {\n                const loadTime = (/** @type {!Object} */ (e))['loadTime'];\n                this.stats_.addLoadTime(loadTime);\n                break;\n              }\n              case shaka.ads.AdManager.AD_STARTED:\n                this.stats_.incrementStarted();\n                break;\n              case shaka.ads.AdManager.AD_COMPLETE:\n                this.stats_.incrementPlayedCompletely();\n                break;\n              case shaka.ads.AdManager.AD_SKIPPED:\n                this.stats_.incrementSkipped();\n                break;\n            }\n          }\n          this.dispatchEvent(event);\n        });\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamRequest} imaRequest\n   * @param {string=} backupUrl\n   * @return {!Promise.<string>}\n   * @override\n   * @export\n   */\n  requestServerSideStream(imaRequest, backupUrl = '') {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    if (!imaRequest.adTagParameters) {\n      imaRequest.adTagParameters = {};\n    }\n    const adTagParams = imaRequest.adTagParameters;\n\n    if (adTagParams['mpt'] || adTagParams['mpv']) {\n      shaka.log.alwaysWarn('You have attempted to set \"mpt\" and/or \"mpv\" ' +\n        'parameters of the ad tag. Please note that those parameters are ' +\n        'used for Shaka adoption tracking and will be overriden.');\n    }\n\n    // Set player and version parameters for tracking\n    imaRequest.adTagParameters['mpt'] = 'shaka-player';\n    imaRequest.adTagParameters['mpv'] = shaka.Player.version;\n    return this.ssAdManager_.streamRequest(imaRequest, backupUrl);\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  replaceServerSideAdTagParameters(adTagParameters) {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n\n    if (adTagParameters['mpt'] || adTagParameters['mpv']) {\n      shaka.log.alwaysWarn('You have attempted to set \"mpt\" and/or \"mpv\" ' +\n        'parameters of the ad tag. Please note that those parameters are ' +\n        'used for Shaka adoption tracking and will be overriden.');\n    }\n\n    adTagParameters['mpt'] = 'Shaka Player';\n    adTagParameters['mpv'] = shaka.Player.version;\n\n    this.ssAdManager_.replaceAdTagParameters(adTagParameters);\n  }\n\n\n  /**\n   * @return {!Array.<!shaka.extern.AdCuePoint>}\n   * @override\n   * @export\n   */\n  getServerSideCuePoints() {\n    if (!this.ssAdManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED);\n    }\n    return this.ssAdManager_.getCuePoints();\n  }\n\n\n  /**\n   * @return {shaka.extern.AdsStats}\n   * @override\n   * @export\n   */\n  getStats() {\n    return this.stats_.getBlob();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onDashTimedMetadata(region) {\n    if (this.ssAdManager_ && region.schemeIdUri == 'urn:google:dai:2018') {\n      const type = region.schemeIdUri;\n      const data = region.eventElement ?\n          region.eventElement.getAttribute('messageData') : null;\n      const timestamp = region.startTime;\n      this.ssAdManager_.onTimedMetadata(type, data, timestamp);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onHlsTimedMetadata(metadata, timestamp) {\n    if (this.ssAdManager_) {\n      this.ssAdManager_.onTimedMetadata('ID3', metadata['data'], timestamp);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  onCueMetadataChange(value) {\n    if (this.ssAdManager_) {\n      this.ssAdManager_.onCueMetadataChange(value);\n    }\n  }\n};\n\n/**\n * The event name for when a sequence of ads has been loaded.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.ADS_LOADED = 'ads-loaded';\n\n/**\n * The event name for when an ad has started playing.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_STARTED = 'ad-started';\n\n\n/**\n * The event name for when an ad playhead crosses first quartile.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_FIRST_QUARTILE = 'ad-first-quartile';\n\n\n/**\n * The event name for when an ad playhead crosses midpoint.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_MIDPOINT = 'ad-midpoint';\n\n\n/**\n * The event name for when an ad playhead crosses third quartile.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_THIRD_QUARTILE = 'ad-third-quartile';\n\n\n/**\n * The event name for when an ad has completed playing.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_COMPLETE = 'ad-complete';\n\n\n/**\n * The event name for when an ad has finished playing\n * (played all the way through, was skipped, or was unable to proceed\n * due to an error).\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_STOPPED = 'ad-stopped';\n\n\n/**\n * The event name for when an ad is skipped by the user..\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_SKIPPED = 'ad-skipped';\n\n\n/**\n * The event name for when the ad volume has changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_VOLUME_CHANGED = 'ad-volume-changed';\n\n\n/**\n * The event name for when the ad was muted.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_MUTED = 'ad-muted';\n\n\n/**\n * The event name for when the ad was paused.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_PAUSED = 'ad-paused';\n\n\n/**\n * The event name for when the ad was resumed after a pause.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_RESUMED = 'ad-resumed';\n\n\n/**\n * The event name for when the ad's skip status changes\n * (usually it becomes skippable when it wasn't before).\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_SKIP_STATE_CHANGED = 'ad-skip-state-changed';\n\n\n/**\n * The event name for when the ad's cue points (start/end markers)\n * have changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.CUEPOINTS_CHANGED = 'ad-cue-points-changed';\n\n\n/**\n * The event name for when the native IMA ad manager object has\n * loaded and become available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.IMA_AD_MANAGER_LOADED = 'ima-ad-manager-loaded';\n\n\n/**\n * The event name for when the native IMA stream manager object has\n * loaded and become available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.IMA_STREAM_MANAGER_LOADED = 'ima-stream-manager-loaded';\n\n\n/**\n * The event name for when the ad was clicked.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_CLICKED = 'ad-clicked';\n\n\n/**\n * The event name for when there is an update to the current ad's progress.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_PROGRESS = 'ad-progress';\n\n\n/**\n * The event name for when the ad is buffering.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_BUFFERING = 'ad-buffering';\n\n\n/**\n * The event name for when the ad's URL was hit.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_IMPRESSION = 'ad-impression';\n\n\n/**\n * The event name for when the ad's duration changed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_DURATION_CHANGED = 'ad-duration-changed';\n\n\n/**\n * The event name for when the ad was closed by the user.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_CLOSED = 'ad-closed';\n\n\n/**\n * The event name for when the ad data becomes available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_LOADED = 'ad-loaded';\n\n\n/**\n * The event name for when all the ads were completed.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.ALL_ADS_COMPLETED = 'all-ads-completed';\n\n\n/**\n * The event name for when the ad changes from or to linear.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_LINEAR_CHANGED = 'ad-linear-changed';\n\n\n/**\n * The event name for when the ad's metadata becomes available.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_METADATA = 'ad-metadata';\n\n\n/**\n * The event name for when the ad display encountered a recoverable\n * error.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_RECOVERABLE_ERROR = 'ad-recoverable-error';\n\n\n/**\n * The event name for when the client side SDK signalled its readiness\n * to play a VPAID ad or an ad rule.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_BREAK_READY = 'ad-break-ready';\n\n\n/**\n * The event name for when the interaction callback for the ad was\n * triggered.\n *\n * @const {string}\n * @export\n */\nshaka.ads.AdManager.AD_INTERACTION = 'ad-interaction';\n\n\n/**\n * Set this is a default ad manager for the player.\n * Apps can also set their own ad manager, if they'd like.\n */\nshaka.Player.setAdManagerFactory(() => new shaka.ads.AdManager());\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.ads.ServerSideAd');\n\n/**\n * @implements {shaka.extern.IAd}\n * @export\n */\nshaka.ads.ServerSideAd = class {\n  /**\n   * @param {google.ima.dai.api.Ad} imaAd\n   * @param {HTMLMediaElement} video\n   */\n  constructor(imaAd, video) {\n    /** @private {google.ima.dai.api.Ad} */\n    this.ad_ = imaAd;\n\n    /** @private {?google.ima.dai.api.AdProgressData} */\n    this.adProgressData_ = null;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n  }\n\n\n  /**\n   * @param {google.ima.dai.api.AdProgressData} data\n   */\n  setProgressData(data) {\n    this.adProgressData_ = data;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getDuration() {\n    if (!this.adProgressData_) {\n      // Unknown yet\n      return -1;\n    }\n    return this.adProgressData_.duration;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getMinSuggestedDuration() {\n    return this.getDuration();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getRemainingTime() {\n    if (!this.adProgressData_) {\n      // Unknown yet\n      return -1;\n    }\n\n    return this.adProgressData_.duration - this.adProgressData_.currentTime;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isPaused() {\n    return this.video_.paused;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isSkippable() {\n    return this.ad_.isSkippable();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTimeUntilSkippable() {\n    const skipOffset = this.ad_.getSkipTimeOffset();\n    const canSkipIn = this.getRemainingTime() - skipOffset;\n    return Math.max(canSkipIn, 0);\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  canSkipNow() {\n    return this.getTimeUntilSkippable() == 0;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  skip() {\n    this.video_.currentTime += this.getRemainingTime();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  pause() {\n    return this.video_.pause();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  play() {\n    return this.video_.play();\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getVolume() {\n    return this.video_.volume;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setVolume(volume) {\n    this.video_.volume = volume;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isMuted() {\n    return this.video_.muted;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  isLinear() {\n    return true;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  resize(width, height) {\n    // Nothing\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setMuted(muted) {\n    this.video_.muted = muted;\n  }\n\n\n  /**\n   * @override\n   * @export\n   */\n  getSequenceLength() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getTotalAds();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getPositionInSequence() {\n    const podInfo = this.ad_.getAdPodInfo();\n    if (podInfo == null) {\n      // No pod, just one ad.\n      return 1;\n    }\n\n    return podInfo.getAdPosition();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getTitle() {\n    return this.ad_.getTitle();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  getDescription() {\n    return this.ad_.getDescription();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  release() {\n    this.ad_ = null;\n    this.adProgressData_ = null;\n    this.video_ = null;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview\n * @suppress {missingRequire} TODO(b/152540451): this shouldn't be needed\n */\n\ngoog.provide('shaka.ads.ServerSideAdManager');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.ads.ServerSideAd');\ngoog.require('shaka.log');\ngoog.require('shaka.util.IReleasable');\n\n\n/**\n * A class responsible for server-side ad interactions.\n * @implements {shaka.util.IReleasable}\n */\nshaka.ads.ServerSideAdManager = class {\n  /**\n   * @param {HTMLElement} adContainer\n   * @param {HTMLMediaElement} video\n   * @param {string} locale\n   * @param {function(!shaka.util.FakeEvent)} onEvent\n   */\n  constructor(adContainer, video, locale, onEvent) {\n    /** @private {HTMLElement} */\n    this.adContainer_ = adContainer;\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private\n        {?shaka.util.PublicPromise.<string>} */\n    this.streamPromise_ = null;\n\n    /** @private {number} */\n    this.streamRequestStartTime_ = NaN;\n\n    /** @private {function(!shaka.util.FakeEvent)} */\n    this.onEvent_ = onEvent;\n\n    /** @private {boolean} */\n    this.isLiveContent_ = false;\n\n    /**\n     * Time to seek to after an ad if that ad was played as the result of\n     * snapback.\n     * @private {?number}\n     */\n    this.snapForwardTime_ = null;\n\n    /** @private {shaka.ads.ServerSideAd} */\n    this.ad_ = null;\n\n    /** @private {?google.ima.dai.api.AdProgressData} */\n    this.adProgressData_ = null;\n\n    /** @private {string} */\n    this.backupUrl_ = '';\n\n    /** @private {!Array.<!shaka.extern.AdCuePoint>} */\n    this.currentCuePoints_ = [];\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {google.ima.dai.api.UiSettings} */\n    const uiSettings = new google.ima.dai.api.UiSettings();\n    uiSettings.setLocale(locale);\n\n    /** @private {google.ima.dai.api.StreamManager} */\n    this.streamManager_ = new google.ima.dai.api.StreamManager(\n        this.video_, this.adContainer_, uiSettings);\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.IMA_STREAM_MANAGER_LOADED,\n        (new Map()).set('imaStreamManager', this.streamManager_)));\n\n    // Events\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.LOADED, (e) => {\n          shaka.log.info('Ad SS Loaded');\n          this.onLoaded_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.ERROR, () => {\n          shaka.log.info('Ad SS Error');\n          this.onError_();\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED, () => {\n          shaka.log.info('Ad Break Started');\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.STARTED, (e) => {\n          shaka.log.info('Ad Started');\n          this.onAdStart_(/** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED, () => {\n          shaka.log.info('Ad Break Ended');\n          this.onAdBreakEnded_();\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.AD_PROGRESS, (e) => {\n          this.onAdProgress_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.FIRST_QUARTILE, () => {\n          shaka.log.info('Ad event: First Quartile');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_FIRST_QUARTILE));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.MIDPOINT, () => {\n          shaka.log.info('Ad event: Midpoint');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_MIDPOINT));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.THIRD_QUARTILE, () => {\n          shaka.log.info('Ad event: Third Quartile');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_THIRD_QUARTILE));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.COMPLETE, () => {\n          shaka.log.info('Ad event: Complete');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_COMPLETE));\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n          this.adContainer_.removeAttribute('ad-active');\n          this.ad_ = null;\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.SKIPPED, () => {\n          shaka.log.info('Ad event: Skipped');\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_SKIPPED));\n          this.onEvent_(\n              new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STOPPED));\n        });\n\n    this.eventManager_.listen(this.streamManager_,\n        google.ima.dai.api.StreamEvent.Type.CUEPOINTS_CHANGED, (e) => {\n          shaka.log.info('Ad event: Cue points changed');\n          this.onCuePointsChanged_(\n              /** @type {!google.ima.dai.api.StreamEvent} */ (e));\n        });\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamRequest} streamRequest\n   * @param {string=} backupUrl\n   * @return {!Promise.<string>}\n   */\n  streamRequest(streamRequest, backupUrl) {\n    if (this.streamPromise_) {\n      return Promise.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.ADS,\n          shaka.util.Error.Code.CURRENT_DAI_REQUEST_NOT_FINISHED));\n    }\n    if (streamRequest instanceof google.ima.dai.api.LiveStreamRequest) {\n      this.isLiveContent_ = true;\n    }\n\n    this.streamPromise_ = new shaka.util.PublicPromise();\n    this.streamManager_.requestStream(streamRequest);\n    this.backupUrl_ = backupUrl || '';\n\n    this.streamRequestStartTime_ = Date.now() / 1000;\n\n    return this.streamPromise_;\n  }\n\n  /**\n   * @param {Object} adTagParameters\n   */\n  replaceAdTagParameters(adTagParameters) {\n    this.streamManager_.replaceAdTagParameters(adTagParameters);\n  }\n\n  /**\n   * Resets the stream manager and removes any continuous polling.\n   */\n  stop() {\n    // TODO:\n    // For SS DAI streams, if a different asset gets unloaded as\n    // part of the process\n    // of loading a DAI asset, stream manager state gets reset and we\n    // don't get any ad events.\n    // We need to figure out if it makes sense to stop the SS\n    // manager on unload, and, if it does, find\n    // a way to do it safely.\n    // this.streamManager_.reset();\n    this.backupUrl_ = '';\n    this.snapForwardTime_ = null;\n    this.currentCuePoints_ = [];\n  }\n\n  /** @override */\n  release() {\n    this.stop();\n    if (this.eventManager_) {\n      this.eventManager_.release();\n    }\n  }\n\n  /**\n   * @param {string} type\n   * @param {Uint8Array|string} data\n   *   Comes as string in DASH and as Uint8Array in HLS.\n   * @param {number} timestamp (in seconds)\n   */\n  onTimedMetadata(type, data, timestamp) {\n    this.streamManager_.processMetadata(type, data, timestamp);\n  }\n\n  /**\n   * @param {shaka.extern.MetadataFrame} value\n   */\n  onCueMetadataChange(value) {\n    // Native HLS over Safari/iOS/iPadOS\n    // For live event streams, the stream needs some way of informing the SDK\n    // that an ad break is coming up or ending. In the IMA DAI SDK, this is\n    // done through timed metadata. Timed metadata is carried as part of the\n    // DAI stream content and carries ad break timing information used by the\n    // SDK to track ad breaks.\n    if (value.key && value.data) {\n      const metadata = {};\n      metadata[value.key] = value.data;\n      this.streamManager_.onTimedMetadata(metadata);\n    }\n  }\n\n  /**\n   * @return {!Array.<!shaka.extern.AdCuePoint>}\n   */\n  getCuePoints() {\n    return this.currentCuePoints_;\n  }\n\n  /**\n   * If a seek jumped over the ad break, return to the start of the\n   * ad break, then complete the seek after the ad played through.\n   * @private\n   */\n  checkForSnapback_() {\n    const currentTime = this.video_.currentTime;\n    if (currentTime == 0) {\n      return;\n    }\n\n    this.streamManager_.streamTimeForContentTime(currentTime);\n    const previousCuePoint =\n        this.streamManager_.previousCuePointForStreamTime(currentTime);\n    // The cue point gets marked as 'played' as soon as the playhead hits it\n    // (at the start of an ad), so when we come back to this method as a result\n    // of seeking back to the user-selected time, the 'played' flag will be set.\n    if (previousCuePoint && !previousCuePoint.played) {\n      shaka.log.info('Seeking back to the start of the ad break at ' +\n          previousCuePoint.start + ' and will return to ' + currentTime);\n      this.snapForwardTime_ = currentTime;\n      this.video_.currentTime = previousCuePoint.start;\n    }\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onAdStart_(e) {\n    goog.asserts.assert(this.streamManager_,\n        'Should have a stream manager at this point!');\n\n    const imaAd = e.getAd();\n    this.ad_ = new shaka.ads.ServerSideAd(imaAd, this.video_);\n\n    // Ad object and ad progress data come from two different IMA events.\n    // It's a race, and we don't know, which one will fire first - the\n    // event that contains an ad object (AD_STARTED) or the one that\n    // contains ad progress info (AD_PROGRESS).\n    // If the progress event fired first, we must've saved the progress\n    // info and can now add it to the ad object.\n    if (this.adProgressData_) {\n      this.ad_.setProgressData(this.adProgressData_);\n    }\n\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.AD_STARTED,\n        (new Map()).set('ad', this.ad_)));\n    this.adContainer_.setAttribute('ad-active', 'true');\n  }\n\n  /**\n   * @private\n   */\n  onAdBreakEnded_() {\n    this.adContainer_.removeAttribute('ad-active');\n    const currentTime = this.video_.currentTime;\n    // If the ad break was a result of snapping back (a user seeked over\n    // an ad break and was returned to it), seek forward to the point,\n    // originally chosen by the user.\n    if (this.snapForwardTime_ && this.snapForwardTime_ > currentTime) {\n      this.video_.currentTime = this.snapForwardTime_;\n      this.snapForwardTime_ = null;\n    }\n  }\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onLoaded_(e) {\n    const now = Date.now() / 1000;\n    const loadTime = now - this.streamRequestStartTime_;\n    this.onEvent_(new shaka.util.FakeEvent(shaka.ads.AdManager.ADS_LOADED,\n        (new Map()).set('loadTime', loadTime)));\n\n    const streamData = e.getStreamData();\n    const url = streamData.url;\n    this.streamPromise_.resolve(url);\n    this.streamPromise_ = null;\n\n    if (!this.isLiveContent_) {\n      this.eventManager_.listen(this.video_, 'seeked', () => {\n        this.checkForSnapback_();\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  onError_() {\n    if (!this.backupUrl_.length) {\n      this.streamPromise_.reject('IMA Stream request returned an error ' +\n          'and there was no backup asset uri provided.');\n      this.streamPromise_ = null;\n      return;\n    }\n\n    shaka.log.warning('IMA stream request returned an error. ' +\n        'Falling back to the backup asset uri.');\n    this.streamPromise_.resolve(this.backupUrl_);\n    this.streamPromise_ = null;\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onAdProgress_(e) {\n    const streamData = e.getStreamData();\n    const adProgressData = streamData.adProgressData;\n    this.adProgressData_ = adProgressData;\n    if (this.ad_) {\n      this.ad_.setProgressData(this.adProgressData_);\n    }\n  }\n\n\n  /**\n   * @param {!google.ima.dai.api.StreamEvent} e\n   * @private\n   */\n  onCuePointsChanged_(e) {\n    const streamData = e.getStreamData();\n\n    /** @type {!Array.<!shaka.extern.AdCuePoint>} */\n    const cuePoints = [];\n    for (const point of streamData.cuepoints) {\n      /** @type {shaka.extern.AdCuePoint} */\n      const shakaCuePoint = {\n        start: point.start,\n        end: point.end,\n      };\n      cuePoints.push(shakaCuePoint);\n    }\n\n    this.currentCuePoints_ = cuePoints;\n\n    this.onEvent_(new shaka.util.FakeEvent(\n        shaka.ads.AdManager.CUEPOINTS_CHANGED,\n        (new Map()).set('cuepoints', cuePoints)));\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastUtils');\n\ngoog.require('shaka.media.TimeRangesUtils');\ngoog.require('shaka.util.FakeEvent');\n\n\n/**\n * @summary A set of cast utility functions and variables shared between sender\n *   and receiver.\n */\nshaka.cast.CastUtils = class {\n  /**\n   * Serialize as JSON, but specially encode things JSON will not otherwise\n   * represent.\n   * @param {?} thing\n   * @return {string}\n   */\n  static serialize(thing) {\n    return JSON.stringify(thing, (key, value) => {\n      if (typeof value == 'function') {\n        // Functions can't be (safely) serialized.\n        return undefined;\n      }\n\n      if (value instanceof Event || value instanceof shaka.util.FakeEvent) {\n        // Events don't serialize to JSON well because of the DOM objects\n        // and other complex objects they contain, so we strip these out.\n        // Note that using Object.keys or JSON.stringify directly on the event\n        // will not capture its properties.  We must use a for loop.\n        const simpleEvent = {};\n        for (const eventKey in value) {\n          const eventValue = value[eventKey];\n          if (eventValue && typeof eventValue == 'object') {\n            if (eventKey == 'detail') {\n              // Keep the detail value, because it contains important\n              // information for diagnosing errors.\n              simpleEvent[eventKey] = eventValue;\n            }\n            // Strip out non-null object types because they are complex and we\n            // don't need them.\n          } else if (eventKey in Event) {\n            // Strip out keys that are found on Event itself because they are\n            // class-level constants we don't need, like Event.MOUSEMOVE == 16.\n          } else {\n            simpleEvent[eventKey] = eventValue;\n          }\n        }\n        return simpleEvent;\n      }\n\n      if (value instanceof Error) {\n        // Errors don't serialize to JSON well, either.  TypeError, for example,\n        // turns in \"{}\", leading to messages like \"Error UNKNOWN.UNKNOWN\" when\n        // deserialized on the sender and displayed in the demo app.\n        return shaka.cast.CastUtils.unpackError_(value);\n      }\n\n      if (value instanceof TimeRanges) {\n        // TimeRanges must be unpacked into plain data for serialization.\n        return shaka.cast.CastUtils.unpackTimeRanges_(value);\n      }\n\n      if (value instanceof Uint8Array) {\n        // Some of our code cares about Uint8Arrays actually being Uint8Arrays,\n        // so this gives them special treatment.\n        return shaka.cast.CastUtils.unpackUint8Array_(value);\n      }\n\n      if (typeof value == 'number') {\n        // NaN and infinity cannot be represented directly in JSON.\n        if (isNaN(value)) {\n          return 'NaN';\n        }\n        if (isFinite(value)) {\n          return value;\n        }\n        if (value < 0) {\n          return '-Infinity';\n        }\n        return 'Infinity';\n      }\n\n      return value;\n    });\n  }\n\n\n  /**\n   * Deserialize JSON using our special encodings.\n   * @param {string} str\n   * @return {?}\n   */\n  static deserialize(str) {\n    return JSON.parse(str, (key, value) => {\n      if (value == 'NaN') {\n        return NaN;\n      } else if (value == '-Infinity') {\n        return -Infinity;\n      } else if (value == 'Infinity') {\n        return Infinity;\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'TimeRanges') {\n        // TimeRanges objects have been unpacked and sent as plain data.\n        // Simulate the original TimeRanges object.\n        return shaka.cast.CastUtils.simulateTimeRanges_(value);\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'Uint8Array') {\n        return shaka.cast.CastUtils.makeUint8Array_(value);\n      } else if (value && typeof value == 'object' &&\n                 value['__type__'] == 'Error') {\n        return shaka.cast.CastUtils.makeError_(value);\n      }\n      return value;\n    });\n  }\n\n\n  /**\n   * @param {!TimeRanges} ranges\n   * @return {!Object}\n   * @private\n   */\n  static unpackTimeRanges_(ranges) {\n    const obj = {\n      '__type__': 'TimeRanges',  // a signal to deserialize\n      'length': ranges.length,\n      'start': [],\n      'end': [],\n    };\n\n    const TimeRangesUtils = shaka.media.TimeRangesUtils;\n    for (const {start, end} of TimeRangesUtils.getBufferedInfo(ranges)) {\n      obj['start'].push(start);\n      obj['end'].push(end);\n    }\n\n    return obj;\n  }\n\n\n  /**\n   * Creates a simulated TimeRanges object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {{\n   *   length: number,\n   *   start: function(number): number,\n   *   end: function(number): number\n   * }}\n   * @private\n   */\n  static simulateTimeRanges_(obj) {\n    return {\n      length: obj.length,\n      // NOTE: a more complete simulation would throw when |i| was out of range,\n      // but for simplicity we will assume a well-behaved application that uses\n      // length instead of catch to stop iterating.\n      start: (i) => { return obj.start[i]; },\n      end: (i) => { return obj.end[i]; },\n    };\n  }\n\n\n  /**\n   * @param {!Uint8Array} array\n   * @return {!Object}\n   * @private\n   */\n  static unpackUint8Array_(array) {\n    return {\n      '__type__': 'Uint8Array',  // a signal to deserialize\n      'entries': Array.from(array),\n    };\n  }\n\n\n  /**\n   * Creates a Uint8Array object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {!Uint8Array}\n   * @private\n   */\n  static makeUint8Array_(obj) {\n    return new Uint8Array(/** @type {!Array.<number>} */ (obj['entries']));\n  }\n\n\n  /**\n   * @param {!Error} error\n   * @return {!Object}\n   * @private\n   */\n  static unpackError_(error) {\n    // None of the properties in TypeError are enumerable, but there are some\n    // common Error properties we expect.  We also enumerate any enumerable\n    // properties and \"own\" properties of the type, in case there is an Error\n    // subtype with additional properties we don't know about in advance.\n    const properties = new Set(['name', 'message', 'stack']);\n    for (const key in error) {\n      properties.add(key);\n    }\n    for (const key of Object.getOwnPropertyNames(error)) {\n      properties.add(key);\n    }\n\n    const contents = {};\n    for (const key of properties) {\n      contents[key] = error[key];\n    }\n\n    return {\n      '__type__': 'Error',  // a signal to deserialize\n      'contents': contents,\n    };\n  }\n\n\n  /**\n   * Creates an Error object from data sent by the cast receiver.\n   * @param {?} obj\n   * @return {!Error}\n   * @private\n   */\n  static makeError_(obj) {\n    const contents = obj['contents'];\n    const error = new Error(contents['message']);\n    for (const key in contents) {\n      error[key] = contents[key];\n    }\n    return error;\n  }\n};\n\n/**\n * HTMLMediaElement events that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoEvents = [\n  'ended',\n  'play',\n  'playing',\n  'pause',\n  'pausing',\n  'ratechange',\n  'seeked',\n  'seeking',\n  'timeupdate',\n  'volumechange',\n];\n\n\n/**\n * HTMLMediaElement attributes that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoAttributes = [\n  'buffered',\n  'currentTime',\n  'duration',\n  'ended',\n  'loop',\n  'muted',\n  'paused',\n  'playbackRate',\n  'seeking',\n  'videoHeight',\n  'videoWidth',\n  'volume',\n];\n\n\n/**\n * HTMLMediaElement attributes that are transferred when casting begins.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoInitStateAttributes = [\n  'loop',\n  'playbackRate',\n];\n\n\n/**\n * HTMLMediaElement methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.VideoVoidMethods = [\n  'pause',\n  'play',\n];\n\n\n/**\n * Player getter methods that are proxied while casting.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethods = {\n  // NOTE: The 'drmInfo' property is not proxied, as it is very large.\n  'getAssetUri': 2,\n  'getAudioLanguages': 4,\n  'getAudioLanguagesAndRoles': 4,\n  'getBufferFullness': 1,\n  'getBufferedInfo': 2,\n  'getExpiration': 2,\n  'getKeyStatuses': 2,\n  // NOTE: The 'getManifest' property is not proxied, as it is very large.\n  // NOTE: The 'getManifestParserFactory' property is not proxied, as it would\n  // not serialize.\n  'getPlaybackRate': 2,\n  'getTextLanguages': 4,\n  'getTextLanguagesAndRoles': 4,\n  'getImageTracks': 2,\n  'getThumbnails': 2,\n  'isAudioOnly': 10,\n  'isBuffering': 1,\n  'isInProgress': 1,\n  'isLive': 10,\n  'isTextTrackVisible': 1,\n  'keySystem': 10,\n  'seekRange': 1,\n  'getLoadMode': 10,\n};\n\n\n/**\n * Player getter methods with data large enough to be sent in their own update\n * messages, to reduce the size of each message.  The format of this is\n * identical to PlayerGetterMethods.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.LargePlayerGetterMethods = {\n  // NOTE: The 'getSharedConfiguration' property is not proxied as it would\n  //       not be possible to share a reference.\n  'getConfiguration': 4,\n  'getStats': 5,\n  'getTextTracks': 2,\n  'getVariantTracks': 2,\n};\n\n\n/**\n * Player getter methods that are proxied while casting, but only when casting\n * a livestream.\n * The key is the method, the value is the frequency of updates.\n * Frequency 1 translates to every update; frequency 2 to every 2 updates, etc.\n * @const {!Object.<string, number>}\n */\nshaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive = {\n  'getPlayheadTimeAsDate': 1,\n  'getPresentationStartTimeAsDate': 20,\n};\n\n\n/**\n * Player getter and setter methods that are used to transfer state when casting\n * begins.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitState = [\n  ['getConfiguration', 'configure'],\n];\n\n\n/**\n * Player getter and setter methods that are used to transfer state after\n * load() is resolved.\n * @const {!Array.<!Array.<string>>}\n */\nshaka.cast.CastUtils.PlayerInitAfterLoadState = [\n  ['isTextTrackVisible', 'setTextTrackVisibility'],\n];\n\n\n/**\n * Player methods with no return value that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerVoidMethods = [\n  'addChaptersTrack',\n  'addTextTrackAsync',\n  'addThumbnailsTrack',\n  'cancelTrickPlay',\n  'configure',\n  'getChapters',\n  'getChaptersTracks',\n  'resetConfiguration',\n  'retryStreaming',\n  'selectAudioLanguage',\n  'selectTextLanguage',\n  'selectTextTrack',\n  'selectVariantTrack',\n  'selectVariantsByLabel',\n  'setTextTrackVisibility',\n  'trickPlay',\n  'updateStartTime',\n  'goToLive',\n];\n\n\n/**\n * Player methods returning a Promise that are proxied while casting.\n * @const {!Array.<string>}\n */\nshaka.cast.CastUtils.PlayerPromiseMethods = [\n  'attach',\n  'attachCanvas',\n  'detach',\n  // The manifestFactory parameter of load is not supported.\n  'load',\n  'unload',\n];\n\n\n/**\n * @typedef {{\n *   video: Object,\n *   player: Object,\n *   manifest: ?string,\n *   startTime: ?number\n * }}\n * @property {Object} video\n *   Dictionary of video properties to be set.\n * @property {Object} player\n *   Dictionary of player setters to be called.\n * @property {?string} manifest\n *   The currently-selected manifest, if present.\n * @property {?number} startTime\n *   The playback start time, if currently playing.\n */\nshaka.cast.CastUtils.InitStateType;\n\n\n/**\n * The namespace for Shaka messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.shaka.v2';\n\n\n/**\n * The namespace for generic messages on the cast bus.\n * @const {string}\n */\nshaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE =\n    'urn:x-cast:com.google.cast.media';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastSender');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @implements {shaka.util.IDestroyable}\n */\nshaka.cast.CastSender = class {\n  /**\n   * @param {string} receiverAppId The ID of the cast receiver application.\n   * @param {function()} onStatusChanged A callback invoked when the cast status\n   *   changes.\n   * @param {function()} onFirstCastStateUpdate A callback invoked when an\n   *   \"update\" event has been received for the first time.\n   * @param {function(string, !shaka.util.FakeEvent)} onRemoteEvent A callback\n   *   invoked with target name and event when a remote event is received.\n   * @param {function()} onResumeLocal A callback invoked when the local player\n   *   should resume playback.  Called before the cached remote state is wiped.\n   * @param {function()} onInitStateRequired A callback to get local player's.\n   *   state.  Invoked when casting is initiated from Chrome's cast button.\n   * @param {boolean} androidReceiverCompatible Indicates if the app is\n   *   compatible with an Android Receiver.\n   */\n  constructor(receiverAppId, onStatusChanged, onFirstCastStateUpdate,\n      onRemoteEvent, onResumeLocal, onInitStateRequired,\n      androidReceiverCompatible) {\n    /** @private {string} */\n    this.receiverAppId_ = receiverAppId;\n\n    /** @private {boolean} */\n    this.androidReceiverCompatible_ = androidReceiverCompatible;\n\n    /** @private {shaka.util.Timer} */\n    this.statusChangeTimer_ = new shaka.util.Timer(onStatusChanged);\n\n    /** @private {?function()} */\n    this.onFirstCastStateUpdate_ = onFirstCastStateUpdate;\n\n    /** @private {boolean} */\n    this.hasJoinedExistingSession_ = false;\n\n    /** @private {?function(string, !shaka.util.FakeEvent)} */\n    this.onRemoteEvent_ = onRemoteEvent;\n\n    /** @private {?function()} */\n    this.onResumeLocal_ = onResumeLocal;\n\n    /** @private {?function()} */\n    this.onInitStateRequired_ = onInitStateRequired;\n\n    /** @private {boolean} */\n    this.apiReady_ = false;\n\n    /** @private {boolean} */\n    this.isCasting_ = false;\n\n    /** @private {string} */\n    this.receiverName_ = '';\n\n    /** @private {Object} */\n    this.appData_ = null;\n\n    /** @private {?function()} */\n    this.onConnectionStatusChangedBound_ =\n        () => this.onConnectionStatusChanged_();\n\n    /** @private {?function(string, string)} */\n    this.onMessageReceivedBound_ = (namespace, serialized) =>\n      this.onMessageReceived_(namespace, serialized);\n\n    /** @private {Object} */\n    this.cachedProperties_ = {\n      'video': {},\n      'player': {},\n    };\n\n    /** @private {number} */\n    this.nextAsyncCallId_ = 0;\n\n    /** @private {Object.<string, !shaka.util.PublicPromise>} */\n    this.asyncCallPromises_ = {};\n\n    /** @private {shaka.util.PublicPromise} */\n    this.castPromise_ = null;\n\n    shaka.cast.CastSender.instances_.add(this);\n  }\n\n\n  /** @override */\n  destroy() {\n    shaka.cast.CastSender.instances_.delete(this);\n\n    this.rejectAllPromises_();\n    if (shaka.cast.CastSender.session_) {\n      this.removeListeners_();\n      // Don't leave the session, so that this session can be re-used later if\n      // necessary.\n    }\n\n    if (this.statusChangeTimer_) {\n      this.statusChangeTimer_.stop();\n      this.statusChangeTimer_ = null;\n    }\n\n    this.onRemoteEvent_ = null;\n    this.onResumeLocal_ = null;\n    this.apiReady_ = false;\n    this.isCasting_ = false;\n    this.appData_ = null;\n    this.cachedProperties_ = null;\n    this.asyncCallPromises_ = null;\n    this.castPromise_ = null;\n    this.onConnectionStatusChangedBound_ = null;\n    this.onMessageReceivedBound_ = null;\n\n    return Promise.resolve();\n  }\n\n\n  /**\n   * @return {boolean} True if the cast API is available.\n   */\n  apiReady() {\n    return this.apiReady_;\n  }\n\n\n  /**\n   * @return {boolean} True if there are receivers.\n   */\n  hasReceivers() {\n    return shaka.cast.CastSender.hasReceivers_;\n  }\n\n\n  /**\n   * @return {boolean} True if we are currently casting.\n   */\n  isCasting() {\n    return this.isCasting_;\n  }\n\n\n  /**\n   * @return {string} The name of the Cast receiver device, if isCasting().\n   */\n  receiverName() {\n    return this.receiverName_;\n  }\n\n\n  /**\n   * @return {boolean} True if we have a cache of remote properties from the\n   *   receiver.\n   */\n  hasRemoteProperties() {\n    return Object.keys(this.cachedProperties_['video']).length != 0;\n  }\n\n\n  /** Initialize the Cast API. */\n  init() {\n    const CastSender = shaka.cast.CastSender;\n\n    if (!this.receiverAppId_.length) {\n      // Return if no cast receiver id has been provided.\n      // Nothing will be initialized, no global hooks will be installed.\n      // If the receiver ID changes before this instance dies, init will be\n      // called again.\n      return;\n    }\n\n    // Check for the cast API.\n    if (!window.chrome || !chrome.cast || !chrome.cast.isAvailable) {\n      // If the API is not available on this platform or is not ready yet,\n      // install a hook to be notified when it becomes available.\n      // If the API becomes available before this instance dies, init will be\n      // called again.\n\n      // Check if our callback is already installed.\n      if (window.__onGCastApiAvailable !== CastSender.onGCastApiAvailable_) {\n        // Save pre-existing __onGCastApiAvailable in order to restore later.\n        CastSender.__onGCastApiAvailable_ =\n          window.__onGCastApiAvailable || null;\n        window.__onGCastApiAvailable = CastSender.onGCastApiAvailable_;\n      }\n\n      return;\n    }\n\n    // The API is now available.\n    this.apiReady_ = true;\n    this.statusChangeTimer_.tickNow();\n\n    // Use static versions of the API callbacks, since the ChromeCast API is\n    // static. If we used local versions, we might end up retaining references\n    // to destroyed players here.\n    const sessionRequest = new chrome.cast.SessionRequest(this.receiverAppId_,\n        /* capabilities= */ [],\n        /* timeout= */ null,\n        this.androidReceiverCompatible_,\n        /* credentialsData= */null);\n    const apiConfig = new chrome.cast.ApiConfig(sessionRequest,\n        (session) => CastSender.onExistingSessionJoined_(session),\n        (availability) => CastSender.onReceiverStatusChanged_(availability),\n        'origin_scoped');\n\n    // TODO: Have never seen this fail.  When would it and how should we react?\n    chrome.cast.initialize(apiConfig,\n        () => { shaka.log.debug('CastSender: init'); },\n        (error) => { shaka.log.error('CastSender: init error', error); });\n    if (shaka.cast.CastSender.hasReceivers_) {\n      // Fire a fake cast status change, to simulate the update that\n      // would be fired normally.\n      // This is after a brief delay, to give users a chance to add event\n      // listeners.\n      this.statusChangeTimer_.tickAfter(shaka.cast.CastSender.STATUS_DELAY);\n    }\n\n    const oldSession = shaka.cast.CastSender.session_;\n    if (oldSession && oldSession.status != chrome.cast.SessionStatus.STOPPED) {\n      // The old session still exists, so re-use it.\n      shaka.log.debug('CastSender: re-using existing connection');\n      this.onExistingSessionJoined_(oldSession);\n    } else {\n      // The session has been canceled in the meantime, so ignore it.\n      shaka.cast.CastSender.session_ = null;\n    }\n  }\n\n\n  /**\n   * Set application-specific data.\n   *\n   * @param {Object} appData Application-specific data to relay to the receiver.\n   */\n  setAppData(appData) {\n    this.appData_ = appData;\n    if (this.isCasting_) {\n      this.sendMessage_({\n        'type': 'appData',\n        'appData': this.appData_,\n      });\n    }\n  }\n\n\n  /**\n   * @param {shaka.cast.CastUtils.InitStateType} initState Video and player\n   *   state to be sent to the receiver.\n   * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n   *   connection fails or is canceled by the user.\n   */\n  async cast(initState) {\n    if (!this.apiReady_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_API_UNAVAILABLE);\n    }\n    if (!shaka.cast.CastSender.hasReceivers_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.NO_CAST_RECEIVERS);\n    }\n    if (this.isCasting_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.ALREADY_CASTING);\n    }\n\n    this.castPromise_ = new shaka.util.PublicPromise();\n    chrome.cast.requestSession(\n        (session) => this.onSessionInitiated_(initState, session),\n        (error) => this.onConnectionError_(error));\n    await this.castPromise_;\n  }\n\n\n  /**\n   * Shows user a cast dialog where they can choose to stop\n   * casting.  Relies on Chrome to perform disconnect if they do.\n   * Doesn't do anything if not connected.\n   */\n  showDisconnectDialog() {\n    if (!this.isCasting_) {\n      return;\n    }\n    const initState = this.onInitStateRequired_();\n\n    chrome.cast.requestSession(\n        (session) => this.onSessionInitiated_(initState, session),\n        (error) => this.onConnectionError_(error));\n  }\n\n\n  /**\n   * Forces the receiver app to shut down by disconnecting.  Does nothing if not\n   * connected.\n   */\n  forceDisconnect() {\n    if (!this.isCasting_) {\n      return;\n    }\n\n    this.rejectAllPromises_();\n\n    if (shaka.cast.CastSender.session_) {\n      this.removeListeners_();\n\n      // This can throw if we've already been disconnected somehow.\n      try {\n        shaka.cast.CastSender.session_.stop(() => {}, () => {});\n      } catch (error) {}\n\n      shaka.cast.CastSender.session_ = null;\n    }\n\n    // Update casting status.\n    this.onConnectionStatusChanged_();\n  }\n\n\n  /**\n   * Getter for properties of remote objects.\n   * @param {string} targetName\n   * @param {string} property\n   * @return {?}\n   */\n  get(targetName, property) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    const CastUtils = shaka.cast.CastUtils;\n    if (targetName == 'video') {\n      if (CastUtils.VideoVoidMethods.includes(property)) {\n        return (...args) => this.remoteCall_(targetName, property, ...args);\n      }\n    } else if (targetName == 'player') {\n      if (CastUtils.PlayerGetterMethodsThatRequireLive[property]) {\n        const isLive = this.get('player', 'isLive')();\n        goog.asserts.assert(isLive,\n            property + ' should be called on a live stream!');\n        // If the property shouldn't exist, return a fake function so that the\n        // user doesn't call an undefined function and get a second error.\n        if (!isLive) {\n          return () => undefined;\n        }\n      }\n      if (CastUtils.PlayerVoidMethods.includes(property)) {\n        return (...args) => this.remoteCall_(targetName, property, ...args);\n      }\n      if (CastUtils.PlayerPromiseMethods.includes(property)) {\n        return (...args) =>\n          this.remoteAsyncCall_(targetName, property, ...args);\n      }\n      if (CastUtils.PlayerGetterMethods[property] ||\n          CastUtils.LargePlayerGetterMethods[property]) {\n        return () => this.propertyGetter_(targetName, property);\n      }\n    }\n\n    return this.propertyGetter_(targetName, property);\n  }\n\n\n  /**\n   * Setter for properties of remote objects.\n   * @param {string} targetName\n   * @param {string} property\n   * @param {?} value\n   */\n  set(targetName, property, value) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n\n    this.cachedProperties_[targetName][property] = value;\n    this.sendMessage_({\n      'type': 'set',\n      'targetName': targetName,\n      'property': property,\n      'value': value,\n    });\n  }\n\n\n  /**\n   * @param {shaka.cast.CastUtils.InitStateType} initState\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onSessionInitiated_(initState, session) {\n    shaka.log.debug('CastSender: onSessionInitiated');\n    this.onSessionCreated_(session);\n\n    this.sendMessage_({\n      'type': 'init',\n      'initState': initState,\n      'appData': this.appData_,\n    });\n\n    this.castPromise_.resolve();\n  }\n\n\n  /**\n   * @param {chrome.cast.Error} error\n   * @private\n   */\n  onConnectionError_(error) {\n    // Default error code:\n    let code = shaka.util.Error.Code.UNEXPECTED_CAST_ERROR;\n\n    switch (error.code) {\n      case 'cancel':\n        code = shaka.util.Error.Code.CAST_CANCELED_BY_USER;\n        break;\n      case 'timeout':\n        code = shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT;\n        break;\n      case 'receiver_unavailable':\n        code = shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE;\n        break;\n    }\n\n    this.castPromise_.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.CAST,\n        code,\n        error));\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} property\n   * @return {?}\n   * @private\n   */\n  propertyGetter_(targetName, property) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    return this.cachedProperties_[targetName][property];\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} methodName\n   * @param {...*} varArgs\n   * @private\n   */\n  remoteCall_(targetName, methodName, ...varArgs) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n    this.sendMessage_({\n      'type': 'call',\n      'targetName': targetName,\n      'methodName': methodName,\n      'args': varArgs,\n    });\n  }\n\n\n  /**\n   * @param {string} targetName\n   * @param {string} methodName\n   * @param {...*} varArgs\n   * @return {!Promise}\n   * @private\n   */\n  remoteAsyncCall_(targetName, methodName, ...varArgs) {\n    goog.asserts.assert(targetName == 'video' || targetName == 'player',\n        'Unexpected target name');\n\n    const p = new shaka.util.PublicPromise();\n    const id = this.nextAsyncCallId_.toString();\n    this.nextAsyncCallId_++;\n    this.asyncCallPromises_[id] = p;\n\n    try {\n      this.sendMessage_({\n        'type': 'asyncCall',\n        'targetName': targetName,\n        'methodName': methodName,\n        'args': varArgs,\n        'id': id,\n      });\n    } catch (error) {\n      p.reject(error);\n    }\n    return p;\n  }\n\n\n  /**\n   * A static version of onExistingSessionJoined_, that calls that method for\n   * each known instance.\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  static onExistingSessionJoined_(session) {\n    for (const instance of shaka.cast.CastSender.instances_) {\n      instance.onExistingSessionJoined_(session);\n    }\n  }\n\n\n  /**\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onExistingSessionJoined_(session) {\n    shaka.log.debug('CastSender: onExistingSessionJoined');\n\n    const initState = this.onInitStateRequired_();\n\n    this.castPromise_ = new shaka.util.PublicPromise();\n    this.hasJoinedExistingSession_ = true;\n\n    this.onSessionInitiated_(initState, session);\n  }\n\n\n  /**\n   * A static version of onReceiverStatusChanged_, that calls that method for\n   * each known instance.\n   * @param {string} availability\n   * @private\n   */\n  static onReceiverStatusChanged_(availability) {\n    for (const instance of shaka.cast.CastSender.instances_) {\n      instance.onReceiverStatusChanged_(availability);\n    }\n  }\n\n\n  /**\n   * @param {string} availability\n   * @private\n   */\n  onReceiverStatusChanged_(availability) {\n    // The cast API is telling us whether there are any cast receiver devices\n    // available.\n    shaka.log.debug('CastSender: receiver status', availability);\n    shaka.cast.CastSender.hasReceivers_ = availability == 'available';\n    this.statusChangeTimer_.tickNow();\n  }\n\n\n  /**\n   * @param {chrome.cast.Session} session\n   * @private\n   */\n  onSessionCreated_(session) {\n    shaka.cast.CastSender.session_ = session;\n    session.addUpdateListener(this.onConnectionStatusChangedBound_);\n    session.addMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n        this.onMessageReceivedBound_);\n    this.onConnectionStatusChanged_();\n  }\n\n\n  /**\n   * @private\n   */\n  removeListeners_() {\n    const session = shaka.cast.CastSender.session_;\n    session.removeUpdateListener(this.onConnectionStatusChangedBound_);\n    session.removeMessageListener(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n        this.onMessageReceivedBound_);\n  }\n\n\n  /**\n   * @private\n   */\n  onConnectionStatusChanged_() {\n    const connected = shaka.cast.CastSender.session_ ?\n        shaka.cast.CastSender.session_.status == 'connected' :\n        false;\n    shaka.log.debug('CastSender: connection status', connected);\n    if (this.isCasting_ && !connected) {\n      // Tell CastProxy to transfer state back to local player.\n      this.onResumeLocal_();\n\n      // Clear whatever we have cached.\n      for (const targetName in this.cachedProperties_) {\n        this.cachedProperties_[targetName] = {};\n      }\n\n      this.rejectAllPromises_();\n    }\n\n    this.isCasting_ = connected;\n    this.receiverName_ = connected ?\n        shaka.cast.CastSender.session_.receiver.friendlyName :\n        '';\n    this.statusChangeTimer_.tickNow();\n  }\n\n\n  /**\n   * Reject any async call promises that are still pending.\n   * @private\n   */\n  rejectAllPromises_() {\n    for (const id in this.asyncCallPromises_) {\n      const p = this.asyncCallPromises_[id];\n      delete this.asyncCallPromises_[id];\n\n      // Reject pending async operations as if they were interrupted.\n      // At the moment, load() is the only async operation we are worried about.\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.RECOVERABLE,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.LOAD_INTERRUPTED));\n    }\n  }\n\n\n  /**\n   * @param {string} namespace\n   * @param {string} serialized\n   * @private\n   */\n  onMessageReceived_(namespace, serialized) {\n    // Since this method is in the compiled library, make sure all messages\n    // passed in here were created with quoted property names.\n\n    const message = shaka.cast.CastUtils.deserialize(serialized);\n    shaka.log.v2('CastSender: message', message);\n\n    switch (message['type']) {\n      case 'event': {\n        const targetName = message['targetName'];\n        const event = message['event'];\n        const fakeEvent = shaka.util.FakeEvent.fromRealEvent(event);\n        this.onRemoteEvent_(targetName, fakeEvent);\n        break;\n      }\n      case 'update': {\n        const update = message['update'];\n        for (const targetName in update) {\n          const target = this.cachedProperties_[targetName] || {};\n          for (const property in update[targetName]) {\n            target[property] = update[targetName][property];\n          }\n        }\n        if (this.hasJoinedExistingSession_) {\n          this.onFirstCastStateUpdate_();\n          this.hasJoinedExistingSession_ = false;\n        }\n        break;\n      }\n      case 'asyncComplete': {\n        const id = message['id'];\n        const error = message['error'];\n        const p = this.asyncCallPromises_[id];\n        delete this.asyncCallPromises_[id];\n\n        goog.asserts.assert(p, 'Unexpected async id');\n        if (!p) {\n          break;\n        }\n\n        if (error) {\n          // This is a hacky way to reconstruct the serialized error.\n          const reconstructedError = new shaka.util.Error(\n              error.severity, error.category, error.code);\n          for (const k in error) {\n            (/** @type {Object} */(reconstructedError))[k] = error[k];\n          }\n          p.reject(reconstructedError);\n        } else {\n          p.resolve();\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * @param {!Object} message\n   * @private\n   */\n  sendMessage_(message) {\n    // Since this method is in the compiled library, make sure all messages\n    // passed in here were created with quoted property names.\n\n    const serialized = shaka.cast.CastUtils.serialize(message);\n    const session = shaka.cast.CastSender.session_;\n\n    // NOTE: This takes an error callback that we have not seen fire.  We don't\n    // know if it would fire synchronously or asynchronously.  Until we know how\n    // it works, we just log from that callback.  But we _have_ seen\n    // sendMessage() throw synchronously, so we handle that.\n    try {\n      session.sendMessage(shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE,\n          serialized,\n          () => {},  // success callback\n          shaka.log.error);  // error callback\n    } catch (error) {\n      shaka.log.error('Cast session sendMessage threw', error);\n\n      // Translate the error\n      const shakaError = new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT,\n          error);\n\n      // Dispatch it through the Player proxy\n      const fakeEvent = new shaka.util.FakeEvent(\n          'error', (new Map()).set('detail', shakaError));\n      this.onRemoteEvent_('player', fakeEvent);\n\n      // Force this session to disconnect and transfer playback to the local\n      // device\n      this.forceDisconnect();\n\n      // Throw the translated error from this getter/setter/method to the UI/app\n      throw shakaError;\n    }\n  }\n};\n\n/** @type {number} */\nshaka.cast.CastSender.STATUS_DELAY = 0.02;\n\n/** @private {boolean} */\nshaka.cast.CastSender.hasReceivers_ = false;\n\n/** @private {chrome.cast.Session} */\nshaka.cast.CastSender.session_ = null;\n\n/** @private {?function(boolean)} */\nshaka.cast.CastSender.__onGCastApiAvailable_ = null;\n\n/**\n * A set of all living CastSender instances.  The constructor and destroy\n * methods will add and remove instances from this set.\n *\n * This is used to deal with delayed initialization of the Cast SDK.  When the\n * SDK becomes available, instances will be reinitialized.\n *\n * @private {!Set.<shaka.cast.CastSender>}\n */\nshaka.cast.CastSender.instances_ = new Set();\n\n/**\n * If the cast SDK is not available yet, it will invoke this callback once it\n * becomes available.\n *\n * @param {boolean} loaded\n * @private\n */\nshaka.cast.CastSender.onSdkLoaded_ = (loaded) => {\n  if (loaded) {\n    // Any living instances of CastSender should have their init methods called\n    // again now that the API is available.\n    for (const sender of shaka.cast.CastSender.instances_) {\n      sender.init();\n    }\n  }\n};\n\n/**\n * @param {boolean} available\n * @private\n */\nshaka.cast.CastSender.onGCastApiAvailable_ = (available) => {\n  // Restore callback from saved.\n  if (shaka.cast.CastSender.__onGCastApiAvailable_) {\n    window.__onGCastApiAvailable =\n      shaka.cast.CastSender.__onGCastApiAvailable_;\n  } else {\n    delete window.__onGCastApiAvailable;\n  }\n  shaka.cast.CastSender.__onGCastApiAvailable_ = null;\n\n  // A note about this value: In our testing environment, we load both\n  // uncompiled and compiled code.  This global callback in uncompiled mode\n  // can be overwritten by the same in compiled mode.  The two versions will\n  // each have their own instances_ map.  Therefore the callback must have a\n  // name, as opposed to being anonymous.  This way, the CastSender tests\n  // can invoke the named static method instead of using a global that could\n  // be overwritten.\n  shaka.cast.CastSender.onSdkLoaded_(available);\n\n  // call restored callback (if any)\n  if (typeof window.__onGCastApiAvailable === 'function') {\n    window.__onGCastApiAvailable(available);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastProxy');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.cast.CastSender');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\n\n\n/**\n * @event shaka.cast.CastProxy.CastStatusChangedEvent\n * @description Fired when cast status changes.  The status change will be\n *   reflected in canCast() and isCasting().\n * @property {string} type\n *   'caststatuschanged'\n * @exportDoc\n */\n\n\n/**\n * @summary A proxy to switch between local and remote playback for Chromecast\n * in a way that is transparent to the app's controls.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.cast.CastProxy = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} video The local video element associated with\n   *   the local Player instance.\n   * @param {!shaka.Player} player A local Player instance.\n   * @param {string} receiverAppId The ID of the cast receiver application.\n   *   If blank, casting will not be available, but the proxy will still\n   *   function otherwise.\n   * @param {boolean} androidReceiverCompatible Indicates if the app is\n   *   compatible with an Android Receiver.\n   */\n  constructor(video, player, receiverAppId,\n      androidReceiverCompatible = false) {\n    super();\n\n    /** @private {HTMLMediaElement} */\n    this.localVideo_ = video;\n\n    /** @private {shaka.Player} */\n    this.localPlayer_ = player;\n\n    /** @private {Object} */\n    this.videoProxy_ = null;\n\n    /** @private {Object} */\n    this.playerProxy_ = null;\n\n    /** @private {shaka.util.FakeEventTarget} */\n    this.videoEventTarget_ = null;\n\n    /** @private {shaka.util.FakeEventTarget} */\n    this.playerEventTarget_ = null;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = null;\n\n    /** @private {string} */\n    this.receiverAppId_ = receiverAppId;\n\n    /** @private {boolean} */\n    this.androidReceiverCompatible_ = androidReceiverCompatible;\n\n    /** @private {!Map} */\n    this.compiledToExternNames_ = new Map();\n\n    /** @private {shaka.cast.CastSender} */\n    this.sender_ = new shaka.cast.CastSender(\n        receiverAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_(),\n        androidReceiverCompatible);\n\n\n    this.init_();\n  }\n\n  /**\n   * Destroys the proxy and the underlying local Player.\n   *\n   * @param {boolean=} forceDisconnect If true, force the receiver app to shut\n   *   down by disconnecting.  Does nothing if not connected.\n   * @override\n   * @export\n   */\n  destroy(forceDisconnect) {\n    if (forceDisconnect) {\n      this.sender_.forceDisconnect();\n    }\n\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    const waitFor = [];\n    if (this.localPlayer_) {\n      waitFor.push(this.localPlayer_.destroy());\n      this.localPlayer_ = null;\n    }\n\n    if (this.sender_) {\n      waitFor.push(this.sender_.destroy());\n      this.sender_ = null;\n    }\n\n    this.localVideo_ = null;\n    this.videoProxy_ = null;\n    this.playerProxy_ = null;\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n\n    return Promise.all(waitFor);\n  }\n\n  /**\n   * Get a proxy for the video element that delegates to local and remote video\n   * elements as appropriate.\n   *\n   * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n   * @return {!HTMLMediaElement}\n   * @export\n   */\n  getVideo() {\n    return /** @type {!HTMLMediaElement} */(this.videoProxy_);\n  }\n\n  /**\n   * Get a proxy for the Player that delegates to local and remote Player\n   * objects as appropriate.\n   *\n   * @suppress {invalidCasts} to cast proxy Objects to unrelated types\n   * @return {!shaka.Player}\n   * @export\n   */\n  getPlayer() {\n    return /** @type {!shaka.Player} */(this.playerProxy_);\n  }\n\n  /**\n   * @return {boolean} True if the cast API is available and there are\n   *   receivers.\n   * @export\n   */\n  canCast() {\n    return this.sender_.apiReady() && this.sender_.hasReceivers();\n  }\n\n  /**\n   * @return {boolean} True if we are currently casting.\n   * @export\n   */\n  isCasting() {\n    return this.sender_.isCasting();\n  }\n\n  /**\n   * @return {string} The name of the Cast receiver device, if isCasting().\n   * @export\n   */\n  receiverName() {\n    return this.sender_.receiverName();\n  }\n\n  /**\n   * @return {!Promise} Resolved when connected to a receiver.  Rejected if the\n   *   connection fails or is canceled by the user.\n   * @export\n   */\n  async cast() {\n    const initState = this.getInitState_();\n\n    // TODO: transfer manually-selected tracks?\n    // TODO: transfer side-loaded text tracks?\n\n    await this.sender_.cast(initState);\n    if (!this.localPlayer_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Unload the local manifest when casting succeeds.\n    await this.localPlayer_.unload();\n  }\n\n  /**\n   * Set application-specific data.\n   *\n   * @param {Object} appData Application-specific data to relay to the receiver.\n   * @export\n   */\n  setAppData(appData) {\n    this.sender_.setAppData(appData);\n  }\n\n  /**\n   * Show a dialog where user can choose to disconnect from the cast connection.\n   * @export\n   */\n  suggestDisconnect() {\n    this.sender_.showDisconnectDialog();\n  }\n\n  /**\n   * Force the receiver app to shut down by disconnecting.\n   * @export\n   */\n  forceDisconnect() {\n    this.sender_.forceDisconnect();\n  }\n\n\n  /**\n   * @param {string} newAppId\n   * @param {boolean=} newCastAndroidReceiver\n   * @export\n   */\n  async changeReceiverId(newAppId, newCastAndroidReceiver = false) {\n    if (newAppId == this.receiverAppId_ &&\n        newCastAndroidReceiver == this.androidReceiverCompatible_) {\n      // Nothing to change\n      return;\n    }\n\n    this.receiverAppId_ = newAppId;\n    this.androidReceiverCompatible_ = newCastAndroidReceiver;\n\n    // Destroy the old sender\n    this.sender_.forceDisconnect();\n    await this.sender_.destroy();\n    this.sender_ = null;\n\n\n    // Create the new one\n    this.sender_ = new shaka.cast.CastSender(\n        newAppId,\n        () => this.onCastStatusChanged_(),\n        () => this.onFirstCastStateUpdate_(),\n        (targetName, event) => this.onRemoteEvent_(targetName, event),\n        () => this.onResumeLocal_(),\n        () => this.getInitState_(),\n        newCastAndroidReceiver);\n\n    this.sender_.init();\n  }\n\n  /**\n   * Initialize the Proxies and the Cast sender.\n   * @private\n   */\n  init_() {\n    this.sender_.init();\n\n    this.eventManager_ = new shaka.util.EventManager();\n\n    for (const name of shaka.cast.CastUtils.VideoEvents) {\n      this.eventManager_.listen(this.localVideo_, name,\n          (event) => this.videoProxyLocalEvent_(event));\n    }\n\n    for (const key in shaka.util.FakeEvent.EventName) {\n      const name = shaka.util.FakeEvent.EventName[key];\n      this.eventManager_.listen(this.localPlayer_, name,\n          (event) => this.playerProxyLocalEvent_(event));\n    }\n\n    // We would like to use Proxy here, but it is not supported on Safari.\n    this.videoProxy_ = {};\n    for (const k in this.localVideo_) {\n      Object.defineProperty(this.videoProxy_, k, {\n        configurable: false,\n        enumerable: true,\n        get: () => this.videoProxyGet_(k),\n        set: (value) => { this.videoProxySet_(k, value); },\n      });\n    }\n\n    this.playerProxy_ = {};\n    this.iterateOverPlayerMethods_((name, method) => {\n      goog.asserts.assert(this.playerProxy_, 'Must have player proxy!');\n      Object.defineProperty(this.playerProxy_, name, {\n        configurable: false,\n        enumerable: true,\n        get: () => this.playerProxyGet_(name),\n      });\n    });\n\n    if (COMPILED) {\n      this.mapCompiledToUncompiledPlayerMethodNames_();\n    }\n\n    this.videoEventTarget_ = new shaka.util.FakeEventTarget();\n    this.videoEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.videoProxy_);\n\n    this.playerEventTarget_ = new shaka.util.FakeEventTarget();\n    this.playerEventTarget_.dispatchTarget =\n      /** @type {EventTarget} */(this.playerProxy_);\n  }\n\n\n  /**\n   * Maps compiled to uncompiled player names so we can figure out\n   * which method to call in compiled build, while casting.\n   * @private\n   */\n  mapCompiledToUncompiledPlayerMethodNames_() {\n    // In compiled mode, UI tries to access player methods by their internal\n    // renamed names, but the proxy object doesn't know about those.  See\n    // https://github.com/shaka-project/shaka-player/issues/2130 for details.\n    const methodsToNames = new Map();\n    this.iterateOverPlayerMethods_((name, method) => {\n      if (methodsToNames.has(method)) {\n        // If two method names, point to the same method, add them to the\n        // map as aliases of each other.\n        const name2 = methodsToNames.get(method);\n        // Assumes that the compiled name is shorter\n        if (name.length < name2.length) {\n          this.compiledToExternNames_.set(name, name2);\n        } else {\n          this.compiledToExternNames_.set(name2, name);\n        }\n      } else {\n        methodsToNames.set(method, name);\n      }\n    });\n  }\n\n  /**\n   * Iterates over all of the methods of the player, including inherited methods\n   * from FakeEventTarget.\n   * @param {function(string, function())} operation\n   * @private\n   */\n  iterateOverPlayerMethods_(operation) {\n    goog.asserts.assert(this.localPlayer_, 'Must have player!');\n    const player = /** @type {!Object} */ (this.localPlayer_);\n    // Avoid accessing any over-written methods in the prototype chain.\n    const seenNames = new Set();\n\n    /**\n     * @param {string} name\n     * @return {boolean}\n     */\n    function shouldAddToTheMap(name) {\n      if (name == 'constructor') {\n        // Don't proxy the constructor.\n        return false;\n      }\n\n      const method = /** @type {Object} */(player)[name];\n      if (typeof method != 'function') {\n        // Don't proxy non-methods.\n        return false;\n      }\n\n      // Add if the map does not already have it\n      return !seenNames.has(name);\n    }\n\n    // First, look at the methods on the object itself, so this can properly\n    // proxy any methods not on the prototype (for example, in the mock player).\n    for (const key in player) {\n      if (shouldAddToTheMap(key)) {\n        seenNames.add(key);\n        operation(key, player[key]);\n      }\n    }\n\n    // The exact length of the prototype chain might vary; for resiliency, this\n    // will just look at the entire chain, rather than assuming a set length.\n    let proto = /** @type {!Object} */ (Object.getPrototypeOf(player));\n    const objProto = /** @type {!Object} */ (Object.getPrototypeOf({}));\n    while (proto && proto != objProto) { // Don't proxy Object methods.\n      for (const name of Object.getOwnPropertyNames(proto)) {\n        if (shouldAddToTheMap(name)) {\n          seenNames.add(name);\n          operation(name, (player)[name]);\n        }\n      }\n      proto = /** @type {!Object} */ (Object.getPrototypeOf(proto));\n    }\n  }\n\n  /**\n   * @return {shaka.cast.CastUtils.InitStateType} initState Video and player\n   *   state to be sent to the receiver.\n   * @private\n   */\n  getInitState_() {\n    const initState = {\n      'video': {},\n      'player': {},\n      'playerAfterLoad': {},\n      'manifest': this.localPlayer_.getAssetUri(),\n      'startTime': null,\n    };\n\n    // Pause local playback before capturing state.\n    this.localVideo_.pause();\n\n    for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n      initState['video'][name] = this.localVideo_[name];\n    }\n\n    // If the video is still playing, set the startTime.\n    // Has no effect if nothing is loaded.\n    if (!this.localVideo_.ended) {\n      initState['startTime'] = this.localVideo_.currentTime;\n    }\n\n    for (const pair of shaka.cast.CastUtils.PlayerInitState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n      initState['player'][setter] = value;\n    }\n\n    for (const pair of shaka.cast.CastUtils.PlayerInitAfterLoadState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = /** @type {Object} */(this.localPlayer_)[getter]();\n\n      initState['playerAfterLoad'][setter] = value;\n    }\n\n    return initState;\n  }\n\n  /**\n   * Dispatch an event to notify the app that the status has changed.\n   * @private\n   */\n  onCastStatusChanged_() {\n    const event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * Dispatch a synthetic play or pause event to ensure that the app correctly\n   * knows that the player is playing, if joining an existing receiver.\n   * @private\n   */\n  onFirstCastStateUpdate_() {\n    const type = this.videoProxy_['paused'] ? 'pause' : 'play';\n    const fakeEvent = new shaka.util.FakeEvent(type);\n    this.videoEventTarget_.dispatchEvent(fakeEvent);\n  }\n\n  /**\n   * Transfer remote state back and resume local playback.\n   * @private\n   */\n  onResumeLocal_() {\n    // Transfer back the player state.\n    for (const pair of shaka.cast.CastUtils.PlayerInitState) {\n      const getter = pair[0];\n      const setter = pair[1];\n      const value = this.sender_.get('player', getter)();\n      /** @type {Object} */(this.localPlayer_)[setter](value);\n    }\n\n    // Get the most recent manifest URI and ended state.\n    const assetUri = this.sender_.get('player', 'getAssetUri')();\n    const ended = this.sender_.get('video', 'ended');\n\n    let manifestReady = Promise.resolve();\n    const autoplay = this.localVideo_.autoplay;\n\n    let startTime = null;\n\n    // If the video is still playing, set the startTime.\n    // Has no effect if nothing is loaded.\n    if (!ended) {\n      startTime = this.sender_.get('video', 'currentTime');\n    }\n\n    // Now load the manifest, if present.\n    if (assetUri) {\n      // Don't autoplay the content until we finish setting up initial state.\n      this.localVideo_.autoplay = false;\n      manifestReady = this.localPlayer_.load(assetUri, startTime);\n    }\n\n    // Get the video state into a temp variable since we will apply it async.\n    const videoState = {};\n    for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n      videoState[name] = this.sender_.get('video', name);\n    }\n\n    // Finally, take on video state and player's \"after load\" state.\n    manifestReady.then(() => {\n      if (!this.localVideo_) {\n        // We've already been destroyed.\n        return;\n      }\n\n      for (const name of shaka.cast.CastUtils.VideoInitStateAttributes) {\n        this.localVideo_[name] = videoState[name];\n      }\n\n      for (const pair of shaka.cast.CastUtils.PlayerInitAfterLoadState) {\n        const getter = pair[0];\n        const setter = pair[1];\n        const value = this.sender_.get('player', getter)();\n        /** @type {Object} */(this.localPlayer_)[setter](value);\n      }\n\n      // Restore the original autoplay setting.\n      this.localVideo_.autoplay = autoplay;\n      if (assetUri) {\n        // Resume playback with transferred state.\n        this.localVideo_.play();\n      }\n    }, (error) => {\n      // Pass any errors through to the app.\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Wrong error type!');\n      const eventType = shaka.util.FakeEvent.EventName.Error;\n      const data = (new Map()).set('detail', error);\n      const event = new shaka.util.FakeEvent(eventType, data);\n      this.localPlayer_.dispatchEvent(event);\n    });\n  }\n\n  /**\n   * @param {string} name\n   * @return {?}\n   * @private\n   */\n  videoProxyGet_(name) {\n    if (name == 'addEventListener') {\n      return (type, listener, options) => {\n        return this.videoEventTarget_.addEventListener(type, listener, options);\n      };\n    }\n    if (name == 'removeEventListener') {\n      return (type, listener, options) => {\n        return this.videoEventTarget_.removeEventListener(\n            type, listener, options);\n      };\n    }\n\n    // If we are casting, but the first update has not come in yet, use local\n    // values, but not local methods.\n    if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n      const value = this.localVideo_[name];\n      if (typeof value != 'function') {\n        return value;\n      }\n    }\n\n    // Use local values and methods if we are not casting.\n    if (!this.sender_.isCasting()) {\n      let value = this.localVideo_[name];\n      if (typeof value == 'function') {\n        // eslint-disable-next-line no-restricted-syntax\n        value = value.bind(this.localVideo_);\n      }\n      return value;\n    }\n\n    return this.sender_.get('video', name);\n  }\n\n  /**\n   * @param {string} name\n   * @param {?} value\n   * @private\n   */\n  videoProxySet_(name, value) {\n    if (!this.sender_.isCasting()) {\n      this.localVideo_[name] = value;\n      return;\n    }\n\n    this.sender_.set('video', name, value);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  videoProxyLocalEvent_(event) {\n    if (this.sender_.isCasting()) {\n      // Ignore any unexpected local events while casting.  Events can still be\n      // fired by the local video and Player when we unload() after the Cast\n      // connection is complete.\n      return;\n    }\n\n    // Convert this real Event into a FakeEvent for dispatch from our\n    // FakeEventListener.\n    const fakeEvent = shaka.util.FakeEvent.fromRealEvent(event);\n    this.videoEventTarget_.dispatchEvent(fakeEvent);\n  }\n\n  /**\n   * @param {string} name\n   * @return {?}\n   * @private\n   */\n  playerProxyGet_(name) {\n    // If name is a shortened compiled name, get the original version\n    // from our map.\n    if (this.compiledToExternNames_.has(name)) {\n      name = this.compiledToExternNames_.get(name);\n    }\n\n    if (name == 'addEventListener') {\n      return (type, listener, options) => {\n        return this.playerEventTarget_.addEventListener(\n            type, listener, options);\n      };\n    }\n    if (name == 'removeEventListener') {\n      return (type, listener, options) => {\n        return this.playerEventTarget_.removeEventListener(\n            type, listener, options);\n      };\n    }\n\n    if (name == 'getMediaElement') {\n      return () => this.videoProxy_;\n    }\n\n    if (name == 'getSharedConfiguration') {\n      shaka.log.warning(\n          'Can\\'t share configuration across a network. Returning copy.');\n      return this.sender_.get('player', 'getConfiguration');\n    }\n\n    if (name == 'getNetworkingEngine') {\n      // Always returns a local instance, in case you need to make a request.\n      // Issues a warning, in case you think you are making a remote request\n      // or affecting remote filters.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getNetworkingEngine() is always local!');\n      }\n      return () => this.localPlayer_.getNetworkingEngine();\n    }\n\n    if (name == 'getDrmEngine') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getDrmEngine() is always local!');\n      }\n      return () => this.localPlayer_.getDrmEngine();\n    }\n\n    if (name == 'getAdManager') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: getAdManager() is always local!');\n      }\n      return () => this.localPlayer_.getAdManager();\n    }\n\n    if (name == 'setVideoContainer') {\n      // Always returns a local instance.\n      if (this.sender_.isCasting()) {\n        shaka.log.warning('NOTE: setVideoContainer() is always local!');\n      }\n      return (container) => this.localPlayer_.setVideoContainer(container);\n    }\n\n    if (this.sender_.isCasting()) {\n      // These methods are unavailable or otherwise stubbed during casting.\n      if (name == 'getManifest' || name == 'drmInfo') {\n        return () => {\n          shaka.log.alwaysWarn(name + '() does not work while casting!');\n          return null;\n        };\n      }\n\n      if (name == 'attach' || name == 'detach') {\n        return () => {\n          shaka.log.alwaysWarn(name + '() does not work while casting!');\n          return Promise.resolve();\n        };\n      }\n    }  // if (this.sender_.isCasting())\n\n    // If we are casting, but the first update has not come in yet, use local\n    // getters, but not local methods.\n    if (this.sender_.isCasting() && !this.sender_.hasRemoteProperties()) {\n      if (shaka.cast.CastUtils.PlayerGetterMethods[name] ||\n          shaka.cast.CastUtils.LargePlayerGetterMethods[name]) {\n        const value = /** @type {Object} */(this.localPlayer_)[name];\n        goog.asserts.assert(typeof value == 'function',\n            'only methods on Player');\n        // eslint-disable-next-line no-restricted-syntax\n        return value.bind(this.localPlayer_);\n      }\n    }\n\n    // Use local getters and methods if we are not casting.\n    if (!this.sender_.isCasting()) {\n      const value = /** @type {Object} */(this.localPlayer_)[name];\n      goog.asserts.assert(typeof value == 'function',\n          'only methods on Player');\n      // eslint-disable-next-line no-restricted-syntax\n      return value.bind(this.localPlayer_);\n    }\n\n    return this.sender_.get('player', name);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  playerProxyLocalEvent_(event) {\n    if (this.sender_.isCasting()) {\n      // Ignore any unexpected local events while casting.\n      return;\n    }\n\n    this.playerEventTarget_.dispatchEvent(event);\n  }\n\n  /**\n   * @param {string} targetName\n   * @param {!shaka.util.FakeEvent} event\n   * @private\n   */\n  onRemoteEvent_(targetName, event) {\n    goog.asserts.assert(this.sender_.isCasting(),\n        'Should only receive remote events while casting');\n    if (!this.sender_.isCasting()) {\n      // Ignore any unexpected remote events.\n      return;\n    }\n\n    if (targetName == 'video') {\n      this.videoEventTarget_.dispatchEvent(event);\n    } else if (targetName == 'player') {\n      this.playerEventTarget_.dispatchEvent(event);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.cast.CastReceiver');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.cast.CastUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A receiver to communicate between the Chromecast-hosted player and the\n * sender application.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.cast.CastReceiver = class extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} video The local video element associated with\n   *   the local Player instance.\n   * @param {!shaka.Player} player A local Player instance.\n   * @param {function(Object)=} appDataCallback A callback to handle\n   *   application-specific data passed from the sender.  This can come either\n   *   from a Shaka-based sender through CastProxy.setAppData, or from a\n   *   sender using the customData field of the LOAD message of the standard\n   *   Cast message namespace.  It can also be null if no such data is sent.\n   * @param {function(string):string=} contentIdCallback A callback to\n   *   retrieve manifest URI from the provided content id.\n   */\n  constructor(video, player, appDataCallback, contentIdCallback) {\n    super();\n\n    /** @private {HTMLMediaElement} */\n    this.video_ = video;\n\n    /** @private {shaka.Player} */\n    this.player_ = player;\n\n    /** @private {shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @private {Object} */\n    this.targets_ = {\n      'video': video,\n      'player': player,\n    };\n\n    /** @private {?function(Object)} */\n    this.appDataCallback_ = appDataCallback || (() => {});\n\n    /** @private {?function(string):string} */\n    this.contentIdCallback_ = contentIdCallback ||\n                          /** @param {string} contentId\n                              @return {string} */\n                          ((contentId) => contentId);\n\n    /**\n     * A Cast metadata object, one of:\n     *  - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata\n     *  - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata\n     * @private {Object}\n     */\n    this.metadata_ = null;\n\n    /** @private {boolean} */\n    this.isConnected_ = false;\n\n    /** @private {boolean} */\n    this.isIdle_ = true;\n\n    /** @private {number} */\n    this.updateNumber_ = 0;\n\n    /** @private {boolean} */\n    this.startUpdatingUpdateNumber_ = false;\n\n    /** @private {boolean} */\n    this.initialStatusUpdatePending_ = true;\n\n    /** @private {cast.receiver.CastMessageBus} */\n    this.shakaBus_ = null;\n\n    /** @private {cast.receiver.CastMessageBus} */\n    this.genericBus_ = null;\n\n    /** @private {shaka.util.Timer} */\n    this.pollTimer_ = new shaka.util.Timer(() => {\n      this.pollAttributes_();\n    });\n\n    this.init_();\n  }\n\n  /**\n   * @return {boolean} True if the cast API is available and there are\n   *   receivers.\n   * @export\n   */\n  isConnected() {\n    return this.isConnected_;\n  }\n\n  /**\n   * @return {boolean} True if the receiver is not currently doing loading or\n   *   playing anything.\n   * @export\n   */\n  isIdle() {\n    return this.isIdle_;\n  }\n\n  /**\n   * Set all Cast content metadata, as defined by the Cast SDK.\n   * Should be called from an appDataCallback.\n   *\n   * For a simpler way to set basic metadata, see:\n   *  - setContentTitle()\n   *  - setContentImage()\n   *  - setContentArtist()\n   *\n   * @param {Object} metadata\n   *   A Cast metadata object, one of:\n   *    - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata\n   *    - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata\n   * @export\n   */\n  setContentMetadata(metadata) {\n    this.metadata_ = metadata;\n  }\n\n  /**\n   * Clear all Cast content metadata.\n   * Should be called from an appDataCallback.\n   *\n   * @export\n   */\n  clearContentMetadata() {\n    this.metadata_ = null;\n  }\n\n  /**\n   * Set the Cast content's title.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} title\n   * @export\n   */\n  setContentTitle(title) {\n    if (!this.metadata_) {\n      this.metadata_ = {\n        'metadataType': cast.receiver.media.MetadataType.GENERIC,\n      };\n    }\n    this.metadata_['title'] = title;\n  }\n\n  /**\n   * Set the Cast content's thumbnail image.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} imageUrl\n   * @export\n   */\n  setContentImage(imageUrl) {\n    if (!this.metadata_) {\n      this.metadata_ = {\n        'metadataType': cast.receiver.media.MetadataType.GENERIC,\n      };\n    }\n    this.metadata_['images'] = [\n      {\n        'url': imageUrl,\n      },\n    ];\n  }\n\n  /**\n   * Set the Cast content's artist.\n   * Also sets the metadata type to music.\n   * Should be called from an appDataCallback.\n   *\n   * @param {string} artist\n   * @export\n   */\n  setContentArtist(artist) {\n    if (!this.metadata_) {\n      this.metadata_ = {};\n    }\n    this.metadata_['artist'] = artist;\n    this.metadata_['metadataType'] =\n        cast.receiver.media.MetadataType.MUSIC_TRACK;\n  }\n\n  /**\n   * Destroys the underlying Player, then terminates the cast receiver app.\n   *\n   * @override\n   * @export\n   */\n  async destroy() {\n    if (this.eventManager_) {\n      this.eventManager_.release();\n      this.eventManager_ = null;\n    }\n\n    const waitFor = [];\n    if (this.player_) {\n      waitFor.push(this.player_.destroy());\n      this.player_ = null;\n    }\n\n    if (this.pollTimer_) {\n      this.pollTimer_.stop();\n      this.pollTimer_ = null;\n    }\n\n    this.video_ = null;\n    this.targets_ = null;\n    this.appDataCallback_ = null;\n    this.isConnected_ = false;\n    this.isIdle_ = true;\n    this.shakaBus_ = null;\n    this.genericBus_ = null;\n\n    // FakeEventTarget implements IReleasable\n    super.release();\n\n    await Promise.all(waitFor);\n\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.stop();\n  }\n\n  /** @private */\n  init_() {\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    manager.onSenderConnected = () => this.onSendersChanged_();\n    manager.onSenderDisconnected = () => this.onSendersChanged_();\n    manager.onSystemVolumeChanged = () => this.fakeVolumeChangeEvent_();\n\n    this.genericBus_ = manager.getCastMessageBus(\n        shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE);\n    this.genericBus_.onMessage = (event) => this.onGenericMessage_(event);\n\n    this.shakaBus_ = manager.getCastMessageBus(\n        shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE);\n    this.shakaBus_.onMessage = (event) => this.onShakaMessage_(event);\n\n    if (goog.DEBUG) {\n      // Sometimes it is useful to load the receiver app in Chrome to work on\n      // the UI.  To avoid log spam caused by the SDK trying to connect to web\n      // sockets that don't exist, in uncompiled mode we check if the hosting\n      // browser is a Chromecast before starting the receiver manager.  We\n      // wouldn't do browser detection except for debugging, so only do this in\n      // uncompiled mode.\n      if (shaka.util.Platform.isChromecast()) {\n        manager.start();\n      }\n    } else {\n      manager.start();\n    }\n\n    for (const name of shaka.cast.CastUtils.VideoEvents) {\n      this.eventManager_.listen(\n          this.video_, name, (event) => this.proxyEvent_('video', event));\n    }\n\n    for (const key in shaka.util.FakeEvent.EventName) {\n      const name = shaka.util.FakeEvent.EventName[key];\n      this.eventManager_.listen(\n          this.player_, name, (event) => this.proxyEvent_('player', event));\n    }\n\n    // In our tests, the original Chromecast seems to have trouble decoding\n    // above 1080p.  It would be a waste to select a higher res anyway, given\n    // that the device only outputs 1080p to begin with.\n\n    // Chromecast has an extension to query the device/display's resolution.\n    if (cast.__platform__ && cast.__platform__.canDisplayType(\n        'video/mp4; codecs=\"avc1.640028\"; width=3840; height=2160')) {\n      // The device and display can both do 4k.  Assume a 4k limit.\n      this.player_.setMaxHardwareResolution(3840, 2160);\n    } else {\n      // Chromecast has always been able to do 1080p.  Assume a 1080p limit.\n      this.player_.setMaxHardwareResolution(1920, 1080);\n    }\n\n    // Do not start excluding values from update messages until the video is\n    // fully loaded.\n    this.eventManager_.listen(this.video_, 'loadeddata', () => {\n      this.startUpdatingUpdateNumber_ = true;\n    });\n\n    // Maintain idle state.\n    this.eventManager_.listen(this.player_, 'loading', () => {\n      // No longer idle once loading.  This allows us to show the spinner during\n      // the initial buffering phase.\n      this.isIdle_ = false;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'playing', () => {\n      // No longer idle once playing.  This allows us to replay a video without\n      // reloading.\n      this.isIdle_ = false;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'pause', () => {\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.player_, 'unloading', () => {\n      // Go idle when unloading content.\n      this.isIdle_ = true;\n      this.onCastStatusChanged_();\n    });\n    this.eventManager_.listen(this.video_, 'ended', () => {\n      // Go idle 5 seconds after 'ended', assuming we haven't started again or\n      // been destroyed.\n      const timer = new shaka.util.Timer(() => {\n        if (this.video_ && this.video_.ended) {\n          this.isIdle_ = true;\n          this.onCastStatusChanged_();\n        }\n      });\n\n      timer.tickAfter(shaka.cast.CastReceiver.IDLE_INTERVAL);\n    });\n\n    // Do not start polling until after the sender's 'init' message is handled.\n  }\n\n  /** @private */\n  onSendersChanged_() {\n    // Reset update message frequency values, to make sure whomever joined\n    // will get a full update message.\n    this.updateNumber_ = 0;\n    // Don't reset startUpdatingUpdateNumber_, because this operation does not\n    // result in new data being loaded.\n    this.initialStatusUpdatePending_ = true;\n\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    this.isConnected_ = manager.getSenders().length != 0;\n    this.onCastStatusChanged_();\n  }\n\n  /**\n   * Dispatch an event to notify the receiver app that the status has changed.\n   * @private\n   */\n  async onCastStatusChanged_() {\n    // Do this asynchronously so that synchronous changes to idle state (such as\n    // Player calling unload() as part of load()) are coalesced before the event\n    // goes out.\n    await Promise.resolve();\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    const event = new shaka.util.FakeEvent('caststatuschanged');\n    this.dispatchEvent(event);\n    // Send a media status message, with a media info message if appropriate.\n    if (!this.maybeSendMediaInfoMessage_()) {\n      this.sendMediaStatus_();\n    }\n  }\n\n  /**\n   * Take on initial state from the sender.\n   * @param {shaka.cast.CastUtils.InitStateType} initState\n   * @param {Object} appData\n   * @private\n   */\n  async initState_(initState, appData) {\n    // Take on player state first.\n    for (const k in initState['player']) {\n      const v = initState['player'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Now process custom app data, which may add additional player configs:\n    this.appDataCallback_(appData);\n\n    const autoplay = this.video_.autoplay;\n\n    // Now load the manifest, if present.\n    if (initState['manifest']) {\n      // Don't autoplay the content until we finish setting up initial state.\n      this.video_.autoplay = false;\n      try {\n        await this.player_.load(initState['manifest'], initState['startTime']);\n      } catch (error) {\n        // Pass any errors through to the app.\n        goog.asserts.assert(error instanceof shaka.util.Error,\n            'Wrong error type!');\n        const eventType = shaka.util.FakeEvent.EventName.Error;\n        const data = (new Map()).set('detail', error);\n        const event = new shaka.util.FakeEvent(eventType, data);\n        // Only dispatch the event if the player still exists.\n        if (this.player_) {\n          this.player_.dispatchEvent(event);\n        }\n        return;\n      }\n    } else {\n      // Ensure the below happens async.\n      await Promise.resolve();\n    }\n\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    // Finally, take on video state and player's \"after load\" state.\n    for (const k in initState['video']) {\n      const v = initState['video'][k];\n      this.video_[k] = v;\n    }\n\n    for (const k in initState['playerAfterLoad']) {\n      const v = initState['playerAfterLoad'][k];\n      // All player state vars are setters to be called.\n      /** @type {Object} */(this.player_)[k](v);\n    }\n\n    // Restore original autoplay setting.\n    this.video_.autoplay = autoplay;\n    if (initState['manifest']) {\n      // Resume playback with transferred state.\n      this.video_.play();\n      // Notify generic controllers of the state change.\n      this.sendMediaStatus_();\n    }\n  }\n\n  /**\n   * @param {string} targetName\n   * @param {!Event} event\n   * @private\n   */\n  proxyEvent_(targetName, event) {\n    if (!this.player_) {\n      // The receiver is destroyed, so it should ignore further events.\n      return;\n    }\n\n    // Poll and send an update right before we send the event.  Some events\n    // indicate an attribute change, so that change should be visible when the\n    // event is handled.\n    this.pollAttributes_();\n\n    this.sendMessage_({\n      'type': 'event',\n      'targetName': targetName,\n      'event': event,\n    }, this.shakaBus_);\n  }\n\n  /** @private */\n  pollAttributes_() {\n    // The poll timer may have been pre-empted by an event (e.g. timeupdate).\n    // Calling |start| will cancel any pending calls and therefore will avoid us\n    // polling too often.\n    this.pollTimer_.tickAfter(shaka.cast.CastReceiver.POLL_INTERVAL);\n\n    const update = {\n      'video': {},\n      'player': {},\n    };\n\n    for (const name of shaka.cast.CastUtils.VideoAttributes) {\n      update['video'][name] = this.video_[name];\n    }\n\n    // TODO: Instead of this variable frequency update system, instead cache the\n    // previous player state and only send over changed values, with complete\n    // updates every ~20 updates to account for dropped messages.\n\n    if (this.player_.isLive()) {\n      const PlayerGetterMethodsThatRequireLive =\n          shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive;\n      for (const name in PlayerGetterMethodsThatRequireLive) {\n        const frequency = PlayerGetterMethodsThatRequireLive[name];\n        if (this.updateNumber_ % frequency == 0) {\n          update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n        }\n      }\n    }\n    for (const name in shaka.cast.CastUtils.PlayerGetterMethods) {\n      const frequency = shaka.cast.CastUtils.PlayerGetterMethods[name];\n      if (this.updateNumber_ % frequency == 0) {\n        update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n      }\n    }\n\n    // Volume attributes are tied to the system volume.\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    const systemVolume = manager.getSystemVolume();\n    if (systemVolume) {\n      update['video']['volume'] = systemVolume.level;\n      update['video']['muted'] = systemVolume.muted;\n    }\n\n    this.sendMessage_({\n      'type': 'update',\n      'update': update,\n    }, this.shakaBus_);\n\n    // Getters with large outputs each get sent in their own update message.\n    for (const name in shaka.cast.CastUtils.LargePlayerGetterMethods) {\n      const frequency = shaka.cast.CastUtils.LargePlayerGetterMethods[name];\n      if (this.updateNumber_ % frequency == 0) {\n        const update = {'player': {}};\n        update['player'][name] = /** @type {Object} */ (this.player_)[name]();\n\n        this.sendMessage_({\n          'type': 'update',\n          'update': update,\n        }, this.shakaBus_);\n      }\n    }\n\n    // Only start progressing the update number once data is loaded,\n    // just in case any of the \"rarely changing\" properties with less frequent\n    // update messages changes significantly during the loading process.\n    if (this.startUpdatingUpdateNumber_) {\n      this.updateNumber_ += 1;\n    }\n\n    this.maybeSendMediaInfoMessage_();\n  }\n\n  /**\n   * Composes and sends a mediaStatus message if appropriate.\n   * @return {boolean}\n   * @private\n   */\n  maybeSendMediaInfoMessage_() {\n    if (this.initialStatusUpdatePending_ &&\n        (this.video_.duration || this.player_.isLive())) {\n      // Send over a media status message to set the duration of the cast\n      // dialogue.\n      this.sendMediaInfoMessage_();\n      this.initialStatusUpdatePending_ = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Composes and sends a mediaStatus message with a mediaInfo component.\n   *\n   * @param {number=} requestId\n   * @private\n   */\n  sendMediaInfoMessage_(requestId = 0) {\n    const media = {\n      'contentId': this.player_.getAssetUri(),\n      'streamType': this.player_.isLive() ? 'LIVE' : 'BUFFERED',\n      // Sending an empty string for now since it's a mandatory field.\n      // We don't have this info, and it doesn't seem to be useful, anyway.\n      'contentType': '',\n    };\n    if (!this.player_.isLive()) {\n      // Optional, and only sent when the duration is known.\n      media['duration'] = this.video_.duration;\n    }\n    if (this.metadata_) {\n      media['metadata'] = this.metadata_;\n    }\n    this.sendMediaStatus_(requestId, media);\n  }\n\n  /**\n   * Dispatch a fake 'volumechange' event to mimic the video element, since\n   * volume changes are routed to the system volume on the receiver.\n   * @private\n   */\n  fakeVolumeChangeEvent_() {\n    // Volume attributes are tied to the system volume.\n    const manager = cast.receiver.CastReceiverManager.getInstance();\n    const systemVolume = manager.getSystemVolume();\n    goog.asserts.assert(systemVolume, 'System volume should not be null!');\n\n    if (systemVolume) {\n      // Send an update message with just the latest volume level and muted\n      // state.\n      this.sendMessage_({\n        'type': 'update',\n        'update': {\n          'video': {\n            'volume': systemVolume.level,\n            'muted': systemVolume.muted,\n          },\n        },\n      }, this.shakaBus_);\n    }\n\n    // Send another message with a 'volumechange' event to update the sender's\n    // UI.\n    this.sendMessage_({\n      'type': 'event',\n      'targetName': 'video',\n      'event': {'type': 'volumechange'},\n    }, this.shakaBus_);\n  }\n\n  /**\n   * Since this method is in the compiled library, make sure all messages are\n   * read with quoted properties.\n   * @param {!cast.receiver.CastMessageBus.Event} event\n   * @private\n   */\n  onShakaMessage_(event) {\n    const message = shaka.cast.CastUtils.deserialize(event.data);\n    shaka.log.debug('CastReceiver: message', message);\n\n    switch (message['type']) {\n      case 'init':\n        // Reset update message frequency values after initialization.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n        this.initialStatusUpdatePending_ = true;\n\n        this.initState_(message['initState'], message['appData']);\n        // The sender is supposed to reflect the cast system volume after\n        // connecting.  Using fakeVolumeChangeEvent_() would create a race on\n        // the sender side, since it would have volume properties, but no\n        // others.\n        // This would lead to hasRemoteProperties() being true, even though a\n        // complete set had never been sent.\n        // Now that we have init state, this is a good time for the first update\n        // message anyway.\n        this.pollAttributes_();\n        break;\n      case 'appData':\n        this.appDataCallback_(message['appData']);\n        break;\n      case 'set': {\n        const targetName = message['targetName'];\n        const property = message['property'];\n        const value = message['value'];\n\n        if (targetName == 'video') {\n          // Volume attributes must be rerouted to the system.\n          const manager = cast.receiver.CastReceiverManager.getInstance();\n          if (property == 'volume') {\n            manager.setSystemVolumeLevel(value);\n            break;\n          } else if (property == 'muted') {\n            manager.setSystemVolumeMuted(value);\n            break;\n          }\n        }\n\n        this.targets_[targetName][property] = value;\n        break;\n      }\n      case 'call': {\n        const targetName = message['targetName'];\n        const methodName = message['methodName'];\n        const args = message['args'];\n        const target = this.targets_[targetName];\n        // eslint-disable-next-line prefer-spread\n        target[methodName].apply(target, args);\n        break;\n      }\n      case 'asyncCall': {\n        const targetName = message['targetName'];\n        const methodName = message['methodName'];\n        if (targetName == 'player' && methodName == 'load') {\n          // Reset update message frequency values after a load.\n          this.updateNumber_ = 0;\n          this.startUpdatingUpdateNumber_ = false;\n        }\n        const args = message['args'];\n        const id = message['id'];\n        const senderId = event.senderId;\n        const target = this.targets_[targetName];\n        // eslint-disable-next-line prefer-spread\n        let p = target[methodName].apply(target, args);\n        if (targetName == 'player' && methodName == 'load') {\n          // Wait until the manifest has actually loaded to send another media\n          // info message, so on a new load it doesn't send the old info over.\n          p = p.then(() => {\n            this.initialStatusUpdatePending_ = true;\n          });\n        }\n        // Replies must go back to the specific sender who initiated, so that we\n        // don't have to deal with conflicting IDs between senders.\n        p.then(\n            () => this.sendAsyncComplete_(senderId, id, /* error= */ null),\n            (error) => this.sendAsyncComplete_(senderId, id, error));\n        break;\n      }\n    }\n  }\n\n  /**\n   * @param {!cast.receiver.CastMessageBus.Event} event\n   * @private\n   */\n  onGenericMessage_(event) {\n    const message = shaka.cast.CastUtils.deserialize(event.data);\n    shaka.log.debug('CastReceiver: message', message);\n    // TODO(ismena): error message on duplicate request id from the same sender\n    switch (message['type']) {\n      case 'PLAY':\n        this.video_.play();\n        // Notify generic controllers that the player state changed.\n        // requestId=0 (the parameter) means that the message was not\n        // triggered by a GET_STATUS request.\n        this.sendMediaStatus_();\n        break;\n      case 'PAUSE':\n        this.video_.pause();\n        this.sendMediaStatus_();\n        break;\n      case 'SEEK': {\n        const currentTime = message['currentTime'];\n        const resumeState = message['resumeState'];\n        if (currentTime != null) {\n          this.video_.currentTime = Number(currentTime);\n        }\n        if (resumeState && resumeState == 'PLAYBACK_START') {\n          this.video_.play();\n          this.sendMediaStatus_();\n        } else if (resumeState && resumeState == 'PLAYBACK_PAUSE') {\n          this.video_.pause();\n          this.sendMediaStatus_();\n        }\n        break;\n      }\n      case 'STOP':\n        this.player_.unload().then(() => {\n          if (!this.player_) {\n            // We've already been destroyed.\n            return;\n          }\n\n          this.sendMediaStatus_();\n        });\n        break;\n      case 'GET_STATUS':\n        // TODO(ismena): According to the SDK this is supposed to be a\n        // unicast message to the sender that requested the status,\n        // but it doesn't appear to be working.\n        // Look into what's going on there and change this to be a\n        // unicast.\n        this.sendMediaInfoMessage_(Number(message['requestId']));\n        break;\n      case 'VOLUME': {\n        const volumeObject = message['volume'];\n        const level = volumeObject['level'];\n        const muted = volumeObject['muted'];\n        const oldVolumeLevel = this.video_.volume;\n        const oldVolumeMuted = this.video_.muted;\n        if (level != null) {\n          this.video_.volume = Number(level);\n        }\n        if (muted != null) {\n          this.video_.muted = muted;\n        }\n        // Notify generic controllers if the volume changed.\n        if (oldVolumeLevel != this.video_.volume ||\n            oldVolumeMuted != this.video_.muted) {\n          this.sendMediaStatus_();\n        }\n        break;\n      }\n      case 'LOAD': {\n        // Reset update message frequency values after a load.\n        this.updateNumber_ = 0;\n        this.startUpdatingUpdateNumber_ = false;\n        // This already sends an update.\n        this.initialStatusUpdatePending_ = false;\n\n        const mediaInfo = message['media'];\n        const contentId = mediaInfo['contentId'];\n        const currentTime = message['currentTime'];\n        const assetUri = this.contentIdCallback_(contentId);\n        const autoplay = message['autoplay'] || true;\n        const customData = mediaInfo['customData'];\n\n        this.appDataCallback_(customData);\n\n        if (autoplay) {\n          this.video_.autoplay = true;\n        }\n        this.player_.load(assetUri, currentTime).then(() => {\n          if (!this.player_) {\n            // We've already been destroyed.\n            return;\n          }\n\n          // Notify generic controllers that the media has changed.\n          this.sendMediaInfoMessage_();\n        }).catch((error) => {\n          goog.asserts.assert(error instanceof shaka.util.Error,\n              'Wrong error type!');\n\n          // Load failed.  Dispatch the error message to the sender.\n          let type = 'LOAD_FAILED';\n          if (error.category == shaka.util.Error.Category.PLAYER &&\n              error.code == shaka.util.Error.Code.LOAD_INTERRUPTED) {\n            type = 'LOAD_CANCELLED';\n          }\n\n          this.sendMessage_({\n            'requestId': Number(message['requestId']),\n            'type': type,\n          }, this.genericBus_);\n        });\n        break;\n      }\n      default:\n        shaka.log.warning(\n            'Unrecognized message type from the generic Chromecast controller!',\n            message['type']);\n        // Dispatch an error to the sender.\n        this.sendMessage_({\n          'requestId': Number(message['requestId']),\n          'type': 'INVALID_REQUEST',\n          'reason': 'INVALID_COMMAND',\n        }, this.genericBus_);\n        break;\n    }\n  }\n\n  /**\n   * Tell the sender that the async operation is complete.\n   * @param {string} senderId\n   * @param {string} id\n   * @param {shaka.util.Error} error\n   * @private\n   */\n  sendAsyncComplete_(senderId, id, error) {\n    if (!this.player_) {\n      // We've already been destroyed.\n      return;\n    }\n\n    this.sendMessage_({\n      'type': 'asyncComplete',\n      'id': id,\n      'error': error,\n    }, this.shakaBus_, senderId);\n  }\n\n  /**\n   * Since this method is in the compiled library, make sure all messages passed\n   * in here were created with quoted property names.\n   * @param {!Object} message\n   * @param {cast.receiver.CastMessageBus} bus\n   * @param {string=} senderId\n   * @private\n   */\n  sendMessage_(message, bus, senderId) {\n    // Cuts log spam when debugging the receiver UI in Chrome.\n    if (!this.isConnected_) {\n      return;\n    }\n\n    const serialized = shaka.cast.CastUtils.serialize(message);\n    if (senderId) {\n      bus.getCastChannel(senderId).send(serialized);\n    } else {\n      bus.broadcast(serialized);\n    }\n  }\n\n  /**\n   * @return {string}\n   * @private\n   */\n  getPlayState_() {\n    const playState = shaka.cast.CastReceiver.PLAY_STATE;\n    if (this.isIdle_) {\n      return playState.IDLE;\n    } else if (this.player_.isBuffering()) {\n      return playState.BUFFERING;\n    } else if (this.video_.paused) {\n      return playState.PAUSED;\n    } else {\n      return playState.PLAYING;\n    }\n  }\n\n  /**\n   * @param {number=} requestId\n   * @param {Object=} media\n   * @private\n   */\n  sendMediaStatus_(requestId = 0, media = null) {\n    const mediaStatus = {\n      // mediaSessionId is a unique ID for the playback of this specific\n      // session.\n      // It's used to identify a specific instance of a playback.\n      // We don't support multiple playbacks, so just return 0.\n      'mediaSessionId': 0,\n      'playbackRate': this.video_.playbackRate,\n      'playerState': this.getPlayState_(),\n      'currentTime': this.video_.currentTime,\n      // supportedMediaCommands is a sum of all the flags of commands that the\n      // player supports.\n      // The list of comands with respective flags is:\n      // 1 - Pause\n      // 2 - Seek\n      // 4 - Stream volume\n      // 8 - Stream mute\n      // 16 - Skip forward\n      // 32 - Skip backward\n      // We support all of them, and their sum is 63.\n      'supportedMediaCommands': 63,\n      'volume': {\n        'level': this.video_.volume,\n        'muted': this.video_.muted,\n      },\n    };\n\n    if (media) {\n      mediaStatus['media'] = media;\n    }\n\n    const ret = {\n      'requestId': requestId,\n      'type': 'MEDIA_STATUS',\n      'status': [mediaStatus],\n    };\n\n    this.sendMessage_(ret, this.genericBus_);\n  }\n};\n\n/** @type {number} The interval, in seconds, to poll for changes. */\nshaka.cast.CastReceiver.POLL_INTERVAL = 0.5;\n\n/** @type {number} The interval, in seconds, to go \"idle\". */\nshaka.cast.CastReceiver.IDLE_INTERVAL = 5;\n\n/**\n * @enum {string}\n */\nshaka.cast.CastReceiver.PLAY_STATE = {\n  IDLE: 'IDLE',\n  PLAYING: 'PLAYING',\n  BUFFERING: 'BUFFERING',\n  PAUSED: 'PAUSED',\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.ContentProtection');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @summary A set of functions for parsing and interpreting ContentProtection\n *   elements.\n */\nshaka.dash.ContentProtection = class {\n  /**\n   * Parses info from the ContentProtection elements at the AdaptationSet level.\n   *\n   * @param {!Array.<!Element>} elems\n   * @param {boolean} ignoreDrmInfo\n   * @param {!Object.<string, string>} keySystemsByURI\n   * @return {shaka.dash.ContentProtection.Context}\n   */\n  static parseFromAdaptationSet(elems, ignoreDrmInfo, keySystemsByURI) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const parsed = ContentProtection.parseElements_(elems);\n    /** @type {Array.<shaka.extern.InitDataOverride>} */\n    let defaultInit = null;\n    /** @type {!Array.<shaka.extern.DrmInfo>} */\n    let drmInfos = [];\n    let parsedNonCenc = [];\n\n    // Get the default key ID; if there are multiple, they must all match.\n    const keyIds = new Set(parsed.map((element) => element.keyId));\n    // Remove any possible null value (elements may have no key ids).\n    keyIds.delete(null);\n\n    if (keyIds.size > 1) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS);\n    }\n\n    if (!ignoreDrmInfo) {\n      // Find the default key ID and init data.  Create a new array of all the\n      // non-CENC elements.\n      parsedNonCenc = parsed.filter((elem) => {\n        if (elem.schemeUri == ContentProtection.MP4Protection_) {\n          goog.asserts.assert(!elem.init || elem.init.length,\n              'Init data must be null or non-empty.');\n          defaultInit = elem.init || defaultInit;\n          return false;\n        } else {\n          return true;\n        }\n      });\n\n      if (parsedNonCenc.length) {\n        drmInfos = ContentProtection.convertElements_(\n            defaultInit, parsedNonCenc, keySystemsByURI, keyIds);\n\n        // If there are no drmInfos after parsing, then add a dummy entry.\n        // This may be removed in parseKeyIds.\n        if (drmInfos.length == 0) {\n          drmInfos = [ManifestParserUtils.createDrmInfo('', defaultInit)];\n        }\n      }\n    }\n\n    // If there are only CENC element(s) or ignoreDrmInfo flag is set, assume\n    // all key-systems are supported.\n    if (parsed.length && (ignoreDrmInfo || !parsedNonCenc.length)) {\n      drmInfos = [];\n\n      for (const keySystem of Object.values(keySystemsByURI)) {\n        // If the manifest doesn't specify any key systems, we shouldn't\n        // put clearkey in this list.  Otherwise, it may be triggered when\n        // a real key system should be used instead.\n        if (keySystem != 'org.w3.clearkey') {\n          const info =\n              ManifestParserUtils.createDrmInfo(keySystem, defaultInit);\n          drmInfos.push(info);\n        }\n      }\n    }\n\n    // If we have a default key id, apply it to every initData.\n    const defaultKeyId = Array.from(keyIds)[0] || null;\n\n    if (defaultKeyId) {\n      for (const info of drmInfos) {\n        for (const initData of info.initData) {\n          initData.keyId = defaultKeyId;\n        }\n      }\n    }\n\n    return {\n      defaultKeyId: defaultKeyId,\n      defaultInit: defaultInit,\n      drmInfos: drmInfos,\n      firstRepresentation: true,\n    };\n  }\n\n  /**\n   * Parses the given ContentProtection elements found at the Representation\n   * level.  This may update the |context|.\n   *\n   * @param {!Array.<!Element>} elems\n   * @param {shaka.dash.ContentProtection.Context} context\n   * @param {boolean} ignoreDrmInfo\n   * @param {!Object.<string, string>} keySystemsByURI\n   * @return {?string} The parsed key ID\n   */\n  static parseFromRepresentation(\n      elems, context, ignoreDrmInfo, keySystemsByURI) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const repContext = ContentProtection.parseFromAdaptationSet(\n        elems, ignoreDrmInfo, keySystemsByURI);\n\n    if (context.firstRepresentation) {\n      const asUnknown = context.drmInfos.length == 1 &&\n          !context.drmInfos[0].keySystem;\n      const asUnencrypted = context.drmInfos.length == 0;\n      const repUnencrypted = repContext.drmInfos.length == 0;\n\n      // There are two cases where we need to replace the |drmInfos| in the\n      // context with those in the Representation:\n      //   1. The AdaptationSet does not list any ContentProtection.\n      //   2. The AdaptationSet only lists unknown key-systems.\n      if (asUnencrypted || (asUnknown && !repUnencrypted)) {\n        context.drmInfos = repContext.drmInfos;\n      }\n      context.firstRepresentation = false;\n    } else if (repContext.drmInfos.length > 0) {\n      // If this is not the first Representation, then we need to remove entries\n      // from the context that do not appear in this Representation.\n      context.drmInfos = context.drmInfos.filter((asInfo) => {\n        return repContext.drmInfos.some((repInfo) => {\n          return repInfo.keySystem == asInfo.keySystem;\n        });\n      });\n      // If we have filtered out all key-systems, throw an error.\n      if (context.drmInfos.length == 0) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM);\n      }\n    }\n\n    return repContext.defaultKeyId || context.defaultKeyId;\n  }\n\n  /**\n   * Gets a Widevine license URL from a content protection element\n   * containing a custom `ms:laurl` element\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getWidevineLicenseUrl(element) {\n    const mslaurlNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft', 'laurl');\n    if (mslaurlNode) {\n      return mslaurlNode.getAttribute('licenseUrl') || '';\n    }\n    return '';\n  }\n\n  /**\n   * Gets a ClearKey license URL from a content protection element\n   * containing a custom `clearkey::Laurl` element\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getClearKeyLicenseUrl(element) {\n    const clearKeyLaurlNode = shaka.util.XmlUtils.findChildNS(\n        element.node, shaka.dash.ContentProtection.ClearKeyNamespaceUri_,\n        'Laurl',\n    );\n    if (clearKeyLaurlNode &&\n      clearKeyLaurlNode.getAttribute('Lic_type') === 'EME-1.0') {\n      if (clearKeyLaurlNode.textContent) {\n        return clearKeyLaurlNode.textContent;\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Parses an Array buffer starting at byteOffset for PlayReady Object Records.\n   * Each PRO Record is preceded by its PlayReady Record type and length in\n   * bytes.\n   *\n   * PlayReady Object Record format: https://goo.gl/FTcu46\n   *\n   * @param {!DataView} view\n   * @param {number} byteOffset\n   * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n   * @private\n   */\n  static parseMsProRecords_(view, byteOffset) {\n    const records = [];\n\n    while (byteOffset < view.byteLength - 1) {\n      const type = view.getUint16(byteOffset, true);\n      byteOffset += 2;\n\n      const byteLength = view.getUint16(byteOffset, true);\n      byteOffset += 2;\n\n      if ((byteLength & 1) != 0 || byteLength + byteOffset > view.byteLength) {\n        shaka.log.warning('Malformed MS PRO object');\n        return [];\n      }\n\n      const recordValue = shaka.util.BufferUtils.toUint8(\n          view, byteOffset, byteLength);\n      records.push({\n        type: type,\n        value: recordValue,\n      });\n\n      byteOffset += byteLength;\n    }\n\n    return records;\n  }\n\n  /**\n   * Parses a buffer for PlayReady Objects.  The data\n   * should contain a 32-bit integer indicating the length of\n   * the PRO in bytes.  Following that, a 16-bit integer for\n   * the number of PlayReady Object Records in the PRO.  Lastly,\n   * a byte array of the PRO Records themselves.\n   *\n   * PlayReady Object format: https://goo.gl/W8yAN4\n   *\n   * @param {BufferSource} data\n   * @return {!Array.<shaka.dash.ContentProtection.PlayReadyRecord>}\n   * @private\n   */\n  static parseMsPro_(data) {\n    let byteOffset = 0;\n    const view = shaka.util.BufferUtils.toDataView(data);\n\n    // First 4 bytes is the PRO length (DWORD)\n    const byteLength = view.getUint32(byteOffset, /* littleEndian= */ true);\n    byteOffset += 4;\n\n    if (byteLength != data.byteLength) {\n      // Malformed PRO\n      shaka.log.warning('PlayReady Object with invalid length encountered.');\n      return [];\n    }\n\n    // Skip PRO Record count (WORD)\n    byteOffset += 2;\n\n    // Rest of the data contains the PRO Records\n    const ContentProtection = shaka.dash.ContentProtection;\n    return ContentProtection.parseMsProRecords_(view, byteOffset);\n  }\n\n  /**\n   * PlayReady Header format: https://goo.gl/dBzxNA\n   *\n   * @param {!Element} xml\n   * @return {string}\n   * @private\n   */\n  static getLaurl_(xml) {\n    // LA_URL element is optional and no more than one is\n    // allowed inside the DATA element. Only absolute URLs are allowed.\n    // If the LA_URL element exists, it must not be empty.\n    for (const elem of xml.getElementsByTagName('DATA')) {\n      for (const child of elem.childNodes) {\n        if (child instanceof Element && child.tagName == 'LA_URL') {\n          return child.textContent;\n        }\n      }\n    }\n\n    // Not found\n    return '';\n  }\n\n  /**\n   * Gets a PlayReady license URL from a content protection element\n   * containing a PlayReady Header Object\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {string}\n   */\n  static getPlayReadyLicenseUrl(element) {\n    const proNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft:playready', 'pro');\n\n    if (!proNode) {\n      return '';\n    }\n\n    const ContentProtection = shaka.dash.ContentProtection;\n    const PLAYREADY_RECORD_TYPES = ContentProtection.PLAYREADY_RECORD_TYPES;\n\n    const bytes = shaka.util.Uint8ArrayUtils.fromBase64(proNode.textContent);\n    const records = ContentProtection.parseMsPro_(bytes);\n    const record = records.filter((record) => {\n      return record.type === PLAYREADY_RECORD_TYPES.RIGHTS_MANAGEMENT;\n    })[0];\n\n    if (!record) {\n      return '';\n    }\n\n    const xml = shaka.util.StringUtils.fromUTF16(record.value, true);\n    const rootElement = shaka.util.XmlUtils.parseXmlString(xml, 'WRMHEADER');\n    if (!rootElement) {\n      return '';\n    }\n\n    return ContentProtection.getLaurl_(rootElement);\n  }\n\n  /**\n   * Gets a PlayReady initData from a content protection element\n   * containing a PlayReady Pro Object\n   *\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @return {?Array.<shaka.extern.InitDataOverride>}\n   * @private\n   */\n  static getInitDataFromPro_(element) {\n    const proNode = shaka.util.XmlUtils.findChildNS(\n        element.node, 'urn:microsoft:playready', 'pro');\n    if (!proNode) {\n      return null;\n    }\n    const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n    const data = Uint8ArrayUtils.fromBase64(proNode.textContent);\n    const systemId = new Uint8Array([\n      0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86,\n      0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95,\n    ]);\n    const keyIds = new Set();\n    const psshVersion = 0;\n    const pssh =\n        shaka.util.Pssh.createPssh(data, systemId, keyIds, psshVersion);\n    return [\n      {\n        initData: pssh,\n        initDataType: 'cenc',\n        keyId: element.keyId,\n      },\n    ];\n  }\n\n  /**\n   * Creates ClearKey initData from Default_KID value retrieved from previously\n   * parsed ContentProtection tag.\n   * @param {shaka.dash.ContentProtection.Element} element\n   * @param {!Set.<string>} keyIds\n   * @return {?Array.<shaka.extern.InitDataOverride>}\n   * @private\n   */\n  static getInitDataClearKey_(element, keyIds) {\n    if (keyIds.size == 0) {\n      return null;\n    }\n\n    const systemId = new Uint8Array([\n      0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02,\n      0xac, 0xe3, 0x3c, 0x1e, 0x52, 0xe2, 0xfb, 0x4b,\n    ]);\n    const data = new Uint8Array([]);\n    const psshVersion = 1;\n    const pssh =\n         shaka.util.Pssh.createPssh(data, systemId, keyIds, psshVersion);\n\n    return [\n      {\n        initData: pssh,\n        initDataType: 'cenc',\n        keyId: element.keyId,\n      },\n    ];\n  }\n\n  /**\n   * Creates DrmInfo objects from the given element.\n   *\n   * @param {Array.<shaka.extern.InitDataOverride>} defaultInit\n   * @param {!Array.<shaka.dash.ContentProtection.Element>} elements\n   * @param {!Object.<string, string>} keySystemsByURI\n   * @param {!Set.<string>} keyIds\n   * @return {!Array.<shaka.extern.DrmInfo>}\n   * @private\n   */\n  static convertElements_(defaultInit, elements, keySystemsByURI, keyIds) {\n    const ContentProtection = shaka.dash.ContentProtection;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const licenseUrlParsers = ContentProtection.licenseUrlParsers_;\n\n    /** @type {!Array.<shaka.extern.DrmInfo>} */\n    const out = [];\n\n    for (const element of elements) {\n      const keySystem = keySystemsByURI[element.schemeUri];\n      if (keySystem) {\n        goog.asserts.assert(\n            !element.init || element.init.length,\n            'Init data must be null or non-empty.');\n\n        const proInitData = ContentProtection.getInitDataFromPro_(element);\n        let clearKeyInitData = null;\n        if (element.schemeUri ===\n              shaka.dash.ContentProtection.ClearKeySchemeUri_) {\n          clearKeyInitData =\n            ContentProtection.getInitDataClearKey_(element, keyIds);\n        }\n        const initData = element.init || defaultInit || proInitData ||\n          clearKeyInitData;\n        const info = ManifestParserUtils.createDrmInfo(keySystem, initData);\n        const licenseParser = licenseUrlParsers.get(keySystem);\n        if (licenseParser) {\n          info.licenseServerUri = licenseParser(element);\n        }\n\n        out.push(info);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses the given ContentProtection elements.  If there is an error, it\n   * removes those elements.\n   *\n   * @param {!Array.<!Element>} elems\n   * @return {!Array.<shaka.dash.ContentProtection.Element>}\n   * @private\n   */\n  static parseElements_(elems) {\n    /** @type {!Array.<shaka.dash.ContentProtection.Element>} */\n    const out = [];\n\n    for (const elem of elems) {\n      const parsed = shaka.dash.ContentProtection.parseElement_(elem);\n      if (parsed) {\n        out.push(parsed);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses the given ContentProtection element.\n   *\n   * @param {!Element} elem\n   * @return {?shaka.dash.ContentProtection.Element}\n   * @private\n   */\n  static parseElement_(elem) {\n    const NS = shaka.dash.ContentProtection.CencNamespaceUri_;\n\n    /** @type {?string} */\n    let schemeUri = elem.getAttribute('schemeIdUri');\n    /** @type {?string} */\n    let keyId = shaka.util.XmlUtils.getAttributeNS(elem, NS, 'default_KID');\n    /** @type {!Array.<string>} */\n    const psshs = shaka.util.XmlUtils.findChildrenNS(elem, NS, 'pssh')\n        .map(shaka.util.XmlUtils.getContents);\n\n    if (!schemeUri) {\n      shaka.log.error('Missing required schemeIdUri attribute on',\n          'ContentProtection element', elem);\n      return null;\n    }\n\n    schemeUri = schemeUri.toLowerCase();\n    if (keyId) {\n      keyId = keyId.replace(/-/g, '').toLowerCase();\n      if (keyId.includes(' ')) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED);\n      }\n    }\n\n    /** @type {!Array.<shaka.extern.InitDataOverride>} */\n    let init = [];\n    try {\n      // Try parsing PSSH data.\n      init = psshs.map((pssh) => {\n        return {\n          initDataType: 'cenc',\n          initData: shaka.util.Uint8ArrayUtils.fromBase64(pssh),\n          keyId: null,\n        };\n      });\n    } catch (e) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING);\n    }\n\n    return {\n      node: elem,\n      schemeUri: schemeUri,\n      keyId: keyId,\n      init: (init.length > 0 ? init : null),\n    };\n  }\n};\n\n/**\n * @typedef {{\n *   type: number,\n *   value: !Uint8Array\n * }}\n *\n * @description\n * The parsed result of a PlayReady object record.\n *\n * @property {number} type\n *   Type of data stored in the record.\n * @property {!Uint8Array} value\n *   Record content.\n */\nshaka.dash.ContentProtection.PlayReadyRecord;\n\n/**\n * Enum for PlayReady record types.\n * @enum {number}\n */\nshaka.dash.ContentProtection.PLAYREADY_RECORD_TYPES = {\n  RIGHTS_MANAGEMENT: 0x001,\n  RESERVED: 0x002,\n  EMBEDDED_LICENSE: 0x003,\n};\n\n/**\n * @typedef {{\n *   defaultKeyId: ?string,\n *   defaultInit: Array.<shaka.extern.InitDataOverride>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   firstRepresentation: boolean\n * }}\n *\n * @description\n * Contains information about the ContentProtection elements found at the\n * AdaptationSet level.\n *\n * @property {?string} defaultKeyId\n *   The default key ID to use.  This is used by parseKeyIds as a default.  This\n *   can be null to indicate that there is no default.\n * @property {Array.<shaka.extern.InitDataOverride>} defaultInit\n *   The default init data override.  This can be null to indicate that there\n *   is no default.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DrmInfo objects.\n * @property {boolean} firstRepresentation\n *   True when first parsed; changed to false after the first call to\n *   parseKeyIds.  This is used to determine if a dummy key-system should be\n *   overwritten; namely that the first representation can replace the dummy\n *   from the AdaptationSet.\n */\nshaka.dash.ContentProtection.Context;\n\n\n/**\n * @typedef {{\n *   node: !Element,\n *   schemeUri: string,\n *   keyId: ?string,\n *   init: Array.<shaka.extern.InitDataOverride>\n * }}\n *\n * @description\n * The parsed result of a single ContentProtection element.\n *\n * @property {!Element} node\n *   The ContentProtection XML element.\n * @property {string} schemeUri\n *   The scheme URI.\n * @property {?string} keyId\n *   The default key ID, if present.\n * @property {Array.<shaka.extern.InitDataOverride>} init\n *   The init data, if present.  If there is no init data, it will be null.  If\n *   this is non-null, there is at least one element.\n */\nshaka.dash.ContentProtection.Element;\n\n/**\n * A map of key system name to license server url parser.\n *\n * @const {!Map.<string, function(shaka.dash.ContentProtection.Element)>}\n * @private\n */\nshaka.dash.ContentProtection.licenseUrlParsers_ = new Map()\n    .set('com.widevine.alpha',\n        shaka.dash.ContentProtection.getWidevineLicenseUrl)\n    .set('com.microsoft.playready',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('com.microsoft.playready.recommendation',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('com.microsoft.playready.software',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('com.microsoft.playready.hardware',\n        shaka.dash.ContentProtection.getPlayReadyLicenseUrl)\n    .set('org.w3.clearkey',\n        shaka.dash.ContentProtection.getClearKeyLicenseUrl);\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.MP4Protection_ =\n    'urn:mpeg:dash:mp4protection:2011';\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.CencNamespaceUri_ = 'urn:mpeg:cenc:2013';\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.ClearKeyNamespaceUri_ =\n  'http://dashif.org/guidelines/clearKey';\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.ContentProtection.ClearKeySchemeUri_ =\n    'urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.MpdUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary MPD processing utility functions.\n */\nshaka.dash.MpdUtils = class {\n  /**\n   * Fills a SegmentTemplate URI template.  This function does not validate the\n   * resulting URI.\n   *\n   * @param {string} uriTemplate\n   * @param {?string} representationId\n   * @param {?number} number\n   * @param {?number} bandwidth\n   * @param {?number} time\n   * @return {string} A URI string.\n   * @see ISO/IEC 23009-1:2014 section 5.3.9.4.4\n   */\n  static fillUriTemplate(\n      uriTemplate, representationId, number, bandwidth, time) {\n    /** @type {!Object.<string, ?number|?string>} */\n    const valueTable = {\n      'RepresentationID': representationId,\n      'Number': number,\n      'Bandwidth': bandwidth,\n      'Time': time,\n    };\n\n    const re = /\\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\\$/g;  // eslint-disable-line max-len\n    const uri = uriTemplate.replace(re, (match, name, widthStr, format) => {\n      if (match == '$$') {\n        return '$';\n      }\n\n      let value = valueTable[name];\n      goog.asserts.assert(value !== undefined, 'Unrecognized identifier');\n\n      // Note that |value| may be 0 or ''.\n      if (value == null) {\n        shaka.log.warning(\n            'URL template does not have an available substitution for ',\n            'identifier \"' + name + '\":',\n            uriTemplate);\n        return match;\n      }\n\n      if (name == 'RepresentationID' && widthStr) {\n        shaka.log.warning(\n            'URL template should not contain a width specifier for identifier',\n            '\"RepresentationID\":',\n            uriTemplate);\n        widthStr = undefined;\n      }\n\n      if (name == 'Time') {\n        goog.asserts.assert(typeof value == 'number',\n            'Time value should be a number!');\n        goog.asserts.assert(Math.abs(value - Math.round(value)) < 0.2,\n            'Calculated $Time$ values must be close to integers');\n        value = Math.round(value);\n      }\n\n      /** @type {string} */\n      let valueString;\n      switch (format) {\n        case undefined:  // Happens if there is no format specifier.\n        case 'd':\n        case 'i':\n        case 'u':\n          valueString = value.toString();\n          break;\n        case 'o':\n          valueString = value.toString(8);\n          break;\n        case 'x':\n          valueString = value.toString(16);\n          break;\n        case 'X':\n          valueString = value.toString(16).toUpperCase();\n          break;\n        default:\n          goog.asserts.assert(false, 'Unhandled format specifier');\n          valueString = value.toString();\n          break;\n      }\n\n      // Create a padding string.\n      const width = window.parseInt(widthStr, 10) || 1;\n      const paddingSize = Math.max(0, width - valueString.length);\n      const padding = (new Array(paddingSize + 1)).join('0');\n\n      return padding + valueString;\n    });\n\n    return uri;\n  }\n\n  /**\n   * Expands a SegmentTimeline into an array-based timeline.  The results are in\n   * seconds.\n   *\n   * @param {!Element} segmentTimeline\n   * @param {number} timescale\n   * @param {number} unscaledPresentationTimeOffset\n   * @param {number} periodDuration The Period's duration in seconds.\n   *   Infinity indicates that the Period continues indefinitely.\n   * @return {!Array.<shaka.dash.MpdUtils.TimeRange>}\n   */\n  static createTimeline(\n      segmentTimeline, timescale, unscaledPresentationTimeOffset,\n      periodDuration) {\n    goog.asserts.assert(\n        timescale > 0 && timescale < Infinity,\n        'timescale must be a positive, finite integer');\n    goog.asserts.assert(\n        periodDuration > 0, 'period duration must be a positive integer');\n\n    // Alias.\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const timePoints = XmlUtils.findChildren(segmentTimeline, 'S');\n\n    /** @type {!Array.<shaka.dash.MpdUtils.TimeRange>} */\n    const timeline = [];\n    let lastEndTime = -unscaledPresentationTimeOffset;\n\n    for (let i = 0; i < timePoints.length; ++i) {\n      const timePoint = timePoints[i];\n      const next = timePoints[i + 1];\n      let t = XmlUtils.parseAttr(timePoint, 't', XmlUtils.parseNonNegativeInt);\n      const d =\n          XmlUtils.parseAttr(timePoint, 'd', XmlUtils.parseNonNegativeInt);\n      const r = XmlUtils.parseAttr(timePoint, 'r', XmlUtils.parseInt);\n\n      // Adjust the start time to account for the presentation time offset.\n      if (t != null) {\n        t -= unscaledPresentationTimeOffset;\n      }\n\n      if (!d) {\n        shaka.log.warning(\n            '\"S\" element must have a duration:',\n            'ignoring the remaining \"S\" elements.', timePoint);\n        return timeline;\n      }\n\n      let startTime = t != null ? t : lastEndTime;\n\n      let repeat = r || 0;\n      if (repeat < 0) {\n        if (next) {\n          const nextStartTime =\n              XmlUtils.parseAttr(next, 't', XmlUtils.parseNonNegativeInt);\n          if (nextStartTime == null) {\n            shaka.log.warning(\n                'An \"S\" element cannot have a negative repeat',\n                'if the next \"S\" element does not have a valid start time:',\n                'ignoring the remaining \"S\" elements.', timePoint);\n            return timeline;\n          } else if (startTime >= nextStartTime) {\n            shaka.log.warning(\n                'An \"S\" element cannot have a negative repeatif its start ',\n                'time exceeds the next \"S\" element\\'s start time:',\n                'ignoring the remaining \"S\" elements.', timePoint);\n            return timeline;\n          }\n          repeat = Math.ceil((nextStartTime - startTime) / d) - 1;\n        } else {\n          if (periodDuration == Infinity) {\n            // The DASH spec. actually allows the last \"S\" element to have a\n            // negative repeat value even when the Period has an infinite\n            // duration.  No one uses this feature and no one ever should,\n            // ever.\n            shaka.log.warning(\n                'The last \"S\" element cannot have a negative repeat',\n                'if the Period has an infinite duration:',\n                'ignoring the last \"S\" element.', timePoint);\n            return timeline;\n          } else if (startTime / timescale >= periodDuration) {\n            shaka.log.warning(\n                'The last \"S\" element cannot have a negative repeat',\n                'if its start time exceeds the Period\\'s duration:',\n                'igoring the last \"S\" element.', timePoint);\n            return timeline;\n          }\n          repeat = Math.ceil((periodDuration * timescale - startTime) / d) - 1;\n        }\n      }\n\n      // The end of the last segment may be before the start of the current\n      // segment (a gap) or after the start of the current segment (an\n      // overlap). If there is a gap/overlap then stretch/compress the end of\n      // the last segment to the start of the current segment.\n      //\n      // Note: it is possible to move the start of the current segment to the\n      // end of the last segment, but this would complicate the computation of\n      // the $Time$ placeholder later on.\n      if ((timeline.length > 0) && (startTime != lastEndTime)) {\n        const delta = startTime - lastEndTime;\n\n        if (Math.abs(delta / timescale) >=\n            shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS) {\n          shaka.log.warning(\n              'SegmentTimeline contains a large gap/overlap:',\n              'the content may have errors in it.', timePoint);\n        }\n\n        timeline[timeline.length - 1].end = startTime / timescale;\n      }\n\n      for (let j = 0; j <= repeat; ++j) {\n        const endTime = startTime + d;\n        const item = {\n          start: startTime / timescale,\n          end: endTime / timescale,\n          unscaledStart: startTime,\n        };\n        timeline.push(item);\n\n        startTime = endTime;\n        lastEndTime = endTime;\n      }\n    }\n\n    return timeline;\n  }\n\n  /**\n   * Parses common segment info for SegmentList and SegmentTemplate.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the element that contains the segment info.\n   * @return {shaka.dash.MpdUtils.SegmentInfo}\n   */\n  static parseSegmentInfo(context, callback) {\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type.');\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const timescaleStr =\n        MpdUtils.inheritAttribute(context, callback, 'timescale');\n    let timescale = 1;\n    if (timescaleStr) {\n      timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n    }\n\n    const durationStr =\n        MpdUtils.inheritAttribute(context, callback, 'duration');\n    let segmentDuration = XmlUtils.parsePositiveInt(durationStr || '');\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    // TODO: The specification is not clear, check this once it is resolved:\n    // https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/404\n    if (context.representation.contentType == ContentType.IMAGE) {\n      segmentDuration = XmlUtils.parseFloat(durationStr || '');\n    }\n    if (segmentDuration) {\n      segmentDuration /= timescale;\n    }\n\n    const startNumberStr =\n        MpdUtils.inheritAttribute(context, callback, 'startNumber');\n    const unscaledPresentationTimeOffset =\n        Number(MpdUtils.inheritAttribute(context, callback,\n            'presentationTimeOffset')) || 0;\n    let startNumber = XmlUtils.parseNonNegativeInt(startNumberStr || '');\n    if (startNumberStr == null || startNumber == null) {\n      startNumber = 1;\n    }\n\n    const timelineNode =\n        MpdUtils.inheritChild(context, callback, 'SegmentTimeline');\n    /** @type {Array.<shaka.dash.MpdUtils.TimeRange>} */\n    let timeline = null;\n    if (timelineNode) {\n      timeline = MpdUtils.createTimeline(\n          timelineNode, timescale, unscaledPresentationTimeOffset,\n          context.periodInfo.duration || Infinity);\n    }\n\n    const scaledPresentationTimeOffset =\n        (unscaledPresentationTimeOffset / timescale) || 0;\n    return {\n      timescale: timescale,\n      segmentDuration: segmentDuration,\n      startNumber: startNumber,\n      scaledPresentationTimeOffset: scaledPresentationTimeOffset,\n      unscaledPresentationTimeOffset: unscaledPresentationTimeOffset,\n      timeline: timeline,\n    };\n  }\n\n  /**\n   * Searches the inheritance for a Segment* with the given attribute.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the Element that contains the attribute to inherit.\n   * @param {string} attribute\n   * @return {?string}\n   */\n  static inheritAttribute(context, callback, attribute) {\n    const Functional = shaka.util.Functional;\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type');\n\n    /** @type {!Array.<!Element>} */\n    const nodes = [\n      callback(context.representation),\n      callback(context.adaptationSet),\n      callback(context.period),\n    ].filter(Functional.isNotNull);\n\n    return nodes\n        .map((s) => { return s.getAttribute(attribute); })\n        .reduce((all, part) => { return all || part; });\n  }\n\n  /**\n   * Searches the inheritance for a Segment* with the given child.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   *   Gets the Element that contains the child to inherit.\n   * @param {string} child\n   * @return {Element}\n   */\n  static inheritChild(context, callback, child) {\n    const Functional = shaka.util.Functional;\n    goog.asserts.assert(\n        callback(context.representation),\n        'There must be at least one element of the given type');\n\n    /** @type {!Array.<!Element>} */\n    const nodes = [\n      callback(context.representation),\n      callback(context.adaptationSet),\n      callback(context.period),\n    ].filter(Functional.isNotNull);\n\n    const XmlUtils = shaka.util.XmlUtils;\n    return nodes\n        .map((s) => { return XmlUtils.findChild(s, child); })\n        .reduce((all, part) => { return all || part; });\n  }\n\n  /**\n   * Follow the xlink link contained in the given element.\n   * It also strips the xlink properties off of the element,\n   * even if the process fails.\n   *\n   * @param {!Element} element\n   * @param {!shaka.extern.RetryParameters} retryParameters\n   * @param {boolean} failGracefully\n   * @param {string} baseUri\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {number} linkDepth\n   * @return {!shaka.util.AbortableOperation.<!Element>}\n   * @private\n   */\n  static handleXlinkInElement_(\n      element, retryParameters, failGracefully, baseUri, networkingEngine,\n      linkDepth) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const Error = shaka.util.Error;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const NS = MpdUtils.XlinkNamespaceUri_;\n\n    const xlinkHref = XmlUtils.getAttributeNS(element, NS, 'href');\n    const xlinkActuate =\n        XmlUtils.getAttributeNS(element, NS, 'actuate') || 'onRequest';\n\n    // Remove the xlink properties, so it won't download again\n    // when re-processed.\n    for (const attribute of Array.from(element.attributes)) {\n      if (attribute.namespaceURI == NS) {\n        element.removeAttributeNS(attribute.namespaceURI, attribute.localName);\n      }\n    }\n\n    if (linkDepth >= 5) {\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_XLINK_DEPTH_LIMIT));\n    }\n\n    if (xlinkActuate != 'onLoad') {\n      // Only xlink:actuate=\"onLoad\" is supported.\n      // When no value is specified, the assumed value is \"onRequest\".\n      return shaka.util.AbortableOperation.failed(new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE));\n    }\n\n    // Resolve the xlink href, in case it's a relative URL.\n    const uris = ManifestParserUtils.resolveUris([baseUri], [xlinkHref]);\n\n    // Load in the linked elements.\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n    const request =\n        shaka.net.NetworkingEngine.makeRequest(uris, retryParameters);\n\n    const requestOperation = networkingEngine.request(requestType, request);\n    // The interface is abstract, but we know it was implemented with the\n    // more capable internal class.\n    goog.asserts.assert(\n        requestOperation instanceof shaka.util.AbortableOperation,\n        'Unexpected implementation of IAbortableOperation!');\n    // Satisfy the compiler with a cast.\n    const networkOperation =\n    /** @type {!shaka.util.AbortableOperation.<shaka.extern.Response>} */ (\n        requestOperation);\n\n    // Chain onto that operation.\n    return networkOperation.chain(\n        (response) => {\n          // This only supports the case where the loaded xml has a single\n          // top-level element.  If there are multiple roots, it will be\n          // rejected.\n          const rootElem =\n          shaka.util.XmlUtils.parseXml(response.data, element.tagName);\n          if (!rootElem) {\n            // It was not valid XML.\n            return shaka.util.AbortableOperation.failed(new Error(\n                Error.Severity.CRITICAL, Error.Category.MANIFEST,\n                Error.Code.DASH_INVALID_XML, xlinkHref));\n          }\n\n          // Now that there is no other possibility of the process erroring,\n          // the element can be changed further.\n\n          // Remove the current contents of the node.\n          while (element.childNodes.length) {\n            element.removeChild(element.childNodes[0]);\n          }\n\n          // Move the children of the loaded xml into the current element.\n          while (rootElem.childNodes.length) {\n            const child = rootElem.childNodes[0];\n            rootElem.removeChild(child);\n            element.appendChild(child);\n          }\n\n          // Move the attributes of the loaded xml into the current element.\n          for (const attribute of Array.from(rootElem.attributes)) {\n            element.setAttributeNode(attribute.cloneNode(/* deep= */ false));\n          }\n\n          return shaka.dash.MpdUtils.processXlinks(\n              element, retryParameters, failGracefully, uris[0],\n              networkingEngine, linkDepth + 1);\n        });\n  }\n\n  /**\n   * Filter the contents of a node recursively, replacing xlink links\n   * with their associated online data.\n   *\n   * @param {!Element} element\n   * @param {!shaka.extern.RetryParameters} retryParameters\n   * @param {boolean} failGracefully\n   * @param {string} baseUri\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   * @param {number=} linkDepth, default set to 0\n   * @return {!shaka.util.AbortableOperation.<!Element>}\n   */\n  static processXlinks(\n      element, retryParameters, failGracefully, baseUri, networkingEngine,\n      linkDepth = 0) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const NS = MpdUtils.XlinkNamespaceUri_;\n\n    if (XmlUtils.getAttributeNS(element, NS, 'href')) {\n      let handled = MpdUtils.handleXlinkInElement_(\n          element, retryParameters, failGracefully, baseUri, networkingEngine,\n          linkDepth);\n      if (failGracefully) {\n        // Catch any error and go on.\n        handled = handled.chain(undefined, (error) => {\n          // handleXlinkInElement_ strips the xlink properties off of the\n          // element even if it fails, so calling processXlinks again will\n          // handle whatever contents the element natively has.\n          return MpdUtils.processXlinks(\n              element, retryParameters, failGracefully, baseUri,\n              networkingEngine, linkDepth);\n        });\n      }\n      return handled;\n    }\n\n    const childOperations = [];\n    for (const child of Array.from(element.childNodes)) {\n      if (child instanceof Element) {\n        const resolveToZeroString = 'urn:mpeg:dash:resolve-to-zero:2013';\n        if (XmlUtils.getAttributeNS(child, NS, 'href') == resolveToZeroString) {\n          // This is a 'resolve to zero' code; it means the element should\n          // be removed, as specified by the mpeg-dash rules for xlink.\n          element.removeChild(child);\n        } else if (child.tagName != 'SegmentTimeline') {\n          // Don't recurse into a SegmentTimeline since xlink attributes\n          // aren't valid in there and looking at each segment can take a long\n          // time with larger manifests.\n\n          // Replace the child with its processed form.\n          childOperations.push(shaka.dash.MpdUtils.processXlinks(\n              /** @type {!Element} */ (child), retryParameters, failGracefully,\n              baseUri, networkingEngine, linkDepth));\n        }\n      }\n    }\n\n    return shaka.util.AbortableOperation.all(childOperations).chain(() => {\n      return element;\n    });\n  }\n};\n\n\n/**\n * @typedef {{\n *   start: number,\n *   unscaledStart: number,\n *   end: number\n * }}\n *\n * @description\n * Defines a time range of a media segment.  Times are in seconds.\n *\n * @property {number} start\n *   The start time of the range.\n * @property {number} unscaledStart\n *   The start time of the range in representation timescale units.\n * @property {number} end\n *   The end time (exclusive) of the range.\n */\nshaka.dash.MpdUtils.TimeRange;\n\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>\n * }}\n *\n * @description\n * Contains common information between SegmentList and SegmentTemplate items.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n */\nshaka.dash.MpdUtils.SegmentInfo;\n\n\n/**\n * @const {string}\n * @private\n */\nshaka.dash.MpdUtils.XlinkNamespaceUri_ = 'http://www.w3.org/1999/xlink';\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.Mp4SegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\nshaka.media.Mp4SegmentIndexParser = class {\n  /**\n   * Parses SegmentReferences from an ISO BMFF SIDX structure.\n   * @param {BufferSource} sidxData The MP4's container's SIDX.\n   * @param {number} sidxOffset The SIDX's offset, in bytes, from the start of\n   *   the MP4 container.\n   * @param {!Array.<string>} uris The possible locations of the MP4 file that\n   *   contains the segments.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   */\n  static parse(\n      sidxData, sidxOffset, uris, initSegmentReference, timestampOffset,\n      appendWindowStart, appendWindowEnd) {\n    const Mp4SegmentIndexParser = shaka.media.Mp4SegmentIndexParser;\n\n    let references;\n\n    const parser = new shaka.util.Mp4Parser()\n        .fullBox('sidx', (box) => {\n          references = Mp4SegmentIndexParser.parseSIDX_(\n              sidxOffset,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd,\n              uris,\n              box);\n        });\n\n    if (sidxData) {\n      parser.parse(sidxData);\n    }\n\n    if (references) {\n      return references;\n    } else {\n      shaka.log.error('Invalid box type, expected \"sidx\".');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE);\n    }\n  }\n\n\n  /**\n   * Parse a SIDX box from the given reader.\n   *\n   * @param {number} sidxOffset\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @param {!Array.<string>} uris The possible locations of the MP4 file that\n   *   contains the segments.\n   * @param {!shaka.extern.ParsedBox} box\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static parseSIDX_(\n      sidxOffset, initSegmentReference, timestampOffset, appendWindowStart,\n      appendWindowEnd, uris, box) {\n    goog.asserts.assert(\n        box.version != null,\n        'SIDX is a full box and should have a valid version.');\n\n    const references = [];\n\n    // Parse the SIDX structure.\n    // Skip reference_ID (32 bits).\n    box.reader.skip(4);\n\n    const timescale = box.reader.readUint32();\n\n    if (timescale == 0) {\n      shaka.log.error('Invalid timescale.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE);\n    }\n\n    let earliestPresentationTime;\n    let firstOffset;\n\n    if (box.version == 0) {\n      earliestPresentationTime = box.reader.readUint32();\n      firstOffset = box.reader.readUint32();\n    } else {\n      earliestPresentationTime = box.reader.readUint64();\n      firstOffset = box.reader.readUint64();\n    }\n\n    // Skip reserved (16 bits).\n    box.reader.skip(2);\n\n    // Add references.\n    const referenceCount = box.reader.readUint16();\n\n    // Subtract the presentation time offset\n    let unscaledStartTime = earliestPresentationTime;\n    let startByte = sidxOffset + box.size + firstOffset;\n\n    for (let i = 0; i < referenceCount; i++) {\n      // |chunk| is 1 bit for |referenceType|, and 31 bits for |referenceSize|.\n      const chunk = box.reader.readUint32();\n      const referenceType = (chunk & 0x80000000) >>> 31;\n      const referenceSize = chunk & 0x7FFFFFFF;\n\n      const subsegmentDuration = box.reader.readUint32();\n\n      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n      // for |sapDelta|.\n      box.reader.skip(4);\n\n      // If |referenceType| is 1 then the reference is to another SIDX.\n      // We do not support this.\n      if (referenceType == 1) {\n        shaka.log.error('Heirarchical SIDXs are not supported.');\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MEDIA,\n            shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED);\n      }\n\n      // The media timestamps inside the container.\n      const nativeStartTime = unscaledStartTime / timescale;\n      const nativeEndTime =\n          (unscaledStartTime + subsegmentDuration) / timescale;\n\n      references.push(\n          new shaka.media.SegmentReference(\n              nativeStartTime + timestampOffset,\n              nativeEndTime + timestampOffset,\n              (() => { return uris; }),\n              startByte,\n              startByte + referenceSize - 1,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd));\n\n      unscaledStartTime += subsegmentDuration;\n      startByte += referenceSize;\n    }\n\n    box.parser.stop();\n    return references;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.EbmlElement');\ngoog.provide('shaka.util.EbmlParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary\n * Extensible Binary Markup Language (EBML) parser.\n */\nshaka.util.EbmlParser = class {\n  /**\n   * @param {BufferSource} data\n   */\n  constructor(data) {\n    /** @private {!DataView} */\n    this.dataView_ = shaka.util.BufferUtils.toDataView(data);\n\n    /** @private {!shaka.util.DataViewReader} */\n    this.reader_ = new shaka.util.DataViewReader(\n        this.dataView_, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n  }\n\n\n  /**\n   * @return {boolean} True if the parser has more data, false otherwise.\n   */\n  hasMoreData() {\n    return this.reader_.hasMoreData();\n  }\n\n\n  /**\n   * Parses an EBML element from the parser's current position, and advances\n   * the parser.\n   * @return {!shaka.util.EbmlElement} The EBML element.\n   * @see http://matroska.org/technical/specs/rfc/index.html\n   */\n  parseElement() {\n    const id = this.parseId_();\n\n    // Parse the element's size.\n    const vint = this.parseVint_();\n    let size;\n    if (shaka.util.EbmlParser.isDynamicSizeValue_(vint)) {\n      // If this has an unknown size, assume that it takes up the rest of the\n      // data.\n      size = this.dataView_.byteLength - this.reader_.getPosition();\n    } else {\n      size = shaka.util.EbmlParser.getVintValue_(vint);\n    }\n\n    // Note that if the element's size is larger than the buffer then we are\n    // parsing a \"partial element\". This may occur if for example we are\n    // parsing the beginning of some WebM container data, but our buffer does\n    // not contain the entire WebM container data.\n    const elementSize =\n        this.reader_.getPosition() + size <= this.dataView_.byteLength ?\n        size :\n        this.dataView_.byteLength - this.reader_.getPosition();\n\n    const dataView = shaka.util.BufferUtils.toDataView(\n        this.dataView_, this.reader_.getPosition(), elementSize);\n\n    this.reader_.skip(elementSize);\n\n    return new shaka.util.EbmlElement(id, dataView);\n  }\n\n\n  /**\n   * Parses an EBML ID from the parser's current position, and advances the\n   * parser.\n   * @return {number} The EBML ID.\n   * @private\n   */\n  parseId_() {\n    const vint = this.parseVint_();\n\n    if (vint.length > 7) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    let id = 0;\n    for (const /* byte */ b of vint) {\n      // Note that we cannot use << since |value| may exceed 32 bits.\n      id = (256 * id) + b;\n    }\n\n    return id;\n  }\n\n\n  /**\n   * Parses a variable sized integer from the parser's current position, and\n   * advances the parser.\n   * For example:\n   *   1 byte  wide: 1xxx xxxx\n   *   2 bytes wide: 01xx xxxx xxxx xxxx\n   *   3 bytes wide: 001x xxxx xxxx xxxx xxxx xxxx\n   * @return {!Uint8Array} The variable sized integer.\n   * @private\n   */\n  parseVint_() {\n    const position = this.reader_.getPosition();\n    const firstByte = this.reader_.readUint8();\n    if (firstByte == 0) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    // Determine the index of the highest bit set.\n    const index = Math.floor(Math.log2(firstByte));\n    const numBytes = 8 - index;\n    goog.asserts.assert(numBytes <= 8 && numBytes >= 1, 'Incorrect log2 value');\n    this.reader_.skip(numBytes - 1);\n    return shaka.util.BufferUtils.toUint8(this.dataView_, position, numBytes);\n  }\n\n\n  /**\n   * Gets the value of a variable sized integer.\n   * For example, the x's below are part of the vint's value.\n   *    7-bit value: 1xxx xxxx\n   *   14-bit value: 01xx xxxx xxxx xxxx\n   *   21-bit value: 001x xxxx xxxx xxxx xxxx xxxx\n   * @param {!Uint8Array} vint The variable sized integer.\n   * @return {number} The value of the variable sized integer.\n   * @private\n   */\n  static getVintValue_(vint) {\n    // If |vint| is 8 bytes wide then we must ensure that it does not have more\n    // than 53 meaningful bits. For example, assume |vint| is 8 bytes wide,\n    // so it has the following structure,\n    // 0000 0001 | xxxx xxxx ...\n    // Thus, the first 3 bits following the first byte of |vint| must be 0.\n    if ((vint.length == 8) && (vint[1] & 0xe0)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    let value = 0;\n    for (let i = 0; i < vint.length; i++) {\n      const item = vint[i];\n      if (i == 0) {\n        // Mask out the first few bits of |vint|'s first byte to get the most\n        // significant bits of |vint|'s value. If |vint| is 8 bytes wide then\n        // |value| will be set to 0.\n        const mask = 0x1 << (8 - vint.length);\n        value = item & (mask - 1);\n      } else {\n        // Note that we cannot use << since |value| may exceed 32 bits.\n        value = (256 * value) + item;\n      }\n    }\n\n    return value;\n  }\n\n\n  /**\n   * Checks if the given variable sized integer represents a dynamic size value.\n   * @param {!Uint8Array} vint The variable sized integer.\n   * @return {boolean} true if |vint| represents a dynamic size value,\n   *   false otherwise.\n   * @private\n   */\n  static isDynamicSizeValue_(vint) {\n    const EbmlParser = shaka.util.EbmlParser;\n    const BufferUtils = shaka.util.BufferUtils;\n\n    for (const dynamicSizeConst of EbmlParser.DYNAMIC_SIZES) {\n      if (BufferUtils.equal(vint, new Uint8Array(dynamicSizeConst))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n\n\n/**\n * A list of EBML dynamic size constants.\n * @const {!Array.<!Array.<number>>}\n */\nshaka.util.EbmlParser.DYNAMIC_SIZES = [\n  [0xff],\n  [0x7f, 0xff],\n  [0x3f, 0xff, 0xff],\n  [0x1f, 0xff, 0xff, 0xff],\n  [0x0f, 0xff, 0xff, 0xff, 0xff],\n  [0x07, 0xff, 0xff, 0xff, 0xff, 0xff],\n  [0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n  [0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff],\n];\n\n\nshaka.util.EbmlElement = class {\n  /**\n   * @param {number} id The ID.\n   * @param {!DataView} dataView The DataView.\n   */\n  constructor(id, dataView) {\n    /** @type {number} */\n    this.id = id;\n\n    /** @private {!DataView} */\n    this.dataView_ = dataView;\n  }\n\n\n  /**\n   * Gets the element's offset from the beginning of the buffer.\n   * @return {number}\n   */\n  getOffset() {\n    return this.dataView_.byteOffset;\n  }\n\n\n  /**\n   * Interpret the element's data as a list of sub-elements.\n   * @return {!shaka.util.EbmlParser} A parser over the sub-elements.\n   */\n  createParser() {\n    return new shaka.util.EbmlParser(this.dataView_);\n  }\n\n\n  /**\n   * Interpret the element's data as an unsigned integer.\n   * @return {number}\n   */\n  getUint() {\n    if (this.dataView_.byteLength > 8) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_OVERFLOW);\n    }\n\n    // Ensure we have at most 53 meaningful bits.\n    if ((this.dataView_.byteLength == 8) &&\n        (this.dataView_.getUint8(0) & 0xe0)) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.JS_INTEGER_OVERFLOW);\n    }\n\n    let value = 0;\n\n    for (let i = 0; i < this.dataView_.byteLength; i++) {\n      const chunk = this.dataView_.getUint8(i);\n      value = (256 * value) + chunk;\n    }\n\n    return value;\n  }\n\n\n  /**\n   * Interpret the element's data as a floating point number\n   * (32 bits or 64 bits). 80-bit floating point numbers are not supported.\n   * @return {number}\n   */\n  getFloat() {\n    if (this.dataView_.byteLength == 4) {\n      return this.dataView_.getFloat32(0);\n    } else if (this.dataView_.byteLength == 8) {\n      return this.dataView_.getFloat64(0);\n    } else {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE);\n    }\n  }\n};\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.media.WebmSegmentIndexParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.EbmlElement');\ngoog.require('shaka.util.EbmlParser');\ngoog.require('shaka.util.Error');\n\n\nshaka.media.WebmSegmentIndexParser = class {\n  /**\n   * Parses SegmentReferences from a WebM container.\n   * @param {BufferSource} cuesData The WebM container's \"Cueing Data\" section.\n   * @param {BufferSource} initData The WebM container's headers.\n   * @param {!Array.<string>} uris The possible locations of the WebM file that\n   *   contains the segments.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @see http://www.matroska.org/technical/specs/index.html\n   * @see http://www.webmproject.org/docs/container/\n   */\n  static parse(\n      cuesData, initData, uris, initSegmentReference, timestampOffset,\n      appendWindowStart, appendWindowEnd) {\n    const tuple =\n        shaka.media.WebmSegmentIndexParser.parseWebmContainer_(initData);\n    const parser = new shaka.util.EbmlParser(cuesData);\n    const cuesElement = parser.parseElement();\n    if (cuesElement.id != shaka.media.WebmSegmentIndexParser.CUES_ID) {\n      shaka.log.error('Not a Cues element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING);\n    }\n\n    return shaka.media.WebmSegmentIndexParser.parseCues_(\n        cuesElement, tuple.segmentOffset, tuple.timecodeScale, tuple.duration,\n        uris, initSegmentReference, timestampOffset, appendWindowStart,\n        appendWindowEnd);\n  }\n\n\n  /**\n   * Parses a WebM container to get the segment's offset, timecode scale, and\n   * duration.\n   *\n   * @param {BufferSource} initData\n   * @return {{segmentOffset: number, timecodeScale: number, duration: number}}\n   *   The segment's offset in bytes, the segment's timecode scale in seconds,\n   *   and the duration in seconds.\n   * @private\n   */\n  static parseWebmContainer_(initData) {\n    const parser = new shaka.util.EbmlParser(initData);\n\n    // Check that the WebM container data starts with the EBML header, but\n    // skip its contents.\n    const ebmlElement = parser.parseElement();\n    if (ebmlElement.id != shaka.media.WebmSegmentIndexParser.EBML_ID) {\n      shaka.log.error('Not an EBML element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING);\n    }\n\n    const segmentElement = parser.parseElement();\n    if (segmentElement.id != shaka.media.WebmSegmentIndexParser.SEGMENT_ID) {\n      shaka.log.error('Not a Segment element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING);\n    }\n\n    // This value is used as the initial offset to the first referenced segment.\n    const segmentOffset = segmentElement.getOffset();\n\n    // Parse the Segment element to get the segment info.\n    const segmentInfo = shaka.media.WebmSegmentIndexParser.parseSegment_(\n        segmentElement);\n    return {\n      segmentOffset: segmentOffset,\n      timecodeScale: segmentInfo.timecodeScale,\n      duration: segmentInfo.duration,\n    };\n  }\n\n\n  /**\n   * Parses a WebM Info element to get the segment's timecode scale and\n   * duration.\n   * @param {!shaka.util.EbmlElement} segmentElement\n   * @return {{timecodeScale: number, duration: number}} The segment's timecode\n   *   scale in seconds and duration in seconds.\n   * @private\n   */\n  static parseSegment_(segmentElement) {\n    const parser = segmentElement.createParser();\n\n    // Find the Info element.\n    let infoElement = null;\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.INFO_ID) {\n        continue;\n      }\n\n      infoElement = elem;\n\n      break;\n    }\n\n    if (!infoElement) {\n      shaka.log.error('Not an Info element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING);\n    }\n\n    return shaka.media.WebmSegmentIndexParser.parseInfo_(infoElement);\n  }\n\n\n  /**\n   * Parses a WebM Info element to get the segment's timecode scale and\n   * duration.\n   * @param {!shaka.util.EbmlElement} infoElement\n   * @return {{timecodeScale: number, duration: number}} The segment's timecode\n   *   scale in seconds and duration in seconds.\n   * @private\n   */\n  static parseInfo_(infoElement) {\n    const parser = infoElement.createParser();\n\n    // The timecode scale factor in units of [nanoseconds / T], where [T] are\n    // the units used to express all other time values in the WebM container.\n    // By default it's assumed that [T] == [milliseconds].\n    let timecodeScaleNanoseconds = 1000000;\n    /** @type {?number} */\n    let durationScale = null;\n\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id == shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID) {\n        timecodeScaleNanoseconds = elem.getUint();\n      } else if (elem.id == shaka.media.WebmSegmentIndexParser.DURATION_ID) {\n        durationScale = elem.getFloat();\n      }\n    }\n    if (durationScale == null) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING);\n    }\n\n    // The timecode scale factor in units of [seconds / T].\n    const timecodeScale = timecodeScaleNanoseconds / 1000000000;\n    // The duration is stored in units of [T]\n    const durationSeconds = durationScale * timecodeScale;\n\n    return {timecodeScale: timecodeScale, duration: durationSeconds};\n  }\n\n\n  /**\n   * Parses a WebM CuesElement.\n   * @param {!shaka.util.EbmlElement} cuesElement\n   * @param {number} segmentOffset\n   * @param {number} timecodeScale\n   * @param {number} duration\n   * @param {!Array.<string>} uris\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} timestampOffset\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static parseCues_(cuesElement, segmentOffset, timecodeScale, duration,\n      uris, initSegmentReference, timestampOffset, appendWindowStart,\n      appendWindowEnd) {\n    const references = [];\n    const getUris = () => uris;\n\n    const parser = cuesElement.createParser();\n\n    let lastTime = null;\n    let lastOffset = null;\n\n    while (parser.hasMoreData()) {\n      const elem = parser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_POINT_ID) {\n        continue;\n      }\n\n      const tuple = shaka.media.WebmSegmentIndexParser.parseCuePoint_(elem);\n      if (!tuple) {\n        continue;\n      }\n\n      // Subtract the presentation time offset from the unscaled time\n      const currentTime = timecodeScale * tuple.unscaledTime;\n      const currentOffset = segmentOffset + tuple.relativeOffset;\n\n      if (lastTime != null) {\n        goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n        references.push(\n            new shaka.media.SegmentReference(\n                lastTime + timestampOffset,\n                currentTime + timestampOffset,\n                getUris,\n                /* startByte= */ lastOffset, /* endByte= */ currentOffset - 1,\n                initSegmentReference,\n                timestampOffset,\n                appendWindowStart,\n                appendWindowEnd));\n      }\n\n      lastTime = currentTime;\n      lastOffset = currentOffset;\n    }\n\n    if (lastTime != null) {\n      goog.asserts.assert(lastOffset != null, 'last offset cannot be null');\n\n      references.push(\n          new shaka.media.SegmentReference(\n              lastTime + timestampOffset,\n              duration + timestampOffset,\n              getUris,\n              /* startByte= */ lastOffset, /* endByte= */ null,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart,\n              appendWindowEnd));\n    }\n\n    return references;\n  }\n\n\n  /**\n   * Parses a WebM CuePointElement to get an \"unadjusted\" segment reference.\n   * @param {shaka.util.EbmlElement} cuePointElement\n   * @return {{unscaledTime: number, relativeOffset: number}} The referenced\n   *   segment's start time in units of [T] (see parseInfo_()), and the\n   *   referenced segment's offset in bytes, relative to a WebM Segment\n   *   element.\n   * @private\n   */\n  static parseCuePoint_(cuePointElement) {\n    const parser = cuePointElement.createParser();\n\n    // Parse CueTime element.\n    const cueTimeElement = parser.parseElement();\n    if (cueTimeElement.id != shaka.media.WebmSegmentIndexParser.CUE_TIME_ID) {\n      shaka.log.warning('Not a CueTime element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING);\n    }\n    const unscaledTime = cueTimeElement.getUint();\n\n    // Parse CueTrackPositions element.\n    const cueTrackPositionsElement = parser.parseElement();\n    if (cueTrackPositionsElement.id !=\n        shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID) {\n      shaka.log.warning('Not a CueTrackPositions element.');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MEDIA,\n          shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING);\n    }\n\n    const cueTrackParser = cueTrackPositionsElement.createParser();\n    let relativeOffset = 0;\n\n    while (cueTrackParser.hasMoreData()) {\n      const elem = cueTrackParser.parseElement();\n      if (elem.id != shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION) {\n        continue;\n      }\n\n      relativeOffset = elem.getUint();\n      break;\n    }\n\n    return {unscaledTime: unscaledTime, relativeOffset: relativeOffset};\n  }\n};\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.EBML_ID = 0x1a45dfa3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.SEGMENT_ID = 0x18538067;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.INFO_ID = 0x1549a966;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID = 0x2ad7b1;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.DURATION_ID = 0x4489;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUES_ID = 0x1c53bb6b;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_POINT_ID = 0xbb;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TIME_ID = 0xb3;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID = 0xb7;\n\n\n/** @const {number} */\nshaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION = 0xf1;\n\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentBase');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.Mp4SegmentIndexParser');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.WebmSegmentIndexParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\ngoog.requireType('shaka.media.PresentationTimeline');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * @summary A set of functions for parsing SegmentBase elements.\n */\nshaka.dash.SegmentBase = class {\n  /**\n   * Creates an init segment reference from a Context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {function(?shaka.dash.DashParser.InheritanceFrame):Element} callback\n   * @return {shaka.media.InitSegmentReference}\n   */\n  static createInitSegment(context, callback) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const initialization =\n        MpdUtils.inheritChild(context, callback, 'Initialization');\n    if (!initialization) {\n      return null;\n    }\n\n    let resolvedUris = context.representation.baseUris;\n    const uri = initialization.getAttribute('sourceURL');\n    if (uri) {\n      resolvedUris = ManifestParserUtils.resolveUris(\n          context.representation.baseUris, [uri]);\n    }\n\n    let startByte = 0;\n    let endByte = null;\n    const range =\n        XmlUtils.parseAttr(initialization, 'range', XmlUtils.parseRange);\n    if (range) {\n      startByte = range.start;\n      endByte = range.end;\n    }\n\n    const getUris = () => resolvedUris;\n    const qualityInfo = shaka.dash.SegmentBase.createQualityInfo(context);\n    return new shaka.media.InitSegmentReference(\n        getUris, startByte, endByte, qualityInfo);\n  }\n\n  /**\n   * Creates a new StreamInfo object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(context, requestInitSegment) {\n    goog.asserts.assert(context.representation.segmentBase,\n        'Should only be called with SegmentBase');\n    // Since SegmentBase does not need updates, simply treat any call as\n    // the initial parse.\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const unscaledPresentationTimeOffset = Number(MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'presentationTimeOffset')) || 0;\n\n    const timescaleStr = MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'timescale');\n    let timescale = 1;\n    if (timescaleStr) {\n      timescale = XmlUtils.parsePositiveInt(timescaleStr) || 1;\n    }\n\n    const scaledPresentationTimeOffset =\n        (unscaledPresentationTimeOffset / timescale) || 0;\n\n    const initSegmentReference =\n        SegmentBase.createInitSegment(context, SegmentBase.fromInheritance_);\n\n    // Throws an immediate error if the format is unsupported.\n    SegmentBase.checkSegmentIndexRangeSupport_(context, initSegmentReference);\n\n    // Direct fields of context will be reassigned by the parser before\n    // generateSegmentIndex is called.  So we must make a shallow copy first,\n    // and use that in the generateSegmentIndex callbacks.\n    const shallowCopyOfContext =\n        shaka.util.ObjectUtils.shallowCloneObject(context);\n\n    return {\n      generateSegmentIndex: () => {\n        return SegmentBase.generateSegmentIndex_(\n            shallowCopyOfContext, requestInitSegment, initSegmentReference,\n            scaledPresentationTimeOffset);\n      },\n    };\n  }\n\n  /**\n   * Creates a SegmentIndex for the given URIs and context.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {!Array.<string>} uris\n   * @param {number} startByte\n   * @param {?number} endByte\n   * @param {number} scaledPresentationTimeOffset\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   */\n  static async generateSegmentIndexFromUris(\n      context, requestInitSegment, initSegmentReference, uris, startByte,\n      endByte, scaledPresentationTimeOffset) {\n    // Unpack context right away, before we start an async process.\n    // This immunizes us against changes to the context object later.\n    /** @type {shaka.media.PresentationTimeline} */\n    const presentationTimeline = context.presentationTimeline;\n    const fitLast = !context.dynamic || !context.periodInfo.isLastPeriod;\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n    const containerType = context.representation.mimeType.split('/')[1];\n\n    // Create a local variable to bind to so we can set to null to help the GC.\n    let localRequest = requestInitSegment;\n    let segmentIndex = null;\n\n    const responses = [\n      localRequest(uris, startByte, endByte),\n      containerType == 'webm' ?\n          localRequest(\n              initSegmentReference.getUris(),\n              initSegmentReference.startByte,\n              initSegmentReference.endByte) :\n          null,\n    ];\n\n    localRequest = null;\n    const results = await Promise.all(responses);\n    const indexData = results[0];\n    const initData = results[1] || null;\n    /** @type {Array.<!shaka.media.SegmentReference>} */\n    let references = null;\n\n    const timestampOffset = periodStart - scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    if (containerType == 'mp4') {\n      references = shaka.media.Mp4SegmentIndexParser.parse(\n          indexData, startByte, uris, initSegmentReference, timestampOffset,\n          appendWindowStart, appendWindowEnd);\n    } else {\n      goog.asserts.assert(initData, 'WebM requires init data');\n      references = shaka.media.WebmSegmentIndexParser.parse(\n          indexData, initData, uris, initSegmentReference, timestampOffset,\n          appendWindowStart, appendWindowEnd);\n    }\n\n    presentationTimeline.notifySegments(references);\n\n    // Since containers are never updated, we don't need to store the\n    // segmentIndex in the map.\n    goog.asserts.assert(!segmentIndex,\n        'Should not call generateSegmentIndex twice');\n\n    segmentIndex = new shaka.media.SegmentIndex(references);\n    if (fitLast) {\n      segmentIndex.fit(appendWindowStart, appendWindowEnd, /* isNew= */ true);\n    }\n    return segmentIndex;\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentBase;\n  }\n\n  /**\n   * Compute the byte range of the segment index from the container.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {?{start: number, end: number}}\n   * @private\n   */\n  static computeIndexRange_(context) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const representationIndex = MpdUtils.inheritChild(\n        context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n    const indexRangeElem = MpdUtils.inheritAttribute(\n        context, SegmentBase.fromInheritance_, 'indexRange');\n\n    let indexRange = XmlUtils.parseRange(indexRangeElem || '');\n    if (representationIndex) {\n      indexRange = XmlUtils.parseAttr(\n          representationIndex, 'range', XmlUtils.parseRange, indexRange);\n    }\n    return indexRange;\n  }\n\n  /**\n   * Compute the URIs of the segment index from the container.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {!Array.<string>}\n   * @private\n   */\n  static computeIndexUris_(context) {\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const MpdUtils = shaka.dash.MpdUtils;\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    const representationIndex = MpdUtils.inheritChild(\n        context, SegmentBase.fromInheritance_, 'RepresentationIndex');\n\n    let indexUris = context.representation.baseUris;\n    if (representationIndex) {\n      const representationUri = representationIndex.getAttribute('sourceURL');\n      if (representationUri) {\n        indexUris = ManifestParserUtils.resolveUris(\n            context.representation.baseUris, [representationUri]);\n      }\n    }\n\n    return indexUris;\n  }\n\n  /**\n   * Check if this type of segment index is supported.  This allows for\n   * immediate errors during parsing, as opposed to an async error from\n   * createSegmentIndex().\n   *\n   * Also checks for a valid byte range, which is not required for callers from\n   * SegmentTemplate.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @private\n   */\n  static checkSegmentIndexRangeSupport_(context, initSegmentReference) {\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    SegmentBase.checkSegmentIndexSupport(context, initSegmentReference);\n\n    const indexRange = SegmentBase.computeIndexRange_(context);\n    if (!indexRange) {\n      shaka.log.error(\n          'SegmentBase does not contain sufficient segment information:',\n          'the SegmentBase does not contain @indexRange',\n          'or a RepresentationIndex element.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Check if this type of segment index is supported.  This allows for\n   * immediate errors during parsing, as opposed to an async error from\n   * createSegmentIndex().\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   */\n  static checkSegmentIndexSupport(context, initSegmentReference) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const contentType = context.representation.contentType;\n    const containerType = context.representation.mimeType.split('/')[1];\n\n    if (contentType != ContentType.TEXT && containerType != 'mp4' &&\n        containerType != 'webm') {\n      shaka.log.error(\n          'SegmentBase specifies an unsupported container type.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER);\n    }\n\n    if ((containerType == 'webm') && !initSegmentReference) {\n      shaka.log.error(\n          'SegmentBase does not contain sufficient segment information:',\n          'the SegmentBase uses a WebM container,',\n          'but does not contain an Initialization element.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_WEBM_MISSING_INIT);\n    }\n  }\n\n  /**\n   * Generate a SegmentIndex from a Context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {number} scaledPresentationTimeOffset\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndex_(\n      context, requestInitSegment, initSegmentReference,\n      scaledPresentationTimeOffset) {\n    const SegmentBase = shaka.dash.SegmentBase;\n\n    const indexUris = SegmentBase.computeIndexUris_(context);\n    const indexRange = SegmentBase.computeIndexRange_(context);\n    goog.asserts.assert(indexRange, 'Index range should not be null!');\n\n    return shaka.dash.SegmentBase.generateSegmentIndexFromUris(\n        context, requestInitSegment, initSegmentReference, indexUris,\n        indexRange.start, indexRange.end,\n        scaledPresentationTimeOffset);\n  }\n\n  /**\n   * Create a MediaQualityInfo object from a Context object.\n   *\n   * @param {!shaka.dash.DashParser.Context} context\n   * @return {!shaka.extern.MediaQualityInfo}\n   */\n  static createQualityInfo(context) {\n    const representation = context.representation;\n    return {\n      bandwidth: context.bandwidth,\n      audioSamplingRate: representation.audioSamplingRate,\n      codecs: representation.codecs,\n      contentType: representation.contentType,\n      frameRate: representation.frameRate || null,\n      height: representation.height || null,\n      mimeType: representation.mimeType,\n      channelsCount: representation.numChannels,\n      pixelAspectRatio: representation.pixelAspectRatio || null,\n      width: representation.width || null,\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentList');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary A set of functions for parsing SegmentList elements.\n */\nshaka.dash.SegmentList = class {\n  /**\n   * Creates a new StreamInfo object.\n   * Updates the existing SegmentIndex, if any.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Object.<string, !shaka.extern.Stream>} streamMap\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(context, streamMap) {\n    goog.asserts.assert(context.representation.segmentList,\n        'Should only be called with SegmentList');\n    const SegmentList = shaka.dash.SegmentList;\n\n    const initSegmentReference = shaka.dash.SegmentBase.createInitSegment(\n        context, SegmentList.fromInheritance_);\n    const info = SegmentList.parseSegmentListInfo_(context);\n\n    SegmentList.checkSegmentListInfo_(context, info);\n\n    /** @type {shaka.media.SegmentIndex} */\n    let segmentIndex = null;\n    let stream = null;\n    if (context.period.id && context.representation.id) {\n      // Only check/store the index if period and representation IDs are set.\n      const id = context.period.id + ',' + context.representation.id;\n      stream = streamMap[id];\n      if (stream) {\n        segmentIndex = stream.segmentIndex;\n      }\n    }\n\n    const references = SegmentList.createSegmentReferences_(\n        context.periodInfo.start, context.periodInfo.duration,\n        info.startNumber, context.representation.baseUris, info,\n        initSegmentReference);\n\n    const isNew = !segmentIndex;\n    if (segmentIndex) {\n      const start = context.presentationTimeline.getSegmentAvailabilityStart();\n      segmentIndex.mergeAndEvict(references, start);\n    } else {\n      segmentIndex = new shaka.media.SegmentIndex(references);\n    }\n    context.presentationTimeline.notifySegments(references);\n\n    if (!context.dynamic || !context.periodInfo.isLastPeriod) {\n      const periodStart = context.periodInfo.start;\n      const periodEnd = context.periodInfo.duration ?\n          context.periodInfo.start + context.periodInfo.duration : Infinity;\n      segmentIndex.fit(periodStart, periodEnd, isNew);\n    }\n\n    if (stream) {\n      stream.segmentIndex = segmentIndex;\n    }\n\n    return {\n      generateSegmentIndex: () => {\n        if (!segmentIndex || segmentIndex.isEmpty()) {\n          segmentIndex.merge(references);\n        }\n        return Promise.resolve(segmentIndex);\n      },\n    };\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentList;\n  }\n\n  /**\n   * Parses the SegmentList items to create an info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.dash.SegmentList.SegmentListInfo}\n   * @private\n   */\n  static parseSegmentListInfo_(context) {\n    const SegmentList = shaka.dash.SegmentList;\n    const MpdUtils = shaka.dash.MpdUtils;\n\n    const mediaSegments = SegmentList.parseMediaSegments_(context);\n    const segmentInfo =\n        MpdUtils.parseSegmentInfo(context, SegmentList.fromInheritance_);\n\n    let startNumber = segmentInfo.startNumber;\n    if (startNumber == 0) {\n      shaka.log.warning('SegmentList@startNumber must be > 0');\n      startNumber = 1;\n    }\n\n    let startTime = 0;\n    if (segmentInfo.segmentDuration) {\n      // See DASH sec. 5.3.9.5.3\n      // Don't use presentationTimeOffset for @duration.\n      startTime = segmentInfo.segmentDuration * (startNumber - 1);\n    } else if (segmentInfo.timeline && segmentInfo.timeline.length > 0) {\n      // The presentationTimeOffset was considered in timeline creation.\n      startTime = segmentInfo.timeline[0].start;\n    }\n\n    return {\n      segmentDuration: segmentInfo.segmentDuration,\n      startTime: startTime,\n      startNumber: startNumber,\n      scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n      timeline: segmentInfo.timeline,\n      mediaSegments: mediaSegments,\n    };\n  }\n\n  /**\n   * Checks whether a SegmentListInfo object is valid.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentList.SegmentListInfo} info\n   * @private\n   */\n  static checkSegmentListInfo_(context, info) {\n    if (!info.segmentDuration && !info.timeline &&\n        info.mediaSegments.length > 1) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList specifies multiple segments,',\n          'but does not specify a segment duration or timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n\n    if (!info.segmentDuration && !context.periodInfo.duration &&\n        !info.timeline && info.mediaSegments.length == 1) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList specifies one segment,',\n          'but does not specify a segment duration, period duration,',\n          'or timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n\n    if (info.timeline && info.timeline.length == 0) {\n      shaka.log.warning(\n          'SegmentList does not contain sufficient segment information:',\n          'the SegmentList has an empty timeline.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Creates an array of segment references for the given data.\n   *\n   * @param {number} periodStart in seconds.\n   * @param {?number} periodDuration in seconds.\n   * @param {number} startNumber\n   * @param {!Array.<string>} baseUris\n   * @param {shaka.dash.SegmentList.SegmentListInfo} info\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static createSegmentReferences_(\n      periodStart, periodDuration, startNumber, baseUris, info,\n      initSegmentReference) {\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    let max = info.mediaSegments.length;\n    if (info.timeline && info.timeline.length != info.mediaSegments.length) {\n      max = Math.min(info.timeline.length, info.mediaSegments.length);\n      shaka.log.warning(\n          'The number of items in the segment timeline and the number of ',\n          'segment URLs do not match, truncating', info.mediaSegments.length,\n          'to', max);\n    }\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n    let prevEndTime = info.startTime;\n    for (let i = 0; i < max; i++) {\n      const segment = info.mediaSegments[i];\n      const mediaUri = ManifestParserUtils.resolveUris(\n          baseUris, [segment.mediaUri]);\n\n      const startTime = prevEndTime;\n      let endTime;\n\n      if (info.segmentDuration != null) {\n        endTime = startTime + info.segmentDuration;\n      } else if (info.timeline) {\n        // Ignore the timepoint start since they are continuous.\n        endTime = info.timeline[i].end;\n      } else {\n        // If segmentDuration and timeline are null then there must\n        // be exactly one segment.\n        goog.asserts.assert(\n            info.mediaSegments.length == 1 && periodDuration,\n            'There should be exactly one segment with a Period duration.');\n        endTime = startTime + periodDuration;\n      }\n\n      const getUris = () => mediaUri;\n      references.push(\n          new shaka.media.SegmentReference(\n              periodStart + startTime,\n              periodStart + endTime,\n              getUris,\n              segment.start,\n              segment.end,\n              initSegmentReference,\n              timestampOffset,\n              appendWindowStart, appendWindowEnd));\n      prevEndTime = endTime;\n    }\n\n    return references;\n  }\n\n  /**\n   * Parses the media URIs from the context.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {!Array.<shaka.dash.SegmentList.MediaSegment>}\n   * @private\n   */\n  static parseMediaSegments_(context) {\n    const Functional = shaka.util.Functional;\n    /** @type {!Array.<!Element>} */\n    const segmentLists = [\n      context.representation.segmentList,\n      context.adaptationSet.segmentList,\n      context.period.segmentList,\n    ].filter(Functional.isNotNull);\n\n    const XmlUtils = shaka.util.XmlUtils;\n    // Search each SegmentList for one with at least one SegmentURL element,\n    // select the first one, and convert each SegmentURL element to a tuple.\n    return segmentLists\n        .map((node) => { return XmlUtils.findChildren(node, 'SegmentURL'); })\n        .reduce((all, part) => { return all.length > 0 ? all : part; })\n        .map((urlNode) => {\n          if (urlNode.getAttribute('indexRange') &&\n              !context.indexRangeWarningGiven) {\n            context.indexRangeWarningGiven = true;\n            shaka.log.warning(\n                'We do not support the SegmentURL@indexRange attribute on ' +\n                'SegmentList.  We only use the SegmentList@duration ' +\n                'attribute or SegmentTimeline, which must be accurate.');\n          }\n\n          const uri = urlNode.getAttribute('media');\n          const range = XmlUtils.parseAttr(\n              urlNode, 'mediaRange', XmlUtils.parseRange,\n              {start: 0, end: null});\n          return {mediaUri: uri, start: range.start, end: range.end};\n        });\n  }\n};\n\n/**\n * @typedef {{\n *   mediaUri: string,\n *   start: number,\n *   end: ?number\n * }}\n *\n * @property {string} mediaUri\n *   The URI of the segment.\n * @property {number} start\n *   The start byte of the segment.\n * @property {?number} end\n *   The end byte of the segment, or null.\n */\nshaka.dash.SegmentList.MediaSegment;\n\n/**\n * @typedef {{\n *   segmentDuration: ?number,\n *   startTime: number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaSegments: !Array.<shaka.dash.SegmentList.MediaSegment>\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentList.\n *\n * @property {?number} segmentDuration\n *   The duration of the segments, if given.\n * @property {number} startTime\n *   The start time of the first segment, in seconds.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The scaledPresentationTimeOffset of the representation, in seconds.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {!Array.<shaka.dash.SegmentList.MediaSegment>} mediaSegments\n *   The URI and byte-ranges of the media segments.\n */\nshaka.dash.SegmentList.SegmentListInfo;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.SegmentTemplate');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.log');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.ObjectUtils');\ngoog.requireType('shaka.dash.DashParser');\n\n\n/**\n * @summary A set of functions for parsing SegmentTemplate elements.\n */\nshaka.dash.SegmentTemplate = class {\n  /**\n   * Creates a new StreamInfo object.\n   * Updates the existing SegmentIndex, if any.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *   requestInitSegment\n   * @param {!Object.<string, !shaka.extern.Stream>} streamMap\n   * @param {boolean} isUpdate True if the manifest is being updated.\n   * @param {number} segmentLimit The maximum number of segments to generate for\n   *   a SegmentTemplate with fixed duration.\n   * @param {!Object.<string, number>} periodDurationMap\n   * @return {shaka.dash.DashParser.StreamInfo}\n   */\n  static createStreamInfo(\n      context, requestInitSegment, streamMap, isUpdate, segmentLimit,\n      periodDurationMap) {\n    goog.asserts.assert(context.representation.segmentTemplate,\n        'Should only be called with SegmentTemplate');\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n    const initSegmentReference = SegmentTemplate.createInitSegment_(context);\n    const info = SegmentTemplate.parseSegmentTemplateInfo_(context);\n\n    SegmentTemplate.checkSegmentTemplateInfo_(context, info);\n\n    // Direct fields of context will be reassigned by the parser before\n    // generateSegmentIndex is called.  So we must make a shallow copy first,\n    // and use that in the generateSegmentIndex callbacks.\n    const shallowCopyOfContext =\n        shaka.util.ObjectUtils.shallowCloneObject(context);\n\n    if (info.indexTemplate) {\n      shaka.dash.SegmentBase.checkSegmentIndexSupport(\n          context, initSegmentReference);\n\n      return {\n        generateSegmentIndex: () => {\n          return SegmentTemplate.generateSegmentIndexFromIndexTemplate_(\n              shallowCopyOfContext, requestInitSegment, initSegmentReference,\n              info);\n        },\n      };\n    } else if (info.segmentDuration) {\n      if (!isUpdate && context.adaptationSet.contentType !== 'image') {\n        context.presentationTimeline.notifyMaxSegmentDuration(\n            info.segmentDuration);\n        context.presentationTimeline.notifyMinSegmentStartTime(\n            context.periodInfo.start);\n      }\n\n      return {\n        generateSegmentIndex: () => {\n          return SegmentTemplate.generateSegmentIndexFromDuration_(\n              shallowCopyOfContext, info, segmentLimit, initSegmentReference,\n              periodDurationMap);\n        },\n      };\n    } else {\n      /** @type {shaka.media.SegmentIndex} */\n      let segmentIndex = null;\n      let id = null;\n      let stream = null;\n      if (context.period.id && context.representation.id) {\n        // Only check/store the index if period and representation IDs are set.\n        id = context.period.id + ',' + context.representation.id;\n        stream = streamMap[id];\n        if (stream) {\n          segmentIndex = stream.segmentIndex;\n        }\n      }\n\n      const references = SegmentTemplate.createFromTimeline_(\n          shallowCopyOfContext, info, initSegmentReference);\n\n      const periodStart = context.periodInfo.start;\n      const periodEnd = context.periodInfo.duration ?\n          context.periodInfo.start + context.periodInfo.duration : Infinity;\n\n      /* When to fit segments.  All refactors should honor/update this table:\n       *\n       * | dynamic | infinite | last   | should | notes                     |\n       * |         | period   | period | fit    |                           |\n       * | ------- | -------- | ------ | ------ | ------------------------- |\n       * |     F   |     F    |    X   |    T   | typical VOD               |\n       * |     F   |     T    |    X   |    X   | impossible: infinite VOD  |\n       * |     T   |     F    |    F   |    T   | typical live, old period  |\n       * |     T   |     F    |    T   |    F   | typical IPR               |\n       * |     T   |     T    |    F   |    X   | impossible: old, infinite |\n       * |     T   |     T    |    T   |    F   | typical live, new period  |\n       */\n\n      // We never fit the final period of dynamic content, which could be\n      // infinite live (with no limit to fit to) or IPR (which would expand the\n      // most recent segment to the end of the presentation).\n      const shouldFit = !(context.dynamic && context.periodInfo.isLastPeriod);\n\n      if (segmentIndex) {\n        if (shouldFit) {\n          // Fit the new references before merging them, so that the merge\n          // algorithm has a more accurate view of their start and end times.\n          const wrapper = new shaka.media.SegmentIndex(references);\n          wrapper.fit(periodStart, periodEnd, /* isNew= */ true);\n        }\n\n        segmentIndex.mergeAndEvict(references,\n            context.presentationTimeline.getSegmentAvailabilityStart());\n      } else {\n        segmentIndex = new shaka.media.SegmentIndex(references);\n      }\n      context.presentationTimeline.notifySegments(references);\n\n      if (shouldFit) {\n        segmentIndex.fit(periodStart, periodEnd);\n      }\n\n      if (stream && context.dynamic) {\n        stream.segmentIndex = segmentIndex;\n      }\n\n      return {\n        generateSegmentIndex: () => {\n          // If segmentIndex is deleted, or segmentIndex's references are\n          // released by closeSegmentIndex(), we should set the value of\n          // segmentIndex again.\n          if (!segmentIndex || segmentIndex.isEmpty()) {\n            segmentIndex.merge(references);\n          }\n          return Promise.resolve(segmentIndex);\n        },\n      };\n    }\n  }\n\n  /**\n   * @param {?shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {Element}\n   * @private\n   */\n  static fromInheritance_(frame) {\n    return frame.segmentTemplate;\n  }\n\n  /**\n   * Parses a SegmentTemplate element into an info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.dash.SegmentTemplate.SegmentTemplateInfo}\n   * @private\n   */\n  static parseSegmentTemplateInfo_(context) {\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n    const MpdUtils = shaka.dash.MpdUtils;\n    const segmentInfo =\n        MpdUtils.parseSegmentInfo(context, SegmentTemplate.fromInheritance_);\n\n    const media = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'media');\n    const index = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'index');\n\n    return {\n      segmentDuration: segmentInfo.segmentDuration,\n      timescale: segmentInfo.timescale,\n      startNumber: segmentInfo.startNumber,\n      scaledPresentationTimeOffset: segmentInfo.scaledPresentationTimeOffset,\n      unscaledPresentationTimeOffset:\n          segmentInfo.unscaledPresentationTimeOffset,\n      timeline: segmentInfo.timeline,\n      mediaTemplate: media,\n      indexTemplate: index,\n    };\n  }\n\n  /**\n   * Verifies a SegmentTemplate info object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @private\n   */\n  static checkSegmentTemplateInfo_(context, info) {\n    let n = 0;\n    n += info.indexTemplate ? 1 : 0;\n    n += info.timeline ? 1 : 0;\n    n += info.segmentDuration ? 1 : 0;\n\n    if (n == 0) {\n      shaka.log.error(\n          'SegmentTemplate does not contain any segment information:',\n          'the SegmentTemplate must contain either an index URL template',\n          'a SegmentTimeline, or a segment duration.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    } else if (n != 1) {\n      shaka.log.warning(\n          'SegmentTemplate containes multiple segment information sources:',\n          'the SegmentTemplate should only contain an index URL template,',\n          'a SegmentTimeline or a segment duration.',\n          context.representation);\n      if (info.indexTemplate) {\n        shaka.log.info('Using the index URL template by default.');\n        info.timeline = null;\n        info.segmentDuration = null;\n      } else {\n        goog.asserts.assert(info.timeline, 'There should be a timeline');\n        shaka.log.info('Using the SegmentTimeline by default.');\n        info.segmentDuration = null;\n      }\n    }\n\n    if (!info.indexTemplate && !info.mediaTemplate) {\n      shaka.log.error(\n          'SegmentTemplate does not contain sufficient segment information:',\n          'the SegmentTemplate\\'s media URL template is missing.',\n          context.representation);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_NO_SEGMENT_INFO);\n    }\n  }\n\n  /**\n   * Generates a SegmentIndex from an index URL template.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.DashParser.RequestInitSegmentCallback}\n   *     requestInitSegment\n   * @param {shaka.media.InitSegmentReference} init\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndexFromIndexTemplate_(\n      context, requestInitSegment, init, info) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    goog.asserts.assert(info.indexTemplate, 'must be using index template');\n    const filledTemplate = MpdUtils.fillUriTemplate(\n        info.indexTemplate, context.representation.id,\n        null, context.bandwidth || null, null);\n\n    const resolvedUris = ManifestParserUtils.resolveUris(\n        context.representation.baseUris, [filledTemplate]);\n\n    return shaka.dash.SegmentBase.generateSegmentIndexFromUris(\n        context, requestInitSegment, init, resolvedUris, 0, null,\n        info.scaledPresentationTimeOffset);\n  }\n\n  /**\n   * Generates a SegmentIndex from fixed-duration segments.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @param {number} segmentLimit The maximum number of segments to generate.\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {!Object.<string, number>} periodDurationMap\n   * @return {!Promise.<shaka.media.SegmentIndex>}\n   * @private\n   */\n  static generateSegmentIndexFromDuration_(\n      context, info, segmentLimit, initSegmentReference, periodDurationMap) {\n    goog.asserts.assert(info.mediaTemplate,\n        'There should be a media template with duration');\n\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const presentationTimeline = context.presentationTimeline;\n\n    // Capture values that could change as the parsing context moves on to\n    // other parts of the manifest.\n    const periodStart = context.periodInfo.start;\n    const periodId = context.period.id;\n    const initialPeriodDuration = context.periodInfo.duration;\n\n    // For multi-period live streams the period duration may not be known until\n    // the following period appears in an updated manifest. periodDurationMap\n    // provides the updated period duration.\n    const getPeriodEnd = () => {\n      const periodDuration =\n        (periodId != null && periodDurationMap[periodId]) ||\n        initialPeriodDuration;\n      const periodEnd = periodDuration ?\n        (periodStart + periodDuration) : Infinity;\n      return periodEnd;\n    };\n\n    const segmentDuration = info.segmentDuration;\n    goog.asserts.assert(\n        segmentDuration != null, 'Segment duration must not be null!');\n\n    const startNumber = info.startNumber;\n    const timescale = info.timescale;\n\n    const template = info.mediaTemplate;\n    const bandwidth = context.bandwidth || null;\n    const id = context.representation.id;\n    const baseUris = context.representation.baseUris;\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n\n    // Computes the range of presentation timestamps both within the period and\n    // available.  This is an intersection of the period range and the\n    // availability window.\n    const computeAvailablePeriodRange = () => {\n      return [\n        Math.max(\n            presentationTimeline.getSegmentAvailabilityStart(),\n            periodStart),\n\n        Math.min(\n            presentationTimeline.getSegmentAvailabilityEnd(),\n            getPeriodEnd()),\n      ];\n    };\n\n    // Computes the range of absolute positions both within the period and\n    // available.  The range is inclusive.  These are the positions for which we\n    // will generate segment references.\n    const computeAvailablePositionRange = () => {\n      // In presentation timestamps.\n      const availablePresentationTimes = computeAvailablePeriodRange();\n      goog.asserts.assert(availablePresentationTimes.every(isFinite),\n          'Available presentation times must be finite!');\n      goog.asserts.assert(availablePresentationTimes.every((x) => x >= 0),\n          'Available presentation times must be positive!');\n      goog.asserts.assert(segmentDuration != null,\n          'Segment duration must not be null!');\n\n      // In period-relative timestamps.\n      const availablePeriodTimes =\n          availablePresentationTimes.map((x) => x - periodStart);\n      // These may sometimes be reversed ([1] <= [0]) if the period is\n      // completely unavailable.  The logic will still work if this happens,\n      // because we will simply generate no references.\n\n      // In period-relative positions (0-based).\n      const availablePeriodPositions = [\n        Math.ceil(availablePeriodTimes[0] / segmentDuration),\n        Math.ceil(availablePeriodTimes[1] / segmentDuration) - 1,\n      ];\n\n      // In absolute positions.\n      const availablePresentationPositions =\n          availablePeriodPositions.map((x) => x + startNumber);\n      return availablePresentationPositions;\n    };\n\n    // For Live, we must limit the initial SegmentIndex in size, to avoid\n    // consuming too much CPU or memory for content with gigantic\n    // timeShiftBufferDepth (which can have values up to and including\n    // Infinity).\n    const range = computeAvailablePositionRange();\n    const minPosition = context.dynamic ?\n        Math.max(range[0], range[1] - segmentLimit + 1) :\n        range[0];\n    const maxPosition = range[1];\n\n    const references = [];\n    const createReference = (position) => {\n      // These inner variables are all scoped to the inner loop, and can be used\n      // safely in the callback below.\n\n      goog.asserts.assert(segmentDuration != null,\n          'Segment duration must not be null!');\n\n      // Relative to the period start.\n      const positionWithinPeriod = position - startNumber;\n      const segmentPeriodTime = positionWithinPeriod * segmentDuration;\n\n      // What will appear in the actual segment files.  The media timestamp is\n      // what is expected in the $Time$ template.\n      const segmentMediaTime = segmentPeriodTime +\n          info.scaledPresentationTimeOffset;\n\n      const getUris = () => {\n        const mediaUri = MpdUtils.fillUriTemplate(\n            template, id, position, bandwidth,\n            segmentMediaTime * timescale);\n        return ManifestParserUtils.resolveUris(baseUris, [mediaUri]);\n      };\n\n      // Relative to the presentation.\n      const segmentStart = segmentPeriodTime + periodStart;\n      const trueSegmentEnd = segmentStart + segmentDuration;\n      // Cap the segment end at the period end so that references from the\n      // next period will fit neatly after it.\n      const segmentEnd = Math.min(trueSegmentEnd, getPeriodEnd());\n\n      // This condition will be true unless the segmentStart was >= periodEnd.\n      // If we've done the position calculations correctly, this won't happen.\n      goog.asserts.assert(segmentStart < segmentEnd,\n          'Generated a segment outside of the period!');\n\n      const ref = new shaka.media.SegmentReference(\n          segmentStart,\n          segmentEnd,\n          getUris,\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          initSegmentReference,\n          timestampOffset,\n          /* appendWindowStart= */ periodStart,\n          /* appendWindowEnd= */ getPeriodEnd());\n      // This is necessary information for thumbnail streams:\n      ref.trueEndTime = trueSegmentEnd;\n      return ref;\n    };\n\n    for (let position = minPosition; position <= maxPosition; ++position) {\n      const reference = createReference(position);\n      references.push(reference);\n    }\n\n    /** @type {shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(references);\n\n    // If the availability timeline currently ends before the period, we will\n    // need to add references over time.\n    const willNeedToAddReferences =\n        presentationTimeline.getSegmentAvailabilityEnd() < getPeriodEnd();\n\n    // When we start a live stream with a period that ends within the\n    // availability window we will not need to add more references, but we will\n    // need to evict old references.\n    const willNeedToEvictReferences = presentationTimeline.isLive();\n\n    if (willNeedToAddReferences || willNeedToEvictReferences) {\n      // The period continues to get longer over time, so check for new\n      // references once every |segmentDuration| seconds.\n      // We clamp to |minPosition| in case the initial range was reversed and no\n      // references were generated.  Otherwise, the update would start creating\n      // negative positions for segments in periods which begin in the future.\n      let nextPosition = Math.max(minPosition, maxPosition + 1);\n      segmentIndex.updateEvery(segmentDuration, () => {\n        // Evict any references outside the window.\n        const availabilityStartTime =\n          presentationTimeline.getSegmentAvailabilityStart();\n        segmentIndex.evict(availabilityStartTime);\n\n        // Compute any new references that need to be added.\n        const [_, maxPosition] = computeAvailablePositionRange();\n        const references = [];\n        while (nextPosition <= maxPosition) {\n          const reference = createReference(nextPosition);\n          references.push(reference);\n          nextPosition++;\n        }\n\n        // The timer must continue firing until the entire period is\n        // unavailable, so that all references will be evicted.\n        if (availabilityStartTime > getPeriodEnd() && !references.length) {\n          // Signal stop.\n          return null;\n        }\n        return references;\n      });\n    }\n\n    return Promise.resolve(segmentIndex);\n  }\n\n  /**\n   * Creates segment references from a timeline.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.SegmentTemplate.SegmentTemplateInfo} info\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  static createFromTimeline_(context, info, initSegmentReference) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n\n    const periodStart = context.periodInfo.start;\n    const periodDuration = context.periodInfo.duration;\n\n    const timestampOffset = periodStart - info.scaledPresentationTimeOffset;\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodDuration ?\n        periodStart + periodDuration : Infinity;\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n    for (let i = 0; i < info.timeline.length; i++) {\n      const {start, unscaledStart, end} = info.timeline[i];\n\n      // Note: i = k - 1, where k indicates the k'th segment listed in the MPD.\n      // (See section 5.3.9.5.3 of the DASH spec.)\n      const segmentReplacement = i + info.startNumber;\n\n      // Consider the presentation time offset in segment uri computation\n      const timeReplacement = unscaledStart +\n          info.unscaledPresentationTimeOffset;\n      const repId = context.representation.id;\n      const bandwidth = context.bandwidth || null;\n      const mediaTemplate = info.mediaTemplate;\n      const baseUris = context.representation.baseUris;\n\n      // This callback must not capture any non-local\n      // variables, such as info, context, etc.  Make\n      // sure any values you reference here have\n      // been assigned to local variables within the\n      // loop, or else we will end up with a leak.\n      const createUris =\n          () => {\n            goog.asserts.assert(\n                mediaTemplate,\n                'There should be a media template with a timeline');\n            const mediaUri = MpdUtils.fillUriTemplate(\n                mediaTemplate, repId,\n                segmentReplacement, bandwidth || null, timeReplacement);\n            return ManifestParserUtils\n                .resolveUris(baseUris, [mediaUri])\n                .map((g) => {\n                  return g.toString();\n                });\n          };\n\n      references.push(new shaka.media.SegmentReference(\n          periodStart + start,\n          periodStart + end,\n          createUris,\n          /* startByte= */ 0,\n          /* endByte= */ null,\n          initSegmentReference,\n          timestampOffset,\n          appendWindowStart,\n          appendWindowEnd));\n    }\n\n    return references;\n  }\n\n  /**\n   * Creates an init segment reference from a context object.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @return {shaka.media.InitSegmentReference}\n   * @private\n   */\n  static createInitSegment_(context) {\n    const MpdUtils = shaka.dash.MpdUtils;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const SegmentTemplate = shaka.dash.SegmentTemplate;\n\n    const initialization = MpdUtils.inheritAttribute(\n        context, SegmentTemplate.fromInheritance_, 'initialization');\n    if (!initialization) {\n      return null;\n    }\n\n    const repId = context.representation.id;\n    const bandwidth = context.bandwidth || null;\n    const baseUris = context.representation.baseUris;\n    const getUris = () => {\n      goog.asserts.assert(initialization, 'Should have returned earler');\n      const filledTemplate = MpdUtils.fillUriTemplate(\n          initialization, repId, null, bandwidth, null);\n      const resolvedUris = ManifestParserUtils.resolveUris(\n          baseUris, [filledTemplate]);\n      return resolvedUris;\n    };\n    const qualityInfo = shaka.dash.SegmentBase.createQualityInfo(context);\n    return new shaka.media.InitSegmentReference(getUris, 0, null, qualityInfo);\n  }\n};\n\n/**\n * @typedef {{\n *   timescale: number,\n *   segmentDuration: ?number,\n *   startNumber: number,\n *   scaledPresentationTimeOffset: number,\n *   unscaledPresentationTimeOffset: number,\n *   timeline: Array.<shaka.dash.MpdUtils.TimeRange>,\n *   mediaTemplate: ?string,\n *   indexTemplate: ?string\n * }}\n * @private\n *\n * @description\n * Contains information about a SegmentTemplate.\n *\n * @property {number} timescale\n *   The time-scale of the representation.\n * @property {?number} segmentDuration\n *   The duration of the segments in seconds, if given.\n * @property {number} startNumber\n *   The start number of the segments; 1 or greater.\n * @property {number} scaledPresentationTimeOffset\n *   The presentation time offset of the representation, in seconds.\n * @property {number} unscaledPresentationTimeOffset\n *   The presentation time offset of the representation, in timescale units.\n * @property {Array.<shaka.dash.MpdUtils.TimeRange>} timeline\n *   The timeline of the representation, if given.  Times in seconds.\n * @property {?string} mediaTemplate\n *   The media URI template, if given.\n * @property {?string} indexTemplate\n *   The index URI template, if given.\n */\nshaka.dash.SegmentTemplate.SegmentTemplateInfo;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.PeriodCombiner');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.MetaSegmentIndex');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IReleasable');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.MimeUtils');\n\n/**\n * A utility to combine streams across periods.\n *\n * @implements {shaka.util.IReleasable}\n * @final\n */\nshaka.util.PeriodCombiner = class {\n  /** */\n  constructor() {\n    /** @private {!Array.<shaka.extern.Variant>} */\n    this.variants_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.audioStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.videoStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.textStreams_ = [];\n\n    /** @private {!Array.<shaka.extern.Stream>} */\n    this.imageStreams_ = [];\n\n    /**\n     * The IDs of the periods we have already used to generate streams.\n     * This helps us identify the periods which have been added when a live\n     * stream is updated.\n     *\n     * @private {!Set.<string>}\n     */\n    this.usedPeriodIds_ = new Set();\n  }\n\n  /** @override */\n  release() {\n    const allStreams =\n        this.audioStreams_.concat(this.videoStreams_, this.textStreams_,\n            this.imageStreams_);\n\n    for (const stream of allStreams) {\n      if (stream.segmentIndex) {\n        stream.segmentIndex.release();\n      }\n    }\n\n    this.audioStreams_ = [];\n    this.videoStreams_ = [];\n    this.textStreams_ = [];\n    this.imageStreams_ = [];\n    this.variants_ = [];\n  }\n\n  /** @return {!Array.<shaka.extern.Variant>} */\n  getVariants() {\n    return this.variants_;\n  }\n\n  /** @return {!Array.<shaka.extern.Stream>} */\n  getTextStreams() {\n    // Return a copy of the array because makeTextStreamsForClosedCaptions\n    // may make changes to the contents of the array. Those changes should not\n    // propagate back to the PeriodCombiner.\n    return this.textStreams_.slice();\n  }\n\n  /** @return {!Array.<shaka.extern.Stream>} */\n  getImageStreams() {\n    return this.imageStreams_;\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @param {boolean} isDynamic\n   * @return {!Promise}\n   */\n  async combinePeriods(periods, isDynamic) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    shaka.util.PeriodCombiner.filterOutAudioStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutVideoStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutTextStreamDuplicates_(periods);\n    shaka.util.PeriodCombiner.filterOutImageStreamDuplicates_(periods);\n\n    // Optimization: for single-period VOD, do nothing.  This makes sure\n    // single-period DASH content will be 100% accurately represented in the\n    // output.\n    if (!isDynamic && periods.length == 1) {\n      const firstPeriod = periods[0];\n      this.audioStreams_ = firstPeriod.audioStreams;\n      this.videoStreams_ = firstPeriod.videoStreams;\n      this.textStreams_ = firstPeriod.textStreams;\n      this.imageStreams_ = firstPeriod.imageStreams;\n    } else {\n      // Find the first period we haven't seen before.  Tag all the periods we\n      // see now as \"used\".\n      let firstNewPeriodIndex = -1;\n      for (let i = 0; i < periods.length; i++) {\n        const period = periods[i];\n        if (this.usedPeriodIds_.has(period.id)) {\n          // This isn't new.\n        } else {\n          // This one _is_ new.\n          this.usedPeriodIds_.add(period.id);\n\n          if (firstNewPeriodIndex == -1) {\n            // And it's the _first_ new one.\n            firstNewPeriodIndex = i;\n          }\n        }\n      }\n\n      if (firstNewPeriodIndex == -1) {\n        // Nothing new? Nothing to do.\n        return;\n      }\n\n      const audioStreamsPerPeriod = periods.map(\n          (period) => period.audioStreams);\n      const videoStreamsPerPeriod = periods.map(\n          (period) => period.videoStreams);\n      const textStreamsPerPeriod = periods.map(\n          (period) => period.textStreams);\n      const imageStreamsPerPeriod = periods.map(\n          (period) => period.imageStreams);\n\n      // It's okay to have a period with no text or images, but our algorithm\n      // fails on any period without matching streams.  So we add dummy streams\n      // to each period.  Since we combine text streams by language and image\n      // streams by resolution, we might need a dummy even in periods with these\n      // streams already.\n      for (const textStreams of textStreamsPerPeriod) {\n        textStreams.push(shaka.util.PeriodCombiner.dummyStream_(\n            ContentType.TEXT));\n      }\n      for (const imageStreams of imageStreamsPerPeriod) {\n        imageStreams.push(shaka.util.PeriodCombiner.dummyStream_(\n            ContentType.IMAGE));\n      }\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.audioStreams_,\n          audioStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.videoStreams_,\n          videoStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.textStreams_,\n          textStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n\n      await shaka.util.PeriodCombiner.combine_(\n          this.imageStreams_,\n          imageStreamsPerPeriod,\n          firstNewPeriodIndex,\n          shaka.util.PeriodCombiner.cloneStream_,\n          shaka.util.PeriodCombiner.concatenateStreams_);\n    }\n\n    // Create variants for all audio/video combinations.\n    let nextVariantId = 0;\n    const variants = [];\n    if (!this.videoStreams_.length || !this.audioStreams_.length) {\n      // For audio-only or video-only content, just give each stream its own\n      // variant.\n      const streams = this.videoStreams_.concat(this.audioStreams_);\n      for (const stream of streams) {\n        const id = nextVariantId++;\n        variants.push({\n          id,\n          language: stream.language,\n          primary: stream.primary,\n          audio: stream.type == ContentType.AUDIO ? stream : null,\n          video: stream.type == ContentType.VIDEO ? stream : null,\n          bandwidth: stream.bandwidth || 0,\n          drmInfos: stream.drmInfos,\n          allowedByApplication: true,\n          allowedByKeySystem: true,\n          decodingInfos: [],\n        });\n      }\n    } else {\n      for (const audio of this.audioStreams_) {\n        for (const video of this.videoStreams_) {\n          const commonDrmInfos = shaka.media.DrmEngine.getCommonDrmInfos(\n              audio.drmInfos, video.drmInfos);\n\n          if (audio.drmInfos.length && video.drmInfos.length &&\n              !commonDrmInfos.length) {\n            shaka.log.warning(\n                'Incompatible DRM in audio & video, skipping variant creation.',\n                audio, video);\n            continue;\n          }\n\n          const id = nextVariantId++;\n          variants.push({\n            id,\n            language: audio.language,\n            primary: audio.primary,\n            audio,\n            video,\n            bandwidth: (audio.bandwidth || 0) + (video.bandwidth || 0),\n            drmInfos: commonDrmInfos,\n            allowedByApplication: true,\n            allowedByKeySystem: true,\n            decodingInfos: [],\n          });\n        }\n      }\n    }\n\n    this.variants_ = variants;\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutAudioStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    // Two audio streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredAudios = [];\n      for (const a1 of period.audioStreams) {\n        let duplicate = false;\n        for (const a2 of filteredAudios) {\n          if (a1.id != a2.id &&\n              a1.channelsCount == a2.channelsCount &&\n              a1.language == a2.language &&\n              a1.bandwidth == a2.bandwidth &&\n              a1.label == a2.label &&\n              a1.codecs == a2.codecs &&\n              a1.mimeType == a2.mimeType &&\n              ArrayUtils.hasSameElements(a1.roles, a2.roles) &&\n              a1.audioSamplingRate == a2.audioSamplingRate &&\n              a1.primary == a2.primary) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredAudios.push(a1);\n        }\n      }\n\n      period.audioStreams = filteredAudios;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutTextStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    // Two text streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredTexts = [];\n      for (const t1 of period.textStreams) {\n        let duplicate = false;\n        for (const t2 of filteredTexts) {\n          if (t1.id != t2.id &&\n            t1.language == t2.language &&\n            t1.label == t2.label &&\n            t1.codecs == t2.codecs &&\n            t1.mimeType == t2.mimeType &&\n            t1.bandwidth == t2.bandwidth &&\n            ArrayUtils.hasSameElements(t1.roles, t2.roles)) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredTexts.push(t1);\n        }\n      }\n\n      period.textStreams = filteredTexts;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutVideoStreamDuplicates_(periods) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n    const MapUtils = shaka.util.MapUtils;\n    // Two video streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredVideos = [];\n      for (const v1 of period.videoStreams) {\n        let duplicate = false;\n        for (const v2 of filteredVideos) {\n          if (v1.id != v2.id &&\n              v1.width == v2.width &&\n              v1.frameRate == v2.frameRate &&\n              v1.codecs == v2.codecs &&\n              v1.mimeType == v2.mimeType &&\n              v1.label == v2.label &&\n              ArrayUtils.hasSameElements(v1.roles, v2.roles) &&\n              MapUtils.hasSameElements(v1.closedCaptions, v2.closedCaptions) &&\n              v1.bandwidth == v2.bandwidth) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredVideos.push(v1);\n        }\n      }\n\n      period.videoStreams = filteredVideos;\n    }\n  }\n\n  /**\n   * @param {!Array.<shaka.util.PeriodCombiner.Period>} periods\n   * @private\n   */\n  static filterOutImageStreamDuplicates_(periods) {\n    // Two image streams are considered to be duplicates of\n    // one another if their ids are different, but all the other\n    // information is the same.\n    for (const period of periods) {\n      const filteredImages = [];\n      for (const i1 of period.imageStreams) {\n        let duplicate = false;\n        for (const i2 of filteredImages) {\n          if (i1.id != i2.id &&\n              i1.width == i2.width &&\n              i1.codecs == i2.codecs &&\n              i1.mimeType == i2.mimeType) {\n            duplicate = true;\n          }\n        }\n\n        if (!duplicate) {\n          filteredImages.push(i1);\n        }\n      }\n\n      period.imageStreams = filteredImages;\n    }\n  }\n\n  /**\n   * Stitch together DB streams across periods, taking a mix of stream types.\n   * The offline database does not separate these by type.\n   *\n   * Unlike the DASH case, this does not need to maintain any state for manifest\n   * updates.\n   *\n   * @param {!Array.<!Array.<shaka.extern.StreamDB>>} streamDbsPerPeriod\n   * @return {!Promise.<!Array.<shaka.extern.StreamDB>>}\n   */\n  static async combineDbStreams(streamDbsPerPeriod) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    // Optimization: for single-period content, do nothing.  This makes sure\n    // single-period DASH or any HLS content stored offline will be 100%\n    // accurately represented in the output.\n    if (streamDbsPerPeriod.length == 1) {\n      return streamDbsPerPeriod[0];\n    }\n\n    const audioStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.AUDIO));\n    const videoStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.VIDEO));\n    const textStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.TEXT));\n    const imageStreamDbsPerPeriod = streamDbsPerPeriod.map(\n        (streams) => streams.filter((s) => s.type == ContentType.IMAGE));\n\n    // It's okay to have a period with no text or images, but our algorithm\n    // fails on any period without matching streams.  So we add dummy streams to\n    // each period.  Since we combine text streams by language and image streams\n    // by resolution, we might need a dummy even in periods with these streams\n    // already.\n    for (const textStreams of textStreamDbsPerPeriod) {\n      textStreams.push(shaka.util.PeriodCombiner.dummyStreamDB_(\n          ContentType.TEXT));\n    }\n    for (const imageStreams of imageStreamDbsPerPeriod) {\n      imageStreams.push(shaka.util.PeriodCombiner.dummyStreamDB_(\n          ContentType.IMAGE));\n    }\n\n    const combinedAudioStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        audioStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedVideoStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        videoStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedTextStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        textStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    const combinedImageStreamDbs = await shaka.util.PeriodCombiner.combine_(\n        /* outputStreams= */ [],\n        imageStreamDbsPerPeriod,\n        /* firstNewPeriodIndex= */ 0,\n        shaka.util.PeriodCombiner.cloneStreamDB_,\n        shaka.util.PeriodCombiner.concatenateStreamDBs_);\n\n    // Recreate variantIds from scratch in the output.\n    // HLS content is always single-period, so the early return at the top of\n    // this method would catch all HLS content.  DASH content stored with v3.0\n    // will already be flattened before storage.  Therefore the only content\n    // that reaches this point is multi-period DASH content stored before v3.0.\n    // Such content always had variants generated from all combinations of audio\n    // and video, so we can simply do that now without loss of correctness.\n    let nextVariantId = 0;\n    if (!combinedVideoStreamDbs.length || !combinedAudioStreamDbs.length) {\n      // For audio-only or video-only content, just give each stream its own\n      // variant ID.\n      const combinedStreamDbs =\n          combinedVideoStreamDbs.concat(combinedAudioStreamDbs);\n      for (const stream of combinedStreamDbs) {\n        stream.variantIds = [nextVariantId++];\n      }\n    } else {\n      for (const audio of combinedAudioStreamDbs) {\n        for (const video of combinedVideoStreamDbs) {\n          const id = nextVariantId++;\n          video.variantIds.push(id);\n          audio.variantIds.push(id);\n        }\n      }\n    }\n\n    return combinedVideoStreamDbs\n        .concat(combinedAudioStreamDbs)\n        .concat(combinedTextStreamDbs)\n        .concat(combinedImageStreamDbs);\n  }\n\n  /**\n   * Combine input Streams per period into flat output Streams.\n   * Templatized to handle both DASH Streams and offline StreamDBs.\n   *\n   * @param {!Array.<T>} outputStreams A list of existing output streams, to\n   *   facilitate updates for live DASH content.  Will be modified and returned.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T):T} clone Make a clone of an input stream.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   *\n   * @return {!Promise.<!Array.<T>>} The same array passed to outputStreams,\n   *   modified to include any newly-created streams.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static async combine_(\n      outputStreams, streamsPerPeriod, firstNewPeriodIndex, clone, concat) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    const unusedStreamsPerPeriod = [];\n    for (let i = 0; i < streamsPerPeriod.length; i++) {\n      if (i >= firstNewPeriodIndex) {\n        // This periods streams are all new.\n        unusedStreamsPerPeriod.push(new Set(streamsPerPeriod[i]));\n      } else {\n        // This period's streams have all been used already.\n        unusedStreamsPerPeriod.push(new Set());\n      }\n    }\n\n    // First, extend all existing output Streams into the new periods.\n    for (const outputStream of outputStreams) {\n      // eslint-disable-next-line no-await-in-loop\n      const ok = await shaka.util.PeriodCombiner.extendExistingOutputStream_(\n          outputStream, streamsPerPeriod, firstNewPeriodIndex, concat,\n          unusedStreamsPerPeriod);\n      if (!ok) {\n        // This output Stream was not properly extended to include streams from\n        // the new period.  This is likely a bug in our algorithm, so throw an\n        // error.\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.PERIOD_FLATTENING_FAILED);\n      }\n\n      // This output stream is now complete with content from all known\n      // periods.\n    }  // for (const outputStream of outputStreams)\n\n    for (const unusedStreams of unusedStreamsPerPeriod) {\n      for (const stream of unusedStreams) {\n        // Create a new output stream which includes this input stream.\n        const outputStream =\n            shaka.util.PeriodCombiner.createNewOutputStream_(\n                stream, streamsPerPeriod, clone, concat,\n                unusedStreamsPerPeriod);\n        if (outputStream) {\n          outputStreams.push(outputStream);\n        } else {\n          // This is not a stream we can build output from, but it may become\n          // part of another output based on another period's stream.\n        }\n      }  // for (const stream of unusedStreams)\n    }  // for (const unusedStreams of unusedStreamsPerPeriod)\n\n    for (const unusedStreams of unusedStreamsPerPeriod) {\n      for (const stream of unusedStreams) {\n        const isDummyText = stream.type == ContentType.TEXT && !stream.language;\n        const isDummyImage = stream.type == ContentType.IMAGE &&\n            !stream.tilesLayout;\n        if (isDummyText || isDummyImage) {\n          // This is one of our dummy streams, so ignore it.  We may not use\n          // them all, and that's fine.\n          continue;\n        }\n        // If this stream has a different codec/MIME than any other stream,\n        // then we can't play it.\n        // TODO(#1528): Consider changing this when we support codec switching.\n        const hasCodec = outputStreams.some((s) => {\n          return s.mimeType == stream.mimeType &&\n                shaka.util.MimeUtils.getNormalizedCodec(s.codecs) ==\n                    shaka.util.MimeUtils.getNormalizedCodec(stream.codecs);\n        });\n        if (!hasCodec) {\n          continue;\n        }\n\n        // Any other unused stream is likely a bug in our algorithm, so throw\n        // an error.\n        shaka.log.error('Unused stream in period-flattening!',\n            stream, outputStreams);\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.PERIOD_FLATTENING_FAILED);\n      }\n    }\n\n    return outputStreams;\n  }\n\n  /**\n   * @param {T} outputStream An existing output stream which needs to be\n   *   extended into new periods.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @return {!Promise.<boolean>}\n   *\n   * @template T\n   * Should only be called with a Stream type in practice, but has call sites\n   * from other templated functions that also accept a StreamDB.\n   *\n   * @private\n   */\n  static async extendExistingOutputStream_(\n      outputStream, streamsPerPeriod, firstNewPeriodIndex, concat,\n      unusedStreamsPerPeriod) {\n    shaka.util.PeriodCombiner.findMatchesInAllPeriods_(streamsPerPeriod,\n        outputStream);\n\n    // This only exists where T == Stream, and this should only ever be called\n    // on Stream types.  StreamDB should not have pre-existing output streams.\n    goog.asserts.assert(outputStream.createSegmentIndex,\n        'outputStream should be a Stream type!');\n\n    if (!outputStream.matchedStreams) {\n      // We were unable to extend this output stream.\n      shaka.log.error('No matches extending output stream!',\n          outputStream, streamsPerPeriod);\n      return false;\n    }\n    // We need to create all the per-period segment indexes and append them to\n    // the output's MetaSegmentIndex.\n    if (outputStream.segmentIndex) {\n      await shaka.util.PeriodCombiner.extendOutputSegmentIndex_(outputStream,\n          firstNewPeriodIndex);\n    }\n\n    shaka.util.PeriodCombiner.extendOutputStream_(outputStream,\n        firstNewPeriodIndex, concat, unusedStreamsPerPeriod);\n    return true;\n  }\n\n  /**\n   * Creates the segment indexes for an array of input streams, and append them\n   * to the output stream's segment index.\n   *\n   * @param {shaka.extern.Stream} outputStream\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @private\n   */\n  static async extendOutputSegmentIndex_(outputStream, firstNewPeriodIndex) {\n    const operations = [];\n    const streams = outputStream.matchedStreams;\n    goog.asserts.assert(streams, 'matched streams should be valid');\n\n    for (const stream of streams) {\n      operations.push(stream.createSegmentIndex());\n      if (stream.trickModeVideo && !stream.trickModeVideo.segmentIndex) {\n        operations.push(stream.trickModeVideo.createSegmentIndex());\n      }\n    }\n    await Promise.all(operations);\n\n    // Concatenate the new matches onto the stream, starting at the first new\n    // period.\n    // Satisfy the compiler about the type.\n    // Also checks if the segmentIndex is still valid after the async\n    // operations, to make sure we stop if the active stream has changed.\n    if (outputStream.segmentIndex instanceof shaka.media.MetaSegmentIndex) {\n      for (let i = 0; i < streams.length; i++) {\n        const match = streams[i];\n        if (match.segmentIndex && i >= firstNewPeriodIndex) {\n          goog.asserts.assert(match.segmentIndex,\n              'stream should have a segmentIndex.');\n          outputStream.segmentIndex.appendSegmentIndex(match.segmentIndex);\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new output Stream based on a particular input Stream.  Locates\n   * matching Streams in all other periods and combines them into an output\n   * Stream.\n   * Templatized to handle both DASH Streams and offline StreamDBs.\n   *\n   * @param {T} stream An input stream on which to base the output stream.\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod A list of lists of Streams\n   *   from each period.\n   * @param {function(T):T} clone Make a clone of an input stream.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @return {?T} A newly-created output Stream, or null if matches\n   *   could not be found.`\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static createNewOutputStream_(\n      stream, streamsPerPeriod, clone, concat, unusedStreamsPerPeriod) {\n    // Start by cloning the stream without segments, key IDs, etc.\n    const outputStream = clone(stream);\n\n    // Find best-matching streams in all periods.\n    shaka.util.PeriodCombiner.findMatchesInAllPeriods_(streamsPerPeriod,\n        outputStream);\n\n    // This only exists where T == Stream.\n    if (outputStream.createSegmentIndex) {\n      // Override the createSegmentIndex function of the outputStream.\n      outputStream.createSegmentIndex = async () => {\n        if (!outputStream.segmentIndex) {\n          outputStream.segmentIndex = new shaka.media.MetaSegmentIndex();\n          await shaka.util.PeriodCombiner.extendOutputSegmentIndex_(\n              outputStream, /* firstNewPeriodIndex= */ 0);\n        }\n      };\n      // For T == Stream, we need to create all the per-period segment indexes\n      // in advance.  concat() will add them to the output's MetaSegmentIndex.\n    }\n\n    if (!outputStream.matchedStreams) {\n      // This is not a stream we can build output from, but it may become part\n      // of another output based on another period's stream.\n      return null;\n    }\n    shaka.util.PeriodCombiner.extendOutputStream_(outputStream,\n        /* firstNewPeriodIndex= */ 0, concat, unusedStreamsPerPeriod);\n\n    return outputStream;\n  }\n\n  /**\n   * @param {T} outputStream An existing output stream which needs to be\n   *   extended into new periods.\n   * @param {number} firstNewPeriodIndex An index into streamsPerPeriod which\n   *   represents the first new period that hasn't been processed yet.\n   * @param {function(T, T)} concat Concatenate the second stream onto the end\n   *   of the first.\n   * @param {!Array.<!Set.<T>>} unusedStreamsPerPeriod An array of sets of\n   *   unused streams from each period.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static extendOutputStream_(\n      outputStream, firstNewPeriodIndex, concat, unusedStreamsPerPeriod) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const matches = outputStream.matchedStreams;\n\n    // Assure the compiler that matches didn't become null during the async\n    // operation before.\n    goog.asserts.assert(outputStream.matchedStreams,\n        'matchedStreams should be non-null');\n\n    // Concatenate the new matches onto the stream, starting at the first new\n    // period.\n    for (let i = 0; i < matches.length; i++) {\n      if (i >= firstNewPeriodIndex) {\n        const match = matches[i];\n        concat(outputStream, match);\n\n        // We only consider an audio stream \"used\" if its language is related to\n        // the output language.  There are scenarios where we want to generate\n        // separate tracks for each language, even when we are forced to connect\n        // unrelated languages across periods.\n        let used = true;\n        if (outputStream.type == ContentType.AUDIO) {\n          const relatedness = LanguageUtils.relatedness(\n              outputStream.language, match.language);\n          if (relatedness == 0) {\n            used = false;\n          }\n        }\n\n        if (used) {\n          unusedStreamsPerPeriod[i].delete(match);\n        }\n      }\n    }\n  }\n\n  /**\n   * Clone a Stream to make an output Stream for combining others across\n   * periods.\n   *\n   * @param {shaka.extern.Stream} stream\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  static cloneStream_(stream) {\n    const clone = /** @type {shaka.extern.Stream} */(Object.assign({}, stream));\n\n    // These are wiped out now and rebuilt later from the various per-period\n    // streams that match this output.\n    clone.originalId = null;\n    clone.createSegmentIndex = () => Promise.resolve();\n    clone.closeSegmentIndex = () => {\n      if (clone.segmentIndex) {\n        clone.segmentIndex.release();\n        clone.segmentIndex = null;\n      }\n      // Close the segment index of the matched streams.\n      if (clone.matchedStreams) {\n        for (const match of clone.matchedStreams) {\n          if (match.segmentIndex) {\n            match.segmentIndex.release();\n            match.segmentIndex = null;\n          }\n        }\n      }\n    };\n\n    clone.segmentIndex = null;\n    clone.emsgSchemeIdUris = [];\n    clone.keyIds = new Set();\n    clone.closedCaptions = null;\n    clone.trickModeVideo = null;\n\n    return clone;\n  }\n\n  /**\n   * Clone a StreamDB to make an output stream for combining others across\n   * periods.\n   *\n   * @param {shaka.extern.StreamDB} streamDb\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static cloneStreamDB_(streamDb) {\n    const clone = /** @type {shaka.extern.StreamDB} */(Object.assign(\n        {}, streamDb));\n\n    // These are wiped out now and rebuilt later from the various per-period\n    // streams that match this output.\n    clone.keyIds = new Set();\n    clone.segments = [];\n    clone.variantIds = [];\n    clone.closedCaptions = null;\n\n    return clone;\n  }\n\n  /**\n   * Combine the various fields of the input Stream into the output.\n   *\n   * @param {shaka.extern.Stream} output\n   * @param {shaka.extern.Stream} input\n   * @private\n   */\n  static concatenateStreams_(output, input) {\n    // We keep the original stream's bandwidth, resolution, frame rate,\n    // sample rate, and channel count to ensure that it's properly\n    // matched with similar content in other periods further down\n    // the line.\n\n    // Combine arrays, keeping only the unique elements\n    const combineArrays = (a, b) => Array.from(new Set(a.concat(b)));\n    output.roles = combineArrays(output.roles, input.roles);\n\n    if (input.emsgSchemeIdUris) {\n      output.emsgSchemeIdUris = combineArrays(\n          output.emsgSchemeIdUris, input.emsgSchemeIdUris);\n    }\n\n    const combineSets = (a, b) => new Set([...a, ...b]);\n    output.keyIds = combineSets(output.keyIds, input.keyIds);\n\n    if (output.originalId == null) {\n      output.originalId = input.originalId;\n    } else {\n      output.originalId += ',' + (input.originalId || '');\n    }\n\n    const commonDrmInfos = shaka.media.DrmEngine.getCommonDrmInfos(\n        output.drmInfos, input.drmInfos);\n    if (input.drmInfos.length && output.drmInfos.length &&\n        !commonDrmInfos.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.INCONSISTENT_DRM_ACROSS_PERIODS);\n    }\n    output.drmInfos = commonDrmInfos;\n\n    // The output is encrypted if any input was encrypted.\n    output.encrypted = output.encrypted || input.encrypted;\n\n    // Combine the closed captions maps.\n    if (input.closedCaptions) {\n      if (!output.closedCaptions) {\n        output.closedCaptions = new Map();\n      }\n      for (const [key, value] of input.closedCaptions) {\n        output.closedCaptions.set(key, value);\n      }\n    }\n\n    // Combine trick-play video streams, if present.\n    if (input.trickModeVideo) {\n      if (!output.trickModeVideo) {\n        // Create a fresh output stream for trick-mode playback.\n        output.trickModeVideo = shaka.util.PeriodCombiner.cloneStream_(\n            input.trickModeVideo);\n        // TODO: fix the createSegmentIndex function for trickModeVideo.\n        // The trick-mode tracks in multi-period content should have trick-mode\n        // segment indexes whenever available, rather than only regular-mode\n        // segment indexes.\n        output.trickModeVideo.createSegmentIndex = () => {\n          // Satisfy the compiler about the type.\n          goog.asserts.assert(\n              output.segmentIndex instanceof shaka.media.MetaSegmentIndex,\n              'The stream should have a MetaSegmentIndex.');\n          output.trickModeVideo.segmentIndex = output.segmentIndex.clone();\n          return Promise.resolve();\n        };\n      }\n\n      // Concatenate the trick mode input onto the trick mode output.\n      shaka.util.PeriodCombiner.concatenateStreams_(\n          output.trickModeVideo, input.trickModeVideo);\n    } else if (output.trickModeVideo) {\n      // We have a trick mode output, but no input from this Period.  Fill it in\n      // from the standard input Stream.\n      shaka.util.PeriodCombiner.concatenateStreams_(\n          output.trickModeVideo, input);\n    }\n  }\n\n  /**\n   * Combine the various fields of the input StreamDB into the output.\n   *\n   * @param {shaka.extern.StreamDB} output\n   * @param {shaka.extern.StreamDB} input\n   * @private\n   */\n  static concatenateStreamDBs_(output, input) {\n    // Combine arrays, keeping only the unique elements\n    const combineArrays = (a, b) => Array.from(new Set(a.concat(b)));\n    output.roles = combineArrays(output.roles, input.roles);\n\n    const combineSets = (a, b) => new Set([...a, ...b]);\n    output.keyIds = combineSets(output.keyIds, input.keyIds);\n\n    // The output is encrypted if any input was encrypted.\n    output.encrypted = output.encrypted && input.encrypted;\n\n    // Concatenate segments without de-duping.\n    output.segments.push(...input.segments);\n\n    // Combine the closed captions maps.\n    if (input.closedCaptions) {\n      if (!output.closedCaptions) {\n        output.closedCaptions = new Map();\n      }\n      for (const [key, value] of input.closedCaptions) {\n        output.closedCaptions.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * Finds streams in all periods which match the output stream.\n   *\n   * @param {!Array.<!Array.<T>>} streamsPerPeriod\n   * @param {T} outputStream\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static findMatchesInAllPeriods_(streamsPerPeriod, outputStream) {\n    const matches = [];\n    for (const streams of streamsPerPeriod) {\n      const match = shaka.util.PeriodCombiner.findBestMatchInPeriod_(\n          streams, outputStream);\n      if (!match) {\n        return;\n      }\n      matches.push(match);\n    }\n    outputStream.matchedStreams = matches;\n  }\n\n  /**\n   * Find the best match for the output stream.\n   *\n   * @param {!Array.<T>} streams\n   * @param {T} outputStream\n   * @return {?T}  Returns null if no match can be found.\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static findBestMatchInPeriod_(streams, outputStream) {\n    const areCompatible = {\n      'audio': shaka.util.PeriodCombiner.areAVStreamsCompatible_,\n      'video': shaka.util.PeriodCombiner.areAVStreamsCompatible_,\n      'text': shaka.util.PeriodCombiner.areTextStreamsCompatible_,\n      'image': shaka.util.PeriodCombiner.areImageStreamsCompatible_,\n    }[outputStream.type];\n\n    const isBetterMatch = {\n      'audio': shaka.util.PeriodCombiner.isAudioStreamBetterMatch_,\n      'video': shaka.util.PeriodCombiner.isVideoStreamBetterMatch_,\n      'text': shaka.util.PeriodCombiner.isTextStreamBetterMatch_,\n      'image': shaka.util.PeriodCombiner.isImageStreamBetterMatch_,\n    }[outputStream.type];\n\n    let best = null;\n\n    for (const stream of streams) {\n      if (!areCompatible(outputStream, stream)) {\n        continue;\n      }\n\n      if (!best || isBetterMatch(outputStream, best, stream)) {\n        best = stream;\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * @param {T} outputStream An audio or video output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output stream\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areAVStreamsCompatible_(outputStream, candidate) {\n    const getCodec = (codecs) =>\n      shaka.util.MimeUtils.getNormalizedCodec(codecs);\n    // Check MIME type and codecs, which should always be the same.\n    if (candidate.mimeType != outputStream.mimeType ||\n        getCodec(candidate.codecs) != getCodec(outputStream.codecs)) {\n      return false;\n    }\n\n    // This field is only available on Stream, not StreamDB.\n    if (outputStream.drmInfos) {\n      // Check for compatible DRM systems.  Note that clear streams are\n      // implicitly compatible with any DRM and with each other.\n      if (!shaka.media.DrmEngine.areDrmCompatible(outputStream.drmInfos,\n          candidate.drmInfos)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream A text output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areTextStreamsCompatible_(outputStream, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // For text, we don't care about MIME type or codec.  We can always switch\n    // between text types.\n\n    // The output stream should not be a dummy stream inserted to fill a period\n    // gap.  So reject any candidate if the output has no language.  This would\n    // cause findMatchesInAllPeriods_ to return null and this output stream to\n    // be skipped (meaning no output streams based on it).\n    if (!outputStream.language) {\n      return false;\n    }\n\n    // If the candidate is a dummy, then it is compatible, and we could use it\n    // if nothing else matches.\n    if (!candidate.language) {\n      return true;\n    }\n\n    const languageRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    // We will strictly avoid combining text across languages or \"kinds\"\n    // (caption vs subtitle).\n    if (languageRelatedness == 0 ||\n        candidate.kind != outputStream.kind) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream A image output stream\n   * @param {T} candidate A candidate stream to be combined with the output\n   * @return {boolean} True if the candidate could be combined with the\n   *   output\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static areImageStreamsCompatible_(outputStream, candidate) {\n    // For image, we don't care about MIME type.  We can always switch\n    // between image types.\n\n    // The output stream should not be a dummy stream inserted to fill a period\n    // gap.  So reject any candidate if the output has no tilesLayout.  This\n    // would cause findMatchesInAllPeriods_ to return null and this output\n    // stream to be skipped (meaning no output streams based on it).\n    if (!outputStream.tilesLayout) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {T} outputStream An audio output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isAudioStreamBetterMatch_(outputStream, best, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to determine the best\n    // match.\n\n    // The most important thing is language.  In some cases, we will accept a\n    // different language across periods when we must.\n    const bestRelatedness = LanguageUtils.relatedness(\n        outputStream.language, best.language);\n    const candidateRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    if (candidateRelatedness > bestRelatedness) {\n      return true;\n    }\n    if (candidateRelatedness < bestRelatedness) {\n      return false;\n    }\n\n    // If language-based differences haven't decided this, look at roles.  If\n    // the candidate has more roles in common with the output, upgrade to the\n    // candidate.\n    if (outputStream.roles.length) {\n      const bestRoleMatches =\n          best.roles.filter((role) => outputStream.roles.includes(role));\n      const candidateRoleMatches =\n          candidate.roles.filter((role) => outputStream.roles.includes(role));\n      if (candidateRoleMatches.length > bestRoleMatches.length) {\n        return true;\n      } else if (candidateRoleMatches.length < bestRoleMatches.length) {\n        return false;\n      } else {\n        // Both streams have the same role overlap with the outputStream\n        // If this is the case, choose the stream with the fewer roles overall.\n        // Streams that match best together tend to be streams with the same\n        // roles, e g stream1 with roles [r1, r2] is likely a better match\n        // for stream2 with roles [r1, r2] vs stream3 with roles\n        // [r1, r2, r3, r4].\n        // If we match stream1 with stream3 due to the same role overlap,\n        // stream2 is likely to be left unmatched and error out later.\n        // See https://github.com/shaka-project/shaka-player/issues/2542 for\n        // more details.\n        return candidate.roles.length < best.roles.length;\n      }\n    } else if (!candidate.roles.length && best.roles.length) {\n      // If outputStream has no roles, and only one of the streams has no roles,\n      // choose the one with no roles.\n      return true;\n    } else if (candidate.roles.length && !best.roles.length) {\n      return false;\n    }\n\n    // If the language doesn't match, but the candidate is the \"primary\"\n    // language, then that should be preferred as a fallback.\n    if (!best.primary && candidate.primary) {\n      return true;\n    }\n    if (best.primary && !candidate.primary) {\n      return false;\n    }\n\n    // If language-based and role-based features are equivalent, take the audio\n    // with the closes channel count to the output.\n    const channelsBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.channelsCount,\n            best.channelsCount,\n            candidate.channelsCount);\n    if (channelsBetterOrWorse == BETTER) {\n      return true;\n    } else if (channelsBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // If channels are equal, take the closest sample rate to the output.\n    const sampleRateBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.audioSamplingRate,\n            best.audioSamplingRate,\n            candidate.audioSamplingRate);\n    if (sampleRateBetterOrWorse == BETTER) {\n      return true;\n    } else if (sampleRateBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    if (outputStream.bandwidth) {\n      // Take the audio with the closest bandwidth to the output.\n      const bandwidthBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_(\n              outputStream.bandwidth,\n              best.bandwidth,\n              candidate.bandwidth);\n      if (bandwidthBetterOrWorse == BETTER) {\n        return true;\n      } else if (bandwidthBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A video output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isVideoStreamBetterMatch_(outputStream, best, candidate) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to determine the best\n    // match.\n\n    // Take the video with the closest resolution to the output.\n    const resolutionBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.width * outputStream.height,\n            best.width * best.height,\n            candidate.width * candidate.height);\n    if (resolutionBetterOrWorse == BETTER) {\n      return true;\n    } else if (resolutionBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // We may not know the frame rate for the content, in which case this gets\n    // skipped.\n    if (outputStream.frameRate) {\n      // Take the video with the closest frame rate to the output.\n      const frameRateBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferLower(\n              outputStream.frameRate,\n              best.frameRate,\n              candidate.frameRate);\n      if (frameRateBetterOrWorse == BETTER) {\n        return true;\n      } else if (frameRateBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n\n    if (outputStream.bandwidth) {\n      // Take the video with the closest bandwidth to the output.\n      const bandwidthBetterOrWorse =\n          shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_(\n              outputStream.bandwidth,\n              best.bandwidth,\n              candidate.bandwidth);\n      if (bandwidthBetterOrWorse == BETTER) {\n        return true;\n      } else if (bandwidthBetterOrWorse == WORSE) {\n        return false;\n      }\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A text output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isTextStreamBetterMatch_(outputStream, best, candidate) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Otherwise, compare the streams' characteristics to determine the best\n    // match.\n\n    // The most important thing is language.  In some cases, we will accept a\n    // different language across periods when we must.\n    const bestRelatedness = LanguageUtils.relatedness(\n        outputStream.language, best.language);\n    const candidateRelatedness = LanguageUtils.relatedness(\n        outputStream.language, candidate.language);\n\n    if (candidateRelatedness > bestRelatedness) {\n      return true;\n    }\n    if (candidateRelatedness < bestRelatedness) {\n      return false;\n    }\n\n    // If the language doesn't match, but the candidate is the \"primary\"\n    // language, then that should be preferred as a fallback.\n    if (!best.primary && candidate.primary) {\n      return true;\n    }\n    if (best.primary && !candidate.primary) {\n      return false;\n    }\n\n    // If the candidate has more roles in common with the output, upgrade to the\n    // candidate.\n    if (outputStream.roles.length) {\n      const bestRoleMatches =\n          best.roles.filter((role) => outputStream.roles.includes(role));\n      const candidateRoleMatches =\n          candidate.roles.filter((role) => outputStream.roles.includes(role));\n      if (candidateRoleMatches.length > bestRoleMatches.length) {\n        return true;\n      }\n      if (candidateRoleMatches.length < bestRoleMatches.length) {\n        return false;\n      }\n    } else if (!candidate.roles.length && best.roles.length) {\n      // If outputStream has no roles, and only one of the streams has no roles,\n      // choose the one with no roles.\n      return true;\n    } else if (candidate.roles.length && !best.roles.length) {\n      return false;\n    }\n\n    // If the candidate has the same MIME type and codec, upgrade to the\n    // candidate.  It's not required that text streams use the same format\n    // across periods, but it's a helpful signal.  Some content in our demo app\n    // contains the same languages repeated with two different text formats in\n    // each period.  This condition ensures that all text streams are used.\n    // Otherwise, we wind up with some one stream of each language left unused,\n    // triggering a failure.\n    if (candidate.mimeType == outputStream.mimeType &&\n        candidate.codecs == outputStream.codecs &&\n        (best.mimeType != outputStream.mimeType ||\n         best.codecs != outputStream.codecs)) {\n      return true;\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * @param {T} outputStream A image output stream\n   * @param {T} best The best match so far for this period\n   * @param {T} candidate A candidate stream which might be better\n   * @return {boolean} True if the candidate is a better match\n   *\n   * @template T\n   * Accepts either a StreamDB or Stream type.\n   *\n   * @private\n   */\n  static isImageStreamBetterMatch_(outputStream, best, candidate) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If the output stream was based on the candidate stream, the candidate\n    // stream should be considered a better match. We can check this by\n    // comparing their ids.\n    if (outputStream.id == candidate.id) {\n      return true;\n    }\n\n    // Take the image with the closest resolution to the output.\n    const resolutionBetterOrWorse =\n        shaka.util.PeriodCombiner.compareClosestPreferLower(\n            outputStream.width * outputStream.height,\n            best.width * best.height,\n            candidate.width * candidate.height);\n    if (resolutionBetterOrWorse == BETTER) {\n      return true;\n    } else if (resolutionBetterOrWorse == WORSE) {\n      return false;\n    }\n\n    // If the result of each comparison was inconclusive, default to false.\n    return false;\n  }\n\n  /**\n   * Create a dummy StreamDB to fill in periods that are missing a certain type,\n   * to avoid failing the general flattening algorithm.  This won't be used for\n   * audio or video, since those are strictly required in all periods if they\n   * exist in any period.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} type\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static dummyStreamDB_(type) {\n    return {\n      id: 0,\n      originalId: '',\n      primary: false,\n      type,\n      mimeType: '',\n      codecs: '',\n      language: '',\n      label: null,\n      width: null,\n      height: null,\n      encrypted: false,\n      keyIds: new Set(),\n      segments: [],\n      variantIds: [],\n      roles: [],\n      forced: false,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * Create a dummy Stream to fill in periods that are missing a certain type,\n   * to avoid failing the general flattening algorithm.  This won't be used for\n   * audio or video, since those are strictly required in all periods if they\n   * exist in any period.\n   *\n   * @param {shaka.util.ManifestParserUtils.ContentType} type\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  static dummyStream_(type) {\n    return {\n      id: 0,\n      originalId: '',\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: new shaka.media.SegmentIndex([]),\n      mimeType: '',\n      codecs: '',\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language: '',\n      label: null,\n      type,\n      primary: false,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: [],\n      forced: false,\n      channelsCount: null,\n      audioSamplingRate: null,\n      spatialAudio: false,\n      closedCaptions: null,\n    };\n  }\n\n  /**\n   * Compare the best value so far with the candidate value and the output\n   * value.  Decide if the candidate is better, equal, or worse than the best\n   * so far.  Any value less than or equal to the output is preferred over a\n   * larger value, and closer to the output is better than farther.\n   *\n   * This provides us a generic way to choose things that should match as\n   * closely as possible, like resolution, frame rate, audio channels, or\n   * sample rate.  If we have to go higher to make a match, we will.  But if\n   * the user selects 480p, for example, we don't want to surprise them with\n   * 720p and waste bandwidth if there's another choice available to us.\n   *\n   * @param {number} outputValue\n   * @param {number} bestValue\n   * @param {number} candidateValue\n   * @return {shaka.util.PeriodCombiner.BetterOrWorse}\n   */\n  static compareClosestPreferLower(outputValue, bestValue, candidateValue) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    // If one is the exact match for the output value, and the other isn't,\n    // prefer the one that is the exact match.\n    if (bestValue == outputValue && outputValue != candidateValue) {\n      return WORSE;\n    } else if (candidateValue == outputValue && outputValue != bestValue) {\n      return BETTER;\n    }\n\n    if (bestValue > outputValue) {\n      if (candidateValue <= outputValue) {\n        // Any smaller-or-equal-to-output value is preferable to a\n        // bigger-than-output value.\n        return BETTER;\n      }\n\n      // Both \"best\" and \"candidate\" are greater than the output.  Take\n      // whichever is closer.\n      if (candidateValue - outputValue < bestValue - outputValue) {\n        return BETTER;\n      } else if (candidateValue - outputValue > bestValue - outputValue) {\n        return WORSE;\n      }\n    } else {\n      // The \"best\" so far is less than or equal to the output.  If the\n      // candidate is bigger than the output, we don't want it.\n      if (candidateValue > outputValue) {\n        return WORSE;\n      }\n\n      // Both \"best\" and \"candidate\" are less than or equal to the output.\n      // Take whichever is closer.\n      if (outputValue - candidateValue < outputValue - bestValue) {\n        return BETTER;\n      } else if (outputValue - candidateValue > outputValue - bestValue) {\n        return WORSE;\n      }\n    }\n\n    return EQUAL;\n  }\n\n  /**\n   * @param {number} outputValue\n   * @param {number} bestValue\n   * @param {number} candidateValue\n   * @return {shaka.util.PeriodCombiner.BetterOrWorse}\n   * @private\n   */\n  static compareClosestPreferMinimalAbsDiff_(\n      outputValue, bestValue, candidateValue) {\n    const {BETTER, EQUAL, WORSE} = shaka.util.PeriodCombiner.BetterOrWorse;\n\n    const absDiffBest = Math.abs(outputValue - bestValue);\n    const absDiffCandidate = Math.abs(outputValue - candidateValue);\n    if (absDiffCandidate < absDiffBest) {\n      return BETTER;\n    } else if (absDiffBest < absDiffCandidate) {\n      return WORSE;\n    }\n\n    return EQUAL;\n  }\n};\n\n/**\n * @typedef {{\n *   id: string,\n *   audioStreams: !Array.<shaka.extern.Stream>,\n *   videoStreams: !Array.<shaka.extern.Stream>,\n *   textStreams: !Array.<shaka.extern.Stream>,\n *   imageStreams: !Array.<shaka.extern.Stream>\n * }}\n *\n * @description Contains the streams from one DASH period.\n *\n * @property {string} id\n *   The Period ID.\n * @property {!Array.<shaka.extern.Stream>} audioStreams\n *   The audio streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} videoStreams\n *   The video streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} textStreams\n *   The text streams from one Period.\n * @property {!Array.<shaka.extern.Stream>} imageStreams\n *   The image streams from one Period.\n */\nshaka.util.PeriodCombiner.Period;\n\n/**\n * @enum {number}\n */\nshaka.util.PeriodCombiner.BetterOrWorse = {\n  BETTER: 1,\n  EQUAL: 0,\n  WORSE: -1,\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.dash.DashParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.abr.Ewma');\ngoog.require('shaka.dash.ContentProtection');\ngoog.require('shaka.dash.MpdUtils');\ngoog.require('shaka.dash.SegmentBase');\ngoog.require('shaka.dash.SegmentList');\ngoog.require('shaka.dash.SegmentTemplate');\ngoog.require('shaka.log');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.CmcdManager');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Networking');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.PeriodCombiner');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * Creates a new DASH parser.\n *\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.dash.DashParser = class {\n  /** Creates a new DASH parser. */\n  constructor() {\n    /** @private {?shaka.extern.ManifestConfiguration} */\n    this.config_ = null;\n\n    /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n    this.playerInterface_ = null;\n\n    /** @private {!Array.<string>} */\n    this.manifestUris_ = [];\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {number} */\n    this.globalId_ = 1;\n\n    /**\n     * A map of IDs to Stream objects.\n     * ID: Period@id,AdaptationSet@id,@Representation@id\n     * e.g.: '1,5,23'\n     * @private {!Object.<string, !shaka.extern.Stream>}\n     */\n    this.streamMap_ = {};\n\n    /**\n     * A map of period ids to their durations\n     * @private {!Object.<string, number>}\n     */\n    this.periodDurations_ = {};\n\n    /** @private {shaka.util.PeriodCombiner} */\n    this.periodCombiner_ = new shaka.util.PeriodCombiner();\n\n    /**\n     * The update period in seconds, or 0 for no updates.\n     * @private {number}\n     */\n    this.updatePeriod_ = 0;\n\n    /**\n     * An ewma that tracks how long updates take.\n     * This is to mitigate issues caused by slow parsing on embedded devices.\n     * @private {!shaka.abr.Ewma}\n     */\n    this.averageUpdateDuration_ = new shaka.abr.Ewma(5);\n\n    /** @private {shaka.util.Timer} */\n    this.updateTimer_ = new shaka.util.Timer(() => {\n      this.onUpdate_();\n    });\n\n    /** @private {!shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /**\n     * Largest period start time seen.\n     * @private {?number}\n     */\n    this.largestPeriodStartTime_ = null;\n\n    /**\n     * Period IDs seen in previous manifest.\n     * @private {!Array.<string>}\n     */\n    this.lastManifestUpdatePeriodIds_ = [];\n\n    /**\n     * The minimum of the availabilityTimeOffset values among the adaptation\n     * sets.\n     * @private {number}\n     */\n    this.minTotalAvailabilityTimeOffset_ = Infinity;\n\n    /** @private {boolean} */\n    this.lowLatencyMode_ = false;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  configure(config) {\n    goog.asserts.assert(config.dash != null,\n        'DashManifestConfiguration should not be null!');\n\n    this.config_ = config;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async start(uri, playerInterface) {\n    goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n    this.lowLatencyMode_ = playerInterface.isLowLatencyMode();\n    this.manifestUris_ = [uri];\n    this.playerInterface_ = playerInterface;\n\n    const updateDelay = await this.requestManifest_();\n\n    if (this.playerInterface_) {\n      this.setUpdateTimer_(updateDelay);\n    }\n\n    // Make sure that the parser has not been destroyed.\n    if (!this.playerInterface_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    goog.asserts.assert(this.manifest_, 'Manifest should be non-null!');\n    return this.manifest_;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  stop() {\n    // When the parser stops, release all segment indexes, which stops their\n    // timers, as well.\n    for (const stream of Object.values(this.streamMap_)) {\n      if (stream.segmentIndex) {\n        stream.segmentIndex.release();\n      }\n    }\n\n    if (this.periodCombiner_) {\n      this.periodCombiner_.release();\n    }\n\n    this.playerInterface_ = null;\n    this.config_ = null;\n    this.manifestUris_ = [];\n    this.manifest_ = null;\n    this.streamMap_ = {};\n    this.periodCombiner_ = null;\n\n    if (this.updateTimer_ != null) {\n      this.updateTimer_.stop();\n      this.updateTimer_ = null;\n    }\n\n    return this.operationManager_.destroy();\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async update() {\n    try {\n      await this.requestManifest_();\n    } catch (error) {\n      if (!this.playerInterface_ || !error) {\n        return;\n      }\n      goog.asserts.assert(error instanceof shaka.util.Error, 'Bad error type');\n      this.playerInterface_.onError(error);\n    }\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  onExpirationUpdated(sessionId, expiration) {\n    // No-op\n  }\n\n  /**\n   * Makes a network request for the manifest and parses the resulting data.\n   *\n   * @return {!Promise.<number>} Resolves with the time it took, in seconds, to\n   *   fulfill the request and parse the data.\n   * @private\n   */\n  async requestManifest_() {\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        this.manifestUris_, this.config_.retryParameters);\n    const networkingEngine = this.playerInterface_.networkingEngine;\n\n    const format = shaka.util.CmcdManager.StreamingFormat.DASH;\n    this.playerInterface_.modifyManifestRequest(request, {format: format});\n\n    const startTime = Date.now();\n    const operation = networkingEngine.request(requestType, request);\n    this.operationManager_.manage(operation);\n\n    const response = await operation.promise;\n\n    // Detect calls to stop().\n    if (!this.playerInterface_) {\n      return 0;\n    }\n\n    // For redirections add the response uri to the first entry in the\n    // Manifest Uris array.\n    if (response.uri && !this.manifestUris_.includes(response.uri)) {\n      this.manifestUris_.unshift(response.uri);\n    }\n\n    // This may throw, but it will result in a failed promise.\n    await this.parseManifest_(response.data, response.uri);\n    // Keep track of how long the longest manifest update took.\n    const endTime = Date.now();\n    const updateDuration = (endTime - startTime) / 1000.0;\n    this.averageUpdateDuration_.sample(1, updateDuration);\n\n    // Let the caller know how long this update took.\n    return updateDuration;\n  }\n\n  /**\n   * Parses the manifest XML.  This also handles updates and will update the\n   * stored manifest.\n   *\n   * @param {BufferSource} data\n   * @param {string} finalManifestUri The final manifest URI, which may\n   *   differ from this.manifestUri_ if there has been a redirect.\n   * @return {!Promise}\n   * @private\n   */\n  async parseManifest_(data, finalManifestUri) {\n    const Error = shaka.util.Error;\n    const MpdUtils = shaka.dash.MpdUtils;\n\n    const mpd = shaka.util.XmlUtils.parseXml(data, 'MPD');\n    if (!mpd) {\n      throw new Error(\n          Error.Severity.CRITICAL, Error.Category.MANIFEST,\n          Error.Code.DASH_INVALID_XML, finalManifestUri);\n    }\n    const disableXlinkProcessing = this.config_.dash.disableXlinkProcessing;\n    if (disableXlinkProcessing) {\n      return this.processManifest_(mpd, finalManifestUri);\n    }\n\n    // Process the mpd to account for xlink connections.\n    const failGracefully = this.config_.dash.xlinkFailGracefully;\n    const xlinkOperation = MpdUtils.processXlinks(\n        mpd, this.config_.retryParameters, failGracefully, finalManifestUri,\n        this.playerInterface_.networkingEngine);\n    this.operationManager_.manage(xlinkOperation);\n    const finalMpd = await xlinkOperation.promise;\n    return this.processManifest_(finalMpd, finalManifestUri);\n  }\n\n\n  /**\n   * Takes a formatted MPD and converts it into a manifest.\n   *\n   * @param {!Element} mpd\n   * @param {string} finalManifestUri The final manifest URI, which may\n   *   differ from this.manifestUri_ if there has been a redirect.\n   * @return {!Promise}\n   * @private\n   */\n  async processManifest_(mpd, finalManifestUri) {\n    const Functional = shaka.util.Functional;\n    const XmlUtils = shaka.util.XmlUtils;\n\n    const manifestPreprocessor = this.config_.dash.manifestPreprocessor;\n    if (manifestPreprocessor) {\n      manifestPreprocessor(mpd);\n    }\n\n    // Get any Location elements.  This will update the manifest location and\n    // the base URI.\n    /** @type {!Array.<string>} */\n    let manifestBaseUris = [finalManifestUri];\n    /** @type {!Array.<string>} */\n    const locations = XmlUtils.findChildren(mpd, 'Location')\n        .map(XmlUtils.getContents)\n        .filter(Functional.isNotNull);\n    if (locations.length > 0) {\n      const absoluteLocations = shaka.util.ManifestParserUtils.resolveUris(\n          manifestBaseUris, locations);\n      this.manifestUris_ = absoluteLocations;\n      manifestBaseUris = absoluteLocations;\n    }\n\n    const uriObjs = XmlUtils.findChildren(mpd, 'BaseURL');\n    const uris = uriObjs.map(XmlUtils.getContents);\n    const baseUris = shaka.util.ManifestParserUtils.resolveUris(\n        manifestBaseUris, uris);\n\n    let availabilityTimeOffset = 0;\n    if (uriObjs && uriObjs.length) {\n      availabilityTimeOffset = XmlUtils.parseAttr(\n          uriObjs[0], 'availabilityTimeOffset', XmlUtils.parseFloat) || 0;\n    }\n\n    const ignoreMinBufferTime = this.config_.dash.ignoreMinBufferTime;\n    let minBufferTime = 0;\n    if (!ignoreMinBufferTime) {\n      minBufferTime =\n          XmlUtils.parseAttr(mpd, 'minBufferTime', XmlUtils.parseDuration) || 0;\n    }\n\n    this.updatePeriod_ = /** @type {number} */ (XmlUtils.parseAttr(\n        mpd, 'minimumUpdatePeriod', XmlUtils.parseDuration, -1));\n\n    const presentationStartTime = XmlUtils.parseAttr(\n        mpd, 'availabilityStartTime', XmlUtils.parseDate);\n    let segmentAvailabilityDuration = XmlUtils.parseAttr(\n        mpd, 'timeShiftBufferDepth', XmlUtils.parseDuration);\n\n    const ignoreSuggestedPresentationDelay =\n      this.config_.dash.ignoreSuggestedPresentationDelay;\n    let suggestedPresentationDelay = null;\n    if (!ignoreSuggestedPresentationDelay) {\n      suggestedPresentationDelay = XmlUtils.parseAttr(\n          mpd, 'suggestedPresentationDelay', XmlUtils.parseDuration);\n    }\n\n    const ignoreMaxSegmentDuration =\n        this.config_.dash.ignoreMaxSegmentDuration;\n    let maxSegmentDuration = null;\n    if (!ignoreMaxSegmentDuration) {\n      maxSegmentDuration = XmlUtils.parseAttr(\n          mpd, 'maxSegmentDuration', XmlUtils.parseDuration);\n    }\n    const mpdType = mpd.getAttribute('type') || 'static';\n\n    /** @type {!shaka.media.PresentationTimeline} */\n    let presentationTimeline;\n    if (this.manifest_) {\n      presentationTimeline = this.manifest_.presentationTimeline;\n\n      // Before processing an update, evict from all segment indexes.  Some of\n      // them may not get updated otherwise if their corresponding Period\n      // element has been dropped from the manifest since the last update.\n      // Without this, playback will still work, but this is necessary to\n      // maintain conditions that we assert on for multi-Period content.\n      // This gives us confidence that our state is maintained correctly, and\n      // that the complex logic of multi-Period eviction and period-flattening\n      // is correct.  See also:\n      // https://github.com/shaka-project/shaka-player/issues/3169#issuecomment-823580634\n      for (const stream of Object.values(this.streamMap_)) {\n        if (stream.segmentIndex) {\n          stream.segmentIndex.evict(\n              presentationTimeline.getSegmentAvailabilityStart());\n        }\n      }\n    } else {\n      // DASH IOP v3.0 suggests using a default delay between minBufferTime\n      // and timeShiftBufferDepth.  This is literally the range of all\n      // feasible choices for the value.  Nothing older than\n      // timeShiftBufferDepth is still available, and anything less than\n      // minBufferTime will cause buffering issues.\n      //\n      // We have decided that our default will be the configured value, or\n      // 1.5 * minBufferTime if not configured. This is fairly conservative.\n      // Content providers should provide a suggestedPresentationDelay whenever\n      // possible to optimize the live streaming experience.\n      const defaultPresentationDelay =\n          this.config_.defaultPresentationDelay || minBufferTime * 1.5;\n      const presentationDelay = suggestedPresentationDelay != null ?\n          suggestedPresentationDelay : defaultPresentationDelay;\n      presentationTimeline = new shaka.media.PresentationTimeline(\n          presentationStartTime, presentationDelay,\n          this.config_.dash.autoCorrectDrift);\n    }\n\n    presentationTimeline.setStatic(mpdType == 'static');\n\n    const isLive = presentationTimeline.isLive();\n\n    // If it's live, we check for an override.\n    if (isLive && !isNaN(this.config_.availabilityWindowOverride)) {\n      segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n    }\n\n    // If it's null, that means segments are always available.  This is always\n    // the case for VOD, and sometimes the case for live.\n    if (segmentAvailabilityDuration == null) {\n      segmentAvailabilityDuration = Infinity;\n    }\n\n    presentationTimeline.setSegmentAvailabilityDuration(\n        segmentAvailabilityDuration);\n\n    const profiles = mpd.getAttribute('profiles') || '';\n\n    /** @type {shaka.dash.DashParser.Context} */\n    const context = {\n      // Don't base on updatePeriod_ since emsg boxes can cause manifest\n      // updates.\n      dynamic: mpdType != 'static',\n      presentationTimeline: presentationTimeline,\n      period: null,\n      periodInfo: null,\n      adaptationSet: null,\n      representation: null,\n      bandwidth: 0,\n      indexRangeWarningGiven: false,\n      availabilityTimeOffset: availabilityTimeOffset,\n      profiles: profiles.split(','),\n    };\n\n    const periodsAndDuration = this.parsePeriods_(context, baseUris, mpd);\n    const duration = periodsAndDuration.duration;\n    const periods = periodsAndDuration.periods;\n\n    if (mpdType == 'static' ||\n        !periodsAndDuration.durationDerivedFromPeriods) {\n      // Ignore duration calculated from Period lengths if this is dynamic.\n      presentationTimeline.setDuration(duration || Infinity);\n    }\n\n    // The segments are available earlier than the availability start time.\n    // If the stream is low latency and the user has not configured the\n    // lowLatencyMode, but if it has been configured to activate the\n    // lowLatencyMode if a stream of this type is detected, we automatically\n    // activate the lowLatencyMode.\n    if (this.minTotalAvailabilityTimeOffset_ && !this.lowLatencyMode_) {\n      const autoLowLatencyMode = this.playerInterface_.isAutoLowLatencyMode();\n      if (autoLowLatencyMode) {\n        this.playerInterface_.enableLowLatencyMode();\n        this.lowLatencyMode_ = this.playerInterface_.isLowLatencyMode();\n      }\n    }\n\n    if (this.lowLatencyMode_) {\n      presentationTimeline.setAvailabilityTimeOffset(\n          this.minTotalAvailabilityTimeOffset_);\n    } else if (this.minTotalAvailabilityTimeOffset_) {\n      // If the playlist contains AvailabilityTimeOffset value, the\n      // streaming.lowLatencyMode value should be set to true to stream with low\n      // latency mode.\n      shaka.log.alwaysWarn('Low-latency DASH live stream detected, but ' +\n        'low-latency streaming mode is not enabled in Shaka Player. ' +\n        'Set streaming.lowLatencyMode configuration to true, and see ' +\n        'https://bit.ly/3clctcj for details.');\n    }\n\n    // Use @maxSegmentDuration to override smaller, derived values.\n    presentationTimeline.notifyMaxSegmentDuration(maxSegmentDuration || 1);\n    if (goog.DEBUG) {\n      presentationTimeline.assertIsValid();\n    }\n\n    await this.periodCombiner_.combinePeriods(periods, context.dynamic);\n\n    // These steps are not done on manifest update.\n    if (!this.manifest_) {\n      this.manifest_ = {\n        presentationTimeline: presentationTimeline,\n        variants: this.periodCombiner_.getVariants(),\n        textStreams: this.periodCombiner_.getTextStreams(),\n        imageStreams: this.periodCombiner_.getImageStreams(),\n        offlineSessionIds: [],\n        minBufferTime: minBufferTime || 0,\n        sequenceMode: this.config_.dash.sequenceMode,\n      };\n\n      // We only need to do clock sync when we're using presentation start\n      // time. This condition also excludes VOD streams.\n      if (presentationTimeline.usingPresentationStartTime()) {\n        const XmlUtils = shaka.util.XmlUtils;\n        const timingElements = XmlUtils.findChildren(mpd, 'UTCTiming');\n        const offset = await this.parseUtcTiming_(baseUris, timingElements);\n        // Detect calls to stop().\n        if (!this.playerInterface_) {\n          return;\n        }\n        presentationTimeline.setClockOffset(offset);\n      }\n\n      // This is the first point where we have a meaningful presentation start\n      // time, and we need to tell PresentationTimeline that so that it can\n      // maintain consistency from here on.\n      presentationTimeline.lockStartTime();\n    } else {\n      // Just update the variants and text streams, which may change as periods\n      // are added or removed.\n      this.manifest_.variants = this.periodCombiner_.getVariants();\n      this.manifest_.textStreams = this.periodCombiner_.getTextStreams();\n      this.manifest_.imageStreams = this.periodCombiner_.getImageStreams();\n\n      // Re-filter the manifest.  This will check any configured restrictions on\n      // new variants, and will pass any new init data to DrmEngine to ensure\n      // that key rotation works correctly.\n      this.playerInterface_.filter(this.manifest_);\n    }\n\n    // Add text streams to correspond to closed captions.  This happens right\n    // after period combining, while we still have a direct reference, so that\n    // any new streams will appear in the period combiner.\n    this.playerInterface_.makeTextStreamsForClosedCaptions(this.manifest_);\n  }\n\n  /**\n   * Reads and parses the periods from the manifest.  This first does some\n   * partial parsing so the start and duration is available when parsing\n   * children.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Array.<string>} baseUris\n   * @param {!Element} mpd\n   * @return {{\n   *   periods: !Array.<shaka.util.PeriodCombiner.Period>,\n   *   duration: ?number,\n   *   durationDerivedFromPeriods: boolean\n   * }}\n   * @private\n   */\n  parsePeriods_(context, baseUris, mpd) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const presentationDuration = XmlUtils.parseAttr(\n        mpd, 'mediaPresentationDuration', XmlUtils.parseDuration);\n\n    const periods = [];\n    let prevEnd = 0;\n    const periodNodes = XmlUtils.findChildren(mpd, 'Period');\n    for (let i = 0; i < periodNodes.length; i++) {\n      const elem = periodNodes[i];\n      const next = periodNodes[i + 1];\n      const start = /** @type {number} */ (\n        XmlUtils.parseAttr(elem, 'start', XmlUtils.parseDuration, prevEnd));\n      const periodId = elem.id;\n      const givenDuration =\n          XmlUtils.parseAttr(elem, 'duration', XmlUtils.parseDuration);\n\n      let periodDuration = null;\n      if (next) {\n        // \"The difference between the start time of a Period and the start time\n        // of the following Period is the duration of the media content\n        // represented by this Period.\"\n        const nextStart =\n            XmlUtils.parseAttr(next, 'start', XmlUtils.parseDuration);\n        if (nextStart != null) {\n          periodDuration = nextStart - start;\n        }\n      } else if (presentationDuration != null) {\n        // \"The Period extends until the Period.start of the next Period, or\n        // until the end of the Media Presentation in the case of the last\n        // Period.\"\n        periodDuration = presentationDuration - start;\n      }\n\n      const threshold =\n          shaka.util.ManifestParserUtils.GAP_OVERLAP_TOLERANCE_SECONDS;\n      if (periodDuration && givenDuration &&\n          Math.abs(periodDuration - givenDuration) > threshold) {\n        shaka.log.warning('There is a gap/overlap between Periods', elem);\n      }\n      // Only use the @duration in the MPD if we can't calculate it.  We should\n      // favor the @start of the following Period.  This ensures that there\n      // aren't gaps between Periods.\n      if (periodDuration == null) {\n        periodDuration = givenDuration;\n      }\n\n      /**\n       * This is to improve robustness when the player observes manifest with\n       * past periods that are inconsistent to previous ones.\n       *\n       * This may happen when a CDN or proxy server switches its upstream from\n       * one encoder to another redundant encoder.\n       *\n       * Skip periods that match all of the following criteria:\n       * - Start time is earlier than latest period start time ever seen\n       * - Period ID is never seen in the previous manifest\n       * - Not the last period in the manifest\n       *\n       * Periods that meet the aforementioned criteria are considered invalid\n       * and should be safe to discard.\n       */\n\n      if (this.largestPeriodStartTime_ !== null &&\n        periodId !== null && start !== null &&\n        start < this.largestPeriodStartTime_ &&\n        !this.lastManifestUpdatePeriodIds_.includes(periodId) &&\n        i + 1 != periodNodes.length) {\n        shaka.log.debug(\n            `Skipping Period with ID ${periodId} as its start time is smaller` +\n            ' than the largest period start time that has been seen, and ID ' +\n            'is unseen before');\n        continue;\n      }\n\n\n      // Save maximum period start time if it is the last period\n      if (start !== null &&\n        (this.largestPeriodStartTime_ === null ||\n          start > this.largestPeriodStartTime_)) {\n        this.largestPeriodStartTime_ = start;\n      }\n\n      // Parse child nodes.\n      const info = {\n        start: start,\n        duration: periodDuration,\n        node: elem,\n        isLastPeriod: periodDuration == null || !next,\n      };\n      const period = this.parsePeriod_(context, baseUris, info);\n      periods.push(period);\n\n      if (context.period.id && periodDuration) {\n        this.periodDurations_[context.period.id] = periodDuration;\n      }\n\n      if (periodDuration == null) {\n        if (next) {\n          // If the duration is still null and we aren't at the end, then we\n          // will skip any remaining periods.\n          shaka.log.warning(\n              'Skipping Period', i + 1, 'and any subsequent Periods:', 'Period',\n              i + 1, 'does not have a valid start time.', next);\n        }\n\n        // The duration is unknown, so the end is unknown.\n        prevEnd = null;\n        break;\n      }\n\n      prevEnd = start + periodDuration;\n    } // end of period parsing loop\n\n    // Replace previous seen periods with the current one.\n    this.lastManifestUpdatePeriodIds_ = periods.map((el) => el.id);\n\n    if (presentationDuration != null) {\n      if (prevEnd != presentationDuration) {\n        shaka.log.warning(\n            '@mediaPresentationDuration does not match the total duration of ',\n            'all Periods.');\n        // Assume @mediaPresentationDuration is correct.\n      }\n      return {\n        periods: periods,\n        duration: presentationDuration,\n        durationDerivedFromPeriods: false,\n      };\n    } else {\n      return {\n        periods: periods,\n        duration: prevEnd,\n        durationDerivedFromPeriods: true,\n      };\n    }\n  }\n\n  /**\n   * Parses a Period XML element.  Unlike the other parse methods, this is not\n   * given the Node; it is given a PeriodInfo structure.  Also, partial parsing\n   * was done before this was called so start and duration are valid.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Array.<string>} baseUris\n   * @param {shaka.dash.DashParser.PeriodInfo} periodInfo\n   * @return {shaka.util.PeriodCombiner.Period}\n   * @private\n   */\n  parsePeriod_(context, baseUris, periodInfo) {\n    const Functional = shaka.util.Functional;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    context.period = this.createFrame_(periodInfo.node, null, baseUris);\n    context.periodInfo = periodInfo;\n    context.period.availabilityTimeOffset = context.availabilityTimeOffset;\n\n    // If the period doesn't have an ID, give it one based on its start time.\n    if (!context.period.id) {\n      shaka.log.info(\n          'No Period ID given for Period with start time ' + periodInfo.start +\n          ',  Assigning a default');\n      context.period.id = '__shaka_period_' + periodInfo.start;\n    }\n\n    const eventStreamNodes =\n        XmlUtils.findChildren(periodInfo.node, 'EventStream');\n    const availabilityStart =\n        context.presentationTimeline.getSegmentAvailabilityStart();\n\n    for (const node of eventStreamNodes) {\n      this.parseEventStream_(\n          periodInfo.start, periodInfo.duration, node, availabilityStart);\n    }\n\n    const adaptationSetNodes =\n        XmlUtils.findChildren(periodInfo.node, 'AdaptationSet');\n    const adaptationSets = adaptationSetNodes\n        .map((node) => this.parseAdaptationSet_(context, node))\n        .filter(Functional.isNotNull);\n\n    // For dynamic manifests, we use rep IDs internally, and they must be\n    // unique.\n    if (context.dynamic) {\n      const ids = [];\n      for (const set of adaptationSets) {\n        for (const id of set.representationIds) {\n          ids.push(id);\n        }\n      }\n\n      const uniqueIds = new Set(ids);\n\n      if (ids.length != uniqueIds.size) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID);\n      }\n    }\n\n    const normalAdaptationSets = adaptationSets\n        .filter((as) => { return !as.trickModeFor; });\n\n    const trickModeAdaptationSets = adaptationSets\n        .filter((as) => { return as.trickModeFor; });\n\n    // Attach trick mode tracks to normal tracks.\n    for (const trickModeSet of trickModeAdaptationSets) {\n      const targetIds = trickModeSet.trickModeFor.split(' ');\n      for (const normalSet of normalAdaptationSets) {\n        if (targetIds.includes(normalSet.id)) {\n          for (const stream of normalSet.streams) {\n            // There may be multiple trick mode streams, but we do not\n            // currently support that.  Just choose one.\n            // TODO: https://github.com/shaka-project/shaka-player/issues/1528\n            stream.trickModeVideo = trickModeSet.streams.find((trickStream) =>\n              shaka.util.MimeUtils.getNormalizedCodec(stream.codecs) ==\n              shaka.util.MimeUtils.getNormalizedCodec(trickStream.codecs));\n          }\n        }\n      }\n    }\n\n    const audioSets = this.config_.disableAudio ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.AUDIO);\n    const videoSets = this.config_.disableVideo ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.VIDEO);\n    const textSets = this.config_.disableText ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.TEXT);\n    const imageSets = this.config_.disableThumbnails ? [] :\n        this.getSetsOfType_(normalAdaptationSets, ContentType.IMAGE);\n\n    if (!videoSets.length && !audioSets.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_EMPTY_PERIOD);\n    }\n\n    const audioStreams = [];\n    for (const audioSet of audioSets) {\n      audioStreams.push(...audioSet.streams);\n    }\n\n    const videoStreams = [];\n    for (const videoSet of videoSets) {\n      videoStreams.push(...videoSet.streams);\n    }\n\n    const textStreams = [];\n    for (const textSet of textSets) {\n      textStreams.push(...textSet.streams);\n    }\n\n    const imageStreams = [];\n    for (const imageSet of imageSets) {\n      imageStreams.push(...imageSet.streams);\n    }\n\n    return {\n      id: context.period.id,\n      audioStreams,\n      videoStreams,\n      textStreams,\n      imageStreams,\n    };\n  }\n\n  /**\n   * @param {!Array.<!shaka.dash.DashParser.AdaptationInfo>} adaptationSets\n   * @param {string} type\n   * @return {!Array.<!shaka.dash.DashParser.AdaptationInfo>}\n   * @private\n   */\n  getSetsOfType_(adaptationSets, type) {\n    return adaptationSets.filter((as) => {\n      return as.contentType == type;\n    });\n  }\n\n  /**\n   * Parses an AdaptationSet XML element.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {!Element} elem The AdaptationSet element.\n   * @return {?shaka.dash.DashParser.AdaptationInfo}\n   * @private\n   */\n  parseAdaptationSet_(context, elem) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const Functional = shaka.util.Functional;\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const ContentType = ManifestParserUtils.ContentType;\n    const ContentProtection = shaka.dash.ContentProtection;\n\n    context.adaptationSet = this.createFrame_(elem, context.period, null);\n\n    let main = false;\n    const roleElements = XmlUtils.findChildren(elem, 'Role');\n    const roleValues = roleElements.map((role) => {\n      return role.getAttribute('value');\n    }).filter(Functional.isNotNull);\n\n    // Default kind for text streams is 'subtitle' if unspecified in the\n    // manifest.\n    let kind = undefined;\n    const isText = context.adaptationSet.contentType == ContentType.TEXT;\n    if (isText) {\n      kind = ManifestParserUtils.TextStreamKind.SUBTITLE;\n    }\n\n    for (const roleElement of roleElements) {\n      const scheme = roleElement.getAttribute('schemeIdUri');\n      if (scheme == null || scheme == 'urn:mpeg:dash:role:2011') {\n        // These only apply for the given scheme, but allow them to be specified\n        // if there is no scheme specified.\n        // See: DASH section 5.8.5.5\n        const value = roleElement.getAttribute('value');\n        switch (value) {\n          case 'main':\n            main = true;\n            break;\n          case 'caption':\n          case 'subtitle':\n            kind = value;\n            break;\n        }\n      }\n    }\n\n    // Parallel for HLS VIDEO-RANGE as defined in DASH-IF IOP v4.3 6.2.5.1.\n    let videoRange;\n    const videoRangeScheme = 'urn:mpeg:mpegB:cicp:TransferCharacteristics';\n    const getVideoRangeFromTransferCharacteristicCICP = (cicp) => {\n      switch (cicp) {\n        case 1:\n        case 6:\n        case 13:\n        case 14:\n        case 15:\n          return 'SDR';\n        case 16:\n          return 'PQ';\n        case 18:\n          return 'HLG';\n      }\n      return undefined;\n    };\n\n    const essentialProperties =\n        XmlUtils.findChildren(elem, 'EssentialProperty');\n    // ID of real AdaptationSet if this is a trick mode set:\n    let trickModeFor = null;\n    let unrecognizedEssentialProperty = false;\n    for (const prop of essentialProperties) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      if (schemeId == 'http://dashif.org/guidelines/trickmode') {\n        trickModeFor = prop.getAttribute('value');\n      } else if (schemeId == videoRangeScheme) {\n        videoRange = getVideoRangeFromTransferCharacteristicCICP(\n            parseInt(prop.getAttribute('value'), 10),\n        );\n      } else {\n        unrecognizedEssentialProperty = true;\n      }\n    }\n\n    const supplementalProperties =\n        XmlUtils.findChildren(elem, 'SupplementalProperty');\n    for (const prop of supplementalProperties) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      if (schemeId == videoRangeScheme) {\n        videoRange = getVideoRangeFromTransferCharacteristicCICP(\n            parseInt(prop.getAttribute('value'), 10),\n        );\n      }\n    }\n\n    const accessibilities = XmlUtils.findChildren(elem, 'Accessibility');\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const closedCaptions = new Map();\n    for (const prop of accessibilities) {\n      const schemeId = prop.getAttribute('schemeIdUri');\n      const value = prop.getAttribute('value');\n      if (schemeId == 'urn:scte:dash:cc:cea-608:2015' ) {\n        let channelId = 1;\n        if (value != null) {\n          const channelAssignments = value.split(';');\n          for (const captionStr of channelAssignments) {\n            let channel;\n            let language;\n            // Some closed caption descriptions have channel number and\n            // language (\"CC1=eng\") others may only have language (\"eng,spa\").\n            if (!captionStr.includes('=')) {\n              // When the channel assignemnts are not explicitly provided and\n              // there are only 2 values provided, it is highly likely that the\n              // assignments are CC1 and CC3 (most commonly used CC streams).\n              // Otherwise, cycle through all channels arbitrarily (CC1 - CC4)\n              // in order of provided langs.\n              channel = `CC${channelId}`;\n              if (channelAssignments.length == 2) {\n                channelId += 2;\n              } else {\n                channelId ++;\n              }\n              language = captionStr;\n            } else {\n              const channelAndLanguage = captionStr.split('=');\n              // The channel info can be '1' or 'CC1'.\n              // If the channel info only has channel number(like '1'), add 'CC'\n              // as prefix so that it can be a full channel id (like 'CC1').\n              channel = channelAndLanguage[0].startsWith('CC') ?\n                  channelAndLanguage[0] : `CC${channelAndLanguage[0]}`;\n\n              // 3 letters (ISO 639-2).  In b/187442669, we saw a blank string\n              // (CC2=;CC3=), so default to \"und\" (the code for \"undetermined\").\n              language = channelAndLanguage[1] || 'und';\n            }\n            closedCaptions.set(channel, LanguageUtils.normalize(language));\n          }\n        } else {\n          // If channel and language information has not been provided, assign\n          // 'CC1' as channel id and 'und' as language info.\n          closedCaptions.set('CC1', 'und');\n        }\n      } else if (schemeId == 'urn:scte:dash:cc:cea-708:2015') {\n        let serviceNumber = 1;\n        if (value != null) {\n          for (const captionStr of value.split(';')) {\n            let service;\n            let language;\n            // Similar to CEA-608, it is possible that service # assignments\n            // are not explicitly provided e.g. \"eng;deu;swe\" In this case,\n            // we just cycle through the services for each language one by one.\n            if (!captionStr.includes('=')) {\n              service = `svc${serviceNumber}`;\n              serviceNumber ++;\n              language = captionStr;\n            } else {\n            // Otherwise, CEA-708 caption values take the form \"\n            // 1=lang:eng;2=lang:deu\" i.e. serviceNumber=lang:threelettercode.\n              const serviceAndLanguage = captionStr.split('=');\n              service = `svc${serviceAndLanguage[0]}`;\n\n              // The language info can be different formats, lang:eng',\n              // or 'lang:eng,war:1,er:1'. Extract the language info.\n              language = serviceAndLanguage[1].split(',')[0].split(':').pop();\n            }\n            closedCaptions.set(service, LanguageUtils.normalize(language));\n          }\n        } else {\n          // If service and language information has not been provided, assign\n          // 'svc1' as service number and 'und' as language info.\n          closedCaptions.set('svc1', 'und');\n        }\n      } else if (schemeId == 'urn:mpeg:dash:role:2011') {\n        // See DASH IOP 3.9.2 Table 4.\n        if (value != null) {\n          roleValues.push(value);\n          if (value == 'captions') {\n            kind = ManifestParserUtils.TextStreamKind.CLOSED_CAPTION;\n          }\n        }\n      }\n    }\n\n    // According to DASH spec (2014) section 5.8.4.8, \"the successful processing\n    // of the descriptor is essential to properly use the information in the\n    // parent element\".  According to DASH IOP v3.3, section 3.3.4, \"if the\n    // scheme or the value\" for EssentialProperty is not recognized, \"the DASH\n    // client shall ignore the parent element.\"\n    if (unrecognizedEssentialProperty) {\n      // Stop parsing this AdaptationSet and let the caller filter out the\n      // nulls.\n      return null;\n    }\n\n    const contentProtectionElems =\n        XmlUtils.findChildren(elem, 'ContentProtection');\n    const contentProtection = ContentProtection.parseFromAdaptationSet(\n        contentProtectionElems,\n        this.config_.dash.ignoreDrmInfo,\n        this.config_.dash.keySystemsByURI);\n\n    const language =\n        shaka.util.LanguageUtils.normalize(elem.getAttribute('lang') || 'und');\n\n    // This attribute is currently non-standard, but it is supported by Kaltura.\n    let label = elem.getAttribute('label');\n\n    // See DASH IOP 4.3 here https://dashif.org/docs/DASH-IF-IOP-v4.3.pdf (page 35)\n    const labelElements = XmlUtils.findChildren(elem, 'Label');\n    if (labelElements && labelElements.length) {\n      // NOTE: Right now only one label field is supported.\n      const firstLabelElement = labelElements[0];\n      if (firstLabelElement.textContent) {\n        label = firstLabelElement.textContent;\n      }\n    }\n\n    // Parse Representations into Streams.\n    const representations = XmlUtils.findChildren(elem, 'Representation');\n    const streams = representations.map((representation) => {\n      const parsedRepresentation = this.parseRepresentation_(context,\n          contentProtection, kind, language, label, main, roleValues,\n          closedCaptions, representation);\n      if (parsedRepresentation) {\n        parsedRepresentation.hdr = parsedRepresentation.hdr || videoRange;\n      }\n      return parsedRepresentation;\n    }).filter((s) => !!s);\n\n    if (streams.length == 0) {\n      const isImage = context.adaptationSet.contentType == ContentType.IMAGE;\n      // Ignore empty AdaptationSets if ignoreEmptyAdaptationSet is true\n      // or they are for text/image content.\n      if (this.config_.dash.ignoreEmptyAdaptationSet || isText || isImage) {\n        return null;\n      }\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET);\n    }\n\n    // If AdaptationSet's type is unknown or is ambiguously \"application\",\n    // guess based on the information in the first stream.  If the attributes\n    // mimeType and codecs are split across levels, they will both be inherited\n    // down to the stream level by this point, so the stream will have all the\n    // necessary information.\n    if (!context.adaptationSet.contentType ||\n        context.adaptationSet.contentType == ContentType.APPLICATION) {\n      const mimeType = streams[0].mimeType;\n      const codecs = streams[0].codecs;\n      context.adaptationSet.contentType =\n          shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n\n      for (const stream of streams) {\n        stream.type = context.adaptationSet.contentType;\n      }\n    }\n\n    for (const stream of streams) {\n      // Some DRM license providers require that we have a default\n      // key ID from the manifest in the wrapped license request.\n      // Thus, it should be put in drmInfo to be accessible to request filters.\n      for (const drmInfo of contentProtection.drmInfos) {\n        drmInfo.keyIds = drmInfo.keyIds && stream.keyIds ?\n            new Set([...drmInfo.keyIds, ...stream.keyIds]) :\n            drmInfo.keyIds || stream.keyIds;\n      }\n    }\n\n    const repIds = representations\n        .map((node) => { return node.getAttribute('id'); })\n        .filter(shaka.util.Functional.isNotNull);\n\n    return {\n      id: context.adaptationSet.id || ('__fake__' + this.globalId_++),\n      contentType: context.adaptationSet.contentType,\n      language: language,\n      main: main,\n      streams: streams,\n      drmInfos: contentProtection.drmInfos,\n      trickModeFor: trickModeFor,\n      representationIds: repIds,\n    };\n  }\n\n  /**\n   * Parses a Representation XML element.\n   *\n   * @param {shaka.dash.DashParser.Context} context\n   * @param {shaka.dash.ContentProtection.Context} contentProtection\n   * @param {(string|undefined)} kind\n   * @param {string} language\n   * @param {string} label\n   * @param {boolean} isPrimary\n   * @param {!Array.<string>} roles\n   * @param {Map.<string, string>} closedCaptions\n   * @param {!Element} node\n   * @return {?shaka.extern.Stream} The Stream, or null when there is a\n   *   non-critical parsing error.\n   * @private\n   */\n  parseRepresentation_(context, contentProtection, kind, language, label,\n      isPrimary, roles, closedCaptions, node) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    context.representation =\n        this.createFrame_(node, context.adaptationSet, null);\n\n    this.minTotalAvailabilityTimeOffset_ =\n        Math.min(this.minTotalAvailabilityTimeOffset_,\n            context.representation.availabilityTimeOffset);\n\n    if (!this.verifyRepresentation_(context.representation)) {\n      shaka.log.warning('Skipping Representation', context.representation);\n      return null;\n    }\n    const periodStart = context.periodInfo.start;\n\n    // NOTE: bandwidth is a mandatory attribute according to the spec, and zero\n    // does not make sense in the DASH spec's bandwidth formulas.\n    // In some content, however, the attribute is missing or zero.\n    // To avoid NaN at the variant level on broken content, fall back to zero.\n    // https://github.com/shaka-project/shaka-player/issues/938#issuecomment-317278180\n    context.bandwidth =\n        XmlUtils.parseAttr(node, 'bandwidth', XmlUtils.parsePositiveInt) || 0;\n\n    /** @type {?shaka.dash.DashParser.StreamInfo} */\n    let streamInfo;\n\n    const contentType = context.representation.contentType;\n    const isText = contentType == ContentType.TEXT ||\n                   contentType == ContentType.APPLICATION;\n    const isImage = contentType == ContentType.IMAGE;\n\n    try {\n      const requestInitSegment = (uris, startByte, endByte) => {\n        return this.requestInitSegment_(uris, startByte, endByte);\n      };\n      if (context.representation.segmentBase) {\n        streamInfo = shaka.dash.SegmentBase.createStreamInfo(\n            context, requestInitSegment);\n      } else if (context.representation.segmentList) {\n        streamInfo = shaka.dash.SegmentList.createStreamInfo(\n            context, this.streamMap_);\n      } else if (context.representation.segmentTemplate) {\n        const hasManifest = !!this.manifest_;\n\n        streamInfo = shaka.dash.SegmentTemplate.createStreamInfo(\n            context, requestInitSegment, this.streamMap_, hasManifest,\n            this.config_.dash.initialSegmentLimit, this.periodDurations_);\n      } else {\n        goog.asserts.assert(isText,\n            'Must have Segment* with non-text streams.');\n\n        const baseUris = context.representation.baseUris;\n        const duration = context.periodInfo.duration || 0;\n        streamInfo = {\n          generateSegmentIndex: () => {\n            return Promise.resolve(shaka.media.SegmentIndex.forSingleSegment(\n                periodStart, duration, baseUris));\n          },\n        };\n      }\n    } catch (error) {\n      if ((isText || isImage) &&\n          error.code == shaka.util.Error.Code.DASH_NO_SEGMENT_INFO) {\n        // We will ignore any DASH_NO_SEGMENT_INFO errors for text/image\n        // streams.\n        return null;\n      }\n\n      // For anything else, re-throw.\n      throw error;\n    }\n\n    const contentProtectionElems =\n        XmlUtils.findChildren(node, 'ContentProtection');\n    const keyId = shaka.dash.ContentProtection.parseFromRepresentation(\n        contentProtectionElems, contentProtection,\n        this.config_.dash.ignoreDrmInfo,\n        this.config_.dash.keySystemsByURI);\n    const keyIds = new Set(keyId ? [keyId] : []);\n\n    // Detect the presence of E-AC3 JOC audio content, using DD+JOC signaling.\n    // See: ETSI TS 103 420 V1.2.1 (2018-10)\n    const supplementalPropertyElems =\n        XmlUtils.findChildren(node, 'SupplementalProperty');\n    const hasJoc = supplementalPropertyElems.some((element) => {\n      const expectedUri = 'tag:dolby.com,2018:dash:EC3_ExtensionType:2018';\n      const expectedValue = 'JOC';\n      return element.getAttribute('schemeIdUri') == expectedUri &&\n          element.getAttribute('value') == expectedValue;\n    });\n    let spatialAudio = false;\n    if (hasJoc) {\n      spatialAudio = true;\n    }\n\n    let forced = false;\n    if (isText) {\n      // See: https://github.com/shaka-project/shaka-player/issues/2122 and\n      // https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/165\n      forced = roles.includes('forced_subtitle') ||\n          roles.includes('forced-subtitle');\n    }\n\n    let tilesLayout;\n    if (isImage) {\n      const essentialPropertyElems =\n          XmlUtils.findChildren(node, 'EssentialProperty');\n      const thumbnailTileElem = essentialPropertyElems.find((element) => {\n        const expectedUris = [\n          'http://dashif.org/thumbnail_tile',\n          'http://dashif.org/guidelines/thumbnail_tile',\n        ];\n        return expectedUris.includes(element.getAttribute('schemeIdUri'));\n      });\n      if (thumbnailTileElem) {\n        tilesLayout = thumbnailTileElem.getAttribute('value');\n      }\n      // Filter image adaptation sets that has no tilesLayout.\n      if (!tilesLayout) {\n        return null;\n      }\n    }\n\n    let hdr;\n    const profiles = context.profiles;\n    const codecs = context.representation.codecs;\n\n    const hevcHDR = 'http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10';\n    if (profiles.includes(hevcHDR) && (codecs.includes('hvc1.2.4.L153.B0') ||\n        codecs.includes('hev1.2.4.L153.B0'))) {\n      hdr = 'PQ';\n    }\n\n    const contextId = context.representation.id ?\n        context.period.id + ',' + context.representation.id : '';\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: this.globalId_++,\n      originalId: context.representation.id,\n      createSegmentIndex: async () => {\n        // If we have a stream with the same context id stored in the map\n        // that has no segmentIndex, we should set the segmentIndex for it.\n        const storedInMap = contextId && context.dynamic &&\n              this.streamMap_[contextId];\n\n        const currentStream = storedInMap ? this.streamMap_[contextId] : stream;\n        if (!currentStream.segmentIndex) {\n          currentStream.segmentIndex = await streamInfo.generateSegmentIndex();\n        }\n      },\n\n      closeSegmentIndex: () => {\n        if (stream.segmentIndex) {\n          stream.segmentIndex.release();\n          stream.segmentIndex = null;\n        }\n      },\n      segmentIndex: null,\n      mimeType: context.representation.mimeType,\n      codecs: context.representation.codecs,\n      frameRate: context.representation.frameRate,\n      pixelAspectRatio: context.representation.pixelAspectRatio,\n      bandwidth: context.bandwidth,\n      width: context.representation.width,\n      height: context.representation.height,\n      kind,\n      encrypted: contentProtection.drmInfos.length > 0,\n      drmInfos: contentProtection.drmInfos,\n      keyIds,\n      language,\n      label,\n      type: context.adaptationSet.contentType,\n      primary: isPrimary,\n      trickModeVideo: null,\n      emsgSchemeIdUris:\n          context.representation.emsgSchemeIdUris,\n      roles,\n      forced: forced,\n      channelsCount: context.representation.numChannels,\n      audioSamplingRate: context.representation.audioSamplingRate,\n      spatialAudio: spatialAudio,\n      closedCaptions,\n      hdr,\n      tilesLayout,\n      matchedStreams: [],\n    };\n\n    if (contextId && context.dynamic && !this.streamMap_[contextId]) {\n      this.streamMap_[contextId] = stream;\n    }\n\n    return stream;\n  }\n\n  /**\n   * Called when the update timer ticks.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onUpdate_() {\n    goog.asserts.assert(this.updatePeriod_ >= 0,\n        'There should be an update period');\n\n    shaka.log.info('Updating manifest...');\n\n    // Default the update delay to 0 seconds so that if there is an error we can\n    // try again right away.\n    let updateDelay = 0;\n\n    try {\n      updateDelay = await this.requestManifest_();\n    } catch (error) {\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      // Try updating again, but ensure we haven't been destroyed.\n      if (this.playerInterface_) {\n        // We will retry updating, so override the severity of the error.\n        error.severity = shaka.util.Error.Severity.RECOVERABLE;\n        this.playerInterface_.onError(error);\n      }\n    }\n\n    // Detect a call to stop()\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    this.setUpdateTimer_(updateDelay);\n  }\n\n  /**\n   * Sets the update timer.  Does nothing if the manifest does not specify an\n   * update period.\n   *\n   * @param {number} offset An offset, in seconds, to apply to the manifest's\n   *   update period.\n   * @private\n   */\n  setUpdateTimer_(offset) {\n    // NOTE: An updatePeriod_ of -1 means the attribute was missing.\n    // An attribute which is present and set to 0 should still result in\n    // periodic updates.  For more, see:\n    // https://github.com/shaka-project/shaka-player/issues/331\n    if (this.updatePeriod_ < 0) {\n      return;\n    }\n\n    const finalDelay = Math.max(\n        shaka.dash.DashParser.MIN_UPDATE_PERIOD_,\n        this.updatePeriod_ - offset,\n        this.averageUpdateDuration_.getEstimate());\n\n    // We do not run the timer as repeating because part of update is async and\n    // we need schedule the update after it finished.\n    this.updateTimer_.tickAfter(/* seconds= */ finalDelay);\n  }\n\n  /**\n   * Creates a new inheritance frame for the given element.\n   *\n   * @param {!Element} elem\n   * @param {?shaka.dash.DashParser.InheritanceFrame} parent\n   * @param {Array.<string>} baseUris\n   * @return {shaka.dash.DashParser.InheritanceFrame}\n   * @private\n   */\n  createFrame_(elem, parent, baseUris) {\n    goog.asserts.assert(parent || baseUris,\n        'Must provide either parent or baseUris');\n    const ManifestParserUtils = shaka.util.ManifestParserUtils;\n    const XmlUtils = shaka.util.XmlUtils;\n    parent = parent || /** @type {shaka.dash.DashParser.InheritanceFrame} */ ({\n      contentType: '',\n      mimeType: '',\n      codecs: '',\n      emsgSchemeIdUris: [],\n      frameRate: undefined,\n      pixelAspectRatio: undefined,\n      numChannels: null,\n      audioSamplingRate: null,\n      availabilityTimeOffset: 0,\n    });\n    baseUris = baseUris || parent.baseUris;\n\n    const parseNumber = XmlUtils.parseNonNegativeInt;\n    const evalDivision = XmlUtils.evalDivision;\n\n    const uriObjs = XmlUtils.findChildren(elem, 'BaseURL');\n    const uris = uriObjs.map(XmlUtils.getContents);\n\n    let contentType = elem.getAttribute('contentType') || parent.contentType;\n    const mimeType = elem.getAttribute('mimeType') || parent.mimeType;\n    const codecs = elem.getAttribute('codecs') || parent.codecs;\n    const frameRate =\n        XmlUtils.parseAttr(elem, 'frameRate', evalDivision) || parent.frameRate;\n    const pixelAspectRatio =\n        elem.getAttribute('sar') || parent.pixelAspectRatio;\n    const emsgSchemeIdUris = this.emsgSchemeIdUris_(\n        XmlUtils.findChildren(elem, 'InbandEventStream'),\n        parent.emsgSchemeIdUris);\n    const audioChannelConfigs =\n        XmlUtils.findChildren(elem, 'AudioChannelConfiguration');\n    const numChannels =\n        this.parseAudioChannels_(audioChannelConfigs) || parent.numChannels;\n    const audioSamplingRate =\n        XmlUtils.parseAttr(elem, 'audioSamplingRate', parseNumber) ||\n        parent.audioSamplingRate;\n\n    if (!contentType) {\n      contentType = shaka.dash.DashParser.guessContentType_(mimeType, codecs);\n    }\n\n    const segmentBase = XmlUtils.findChild(elem, 'SegmentBase');\n    const segmentTemplate = XmlUtils.findChild(elem, 'SegmentTemplate');\n\n    // The availabilityTimeOffset is the sum of all @availabilityTimeOffset\n    // values that apply to the adaptation set, via BaseURL, SegmentBase,\n    // or SegmentTemplate elements.\n    const segmentBaseAto = segmentBase ?\n        (XmlUtils.parseAttr(segmentBase, 'availabilityTimeOffset',\n            XmlUtils.parseFloat) || 0) : 0;\n    const segmentTemplateAto = segmentTemplate ?\n        (XmlUtils.parseAttr(segmentTemplate, 'availabilityTimeOffset',\n            XmlUtils.parseFloat) || 0) : 0;\n    const baseUriAto = uriObjs && uriObjs.length ?\n        (XmlUtils.parseAttr(uriObjs[0], 'availabilityTimeOffset',\n            XmlUtils.parseFloat) || 0) : 0;\n\n    const availabilityTimeOffset = parent.availabilityTimeOffset + baseUriAto +\n        segmentBaseAto + segmentTemplateAto;\n\n    return {\n      baseUris: ManifestParserUtils.resolveUris(baseUris, uris),\n      segmentBase: segmentBase || parent.segmentBase,\n      segmentList:\n          XmlUtils.findChild(elem, 'SegmentList') || parent.segmentList,\n      segmentTemplate: segmentTemplate || parent.segmentTemplate,\n      width: XmlUtils.parseAttr(elem, 'width', parseNumber) || parent.width,\n      height: XmlUtils.parseAttr(elem, 'height', parseNumber) || parent.height,\n      contentType: contentType,\n      mimeType: mimeType,\n      codecs: codecs,\n      frameRate: frameRate,\n      pixelAspectRatio: pixelAspectRatio,\n      emsgSchemeIdUris: emsgSchemeIdUris,\n      id: elem.getAttribute('id'),\n      numChannels: numChannels,\n      audioSamplingRate: audioSamplingRate,\n      availabilityTimeOffset: availabilityTimeOffset,\n    };\n  }\n\n  /**\n   * Returns a new array of InbandEventStream schemeIdUri containing the union\n   * of the ones parsed from inBandEventStreams and the ones provided in\n   * emsgSchemeIdUris.\n   *\n   * @param {!Array.<!Element>} inBandEventStreams Array of InbandEventStream\n   *     elements to parse and add to the returned array.\n   * @param {!Array.<string>} emsgSchemeIdUris Array of parsed\n   *     InbandEventStream schemeIdUri attributes to add to the returned array.\n   * @return {!Array.<string>} schemeIdUris Array of parsed\n   *     InbandEventStream schemeIdUri attributes.\n   * @private\n   */\n  emsgSchemeIdUris_(inBandEventStreams, emsgSchemeIdUris) {\n    const schemeIdUris = emsgSchemeIdUris.slice();\n    for (const event of inBandEventStreams) {\n      const schemeIdUri = event.getAttribute('schemeIdUri');\n      if (!schemeIdUris.includes(schemeIdUri)) {\n        schemeIdUris.push(schemeIdUri);\n      }\n    }\n    return schemeIdUris;\n  }\n\n  /**\n   * @param {!Array.<!Element>} audioChannelConfigs An array of\n   *   AudioChannelConfiguration elements.\n   * @return {?number} The number of audio channels, or null if unknown.\n   * @private\n   */\n  parseAudioChannels_(audioChannelConfigs) {\n    for (const elem of audioChannelConfigs) {\n      const scheme = elem.getAttribute('schemeIdUri');\n      if (!scheme) {\n        continue;\n      }\n\n      const value = elem.getAttribute('value');\n      if (!value) {\n        continue;\n      }\n\n      switch (scheme) {\n        case 'urn:mpeg:dash:outputChannelPositionList:2012':\n          // A space-separated list of speaker positions, so the number of\n          // channels is the length of this list.\n          return value.trim().split(/ +/).length;\n\n        case 'urn:mpeg:dash:23003:3:audio_channel_configuration:2011':\n        case 'urn:dts:dash:audio_channel_configuration:2012': {\n          // As far as we can tell, this is a number of channels.\n          const intValue = parseInt(value, 10);\n          if (!intValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          return intValue;\n        }\n\n        case 'tag:dolby.com,2014:dash:audio_channel_configuration:2011':\n        case 'urn:dolby:dash:audio_channel_configuration:2011': {\n          // A hex-encoded 16-bit integer, in which each bit represents a\n          // channel.\n          let hexValue = parseInt(value, 16);\n          if (!hexValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          // Count the 1-bits in hexValue.\n          let numBits = 0;\n          while (hexValue) {\n            if (hexValue & 1) {\n              ++numBits;\n            }\n            hexValue >>= 1;\n          }\n          return numBits;\n        }\n\n        // Defined by https://dashif.org/identifiers/audio_source_metadata/ and clause 8.2, in ISO/IEC 23001-8.\n        case 'urn:mpeg:mpegB:cicp:ChannelConfiguration': {\n          const noValue = 0;\n          const channelCountMapping = [\n            noValue, 1, 2, 3, 4, 5, 6, 8, 2, 3, /* 0--9 */\n            4, 7, 8, 24, 8, 12, 10, 12, 14, 12, /* 10--19 */\n            14, /* 20 */\n          ];\n          const intValue = parseInt(value, 10);\n          if (!intValue) {  // 0 or NaN\n            shaka.log.warning('Channel parsing failure! ' +\n                          'Ignoring scheme and value', scheme, value);\n            continue;\n          }\n          if (intValue > noValue && intValue < channelCountMapping.length) {\n            return channelCountMapping[intValue];\n          }\n          continue;\n        }\n\n        default:\n          shaka.log.warning(\n              'Unrecognized audio channel scheme:', scheme, value);\n          continue;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Verifies that a Representation has exactly one Segment* element.  Prints\n   * warnings if there is a problem.\n   *\n   * @param {shaka.dash.DashParser.InheritanceFrame} frame\n   * @return {boolean} True if the Representation is usable; otherwise return\n   *   false.\n   * @private\n   */\n  verifyRepresentation_(frame) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    let n = 0;\n    n += frame.segmentBase ? 1 : 0;\n    n += frame.segmentList ? 1 : 0;\n    n += frame.segmentTemplate ? 1 : 0;\n\n    if (n == 0) {\n      // TODO: Extend with the list of MIME types registered to TextEngine.\n      if (frame.contentType == ContentType.TEXT ||\n          frame.contentType == ContentType.APPLICATION) {\n        return true;\n      } else {\n        shaka.log.warning(\n            'Representation does not contain a segment information source:',\n            'the Representation must contain one of SegmentBase, SegmentList,',\n            'SegmentTemplate, or explicitly indicate that it is \"text\".',\n            frame);\n        return false;\n      }\n    }\n\n    if (n != 1) {\n      shaka.log.warning(\n          'Representation contains multiple segment information sources:',\n          'the Representation should only contain one of SegmentBase,',\n          'SegmentList, or SegmentTemplate.',\n          frame);\n      if (frame.segmentBase) {\n        shaka.log.info('Using SegmentBase by default.');\n        frame.segmentList = null;\n        frame.segmentTemplate = null;\n      } else {\n        goog.asserts.assert(frame.segmentList, 'There should be a SegmentList');\n        shaka.log.info('Using SegmentList by default.');\n        frame.segmentTemplate = null;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Makes a request to the given URI and calculates the clock offset.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {string} uri\n   * @param {string} method\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async requestForTiming_(baseUris, uri, method) {\n    const requestUris =\n        shaka.util.ManifestParserUtils.resolveUris(baseUris, [uri]);\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        requestUris, this.config_.retryParameters);\n    request.method = method;\n    const type = shaka.net.NetworkingEngine.RequestType.TIMING;\n\n    const operation =\n    this.playerInterface_.networkingEngine.request(type, request);\n    this.operationManager_.manage(operation);\n\n    const response = await operation.promise;\n    let text;\n    if (method == 'HEAD') {\n      if (!response.headers || !response.headers['date']) {\n        shaka.log.warning('UTC timing response is missing',\n            'expected date header');\n        return 0;\n      }\n      text = response.headers['date'];\n    } else {\n      text = shaka.util.StringUtils.fromUTF8(response.data);\n    }\n    const date = Date.parse(text);\n    if (isNaN(date)) {\n      shaka.log.warning('Unable to parse date from UTC timing response');\n      return 0;\n    }\n    return (date - Date.now());\n  }\n\n  /**\n   * Parses an array of UTCTiming elements.\n   *\n   * @param {!Array.<string>} baseUris\n   * @param {!Array.<!Element>} elems\n   * @return {!Promise.<number>}\n   * @private\n   */\n  async parseUtcTiming_(baseUris, elems) {\n    const schemesAndValues = elems.map((elem) => {\n      return {\n        scheme: elem.getAttribute('schemeIdUri'),\n        value: elem.getAttribute('value'),\n      };\n    });\n\n    // If there's nothing specified in the manifest, but we have a default from\n    // the config, use that.\n    const clockSyncUri = this.config_.dash.clockSyncUri;\n    if (!schemesAndValues.length && clockSyncUri) {\n      schemesAndValues.push({\n        scheme: 'urn:mpeg:dash:utc:http-head:2014',\n        value: clockSyncUri,\n      });\n    }\n\n    for (const sv of schemesAndValues) {\n      try {\n        const scheme = sv.scheme;\n        const value = sv.value;\n        switch (scheme) {\n          // See DASH IOP Guidelines Section 4.7\n          // https://bit.ly/DashIop3-2\n          // Some old ISO23009-1 drafts used 2012.\n          case 'urn:mpeg:dash:utc:http-head:2014':\n          case 'urn:mpeg:dash:utc:http-head:2012':\n            // eslint-disable-next-line no-await-in-loop\n            return await this.requestForTiming_(baseUris, value, 'HEAD');\n          case 'urn:mpeg:dash:utc:http-xsdate:2014':\n          case 'urn:mpeg:dash:utc:http-iso:2014':\n          case 'urn:mpeg:dash:utc:http-xsdate:2012':\n          case 'urn:mpeg:dash:utc:http-iso:2012':\n            // eslint-disable-next-line no-await-in-loop\n            return await this.requestForTiming_(baseUris, value, 'GET');\n          case 'urn:mpeg:dash:utc:direct:2014':\n          case 'urn:mpeg:dash:utc:direct:2012': {\n            const date = Date.parse(value);\n            return isNaN(date) ? 0 : (date - Date.now());\n          }\n\n          case 'urn:mpeg:dash:utc:http-ntp:2014':\n          case 'urn:mpeg:dash:utc:ntp:2014':\n          case 'urn:mpeg:dash:utc:sntp:2014':\n            shaka.log.alwaysWarn('NTP UTCTiming scheme is not supported');\n            break;\n          default:\n            shaka.log.alwaysWarn(\n                'Unrecognized scheme in UTCTiming element', scheme);\n            break;\n        }\n      } catch (e) {\n        shaka.log.warning('Error fetching time from UTCTiming elem', e.message);\n      }\n    }\n\n    shaka.log.alwaysWarn(\n        'A UTCTiming element should always be given in live manifests! ' +\n        'This content may not play on clients with bad clocks!');\n    return 0;\n  }\n\n  /**\n   * Parses an EventStream element.\n   *\n   * @param {number} periodStart\n   * @param {?number} periodDuration\n   * @param {!Element} elem\n   * @param {number} availabilityStart\n   * @private\n   */\n  parseEventStream_(periodStart, periodDuration, elem, availabilityStart) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const parseNumber = XmlUtils.parseNonNegativeInt;\n\n    const schemeIdUri = elem.getAttribute('schemeIdUri') || '';\n    const value = elem.getAttribute('value') || '';\n    const timescale = XmlUtils.parseAttr(elem, 'timescale', parseNumber) || 1;\n\n    for (const eventNode of XmlUtils.findChildren(elem, 'Event')) {\n      const presentationTime =\n          XmlUtils.parseAttr(eventNode, 'presentationTime', parseNumber) || 0;\n      const duration =\n          XmlUtils.parseAttr(eventNode, 'duration', parseNumber) || 0;\n\n      let startTime = presentationTime / timescale + periodStart;\n      let endTime = startTime + (duration / timescale);\n      if (periodDuration != null) {\n        // An event should not go past the Period, even if the manifest says so.\n        // See: Dash sec. 5.10.2.1\n        startTime = Math.min(startTime, periodStart + periodDuration);\n        endTime = Math.min(endTime, periodStart + periodDuration);\n      }\n\n      // Don't add unavailable regions to the timeline.\n      if (endTime < availabilityStart) {\n        continue;\n      }\n\n      /** @type {shaka.extern.TimelineRegionInfo} */\n      const region = {\n        schemeIdUri: schemeIdUri,\n        value: value,\n        startTime: startTime,\n        endTime: endTime,\n        id: eventNode.getAttribute('id') || '',\n        eventElement: eventNode,\n      };\n\n      this.playerInterface_.onTimelineRegionAdded(region);\n    }\n  }\n\n  /**\n   * Makes a network request on behalf of SegmentBase.createStreamInfo.\n   *\n   * @param {!Array.<string>} uris\n   * @param {?number} startByte\n   * @param {?number} endByte\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async requestInitSegment_(uris, startByte, endByte) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    const request = shaka.util.Networking.createSegmentRequest(\n        uris,\n        startByte,\n        endByte,\n        this.config_.retryParameters);\n\n    const networkingEngine = this.playerInterface_.networkingEngine;\n    const operation = networkingEngine.request(requestType, request);\n    this.operationManager_.manage(operation);\n    const response = await operation.promise;\n    return response.data;\n  }\n\n  /**\n   * Guess the content type based on MIME type and codecs.\n   *\n   * @param {string} mimeType\n   * @param {string} codecs\n   * @return {string}\n   * @private\n   */\n  static guessContentType_(mimeType, codecs) {\n    const fullMimeType = shaka.util.MimeUtils.getFullType(mimeType, codecs);\n\n    if (shaka.text.TextEngine.isTypeSupported(fullMimeType)) {\n      // If it's supported by TextEngine, it's definitely text.\n      // We don't check MediaSourceEngine, because that would report support\n      // for platform-supported video and audio types as well.\n      return shaka.util.ManifestParserUtils.ContentType.TEXT;\n    }\n\n    // Otherwise, just split the MIME type.  This handles video and audio\n    // types well.\n    return mimeType.split('/')[0];\n  }\n};\n\n\n/**\n * Contains the minimum amount of time, in seconds, between manifest update\n * requests.\n *\n * @private\n * @const {number}\n */\nshaka.dash.DashParser.MIN_UPDATE_PERIOD_ = 3;\n\n\n/**\n * @typedef {\n *   function(!Array.<string>, ?number, ?number):!Promise.<BufferSource>\n * }\n */\nshaka.dash.DashParser.RequestInitSegmentCallback;\n\n\n/**\n * @typedef {{\n *   segmentBase: Element,\n *   segmentList: Element,\n *   segmentTemplate: Element,\n *   baseUris: !Array.<string>,\n *   width: (number|undefined),\n *   height: (number|undefined),\n *   contentType: string,\n *   mimeType: string,\n *   codecs: string,\n *   frameRate: (number|undefined),\n *   pixelAspectRatio: (string|undefined),\n *   emsgSchemeIdUris: !Array.<string>,\n *   id: ?string,\n *   numChannels: ?number,\n *   audioSamplingRate: ?number,\n *   availabilityTimeOffset: number\n * }}\n *\n * @description\n * A collection of elements and properties which are inherited across levels\n * of a DASH manifest.\n *\n * @property {Element} segmentBase\n *   The XML node for SegmentBase.\n * @property {Element} segmentList\n *   The XML node for SegmentList.\n * @property {Element} segmentTemplate\n *   The XML node for SegmentTemplate.\n * @property {!Array.<string>} baseUris\n *   An array of absolute base URIs for the frame.\n * @property {(number|undefined)} width\n *   The inherited width value.\n * @property {(number|undefined)} height\n *   The inherited height value.\n * @property {string} contentType\n *   The inherited media type.\n * @property {string} mimeType\n *   The inherited MIME type value.\n * @property {string} codecs\n *   The inherited codecs value.\n * @property {(number|undefined)} frameRate\n *   The inherited framerate value.\n * @property {(string|undefined)} pixelAspectRatio\n *   The inherited pixel aspect ratio value.\n * @property {!Array.<string>} emsgSchemeIdUris\n *   emsg registered schemeIdUris.\n * @property {?string} id\n *   The ID of the element.\n * @property {?number} numChannels\n *   The number of audio channels, or null if unknown.\n * @property {?number} audioSamplingRate\n *   Specifies the maximum sampling rate of the content, or null if unknown.\n * @property {number} availabilityTimeOffset\n *   Specifies the total availabilityTimeOffset of the segment, or 0 if unknown.\n */\nshaka.dash.DashParser.InheritanceFrame;\n\n\n/**\n * @typedef {{\n *   dynamic: boolean,\n *   presentationTimeline: !shaka.media.PresentationTimeline,\n *   period: ?shaka.dash.DashParser.InheritanceFrame,\n *   periodInfo: ?shaka.dash.DashParser.PeriodInfo,\n *   adaptationSet: ?shaka.dash.DashParser.InheritanceFrame,\n *   representation: ?shaka.dash.DashParser.InheritanceFrame,\n *   bandwidth: number,\n *   indexRangeWarningGiven: boolean,\n *   availabilityTimeOffset: number,\n *   profiles: !Array.<string>\n * }}\n *\n * @description\n * Contains context data for the streams.  This is designed to be\n * shallow-copyable, so the parser must overwrite (not modify) each key as the\n * parser moves through the manifest and the parsing context changes.\n *\n * @property {boolean} dynamic\n *   True if the MPD is dynamic (not all segments available at once)\n * @property {!shaka.media.PresentationTimeline} presentationTimeline\n *   The PresentationTimeline.\n * @property {?shaka.dash.DashParser.InheritanceFrame} period\n *   The inheritance from the Period element.\n * @property {?shaka.dash.DashParser.PeriodInfo} periodInfo\n *   The Period info for the current Period.\n * @property {?shaka.dash.DashParser.InheritanceFrame} adaptationSet\n *   The inheritance from the AdaptationSet element.\n * @property {?shaka.dash.DashParser.InheritanceFrame} representation\n *   The inheritance from the Representation element.\n * @property {number} bandwidth\n *   The bandwidth of the Representation, or zero if missing.\n * @property {boolean} indexRangeWarningGiven\n *   True if the warning about SegmentURL@indexRange has been printed.\n * @property {number} availabilityTimeOffset\n *   The sum of the availabilityTimeOffset values that apply to the element.\n * @property {!Array.<string>} profiles\n *   Profiles of DASH are defined to enable interoperability and the signaling\n *   of the use of features.\n */\nshaka.dash.DashParser.Context;\n\n\n/**\n * @typedef {{\n *   start: number,\n *   duration: ?number,\n *   node: !Element,\n *   isLastPeriod: boolean\n * }}\n *\n * @description\n * Contains information about a Period element.\n *\n * @property {number} start\n *   The start time of the period.\n * @property {?number} duration\n *   The duration of the period; or null if the duration is not given.  This\n *   will be non-null for all periods except the last.\n * @property {!Element} node\n *   The XML Node for the Period.\n * @property {boolean} isLastPeriod\n *   Whether this Period is the last one in the manifest.\n */\nshaka.dash.DashParser.PeriodInfo;\n\n\n/**\n * @typedef {{\n *   id: string,\n *   contentType: ?string,\n *   language: string,\n *   main: boolean,\n *   streams: !Array.<shaka.extern.Stream>,\n *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n *   trickModeFor: ?string,\n *   representationIds: !Array.<string>\n * }}\n *\n * @description\n * Contains information about an AdaptationSet element.\n *\n * @property {string} id\n *   The unique ID of the adaptation set.\n * @property {?string} contentType\n *   The content type of the AdaptationSet.\n * @property {string} language\n *   The language of the AdaptationSet.\n * @property {boolean} main\n *   Whether the AdaptationSet has the 'main' type.\n * @property {!Array.<shaka.extern.Stream>} streams\n *   The streams this AdaptationSet contains.\n * @property {!Array.<shaka.extern.DrmInfo>} drmInfos\n *   The DRM info for the AdaptationSet.\n * @property {?string} trickModeFor\n *   If non-null, this AdaptationInfo represents trick mode tracks.  This\n *   property is the ID of the normal AdaptationSet these tracks should be\n *   associated with.\n * @property {!Array.<string>} representationIds\n *   An array of the IDs of the Representations this AdaptationSet contains.\n */\nshaka.dash.DashParser.AdaptationInfo;\n\n\n/**\n * @typedef {function():!Promise.<shaka.media.SegmentIndex>}\n * @description\n * An async function which generates and returns a SegmentIndex.\n */\nshaka.dash.DashParser.GenerateSegmentIndexFunction;\n\n\n/**\n * @typedef {{\n *   generateSegmentIndex: shaka.dash.DashParser.GenerateSegmentIndexFunction\n * }}\n *\n * @description\n * Contains information about a Stream. This is passed from the createStreamInfo\n * methods.\n *\n * @property {shaka.dash.DashParser.GenerateSegmentIndexFunction}\n *     generateSegmentIndex\n *   An async function to create the SegmentIndex for the stream.\n */\nshaka.dash.DashParser.StreamInfo;\n\n\nshaka.media.ManifestParser.registerParserByExtension(\n    'mpd', () => new shaka.dash.DashParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'application/dash+xml', () => new shaka.dash.DashParser());\nshaka.media.ManifestParser.registerParserByMime(\n    'video/vnd.mpeg.dash.mpd', () => new shaka.dash.DashParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.Attribute');\ngoog.provide('shaka.hls.Playlist');\ngoog.provide('shaka.hls.PlaylistType');\ngoog.provide('shaka.hls.Segment');\ngoog.provide('shaka.hls.Tag');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.util.Error');\n\n\n/**\n * HLS playlist class.\n */\nshaka.hls.Playlist = class {\n  /**\n   * @param {string} absoluteUri An absolute, final URI after redirects.\n   * @param {!shaka.hls.PlaylistType} type\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {!Array.<shaka.hls.Segment>=} segments\n   */\n  constructor(absoluteUri, type, tags, segments) {\n    /**\n     * An absolute, final URI after redirects.\n     *\n     * @const {string}\n     */\n    this.absoluteUri = absoluteUri;\n\n    /** @const {shaka.hls.PlaylistType} */\n    this.type = type;\n\n    /** @const {!Array.<!shaka.hls.Tag>} */\n    this.tags = tags;\n\n    /** @const {Array.<!shaka.hls.Segment>} */\n    this.segments = segments || null;\n  }\n};\n\n\n/**\n * @enum {number}\n */\nshaka.hls.PlaylistType = {\n  MASTER: 0,\n  MEDIA: 1,\n};\n\n\n/**\n * HLS tag class.\n */\nshaka.hls.Tag = class {\n  /**\n   * @param {number} id\n   * @param {string} name\n   * @param {!Array.<shaka.hls.Attribute>} attributes\n   * @param {?string=} value\n   */\n  constructor(id, name, attributes, value = null) {\n    /** @const {number} */\n    this.id = id;\n\n    /** @type {string} */\n    this.name = name;\n\n    /** @const {!Array.<shaka.hls.Attribute>} */\n    this.attributes = attributes;\n\n    /** @const {?string} */\n    this.value = value;\n  }\n\n  /**\n   * Create the string representation of the tag.\n   *\n   * For the DRM system - the full tag needs to be passed down to the CDM.\n   * There are two ways of doing this (1) save the original tag or (2) recreate\n   * the tag.\n   * As in some cases (like in tests) the tag never existed in string form, it\n   * is far easier to recreate the tag from the parsed form.\n   *\n   * @return {string}\n   * @override\n   */\n  toString() {\n    /**\n     * @param {shaka.hls.Attribute} attr\n     * @return {string}\n     */\n    const attrToStr = (attr) => {\n      const isNumericAttr = !isNaN(Number(attr.value));\n      const value = (isNumericAttr ? attr.value : '\"' + attr.value + '\"');\n      return attr.name + '=' + value;\n    };\n    // A valid tag can only follow 1 of 4 patterns.\n    //  1) <NAME>:<VALUE>\n    //  2) <NAME>:<ATTRIBUTE LIST>\n    //  3) <NAME>\n    //  4) <NAME>:<VALUE>,<ATTRIBUTE_LIST>\n\n    let tagStr = '#' + this.name;\n    const appendages = this.attributes ? this.attributes.map(attrToStr) : [];\n\n    if (this.value) {\n      appendages.unshift(this.value);\n    }\n\n    if (appendages.length > 0) {\n      tagStr += ':' + appendages.join(',');\n    }\n\n    return tagStr;\n  }\n\n  /**\n   * Adds an attribute to an HLS Tag.\n   *\n   * @param {!shaka.hls.Attribute} attribute\n   */\n  addAttribute(attribute) {\n    this.attributes.push(attribute);\n  }\n\n\n  /**\n   * Gets the first attribute of the tag with a specified name.\n   *\n   * @param {string} name\n   * @return {?shaka.hls.Attribute} attribute\n   */\n  getAttribute(name) {\n    const attributes = this.attributes.filter((attr) => {\n      return attr.name == name;\n    });\n\n    goog.asserts.assert(attributes.length < 2,\n        'A tag should not have multiple attributes ' +\n                        'with the same name!');\n\n    if (attributes.length) {\n      return attributes[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the value of the first attribute of the tag with a specified name.\n   * If not found, returns an optional default value.\n   *\n   * @param {string} name\n   * @param {string=} defaultValue\n   * @return {?string}\n   */\n  getAttributeValue(name, defaultValue) {\n    const attribute = this.getAttribute(name);\n    return attribute ? attribute.value : (defaultValue || null);\n  }\n\n\n  /**\n   * Finds the attribute and returns its value.\n   * Throws an error if attribute was not found.\n   *\n   * @param {string} name\n   * @return {string}\n   */\n  getRequiredAttrValue(name) {\n    const attribute = this.getAttribute(name);\n    if (!attribute) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING,\n          name);\n    }\n\n    return attribute.value;\n  }\n\n  /**\n   * Set the name of the tag. Used only for Preload hinted MAP tag.\n   * @param {string} name\n   */\n  setName(name) {\n    this.name = name;\n  }\n};\n\n\n/**\n * HLS segment class.\n */\nshaka.hls.Segment = class {\n  /**\n   * Creates an HLS segment object.\n   *\n   * @param {string} absoluteUri An absolute URI.\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {!Array.<shaka.hls.Tag>=} partialSegments\n   */\n  constructor(absoluteUri, tags, partialSegments=[]) {\n    /** @const {!Array.<shaka.hls.Tag>} */\n    this.tags = tags;\n\n    /**\n     * An absolute URI.\n     *\n     * @const {string}\n     */\n    this.absoluteUri = absoluteUri;\n\n    /** @type {!Array.<shaka.hls.Tag>} */\n    this.partialSegments = partialSegments;\n  }\n};\n\n\n/**\n * HLS Attribute class.\n */\nshaka.hls.Attribute = class {\n  /**\n   * Creates an HLS attribute object.\n   *\n   * @param {string} name\n   * @param {string} value\n   */\n  constructor(name, value) {\n    /** @const {string} */\n    this.name = name;\n\n    /** @const {string} */\n    this.value = value;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.Utils');\n\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.requireType('shaka.hls.Tag');\n\n\nshaka.hls.Utils = class {\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @return {!Array.<!shaka.hls.Tag>}\n   */\n  static filterTagsByName(tags, name) {\n    return tags.filter((tag) => {\n      return tag.name == name;\n    });\n  }\n\n\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} type\n   * @return {!Array.<!shaka.hls.Tag>}\n   */\n  static filterTagsByType(tags, type) {\n    return tags.filter((tag) => {\n      const tagType = tag.getRequiredAttrValue('TYPE');\n      return tagType == type;\n    });\n  }\n\n\n  /**\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @return {?shaka.hls.Tag}\n   */\n  static getFirstTagWithName(tags, name) {\n    const tagsWithName = shaka.hls.Utils.filterTagsByName(tags, name);\n    if (!tagsWithName.length) {\n      return null;\n    }\n\n    return tagsWithName[0];\n  }\n\n  /**\n   * Get the numerical value of the first tag with given name if available.\n   * Return the default value if the tag is not present.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} tags\n   * @param {string} name\n   * @param {number=} defaultValue\n   * @return {number}\n   */\n  static getFirstTagWithNameAsNumber(tags, name, defaultValue = 0) {\n    const tag = shaka.hls.Utils.getFirstTagWithName(tags, name);\n    const value = tag ? Number(tag.value) : defaultValue;\n    return value;\n  }\n\n\n  /**\n   * @param {string} parentAbsoluteUri\n   * @param {string} uri\n   * @return {string}\n   */\n  static constructAbsoluteUri(parentAbsoluteUri, uri) {\n    const uris = shaka.util.ManifestParserUtils.resolveUris(\n        [parentAbsoluteUri], [uri]);\n\n    return uris[0];\n  }\n\n\n  /**\n   * Matches a string to an HLS comment format and returns the result.\n   *\n   * @param {string} line\n   * @return {boolean}\n   */\n  static isComment(line) {\n    return /^#(?!EXT)/m.test(line);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\ngoog.provide('shaka.hls.HlsParser');\n\ngoog.require('goog.Uri');\ngoog.require('goog.asserts');\ngoog.require('shaka.hls.ManifestTextParser');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.media.MediaSourceEngine');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.net.DataUriPlugin');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.CmcdManager');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.LanguageUtils');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.OperationManager');\ngoog.require('shaka.util.Pssh');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Uint8ArrayUtils');\ngoog.require('shaka.util.XmlUtils');\ngoog.requireType('shaka.hls.Segment');\n\n\n/**\n * HLS parser.\n *\n * @implements {shaka.extern.ManifestParser}\n * @export\n */\nshaka.hls.HlsParser = class {\n  /**\n   * Creates an Hls Parser object.\n   */\n  constructor() {\n    /** @private {?shaka.extern.ManifestParser.PlayerInterface} */\n    this.playerInterface_ = null;\n\n    /** @private {?shaka.extern.ManifestConfiguration} */\n    this.config_ = null;\n\n    /** @private {number} */\n    this.globalId_ = 1;\n\n    /** @private {!Map.<string, string>} */\n    this.globalVariables_ = new Map();\n\n    /**\n     * A map from group id to stream infos created from the media tags.\n     * @private {!Map.<string, !Array.<?shaka.hls.HlsParser.StreamInfo>>}\n     */\n    this.groupIdToStreamInfosMap_ = new Map();\n\n    /**\n     * For media playlist lazy-loading to work in livestreams, we have to assume\n     * that each stream of a type (video, audio, etc) has the same mappings of\n     * sequence number to start time.\n     * This map stores those relationships.\n     * Only used during livestreams; we do not assume that VOD content is\n     * aligned in that way.\n     * @private {!Map.<string, !Map.<number, number>>}\n     */\n    this.mediaSequenceToStartTimeByType_ = new Map();\n\n    // Set initial maps.\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    this.mediaSequenceToStartTimeByType_.set(ContentType.VIDEO, new Map());\n    this.mediaSequenceToStartTimeByType_.set(ContentType.AUDIO, new Map());\n    this.mediaSequenceToStartTimeByType_.set(ContentType.TEXT, new Map());\n    this.mediaSequenceToStartTimeByType_.set(ContentType.IMAGE, new Map());\n\n    /**\n     * The values are strings of the form \"<VIDEO URI> - <AUDIO URI>\",\n     * where the URIs are the verbatim media playlist URIs as they appeared in\n     * the master playlist.\n     *\n     * Used to avoid duplicates that vary only in their text stream.\n     *\n     * @private {!Set.<string>}\n     */\n    this.variantUriSet_ = new Set();\n\n    /**\n     * A map from (verbatim) media playlist URI to stream infos representing the\n     * playlists.\n     *\n     * On update, used to iterate through and update from media playlists.\n     *\n     * On initial parse, used to iterate through and determine minimum\n     * timestamps, offsets, and to handle TS rollover.\n     *\n     * During parsing, used to avoid duplicates in the async methods\n     * createStreamInfoFromMediaTag_, createStreamInfoFromImageTag_ and\n     * createStreamInfoFromVariantTag_.\n     *\n     * @private {!Map.<string, shaka.hls.HlsParser.StreamInfo>}\n     */\n    this.uriToStreamInfosMap_ = new Map();\n\n    /** @private {?shaka.media.PresentationTimeline} */\n    this.presentationTimeline_ = null;\n\n    /**\n     * The master playlist URI, after redirects.\n     *\n     * @private {string}\n     */\n    this.masterPlaylistUri_ = '';\n\n    /** @private {shaka.hls.ManifestTextParser} */\n    this.manifestTextParser_ = new shaka.hls.ManifestTextParser();\n\n    /**\n     * This is the number of seconds we want to wait between finishing a\n     * manifest update and starting the next one. This will be set when we parse\n     * the manifest.\n     *\n     * @private {number}\n     */\n    this.updatePlaylistDelay_ = 0;\n\n    /**\n     * The minimum sequence number for generated segments, when ignoring\n     * EXT-X-PROGRAM-DATE-TIME.\n     *\n     * @private {number}\n     */\n    this.minSequenceNumber_ = -1;\n\n    /**\n     * The lowest time value for any of the streams, as defined by the\n     * EXT-X-PROGRAM-DATE-TIME value. Measured in seconds since January 1, 1970.\n     *\n     * @private {number}\n     */\n    this.lowestSyncTime_ = Infinity;\n\n    /**\n     * Whether the streams have previously been \"finalized\"; that is to say,\n     * whether we have loaded enough streams to know information about the asset\n     * such as timing information, live status, etc.\n     *\n     * @private {boolean}\n     */\n    this.streamsFinalized_ = false;\n\n    /**\n     * This timer is used to trigger the start of a manifest update. A manifest\n     * update is async. Once the update is finished, the timer will be restarted\n     * to trigger the next update. The timer will only be started if the content\n     * is live content.\n     *\n     * @private {shaka.util.Timer}\n     */\n    this.updatePlaylistTimer_ = new shaka.util.Timer(() => {\n      this.onUpdate_();\n    });\n\n    /** @private {shaka.hls.HlsParser.PresentationType_} */\n    this.presentationType_ = shaka.hls.HlsParser.PresentationType_.VOD;\n\n    /** @private {?shaka.extern.Manifest} */\n    this.manifest_ = null;\n\n    /** @private {number} */\n    this.maxTargetDuration_ = 0;\n\n    /** @private {number} */\n    this.minTargetDuration_ = Infinity;\n\n    /** Partial segments target duration.\n     * @private {number}\n     */\n    this.partialTargetDuration_ = 0;\n\n    /** @private {number} */\n    this.lowLatencyPresentationDelay_ = 0;\n\n    /** @private {shaka.util.OperationManager} */\n    this.operationManager_ = new shaka.util.OperationManager();\n\n    /** A map from closed captions' group id, to a map of closed captions info.\n     * {group id -> {closed captions channel id -> language}}\n     * @private {Map.<string, Map.<string, string>>}\n     */\n    this.groupIdToClosedCaptionsMap_ = new Map();\n\n    /** @private {Map.<string, string>} */\n    this.groupIdToCodecsMap_ = new Map();\n\n    /** A cache mapping EXT-X-MAP tag info to the InitSegmentReference created\n     * from the tag.\n     * The key is a string combining the EXT-X-MAP tag's absolute uri, and\n     * its BYTERANGE if available.\n     * {!Map.<string, !shaka.media.InitSegmentReference>} */\n    this.mapTagToInitSegmentRefMap_ = new Map();\n\n    /** @private {boolean} */\n    this.lowLatencyMode_ = false;\n  }\n\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  configure(config) {\n    this.config_ = config;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async start(uri, playerInterface) {\n    goog.asserts.assert(this.config_, 'Must call configure() before start()!');\n    this.playerInterface_ = playerInterface;\n    this.lowLatencyMode_ = playerInterface.isLowLatencyMode();\n\n    const response = await this.requestManifest_(uri);\n\n    // Record the master playlist URI after redirects.\n    this.masterPlaylistUri_ = response.uri;\n\n    goog.asserts.assert(response.data, 'Response data should be non-null!');\n    await this.parseManifest_(response.data, uri);\n\n    goog.asserts.assert(this.manifest_, 'Manifest should be non-null');\n    return this.manifest_;\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  stop() {\n    // Make sure we don't update the manifest again. Even if the timer is not\n    // running, this is safe to call.\n    if (this.updatePlaylistTimer_) {\n      this.updatePlaylistTimer_.stop();\n      this.updatePlaylistTimer_ = null;\n    }\n\n    /** @type {!Array.<!Promise>} */\n    const pending = [];\n\n    if (this.operationManager_) {\n      pending.push(this.operationManager_.destroy());\n      this.operationManager_ = null;\n    }\n\n    this.playerInterface_ = null;\n    this.config_ = null;\n    this.variantUriSet_.clear();\n    this.manifest_ = null;\n    this.uriToStreamInfosMap_.clear();\n    this.groupIdToStreamInfosMap_.clear();\n    this.groupIdToCodecsMap_.clear();\n    this.globalVariables_.clear();\n\n    return Promise.all(pending);\n  }\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  async update() {\n    if (!this.isLive_()) {\n      return;\n    }\n\n    /** @type {!Array.<!Promise>} */\n    const updates = [];\n    const streamInfos = Array.from(this.uriToStreamInfosMap_.values());\n\n    // Only update active streams.\n    const activeStreamInfos = streamInfos.filter((s) => s.stream.segmentIndex);\n    for (const streamInfo of activeStreamInfos) {\n      updates.push(this.updateStream_(streamInfo));\n    }\n    await Promise.all(updates);\n\n    // Now that streams have been updated, notify the presentation timeline.\n    this.notifySegmentsForStreams_(activeStreamInfos.map((s) => s.stream));\n\n    // If any hasEndList is false, the stream is still live.\n    const stillLive = activeStreamInfos.some((s) => s.hasEndList == false);\n    if (activeStreamInfos.length && !stillLive) {\n      // Convert the presentation to VOD and set the duration.\n      const PresentationType = shaka.hls.HlsParser.PresentationType_;\n      this.setPresentationType_(PresentationType.VOD);\n\n      const maxTimestamps = streamInfos.map((s) => s.maxTimestamp);\n      // The duration is the minimum of the end times of all streams.\n      this.presentationTimeline_.setDuration(Math.min(...maxTimestamps));\n      this.playerInterface_.updateDuration();\n    }\n  }\n\n  /**\n   * @param {!shaka.hls.HlsParser.StreamInfo} streamInfo\n   * @return {!Map.<number, number>}\n   * @private\n   */\n  getMediaSequenceToStartTimeFor_(streamInfo) {\n    if (this.isLive_()) {\n      return this.mediaSequenceToStartTimeByType_.get(streamInfo.type);\n    } else {\n      return streamInfo.mediaSequenceToStartTime;\n    }\n  }\n\n  /**\n   * Updates a stream.\n   *\n   * @param {!shaka.hls.HlsParser.StreamInfo} streamInfo\n   * @return {!Promise}\n   * @private\n   */\n  async updateStream_(streamInfo) {\n    const manifestUri = streamInfo.absoluteMediaPlaylistUri;\n    const uriObj = new goog.Uri(manifestUri);\n    if (this.lowLatencyMode_ && streamInfo.canSkipSegments) {\n      // Enable delta updates. This will replace older segments with\n      // 'EXT-X-SKIP' tag in the media playlist.\n      uriObj.setQueryData(new goog.Uri.QueryData('_HLS_skip=YES'));\n    }\n    const response = await this.requestManifest_(uriObj.toString());\n    if (!streamInfo.stream.segmentIndex) {\n      // The stream was closed since the update was first requested.\n      return;\n    }\n\n    /** @type {shaka.hls.Playlist} */\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        response.data, response.uri);\n\n    if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = shaka.hls.Utils.filterTagsByName(playlist.tags,\n        'EXT-X-DEFINE');\n\n    const mediaVariables = this.parseMediaVariables_(variablesTags);\n\n    const stream = streamInfo.stream;\n\n    const mediaSequenceToStartTime =\n        this.getMediaSequenceToStartTimeFor_(streamInfo);\n    const {keyIds, drmInfos} = this.parseDrmInfo_(playlist, stream.mimeType);\n\n    const keysAreEqual =\n      (a, b) => a.size === b.size && [...a].every((value) => b.has(value));\n\n    if (!keysAreEqual(stream.keyIds, keyIds)) {\n      stream.keyIds = keyIds;\n      stream.drmInfos = drmInfos;\n      this.playerInterface_.newDrmInfo(stream);\n    }\n\n    const segments = this.createSegments_(\n        streamInfo.verbatimMediaPlaylistUri, playlist, stream.type,\n        stream.mimeType, mediaSequenceToStartTime, mediaVariables);\n\n    stream.segmentIndex.mergeAndEvict(\n        segments, this.presentationTimeline_.getSegmentAvailabilityStart());\n    if (segments.length) {\n      const mediaSequenceNumber = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n          playlist.tags, 'EXT-X-MEDIA-SEQUENCE', 0);\n      const playlistStartTime = mediaSequenceToStartTime.get(\n          mediaSequenceNumber);\n      stream.segmentIndex.evict(playlistStartTime);\n    }\n    const newestSegment = segments[segments.length - 1];\n    goog.asserts.assert(newestSegment, 'Should have segments!');\n\n    // Once the last segment has been added to the playlist,\n    // #EXT-X-ENDLIST tag will be appended.\n    // If that happened, treat the rest of the EVENT presentation as VOD.\n    const endListTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n    if (endListTag) {\n      // Flag this for later.  We don't convert the whole presentation into VOD\n      // until we've seen the ENDLIST tag for all active playlists.\n      streamInfo.hasEndList = true;\n      streamInfo.maxTimestamp = newestSegment.endTime;\n    }\n  }\n\n\n  /**\n   * @override\n   * @exportInterface\n   */\n  onExpirationUpdated(sessionId, expiration) {\n    // No-op\n  }\n\n  /**\n   * Align the streams by sequence number by dropping early segments.  Then\n   * offset the streams to begin at presentation time 0.\n   * @param {!Array.<!shaka.hls.HlsParser.StreamInfo>} streamInfos\n   * @private\n   */\n  syncStreamsWithSequenceNumber_(streamInfos) {\n    // We assume that, when this is first called, we have enough info to\n    // determine how to use the program date times (e.g. we have both a video\n    // and an audio, and all other videos and audios match those).\n    // Thus, we only need to calculate this once.\n    const updateMinSequenceNumber = this.minSequenceNumber_ == -1;\n    // Sync using media sequence number.  Find the highest starting sequence\n    // number among all streams.  Later, we will drop any references to\n    // earlier segments in other streams, then offset everything back to 0.\n    for (const streamInfo of streamInfos) {\n      const segmentIndex = streamInfo.stream.segmentIndex;\n      goog.asserts.assert(segmentIndex,\n          'Only loaded streams should be synced');\n      const mediaSequenceToStartTime =\n          this.getMediaSequenceToStartTimeFor_(streamInfo);\n      const segment0 = segmentIndex.earliestReference();\n      if (segment0) {\n        // This looks inefficient, but iteration order is insertion order.\n        // So the very first entry should be the one we want.\n        // We assert that this holds true so that we are alerted by debug\n        // builds and tests if it changes.  We still do a loop, though, so\n        // that the code functions correctly in production no matter what.\n        if (goog.DEBUG) {\n          const firstSequenceStartTime =\n              mediaSequenceToStartTime.values().next().value;\n          goog.asserts.assert(\n              firstSequenceStartTime == segment0.startTime,\n              'Sequence number map is not ordered as expected!');\n        }\n        for (const [sequence, start] of mediaSequenceToStartTime) {\n          if (start == segment0.startTime) {\n            if (updateMinSequenceNumber) {\n              this.minSequenceNumber_ = Math.max(\n                  this.minSequenceNumber_, sequence);\n            }\n            // Even if we already have decided on a value for\n            // |this.minSequenceNumber_|, we still need to determine the first\n            // sequence number for the stream, to offset it in the code below.\n            streamInfo.firstSequenceNumber = sequence;\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.minSequenceNumber_ < 0) {\n      // Nothing to sync.\n      return;\n    }\n\n    shaka.log.debug('Syncing HLS streams against base sequence number:',\n        this.minSequenceNumber_);\n\n    for (const streamInfo of streamInfos) {\n      const segmentIndex = streamInfo.stream.segmentIndex;\n      if (segmentIndex) {\n        // Drop any earlier references.\n        const numSegmentsToDrop =\n            this.minSequenceNumber_ - streamInfo.firstSequenceNumber;\n        segmentIndex.dropFirstReferences(numSegmentsToDrop);\n\n        // Now adjust timestamps back to begin at 0.\n        const segmentN = segmentIndex.earliestReference();\n        if (segmentN) {\n          const streamOffset = -segmentN.startTime;\n          // Modify all SegmentReferences equally.\n          streamInfo.stream.segmentIndex.offset(streamOffset);\n          // Update other parts of streamInfo the same way.\n          this.offsetStreamInfo_(streamInfo, streamOffset);\n        }\n      }\n    }\n  }\n\n  /**\n   * Synchronize streams by the EXT-X-PROGRAM-DATE-TIME tags attached to their\n   * segments.  Also normalizes segment times so that the earliest segment in\n   * any stream is at time 0.\n   * @param {!Array.<!shaka.hls.HlsParser.StreamInfo>} streamInfos\n   * @private\n   */\n  syncStreamsWithProgramDateTime_(streamInfos) {\n    // We assume that, when this is first called, we have enough info to\n    // determine how to use the program date times (e.g. we have both a video\n    // and an audio, and all other videos and audios match those).\n    // Thus, we only need to calculate this once.\n    if (this.lowestSyncTime_ == Infinity) {\n      for (const streamInfo of streamInfos) {\n        const segmentIndex = streamInfo.stream.segmentIndex;\n        goog.asserts.assert(segmentIndex,\n            'Only loaded streams should be synced');\n        const segment0 = segmentIndex.earliestReference();\n        if (segment0 != null && segment0.syncTime != null) {\n          this.lowestSyncTime_ =\n              Math.min(this.lowestSyncTime_, segment0.syncTime);\n        }\n      }\n    }\n\n    const lowestSyncTime = this.lowestSyncTime_;\n    if (lowestSyncTime == Infinity) {\n      // Nothing to sync.\n      return;\n    }\n\n    shaka.log.debug('Syncing HLS streams against base time:', lowestSyncTime);\n\n    for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n      const segmentIndex = streamInfo.stream.segmentIndex;\n      if (segmentIndex != null) {\n        // A segment's startTime should be based on its syncTime vs the lowest\n        // syncTime across all streams.  The earliest segment sync time from\n        // any stream will become presentation time 0.  If two streams start\n        // e.g. 6 seconds apart in syncTime, then their first segments will\n        // also start 6 seconds apart in presentation time.\n\n        const segment0 = segmentIndex.earliestReference();\n        if (segment0.syncTime == null) {\n          shaka.log.alwaysError('Missing EXT-X-PROGRAM-DATE-TIME for stream',\n              streamInfo.verbatimMediaPlaylistUri,\n              'Expect AV sync issues!');\n        } else {\n          // Stream metadata are offset by a fixed amount based on the\n          // first segment.\n          const segment0TargetTime = segment0.syncTime - lowestSyncTime;\n          const streamOffset = segment0TargetTime - segment0.startTime;\n          this.offsetStreamInfo_(streamInfo, streamOffset);\n\n          // This is computed across all segments separately to manage\n          // accumulated drift in durations.\n          for (const segment of segmentIndex) {\n            segment.syncAgainst(lowestSyncTime);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {!shaka.hls.HlsParser.StreamInfo} streamInfo\n   * @param {number} offset\n   * @private\n   */\n  offsetStreamInfo_(streamInfo, offset) {\n    // Adjust our accounting of the maximum timestamp.\n    streamInfo.maxTimestamp += offset;\n    goog.asserts.assert(streamInfo.maxTimestamp >= 0,\n        'Negative maxTimestamp after adjustment!');\n\n    // Update our map from sequence number to start time.\n    const mediaSequenceToStartTime =\n        this.getMediaSequenceToStartTimeFor_(streamInfo);\n    for (const [key, value] of mediaSequenceToStartTime) {\n      mediaSequenceToStartTime.set(key, value + offset);\n    }\n\n    shaka.log.debug('Offset', offset, 'applied to',\n        streamInfo.verbatimMediaPlaylistUri);\n  }\n\n  /**\n   * Parses the manifest.\n   *\n   * @param {BufferSource} data\n   * @param {string} uri\n   * @return {!Promise}\n   * @private\n   */\n  async parseManifest_(data, uri) {\n    const HlsParser = shaka.hls.HlsParser;\n    const Utils = shaka.hls.Utils;\n\n    goog.asserts.assert(this.masterPlaylistUri_,\n        'Master playlist URI must be set before calling parseManifest_!');\n\n    const playlist = this.manifestTextParser_.parsePlaylist(\n        data, this.masterPlaylistUri_);\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-DEFINE');\n\n    this.parseMasterVariables_(variablesTags);\n\n    /** @type {!Array.<!shaka.extern.Variant>} */\n    let variants = [];\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    let textStreams = [];\n    /** @type {!Array.<!shaka.extern.Stream>} */\n    let imageStreams = [];\n\n    // Parsing a media playlist results in a single-variant stream.\n    if (playlist.type == shaka.hls.PlaylistType.MEDIA) {\n      // Get necessary info for this stream, from the config. These are things\n      // we would normally find from the master playlist (e.g. from values on\n      // EXT-X-MEDIA tags).\n      let fullMimeType = this.config_.hls.mediaPlaylistFullMimeType;\n      // Try to infer the full mimetype better.\n      if (playlist.segments.length) {\n        const parsedUri = new goog.Uri(playlist.segments[0].absoluteUri);\n        const extension = parsedUri.getPath().split('.').pop();\n        let mimeType = HlsParser.RAW_FORMATS_TO_MIME_TYPES_[extension];\n        if (mimeType) {\n          fullMimeType = mimeType;\n        } else if (extension === 'ts') {\n          // TODO: Fetch one segment a use the TsParser to analize if there is\n          // video, audio or both.\n        } else if (extension === 'mp4') {\n          // TODO: Fetch one segment a use the Mp4Parser to analize if there is\n          // video, audio or both.\n        } else if (HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_[extension]) {\n          mimeType = HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_[extension];\n          const defaultAudioCodec = this.config_.hls.defaultAudioCodec;\n          fullMimeType = `${mimeType}; codecs=\"${defaultAudioCodec}\"`;\n        } else if (HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_[extension]) {\n          mimeType = HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_[extension];\n          const defaultVideoCodec = this.config_.hls.defaultVideoCodec;\n          fullMimeType = `${mimeType}; codecs=\"${defaultVideoCodec}\"`;\n        }\n      }\n\n      const mimeType = shaka.util.MimeUtils.getBasicType(fullMimeType);\n      const type = mimeType.split('/')[0];\n      const codecs = shaka.util.MimeUtils.getCodecs(fullMimeType);\n\n      // Some values we cannot figure out, and aren't important enough to ask\n      // the user to provide through config values. A lot of these are only\n      // relevant to ABR, which isn't necessary if there's only one variant.\n      // So these unknowns should be set to false or null, largely.\n      const language = '';\n      const channelsCount = null;\n      const spatialAudio = false;\n      const characteristics = null;\n      const closedCaptions = new Map();\n      const forced = false; // Only relevant for text.\n      const primary = true; // This is the only stream!\n      const name = 'Media Playlist';\n\n      // Make the stream info, with those values.\n      const streamInfo = await this.convertParsedPlaylistIntoStreamInfo_(\n          playlist, uri, uri, codecs, type, language, primary, name,\n          channelsCount, closedCaptions, characteristics, forced, spatialAudio,\n          mimeType);\n      this.uriToStreamInfosMap_.set(uri, streamInfo);\n\n      // Wrap the stream from that stream info with a variant.\n      variants.push({\n        id: 0,\n        language: 'und',\n        disabledUntilTime: 0,\n        primary: true,\n        audio: type == 'audio' ? streamInfo.stream : null,\n        video: type == 'video' ? streamInfo.stream : null,\n        bandwidth: 0,\n        allowedByApplication: true,\n        allowedByKeySystem: true,\n        decodingInfos: [],\n      });\n    } else {\n      /** @type {!Array.<!shaka.hls.Tag>} */\n      const mediaTags = Utils.filterTagsByName(playlist.tags, 'EXT-X-MEDIA');\n      /** @type {!Array.<!shaka.hls.Tag>} */\n      const variantTags = Utils.filterTagsByName(\n          playlist.tags, 'EXT-X-STREAM-INF');\n      /** @type {!Array.<!shaka.hls.Tag>} */\n      const imageTags = Utils.filterTagsByName(\n          playlist.tags, 'EXT-X-IMAGE-STREAM-INF');\n      /** @type {!Array.<!shaka.hls.Tag>} */\n      const sessionKeyTags = Utils.filterTagsByName(\n          playlist.tags, 'EXT-X-SESSION-KEY');\n\n      this.parseCodecs_(variantTags);\n\n      /** @type {!Array.<!shaka.hls.Tag>} */\n      const sesionDataTags =\n          Utils.filterTagsByName(playlist.tags, 'EXT-X-SESSION-DATA');\n      for (const tag of sesionDataTags) {\n        const id = tag.getAttributeValue('DATA-ID');\n        const uri = tag.getAttributeValue('URI');\n        const language = tag.getAttributeValue('LANGUAGE');\n        const value = tag.getAttributeValue('VALUE');\n        const data = (new Map()).set('id', id);\n        if (uri) {\n          data.set('uri', shaka.hls.Utils.constructAbsoluteUri(\n              this.masterPlaylistUri_, uri));\n        }\n        if (language) {\n          data.set('language', language);\n        }\n        if (value) {\n          data.set('value', value);\n        }\n        const event = new shaka.util.FakeEvent('sessiondata', data);\n        if (this.playerInterface_) {\n          this.playerInterface_.onEvent(event);\n        }\n      }\n\n      // Parse audio and video media tags first, so that we can extract segment\n      // start time from audio/video streams and reuse for text streams.\n      this.createStreamInfosFromMediaTags_(mediaTags);\n      this.parseClosedCaptions_(mediaTags);\n      variants = this.createVariantsForTags_(variantTags, sessionKeyTags);\n      textStreams = this.parseTexts_(mediaTags);\n      imageStreams = await this.parseImages_(imageTags);\n    }\n\n    // Make sure that the parser has not been destroyed.\n    if (!this.playerInterface_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    // This assert is our own sanity check.\n    goog.asserts.assert(this.presentationTimeline_ == null,\n        'Presentation timeline created early!');\n    // We don't know if the presentation is VOD or live until we parse at least\n    // one media playlist, so make a VOD-style presentation timeline for now\n    // and change the type later if we discover this is live.\n    // Since the player will load the first variant chosen early in the process,\n    // there isn't a window during playback where the live-ness is unknown.\n    this.presentationTimeline_ = new shaka.media.PresentationTimeline(\n        /* presentationStartTime= */ null, /* delay= */ 0);\n    this.presentationTimeline_.setStatic(true);\n\n    // Single-variant streams aren't lazy-loaded, so for them we already have\n    // enough info here to determine the presentation type and duration.\n    if (playlist.type == shaka.hls.PlaylistType.MEDIA) {\n      if (this.isLive_()) {\n        this.changePresentationTimelineToLive_();\n        const delay = this.updatePlaylistDelay_;\n        this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n      }\n      const streamInfos = Array.from(this.uriToStreamInfosMap_.values());\n      this.finalizeStreams_(streamInfos);\n      this.determineDuration_();\n    }\n\n    this.manifest_ = {\n      presentationTimeline: this.presentationTimeline_,\n      variants,\n      textStreams,\n      imageStreams,\n      offlineSessionIds: [],\n      minBufferTime: 0,\n      sequenceMode: true,\n    };\n    this.playerInterface_.makeTextStreamsForClosedCaptions(this.manifest_);\n  }\n\n  /** @private */\n  determineDuration_() {\n    goog.asserts.assert(this.presentationTimeline_,\n        'Presentation timeline not created!');\n\n    if (this.isLive_()) {\n      // The HLS spec (RFC 8216) states in 6.3.4:\n      // \"the client MUST wait for at least the target duration before\n      // attempting to reload the Playlist file again\".\n      // For LL-HLS, the server must add a new partial segment to the Playlist\n      // every part target duration.\n      this.updatePlaylistDelay_ = this.minTargetDuration_;\n\n      // The spec says nothing much about seeking in live content, but Safari's\n      // built-in HLS implementation does not allow it.  Therefore we will set\n      // the availability window equal to the presentation delay.  The player\n      // will be able to buffer ahead three segments, but the seek window will\n      // be zero-sized.\n      const PresentationType = shaka.hls.HlsParser.PresentationType_;\n\n      if (this.presentationType_ == PresentationType.LIVE) {\n        let segmentAvailabilityDuration = this.getMinDuration_();\n\n        // This defaults to the presentation delay, which has the effect of\n        // making the live stream unseekable.  This is consistent with Apple's\n        // HLS implementation.\n        if (this.config_.hls.useSafariBehaviorForLive) {\n          segmentAvailabilityDuration = this.presentationTimeline_.getDelay();\n        }\n\n        // The app can override that with a longer duration, to allow seeking.\n        if (!isNaN(this.config_.availabilityWindowOverride)) {\n          segmentAvailabilityDuration = this.config_.availabilityWindowOverride;\n        }\n\n        this.presentationTimeline_.setSegmentAvailabilityDuration(\n            segmentAvailabilityDuration);\n      }\n    } else {\n      // Use the minimum duration as the presentation duration.\n      this.presentationTimeline_.setDuration(this.getMinDuration_());\n    }\n\n    // This is the first point where we have a meaningful presentation start\n    // time, and we need to tell PresentationTimeline that so that it can\n    // maintain consistency from here on.\n    this.presentationTimeline_.lockStartTime();\n\n    // This asserts that the live edge is being calculated from segment times.\n    // For VOD and event streams, this check should still pass.\n    goog.asserts.assert(\n        !this.presentationTimeline_.usingPresentationStartTime(),\n        'We should not be using the presentation start time in HLS!');\n  }\n\n  /**\n   * Get the variables of each variant tag, and store in a map.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @private\n   */\n  parseMasterVariables_(tags) {\n    for (const variableTag of tags) {\n      const name = variableTag.getAttributeValue('NAME');\n      const value = variableTag.getAttributeValue('VALUE');\n      if (name && value) {\n        if (!this.globalVariables_.has(name)) {\n          this.globalVariables_.set(name, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the variables of each variant tag, and store in a map.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @return {!Map.<string, string>}\n   * @private\n   */\n  parseMediaVariables_(tags) {\n    const mediaVariables = new Map();\n    for (const variableTag of tags) {\n      const name = variableTag.getAttributeValue('NAME');\n      const value = variableTag.getAttributeValue('VALUE');\n      const mediaImport = variableTag.getAttributeValue('IMPORT');\n      if (name && value) {\n        mediaVariables.set(name, value);\n      }\n      if (mediaImport) {\n        const globalValue = this.globalVariables_.get(mediaImport);\n        if (globalValue) {\n          mediaVariables.set(mediaImport, globalValue);\n        }\n      }\n    }\n    return mediaVariables;\n  }\n\n  /**\n   * Get the codecs of each variant tag, and store in a map from\n   * audio/video/subtitle group id to the codecs arraylist.\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @private\n   */\n  parseCodecs_(tags) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n\n    for (const variantTag of tags) {\n      const audioGroupId = variantTag.getAttributeValue('AUDIO');\n      const videoGroupId = variantTag.getAttributeValue('VIDEO');\n      const subGroupId = variantTag.getAttributeValue('SUBTITLES');\n      const allCodecs = this.getCodecsForVariantTag_(variantTag);\n\n      if (subGroupId) {\n        const textCodecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n            ContentType.TEXT, allCodecs);\n        goog.asserts.assert(textCodecs != null, 'Text codecs should be valid.');\n        this.groupIdToCodecsMap_.set(subGroupId, textCodecs);\n        shaka.util.ArrayUtils.remove(allCodecs, textCodecs);\n      }\n      if (audioGroupId) {\n        let codecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n            ContentType.AUDIO, allCodecs);\n        if (!codecs) {\n          codecs = this.config_.hls.defaultAudioCodec;\n        }\n        this.groupIdToCodecsMap_.set(audioGroupId, codecs);\n      }\n      if (videoGroupId) {\n        let codecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n            ContentType.VIDEO, allCodecs);\n        if (!codecs) {\n          codecs = this.config_.hls.defaultVideoCodec;\n        }\n        this.groupIdToCodecsMap_.set(videoGroupId, codecs);\n      }\n    }\n  }\n\n  /**\n   * Parse Subtitles and Closed Captions from 'EXT-X-MEDIA' tags.\n   * Create text streams for Subtitles, but not Closed Captions.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags Media tags from the playlist.\n   * @return {!Array.<!shaka.extern.Stream>}\n   * @private\n   */\n  parseTexts_(mediaTags) {\n    // Create text stream for each Subtitle media tag.\n    const subtitleTags =\n        shaka.hls.Utils.filterTagsByType(mediaTags, 'SUBTITLES');\n    const textStreams = subtitleTags.map((tag) => {\n      const disableText = this.config_.disableText;\n      if (disableText) {\n        return null;\n      }\n      try {\n        return this.createStreamInfoFromMediaTag_(tag).stream;\n      } catch (e) {\n        if (this.config_.hls.ignoreTextStreamFailures) {\n          return null;\n        }\n        throw e;\n      }\n    });\n\n    const type = shaka.util.ManifestParserUtils.ContentType.TEXT;\n\n    // Set the codecs for text streams.\n    for (const tag of subtitleTags) {\n      const groupId = tag.getRequiredAttrValue('GROUP-ID');\n      const codecs = this.groupIdToCodecsMap_.get(groupId);\n      if (codecs) {\n        const textStreamInfos = this.groupIdToStreamInfosMap_.get(groupId);\n        if (textStreamInfos) {\n          for (const textStreamInfo of textStreamInfos) {\n            textStreamInfo.stream.codecs = codecs;\n            textStreamInfo.stream.mimeType =\n                this.guessMimeTypeBeforeLoading_(type, codecs) ||\n                this.guessMimeTypeFallback_(type);\n          }\n        }\n      }\n    }\n\n    // Do not create text streams for Closed captions.\n    return textStreams.filter((s) => s);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} imageTags from the playlist.\n   * @return {!Promise.<!Array.<!shaka.extern.Stream>>}\n   * @private\n   */\n  async parseImages_(imageTags) {\n    // Create image stream for each image tag.\n    const imageStreamPromises = imageTags.map(async (tag) => {\n      const disableThumbnails = this.config_.disableThumbnails;\n      if (disableThumbnails) {\n        return null;\n      }\n      try {\n        const streamInfo = await this.createStreamInfoFromImageTag_(tag);\n        return streamInfo.stream;\n      } catch (e) {\n        if (this.config_.hls.ignoreImageStreamFailures) {\n          return null;\n        }\n        throw e;\n      }\n    });\n    const imageStreams = await Promise.all(imageStreamPromises);\n    return imageStreams.filter((s) => s);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags Media tags from the playlist.\n   * @private\n   */\n  createStreamInfosFromMediaTags_(mediaTags) {\n    // Filter out subtitles and  media tags without uri.\n    mediaTags = mediaTags.filter((tag) => {\n      const uri = tag.getAttributeValue('URI') || '';\n      const type = tag.getAttributeValue('TYPE');\n      return type != 'SUBTITLES' && uri != '';\n    });\n\n    // Create stream info for each audio / video media tag.\n    for (const tag of mediaTags) {\n      this.createStreamInfoFromMediaTag_(tag);\n    }\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.Tag>} tags Variant tags from the playlist.\n   * @param {!Array.<!shaka.hls.Tag>} sessionKeyTags EXT-X-SESSION-KEY tags\n   * from the playlist.\n   * @return {!Array.<!shaka.extern.Variant>}\n   * @private\n   */\n  createVariantsForTags_(tags, sessionKeyTags) {\n    // EXT-X-SESSION-KEY processing\n    const drmInfos = [];\n    const keyIds = new Set();\n    if (sessionKeyTags.length > 0) {\n      for (const drmTag of sessionKeyTags) {\n        const method = drmTag.getRequiredAttrValue('METHOD');\n        if (method != 'NONE' && method != 'AES-128') {\n          // According to the HLS spec, KEYFORMAT is optional and implicitly\n          // defaults to \"identity\".\n          // https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-11#section-4.4.4.4\n          const keyFormat =\n              drmTag.getAttributeValue('KEYFORMAT') || 'identity';\n          const drmParser =\n              shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_[keyFormat];\n\n          const drmInfo = drmParser ?\n              drmParser(drmTag, /* mimeType= */ '') : null;\n          if (drmInfo) {\n            if (drmInfo.keyIds) {\n              for (const keyId of drmInfo.keyIds) {\n                keyIds.add(keyId);\n              }\n            }\n            drmInfos.push(drmInfo);\n          } else {\n            shaka.log.warning('Unsupported HLS KEYFORMAT', keyFormat);\n          }\n        }\n      }\n    }\n\n    // Create variants for each variant tag.\n    const allVariants = tags.map((tag) => {\n      const frameRate = tag.getAttributeValue('FRAME-RATE');\n      const bandwidth = Number(tag.getAttributeValue('AVERAGE-BANDWIDTH')) ||\n        Number(tag.getRequiredAttrValue('BANDWIDTH'));\n\n      const resolution = tag.getAttributeValue('RESOLUTION');\n      const [width, height] = resolution ? resolution.split('x') : [null, null];\n\n      const videoRange = tag.getAttributeValue('VIDEO-RANGE');\n\n      const streamInfos = this.createStreamInfosForVariantTag_(tag,\n          resolution, frameRate);\n\n      goog.asserts.assert(streamInfos.audio.length ||\n          streamInfos.video.length, 'We should have created a stream!');\n\n      return this.createVariants_(\n          streamInfos.audio,\n          streamInfos.video,\n          bandwidth,\n          width,\n          height,\n          frameRate,\n          videoRange,\n          drmInfos,\n          keyIds);\n    });\n    let variants = allVariants.reduce(shaka.util.Functional.collapseArrays, []);\n    // Filter out null variants.\n    variants = variants.filter((variant) => variant != null);\n    return variants;\n  }\n\n  /**\n   * Create audio and video streamInfos from an 'EXT-X-STREAM-INF' tag and its\n   * related media tags.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @param {?string} resolution\n   * @param {?string} frameRate\n   * @return {!shaka.hls.HlsParser.StreamInfos}\n   * @private\n   */\n  createStreamInfosForVariantTag_(tag, resolution, frameRate) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    /** @type {!Array.<string>} */\n    let allCodecs = this.getCodecsForVariantTag_(tag);\n    const audioGroupId = tag.getAttributeValue('AUDIO');\n    const videoGroupId = tag.getAttributeValue('VIDEO');\n    goog.asserts.assert(audioGroupId == null || videoGroupId == null,\n        'Unexpected: both video and audio described by media tags!');\n\n    const groupId = audioGroupId || videoGroupId;\n    const streamInfos =\n        (groupId && this.groupIdToStreamInfosMap_.has(groupId)) ?\n        this.groupIdToStreamInfosMap_.get(groupId) : [];\n\n    /** @type {shaka.hls.HlsParser.StreamInfos} */\n    const res = {\n      audio: audioGroupId ? streamInfos : [],\n      video: videoGroupId ? streamInfos : [],\n    };\n\n    // Make an educated guess about the stream type.\n    shaka.log.debug('Guessing stream type for', tag.toString());\n    let type;\n    let ignoreStream = false;\n\n    // The Microsoft HLS manifest generators will make audio-only variants\n    // that link to their URI both directly and through an audio tag.\n    // In that case, ignore the local URI and use the version in the\n    // AUDIO tag, so you inherit its language.\n    // As an example, see the manifest linked in issue #860.\n    const streamURI = tag.getRequiredAttrValue('URI');\n    const hasSameUri = res.audio.find((audio) => {\n      return audio && audio.verbatimMediaPlaylistUri == streamURI;\n    });\n\n    const videoCodecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n        ContentType.VIDEO, allCodecs);\n    const audioCodecs = shaka.util.ManifestParserUtils.guessCodecsSafe(\n        ContentType.AUDIO, allCodecs);\n\n    if (audioCodecs && !videoCodecs) {\n      // There are no associated media tags, and there's only audio codec,\n      // and no video codec, so it should be audio.\n      type = ContentType.AUDIO;\n      shaka.log.debug('Guessing audio-only.');\n    } else if (!streamInfos.length && audioCodecs && videoCodecs) {\n      // There are both audio and video codecs, so assume multiplexed content.\n      // Note that the default used when CODECS is missing assumes multiple\n      // (and therefore multiplexed).\n      // Recombine the codec strings into one so that MediaSource isn't\n      // lied to later. (That would trigger an error in Chrome.)\n      shaka.log.debug('Guessing multiplexed audio+video.');\n      type = ContentType.VIDEO;\n      allCodecs = [[videoCodecs, audioCodecs].join(',')];\n    } else if (res.audio.length && hasSameUri) {\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n      ignoreStream = true;\n    } else if (res.video.length && !res.audio.length) {\n      // There are associated video streams.  Assume this is audio.\n      shaka.log.debug('Guessing audio-only.');\n      type = ContentType.AUDIO;\n    } else {\n      shaka.log.debug('Guessing video-only.');\n      type = ContentType.VIDEO;\n    }\n\n    if (!ignoreStream) {\n      const streamInfo =\n          this.createStreamInfoFromVariantTag_(tag, allCodecs, type);\n      res[streamInfo.stream.type] = [streamInfo];\n    }\n    return res;\n  }\n\n\n  /**\n   * Get the codecs from the 'EXT-X-STREAM-INF' tag.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {!Array.<string>} codecs\n   * @private\n   */\n  getCodecsForVariantTag_(tag) {\n    // These are the default codecs to assume if none are specified.\n    const defaultCodecsArray = [];\n    if (!this.config_.disableVideo) {\n      defaultCodecsArray.push(this.config_.hls.defaultVideoCodec);\n    }\n    if (!this.config_.disableAudio) {\n      defaultCodecsArray.push(this.config_.hls.defaultAudioCodec);\n    }\n    const defaultCodecs = defaultCodecsArray.join(',');\n\n    const codecsString = tag.getAttributeValue('CODECS', defaultCodecs);\n    // Strip out internal whitespace while splitting on commas:\n    /** @type {!Array.<string>} */\n    const codecs = codecsString.split(/\\s*,\\s*/);\n\n    // Filter out duplicate codecs.\n    const seen = new Set();\n    const ret = [];\n    for (const codec of codecs) {\n      // HLS says the CODECS field needs to include all codecs that appear in\n      // the content. This means that if the content changes profiles, it should\n      // include both. Since all known browsers support changing profiles\n      // without any other work, just ignore them.  See also:\n      // https://github.com/shaka-project/shaka-player/issues/1817\n      const shortCodec = shaka.util.MimeUtils.getCodecBase(codec);\n      if (!seen.has(shortCodec)) {\n        ret.push(codec);\n        seen.add(shortCodec);\n      } else {\n        shaka.log.debug('Ignoring duplicate codec');\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Get the channel count information for an HLS audio track.\n   * CHANNELS specifies an ordered, \"/\" separated list of parameters.\n   * If the type is audio, the first parameter will be a decimal integer\n   * specifying the number of independent, simultaneous audio channels.\n   * No other channels parameters are currently defined.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {?number}\n   * @private\n   */\n  getChannelsCount_(tag) {\n    const channels = tag.getAttributeValue('CHANNELS');\n    if (!channels) {\n      return null;\n    }\n    const channelcountstring = channels.split('/')[0];\n    const count = parseInt(channelcountstring, 10);\n    return count;\n  }\n\n  /**\n   * Get the spatial audio information for an HLS audio track.\n   * In HLS the channels field indicates the number of audio channels that the\n   * stream has (eg: 2). In the case of Dolby Atmos, the complexity is\n   * expressed with the number of channels followed by the word JOC\n   * (eg: 16/JOC), so 16 would be the number of channels (eg: 7.3.6 layout),\n   * and JOC indicates that the stream has spatial audio.\n   * @see https://developer.apple.com/documentation/http_live_streaming/hls_authoring_specification_for_apple_devices/hls_authoring_specification_for_apple_devices_appendixes\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {boolean}\n   * @private\n   */\n  isSpatialAudio_(tag) {\n    const channels = tag.getAttributeValue('CHANNELS');\n    if (!channels) {\n      return false;\n    }\n    return channels.includes('/JOC');\n  }\n\n  /**\n   * Get the closed captions map information for the EXT-X-STREAM-INF tag, to\n   * create the stream info.\n   * @param {!shaka.hls.Tag} tag\n   * @param {string} type\n   * @return {Map.<string, string>} closedCaptions\n   * @private\n   */\n  getClosedCaptions_(tag, type) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    // The attribute of closed captions is optional, and the value may be\n    // 'NONE'.\n    const closedCaptionsAttr = tag.getAttributeValue('CLOSED-CAPTIONS');\n\n    // EXT-X-STREAM-INF tags may have CLOSED-CAPTIONS attributes.\n    // The value can be either a quoted-string or an enumerated-string with\n    // the value NONE. If the value is a quoted-string, it MUST match the\n    // value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the\n    // Playlist whose TYPE attribute is CLOSED-CAPTIONS.\n    if (type == ContentType.VIDEO && closedCaptionsAttr &&\n    closedCaptionsAttr != 'NONE') {\n      return this.groupIdToClosedCaptionsMap_.get(closedCaptionsAttr);\n    }\n    return null;\n  }\n\n  /**\n   * Get the language value.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @return {string}\n   * @private\n   */\n  getLanguage_(tag) {\n    const LanguageUtils = shaka.util.LanguageUtils;\n    const languageValue = tag.getAttributeValue('LANGUAGE') || 'und';\n    return LanguageUtils.normalize(languageValue);\n  }\n\n  /**\n   * Get the type value.\n   * Shaka recognizes the content types 'audio', 'video', 'text', and 'image'.\n   * The HLS 'subtitles' type needs to be mapped to 'text'.\n   * @param {!shaka.hls.Tag} tag\n   * @return {string}\n   * @private\n   */\n  getType_(tag) {\n    let type = tag.getRequiredAttrValue('TYPE').toLowerCase();\n    if (type == 'subtitles') {\n      type = shaka.util.ManifestParserUtils.ContentType.TEXT;\n    }\n    return type;\n  }\n\n  /**\n   * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} audioInfos\n   * @param {!Array.<shaka.hls.HlsParser.StreamInfo>} videoInfos\n   * @param {number} bandwidth\n   * @param {?string} width\n   * @param {?string} height\n   * @param {?string} frameRate\n   * @param {?string} videoRange\n   * @param {!Array.<shaka.extern.DrmInfo>} drmInfos\n   * @param {!Set.<string>} keyIds\n   * @return {!Array.<!shaka.extern.Variant>}\n   * @private\n   */\n  createVariants_(\n      audioInfos, videoInfos, bandwidth, width, height, frameRate, videoRange,\n      drmInfos, keyIds) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    const DrmEngine = shaka.media.DrmEngine;\n\n    for (const info of videoInfos) {\n      this.addVideoAttributes_(\n          info.stream, width, height, frameRate, videoRange);\n    }\n\n    // In case of audio-only or video-only content or the audio/video is\n    // disabled by the config, we create an array of one item containing\n    // a null. This way, the double-loop works for all kinds of content.\n    // NOTE: we currently don't have support for audio-only content.\n    const disableAudio = this.config_.disableAudio;\n    if (!audioInfos.length || disableAudio) {\n      audioInfos = [null];\n    }\n    const disableVideo = this.config_.disableVideo;\n    if (!videoInfos.length || disableVideo) {\n      videoInfos = [null];\n    }\n\n    const variants = [];\n    for (const audioInfo of audioInfos) {\n      for (const videoInfo of videoInfos) {\n        const audioStream = audioInfo ? audioInfo.stream : null;\n        if (audioStream) {\n          audioStream.drmInfos = drmInfos;\n          audioStream.keyIds = keyIds;\n        }\n        const videoStream = videoInfo ? videoInfo.stream : null;\n        if (videoStream) {\n          videoStream.drmInfos = drmInfos;\n          videoStream.keyIds = keyIds;\n        }\n        const audioDrmInfos = audioInfo ? audioInfo.stream.drmInfos : null;\n        const videoDrmInfos = videoInfo ? videoInfo.stream.drmInfos : null;\n        const videoStreamUri =\n            videoInfo ? videoInfo.verbatimMediaPlaylistUri : '';\n        const audioStreamUri =\n            audioInfo ? audioInfo.verbatimMediaPlaylistUri : '';\n        const variantUriKey = videoStreamUri + ' - ' + audioStreamUri;\n\n        if (audioStream && videoStream) {\n          if (!DrmEngine.areDrmCompatible(audioDrmInfos, videoDrmInfos)) {\n            shaka.log.warning(\n                'Incompatible DRM info in HLS variant.  Skipping.');\n            continue;\n          }\n        }\n\n        if (this.variantUriSet_.has(variantUriKey)) {\n          // This happens when two variants only differ in their text streams.\n          shaka.log.debug(\n              'Skipping variant which only differs in text streams.');\n          continue;\n        }\n\n        // Since both audio and video are of the same type, this assertion will\n        // catch certain mistakes at runtime that the compiler would miss.\n        goog.asserts.assert(!audioStream ||\n            audioStream.type == ContentType.AUDIO, 'Audio parameter mismatch!');\n        goog.asserts.assert(!videoStream ||\n            videoStream.type == ContentType.VIDEO, 'Video parameter mismatch!');\n\n        const variant = {\n          id: this.globalId_++,\n          language: audioStream ? audioStream.language : 'und',\n          primary: (!!audioStream && audioStream.primary) ||\n              (!!videoStream && videoStream.primary),\n          audio: audioStream,\n          video: videoStream,\n          bandwidth,\n          allowedByApplication: true,\n          allowedByKeySystem: true,\n          decodingInfos: [],\n        };\n\n        variants.push(variant);\n        this.variantUriSet_.add(variantUriKey);\n      }\n    }\n    return variants;\n  }\n\n  /**\n   * Parses an array of EXT-X-MEDIA tags, then stores the values of all tags\n   * with TYPE=\"CLOSED-CAPTIONS\" into a map of group id to closed captions.\n   *\n   * @param {!Array.<!shaka.hls.Tag>} mediaTags\n   * @private\n   */\n  parseClosedCaptions_(mediaTags) {\n    const closedCaptionsTags =\n        shaka.hls.Utils.filterTagsByType(mediaTags, 'CLOSED-CAPTIONS');\n    for (const tag of closedCaptionsTags) {\n      goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n          'Should only be called on media tags!');\n      const language = this.getLanguage_(tag);\n\n      // The GROUP-ID value is a quoted-string that specifies the group to which\n      // the Rendition belongs.\n      const groupId = tag.getRequiredAttrValue('GROUP-ID');\n\n      // The value of INSTREAM-ID is a quoted-string that specifies a Rendition\n      // within the segments in the Media Playlist. This attribute is REQUIRED\n      // if the TYPE attribute is CLOSED-CAPTIONS.\n      const instreamId = tag.getRequiredAttrValue('INSTREAM-ID');\n      if (!this.groupIdToClosedCaptionsMap_.get(groupId)) {\n        this.groupIdToClosedCaptionsMap_.set(groupId, new Map());\n      }\n      this.groupIdToClosedCaptionsMap_.get(groupId).set(instreamId, language);\n    }\n  }\n\n  /**\n   * Parse EXT-X-MEDIA media tag into a Stream object.\n   *\n   * @param {shaka.hls.Tag} tag\n   * @return {!shaka.hls.HlsParser.StreamInfo}\n   * @private\n   */\n  createStreamInfoFromMediaTag_(tag) {\n    goog.asserts.assert(tag.name == 'EXT-X-MEDIA',\n        'Should only be called on media tags!');\n    const groupId = tag.getRequiredAttrValue('GROUP-ID');\n    let codecs = '';\n    /** @type {string} */\n    const type = this.getType_(tag);\n    // Text does not require a codec.\n    if (type != shaka.util.ManifestParserUtils.ContentType.TEXT && groupId &&\n        this.groupIdToCodecsMap_.has(groupId)) {\n      codecs = this.groupIdToCodecsMap_.get(groupId);\n    }\n\n    const verbatimMediaPlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n\n    // Check if the stream has already been created as part of another Variant\n    // and return it if it has.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    const language = this.getLanguage_(tag);\n    const name = tag.getAttributeValue('NAME');\n\n    // NOTE: According to the HLS spec, \"DEFAULT=YES\" requires \"AUTOSELECT=YES\".\n    // However, we don't bother to validate \"AUTOSELECT\", since we don't\n    // actually use it in our streaming model, and we treat everything as\n    // \"AUTOSELECT=YES\".  A value of \"AUTOSELECT=NO\" would imply that it may\n    // only be selected explicitly by the user, and we don't have a way to\n    // represent that in our model.\n    const defaultAttrValue = tag.getAttributeValue('DEFAULT');\n    const primary = defaultAttrValue == 'YES';\n\n    const channelsCount = type == 'audio' ? this.getChannelsCount_(tag) : null;\n    const spatialAudio = type == 'audio' ? this.isSpatialAudio_(tag) : false;\n    const characteristics = tag.getAttributeValue('CHARACTERISTICS');\n\n    const forcedAttrValue = tag.getAttributeValue('FORCED');\n    const forced = forcedAttrValue == 'YES';\n    // TODO: Should we take into account some of the currently ignored\n    // attributes: INSTREAM-ID, Attribute descriptions: https://bit.ly/2lpjOhj\n    const streamInfo = this.createStreamInfo_(\n        verbatimMediaPlaylistUri, codecs, type, language, primary, name,\n        channelsCount, /* closedCaptions= */ null, characteristics, forced,\n        spatialAudio);\n    if (this.groupIdToStreamInfosMap_.has(groupId)) {\n      this.groupIdToStreamInfosMap_.get(groupId).push(streamInfo);\n    } else {\n      this.groupIdToStreamInfosMap_.set(groupId, [streamInfo]);\n    }\n\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromMediaTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n    this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n  /**\n   * Parse EXT-X-MEDIA media tag into a Stream object.\n   *\n   * @param {shaka.hls.Tag} tag\n   * @return {!Promise.<!shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async createStreamInfoFromImageTag_(tag) {\n    goog.asserts.assert(tag.name == 'EXT-X-IMAGE-STREAM-INF',\n        'Should only be called on image tags!');\n    /** @type {string} */\n    const type = shaka.util.ManifestParserUtils.ContentType.IMAGE;\n\n    const verbatimImagePlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n    const codecs = tag.getAttributeValue('CODECS', 'jpeg') || '';\n\n    // Check if the stream has already been created as part of another Variant\n    // and return it if it has.\n    if (this.uriToStreamInfosMap_.has(verbatimImagePlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimImagePlaylistUri);\n    }\n\n    const language = this.getLanguage_(tag);\n    const name = tag.getAttributeValue('NAME');\n\n    const characteristics = tag.getAttributeValue('CHARACTERISTICS');\n\n    const streamInfo = this.createStreamInfo_(\n        verbatimImagePlaylistUri, codecs, type, language, /* primary= */ false,\n        name, /* channelsCount= */ null, /* closedCaptions= */ null,\n        characteristics, /* forced= */ false, /* spatialAudio= */ false);\n\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromImageTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimImagePlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimImagePlaylistUri);\n    }\n\n    // Parse misc attributes.\n    const resolution = tag.getAttributeValue('RESOLUTION');\n    if (resolution) {\n      // The RESOLUTION tag represents the resolution of a single thumbnail, not\n      // of the entire sheet at once (like we expect in the output).\n      // So multiply by the layout size.\n\n      // Since we need to have generated the segment index for this, we can't\n      // lazy-load in this situation.\n      await streamInfo.stream.createSegmentIndex();\n\n      const reference = streamInfo.stream.segmentIndex.get(0);\n      const layout = reference.getTilesLayout();\n      if (layout) {\n        streamInfo.stream.width =\n            Number(resolution.split('x')[0]) * Number(layout.split('x')[0]);\n        streamInfo.stream.height =\n            Number(resolution.split('x')[1]) * Number(layout.split('x')[1]);\n        // TODO: What happens if there are multiple grids, with different\n        // layout sizes, inside this image stream?\n      }\n    }\n    const bandwidth = tag.getAttributeValue('BANDWIDTH');\n    if (bandwidth) {\n      streamInfo.stream.bandwidth = Number(bandwidth);\n    }\n\n    this.uriToStreamInfosMap_.set(verbatimImagePlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n  /**\n   * Parse an EXT-X-STREAM-INF media tag into a Stream object.\n   *\n   * @param {!shaka.hls.Tag} tag\n   * @param {!Array.<string>} allCodecs\n   * @param {string} type\n   * @return {!shaka.hls.HlsParser.StreamInfo}\n   * @private\n   */\n  createStreamInfoFromVariantTag_(tag, allCodecs, type) {\n    goog.asserts.assert(tag.name == 'EXT-X-STREAM-INF',\n        'Should only be called on variant tags!');\n    const verbatimMediaPlaylistUri = this.variableSubstitution_(\n        tag.getRequiredAttrValue('URI'), this.globalVariables_);\n\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    const closedCaptions = this.getClosedCaptions_(tag, type);\n    const codecs = shaka.util.ManifestParserUtils.guessCodecs(type, allCodecs);\n    const streamInfo = this.createStreamInfo_(verbatimMediaPlaylistUri,\n        codecs, type, /* language= */ 'und', /* primary= */ false,\n        /* name= */ null, /* channelcount= */ null, closedCaptions,\n        /* characteristics= */ null, /* forced= */ false,\n        /* spatialAudio= */ false);\n    // TODO: This check is necessary because of the possibility of multiple\n    // calls to createStreamInfoFromVariantTag_ before either has resolved.\n    if (this.uriToStreamInfosMap_.has(verbatimMediaPlaylistUri)) {\n      return this.uriToStreamInfosMap_.get(verbatimMediaPlaylistUri);\n    }\n\n    this.uriToStreamInfosMap_.set(verbatimMediaPlaylistUri, streamInfo);\n    return streamInfo;\n  }\n\n\n  /**\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {string} codecs\n   * @param {string} type\n   * @param {string} language\n   * @param {boolean} primary\n   * @param {?string} name\n   * @param {?number} channelsCount\n   * @param {Map.<string, string>} closedCaptions\n   * @param {?string} characteristics\n   * @param {boolean} forced\n   * @param {boolean} spatialAudio\n   * @return {!shaka.hls.HlsParser.StreamInfo}\n   * @private\n   */\n  createStreamInfo_(verbatimMediaPlaylistUri, codecs, type, language,\n      primary, name, channelsCount, closedCaptions, characteristics, forced,\n      spatialAudio) {\n    // TODO: Refactor, too many parameters\n    const initialMediaPlaylistUri = shaka.hls.Utils.constructAbsoluteUri(\n        this.masterPlaylistUri_, verbatimMediaPlaylistUri);\n\n    // This stream is lazy-loaded inside the createSegmentIndex function.\n    // So we start out with a stream object that does not contain the actual\n    // segment index, then download when createSegmentIndex is called.\n    const stream = this.makeStreamObject_(codecs, type, language, primary, name,\n        channelsCount, closedCaptions, characteristics, forced, spatialAudio);\n    if (shaka.media.MediaSourceEngine.RAW_FORMATS.includes(stream.mimeType)) {\n      stream.codecs = '';\n    }\n    const streamInfo = {\n      stream,\n      type,\n      verbatimMediaPlaylistUri,\n      // These values are filled out or updated after lazy-loading:\n      absoluteMediaPlaylistUri: initialMediaPlaylistUri,\n      maxTimestamp: 0,\n      mediaSequenceToStartTime: new Map(),\n      canSkipSegments: false,\n      hasEndList: false,\n      firstSequenceNumber: -1,\n      loadedOnce: false,\n    };\n\n    /** @param {!AbortSignal} abortSignal */\n    const downloadSegmentIndex = async (abortSignal) => {\n      // Download the actual manifest.\n      const response = await this.requestManifest_(\n          streamInfo.absoluteMediaPlaylistUri);\n      if (abortSignal.aborted) {\n        return;\n      }\n\n      // Record the final URI after redirects.\n      const absoluteMediaPlaylistUri = response.uri;\n\n      // Record the redirected, final URI of this media playlist when we parse\n      // it.\n      /** @type {!shaka.hls.Playlist} */\n      const playlist = this.manifestTextParser_.parsePlaylist(\n          response.data, absoluteMediaPlaylistUri);\n\n      const wasLive = this.isLive_();\n      const realStreamInfo = await this.convertParsedPlaylistIntoStreamInfo_(\n          playlist, verbatimMediaPlaylistUri, absoluteMediaPlaylistUri, codecs,\n          type, language, primary, name, channelsCount, closedCaptions,\n          characteristics, forced, spatialAudio);\n      if (abortSignal.aborted) {\n        return;\n      }\n\n      const realStream = realStreamInfo.stream;\n\n      if (this.isLive_() && !wasLive) {\n        // Now that we know that the presentation is live, convert the timeline\n        // to live.\n        this.changePresentationTimelineToLive_();\n      }\n\n      // Copy values from the real stream info to our initial one.\n      streamInfo.absoluteMediaPlaylistUri = absoluteMediaPlaylistUri;\n      streamInfo.maxTimestamp = realStreamInfo.maxTimestamp;\n      streamInfo.canSkipSegments = realStreamInfo.canSkipSegments;\n      streamInfo.hasEndList = realStreamInfo.hasEndList;\n      streamInfo.mediaSequenceToStartTime =\n          realStreamInfo.mediaSequenceToStartTime;\n      streamInfo.loadedOnce = true;\n      stream.segmentIndex = realStream.segmentIndex;\n      stream.encrypted = realStream.encrypted;\n      stream.drmInfos = realStream.drmInfos;\n      stream.keyIds = realStream.keyIds;\n      stream.mimeType = realStream.mimeType;\n      if (shaka.media.MediaSourceEngine.RAW_FORMATS.includes(stream.mimeType)) {\n        stream.codecs = '';\n      }\n\n      // Since we lazy-loaded this content, the player may need to create new\n      // sessions for the DRM info in this stream.\n      if (stream.drmInfos.length) {\n        this.playerInterface_.newDrmInfo(stream);\n      }\n\n      const ContentType = shaka.util.ManifestParserUtils.ContentType;\n      if (type == ContentType.VIDEO || type == ContentType.AUDIO) {\n        for (const otherStreamInfo of this.uriToStreamInfosMap_.values()) {\n          if (!otherStreamInfo.loadedOnce && otherStreamInfo.type == type) {\n            // To aid manifest filtering, assume before loading that all video\n            // renditions have the same MIME type.  (And likewise for audio.)\n            otherStreamInfo.stream.mimeType = realStream.mimeType;\n            if (shaka.media.MediaSourceEngine.RAW_FORMATS\n                .includes(otherStreamInfo.stream.mimeType)) {\n              otherStreamInfo.stream.codecs = '';\n            }\n          }\n        }\n      }\n\n      // Add finishing touches to the stream that can only be done once we have\n      // more full context on the media as a whole.\n      if (this.hasEnoughInfoToFinalizeStreams_()) {\n        if (!this.streamsFinalized_) {\n          // Mark this manifest as having been finalized, so we don't go through\n          // this whole process of finishing touches a second time.\n          this.streamsFinalized_ = true;\n          // Finalize all of the currently-loaded streams.\n          const streamInfos = Array.from(this.uriToStreamInfosMap_.values());\n          const activeStreamInfos =\n              streamInfos.filter((s) => s.stream.segmentIndex);\n          this.finalizeStreams_(activeStreamInfos);\n          // With the addition of this new stream, we now have enough info to\n          // figure out how long the streams should be. So process all streams\n          // we have downloaded up until this point.\n          this.determineDuration_();\n          // Finally, start the update timer, if this asset has been determined\n          // to be a livestream.\n          const delay = this.updatePlaylistDelay_;\n          if (delay > 0) {\n            this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n          }\n        } else {\n          // We don't need to go through the full process; just finalize this\n          // single stream.\n          this.finalizeStreams_([streamInfo]);\n        }\n      }\n    };\n\n    /** @type {Promise} */\n    let creationPromise = null;\n    /** @type {!AbortController} */\n    let abortController = new AbortController();\n    const safeCreateSegmentIndex = () => {\n      // An operation is already in progress.  The second and subsequent\n      // callers receive the same Promise as the first caller, and only one\n      // download operation will occur.\n      if (creationPromise) {\n        return creationPromise;\n      }\n\n      // Create a new AbortController to be able to cancel this specific\n      // download.\n      abortController = new AbortController();\n\n      // Create a Promise tied to the outcome of downloadSegmentIndex().  If\n      // downloadSegmentIndex is rejected, creationPromise will also be\n      // rejected.\n      creationPromise = new Promise((resolve) => {\n        resolve(downloadSegmentIndex(abortController.signal));\n      });\n      return creationPromise;\n    };\n\n    stream.createSegmentIndex = safeCreateSegmentIndex;\n\n    stream.closeSegmentIndex = () => {\n      // If we're mid-creation, cancel it.\n      if (creationPromise && !stream.segmentIndex) {\n        abortController.abort();\n      }\n      // If we have a segment index, release it.\n      if (stream.segmentIndex) {\n        stream.segmentIndex.release();\n        stream.segmentIndex = null;\n      }\n      // Clear the creation Promise so that a new operation can begin.\n      creationPromise = null;\n    };\n\n    return streamInfo;\n  }\n\n  /**\n   * @return {number}\n   * @private\n   */\n  getMinDuration_() {\n    let minDuration = Infinity;\n    for (const streamInfo of this.uriToStreamInfosMap_.values()) {\n      if (streamInfo.stream.segmentIndex && streamInfo.stream.type != 'text') {\n        // Since everything is already offset to 0 (either by sync or by being\n        // VOD), only maxTimestamp is necessary to compute the duration.\n        minDuration = Math.min(minDuration, streamInfo.maxTimestamp);\n      }\n    }\n    return minDuration;\n  }\n\n  /**\n   * @param {!Array.<!shaka.extern.Stream>} streams\n   * @private\n   */\n  notifySegmentsForStreams_(streams) {\n    const references = [];\n    for (const stream of streams) {\n      if (!stream.segmentIndex) {\n        // The stream was closed since the list of streams was built.\n        continue;\n      }\n      stream.segmentIndex.forEachTopLevelReference((reference) => {\n        references.push(reference);\n      });\n    }\n    this.presentationTimeline_.notifySegments(references);\n  }\n\n  /**\n   * @param {!Array.<!shaka.hls.HlsParser.StreamInfo>} streamInfos\n   * @private\n   */\n  finalizeStreams_(streamInfos) {\n    if (!this.isLive_()) {\n      const minDuration = this.getMinDuration_();\n      for (const streamInfo of streamInfos) {\n        streamInfo.stream.segmentIndex.fit(/* periodStart= */ 0, minDuration);\n      }\n    }\n    // MediaSource expects no codec strings combined with raw formats.\n    for (const streamInfo of streamInfos) {\n      const stream = streamInfo.stream;\n      if (shaka.media.MediaSourceEngine.RAW_FORMATS.includes(stream.mimeType)) {\n        stream.codecs = '';\n      }\n    }\n    this.notifySegmentsForStreams_(streamInfos.map((s) => s.stream));\n    if (this.config_.hls.ignoreManifestProgramDateTime) {\n      this.syncStreamsWithSequenceNumber_(streamInfos);\n    } else {\n      this.syncStreamsWithProgramDateTime_(streamInfos);\n    }\n  }\n\n  /**\n   * There are some values on streams that can only be set once we know about\n   * both the video and audio content, if present.\n   * This checks if there is at least one video downloaded (if the media has\n   * video), and that there is at least one audio downloaded (if the media has\n   * audio).\n   * @return {boolean}\n   * @private\n   */\n  hasEnoughInfoToFinalizeStreams_() {\n    if (!this.manifest_) {\n      return false;\n    }\n    const videos = [];\n    const audios = [];\n    for (const variant of this.manifest_.variants) {\n      if (variant.video) {\n        videos.push(variant.video);\n      }\n      if (variant.audio) {\n        audios.push(variant.audio);\n      }\n    }\n    if (videos.length > 0 && !videos.some((stream) => stream.segmentIndex)) {\n      return false;\n    }\n    if (audios.length > 0 && !audios.some((stream) => stream.segmentIndex)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {string} absoluteMediaPlaylistUri\n   * @param {string} codecs\n   * @param {string} type\n   * @param {string} language\n   * @param {boolean} primary\n   * @param {?string} name\n   * @param {?number} channelsCount\n   * @param {Map.<string, string>} closedCaptions\n   * @param {?string} characteristics\n   * @param {boolean} forced\n   * @param {boolean} spatialAudio\n   * @param {(string|undefined)} mimeType\n   * @return {!Promise.<!shaka.hls.HlsParser.StreamInfo>}\n   * @private\n   */\n  async convertParsedPlaylistIntoStreamInfo_(playlist, verbatimMediaPlaylistUri,\n      absoluteMediaPlaylistUri, codecs, type, language, primary, name,\n      channelsCount, closedCaptions, characteristics, forced, spatialAudio,\n      mimeType = undefined) {\n    if (playlist.type != shaka.hls.PlaylistType.MEDIA) {\n      // EXT-X-MEDIA and EXT-X-IMAGE-STREAM-INF tags should point to media\n      // playlists.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n    }\n\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const variablesTags = shaka.hls.Utils.filterTagsByName(playlist.tags,\n        'EXT-X-DEFINE');\n\n    const mediaVariables = this.parseMediaVariables_(variablesTags);\n\n    goog.asserts.assert(playlist.segments != null,\n        'Media playlist should have segments!');\n\n    this.determinePresentationType_(playlist);\n\n    if (!mimeType) {\n      mimeType = await this.guessMimeType_(type, codecs, playlist,\n          mediaVariables);\n    }\n\n    const {drmInfos, keyIds, encrypted, aesEncrypted} =\n                        this.parseDrmInfo_(playlist, mimeType);\n\n    if (encrypted && !drmInfos.length && !aesEncrypted) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED);\n    }\n\n    const mediaSequenceToStartTime = this.isLive_() ?\n        this.mediaSequenceToStartTimeByType_.get(type) : new Map();\n    const prevLowLatencyMode = this.lowLatencyMode_;\n    const segments = this.createSegments_(verbatimMediaPlaylistUri, playlist,\n        type, mimeType, mediaSequenceToStartTime, mediaVariables);\n\n    // This happens when autoLowLatencyMode is true, so we need set the\n    // correct lowLatencyPresentationDelay_\n    if (prevLowLatencyMode != this.lowLatencyMode_) {\n      this.determinePresentationType_(playlist);\n    }\n\n    const lastEndTime = segments[segments.length - 1].endTime;\n    /** @type {!shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    const serverControlTag = shaka.hls.Utils.getFirstTagWithName(\n        playlist.tags, 'EXT-X-SERVER-CONTROL');\n    const canSkipSegments = serverControlTag ?\n          serverControlTag.getAttribute('CAN-SKIP-UNTIL') != null : false;\n\n    const stream = this.makeStreamObject_(codecs, type, language, primary, name,\n        channelsCount, closedCaptions, characteristics, forced, spatialAudio);\n    stream.segmentIndex = segmentIndex;\n    stream.encrypted = encrypted;\n    stream.drmInfos = drmInfos;\n    stream.keyIds = keyIds;\n    stream.mimeType = mimeType;\n\n    return {\n      stream,\n      type,\n      verbatimMediaPlaylistUri,\n      absoluteMediaPlaylistUri,\n      maxTimestamp: lastEndTime,\n      canSkipSegments,\n      hasEndList: false,\n      firstSequenceNumber: -1,\n      mediaSequenceToStartTime,\n      loadedOnce: false,\n    };\n  }\n\n\n  /**\n   * Creates a stream object with the given parameters.\n   * The parameters that are passed into here are only the things that can be\n   * known without downloading the media playlist; other values must be set\n   * manually on the object after creation.\n   * @param {string} codecs\n   * @param {string} type\n   * @param {string} language\n   * @param {boolean} primary\n   * @param {?string} name\n   * @param {?number} channelsCount\n   * @param {Map.<string, string>} closedCaptions\n   * @param {?string} characteristics\n   * @param {boolean} forced\n   * @param {boolean} spatialAudio\n   * @return {!shaka.extern.Stream}\n   * @private\n   */\n  makeStreamObject_(codecs, type, language, primary, name, channelsCount,\n      closedCaptions, characteristics, forced, spatialAudio) {\n    // Fill out a \"best-guess\" mimeType, for now. It will be replaced once the\n    // stream is lazy-loaded.\n    const mimeType = this.guessMimeTypeBeforeLoading_(type, codecs) ||\n        this.guessMimeTypeFallback_(type);\n\n    return {\n      id: this.globalId_++,\n      originalId: name,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex: null,\n      mimeType,\n      codecs,\n      kind: (type == shaka.util.ManifestParserUtils.ContentType.TEXT) ?\n          shaka.util.ManifestParserUtils.TextStreamKind.SUBTITLE : undefined,\n      encrypted: false,\n      drmInfos: [],\n      keyIds: new Set(),\n      language,\n      label: name,  // For historical reasons, since before \"originalId\".\n      type,\n      primary,\n      // TODO: trick mode\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      frameRate: undefined,\n      pixelAspectRatio: undefined,\n      width: undefined,\n      height: undefined,\n      bandwidth: undefined,\n      roles: characteristics ? characteristics.split(',') : [],\n      forced,\n      channelsCount,\n      audioSamplingRate: null,\n      spatialAudio,\n      closedCaptions,\n      hdr: undefined,\n      tilesLayout: undefined,\n    };\n  }\n\n  /**\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {string} mimeType\n   * @return {{\n   *   drmInfos: !Array.<shaka.extern.DrmInfo>,\n   *   keyIds: !Set.<string>,\n   *   encrypted: boolean,\n   *   aesEncrypted: boolean\n   * }}\n   * @private\n   */\n  parseDrmInfo_(playlist, mimeType) {\n    /** @type {!Array.<!shaka.hls.Tag>} */\n    const drmTags = [];\n    if (playlist.segments) {\n      for (const segment of playlist.segments) {\n        const segmentKeyTags = shaka.hls.Utils.filterTagsByName(segment.tags,\n            'EXT-X-KEY');\n        drmTags.push(...segmentKeyTags);\n      }\n    }\n\n    let encrypted = false;\n    let aesEncrypted = false;\n\n    /** @type {!Array.<shaka.extern.DrmInfo>}*/\n    const drmInfos = [];\n    const keyIds = new Set();\n\n    for (const drmTag of drmTags) {\n      const method = drmTag.getRequiredAttrValue('METHOD');\n      if (method != 'NONE') {\n        encrypted = true;\n\n        if (method == 'AES-128') {\n          // These keys are handled separately.\n          aesEncrypted = true;\n        } else {\n          // According to the HLS spec, KEYFORMAT is optional and implicitly\n          // defaults to \"identity\".\n          // https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-11#section-4.4.4.4\n          const keyFormat =\n              drmTag.getAttributeValue('KEYFORMAT') || 'identity';\n          const drmParser =\n              shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_[keyFormat];\n\n          const drmInfo = drmParser ? drmParser(drmTag, mimeType) : null;\n          if (drmInfo) {\n            if (drmInfo.keyIds) {\n              for (const keyId of drmInfo.keyIds) {\n                keyIds.add(keyId);\n              }\n            }\n            drmInfos.push(drmInfo);\n          } else {\n            shaka.log.warning('Unsupported HLS KEYFORMAT', keyFormat);\n          }\n        }\n      }\n    }\n\n    return {drmInfos, keyIds, encrypted, aesEncrypted};\n  }\n\n  /**\n   * @param {!shaka.hls.Tag} drmTag\n   * @param {!shaka.hls.Playlist} playlist\n   * @return {!shaka.extern.HlsAes128Key}\n   * @private\n   */\n  parseAES128DrmTag_(drmTag, playlist) {\n    // Check if the Web Crypto API is available.\n    if (!window.crypto || !window.crypto.subtle) {\n      shaka.log.alwaysWarn('Web Crypto API is not available to decrypt ' +\n          'AES-128. (Web Crypto only exists in secure origins like https)');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.NO_WEB_CRYPTO_API);\n    }\n\n    // HLS RFC 8216 Section 5.2:\n    // An EXT-X-KEY tag with a KEYFORMAT of \"identity\" that does not have an IV\n    // attribute indicates that the Media Sequence Number is to be used as the\n    // IV when decrypting a Media Segment, by putting its big-endian binary\n    // representation into a 16-octet (128-bit) buffer and padding (on the left)\n    // with zeros.\n    let firstMediaSequenceNumber = 0;\n    let iv;\n    const ivHex = drmTag.getAttributeValue('IV', '');\n    if (!ivHex) {\n      // Media Sequence Number will be used as IV.\n      firstMediaSequenceNumber = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n          playlist.tags, 'EXT-X-MEDIA-SEQUENCE', 0);\n    } else {\n      // Exclude 0x at the start of string.\n      iv = shaka.util.Uint8ArrayUtils.fromHex(ivHex.substr(2));\n      if (iv.byteLength != 16) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.HLS_AES_128_INVALID_IV_LENGTH);\n      }\n    }\n\n    const keyUri = shaka.hls.Utils.constructAbsoluteUri(\n        playlist.absoluteUri, drmTag.getRequiredAttrValue('URI'));\n\n    const requestType = shaka.net.NetworkingEngine.RequestType.KEY;\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [keyUri], this.config_.retryParameters);\n\n    const keyInfo = {method: 'AES-128', iv, firstMediaSequenceNumber};\n\n    // Don't download the key object until the segment is parsed, to avoid a\n    // startup delay for long manifests with lots of keys.\n    keyInfo.fetchKey = async () => {\n      const keyResponse = await this.makeNetworkRequest_(request, requestType);\n\n      // keyResponse.status is undefined when URI is \"data:text/plain;base64,\"\n      if (!keyResponse.data || keyResponse.data.byteLength != 16) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.HLS_AES_128_INVALID_KEY_LENGTH);\n      }\n\n      const algorithm = {\n        name: 'AES-CBC',\n      };\n      keyInfo.cryptoKey = await window.crypto.subtle.importKey(\n          'raw', keyResponse.data, algorithm, true, ['decrypt']);\n      keyInfo.fetchKey = undefined; // No longer needed.\n    };\n\n    return keyInfo;\n  }\n\n\n  /**\n   * @param {!shaka.hls.Playlist} playlist\n   * @private\n   */\n  determinePresentationType_(playlist) {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    const presentationTypeTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags,\n            'EXT-X-PLAYLIST-TYPE');\n    const endListTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-ENDLIST');\n\n    const isVod = (presentationTypeTag && presentationTypeTag.value == 'VOD') ||\n        endListTag;\n    const isEvent = presentationTypeTag &&\n        presentationTypeTag.value == 'EVENT' && !isVod;\n    const isLive = !isVod && !isEvent;\n\n    if (isVod) {\n      this.setPresentationType_(PresentationType.VOD);\n    } else {\n      // If it's not VOD, it must be presentation type LIVE or an ongoing EVENT.\n      if (isLive) {\n        this.setPresentationType_(PresentationType.LIVE);\n      } else {\n        this.setPresentationType_(PresentationType.EVENT);\n      }\n\n      const targetDurationTag = this.getRequiredTag_(playlist.tags,\n          'EXT-X-TARGETDURATION');\n      const targetDuration = Number(targetDurationTag.value);\n      const partialTargetDurationTag =\n        shaka.hls.Utils.getFirstTagWithName(playlist.tags, 'EXT-X-PART-INF');\n      // According to the HLS spec, updates should not happen more often than\n      // once in targetDuration.  It also requires us to only update the active\n      // variant.  We might implement that later, but for now every variant\n      // will be updated.  To get the update period, choose the smallest\n      // targetDuration value across all playlists.\n      // 1. Update the shortest one to use as update period and segment\n      // availability time (for LIVE).\n      if (this.lowLatencyMode_ && partialTargetDurationTag) {\n        // For low latency streaming, use the partial segment target duration.\n        this.partialTargetDuration_ = Number(\n            partialTargetDurationTag.getRequiredAttrValue('PART-TARGET'));\n        this.minTargetDuration_ = Math.min(\n            this.partialTargetDuration_, this.minTargetDuration_);\n        // Get the server-recommended min distance from the live edge.\n        const serverControlTag = shaka.hls.Utils.getFirstTagWithName(\n            playlist.tags, 'EXT-X-SERVER-CONTROL');\n        // Use 'PART-HOLD-BACK' as the presentation delay for low latency mode.\n        this.lowLatencyPresentationDelay_ = serverControlTag ? Number(\n            serverControlTag.getRequiredAttrValue('PART-HOLD-BACK')) : 0;\n      } else {\n        // For regular HLS, use the target duration of regular segments.\n        this.minTargetDuration_ = Math.min(\n            targetDuration, this.minTargetDuration_);\n      }\n      // 2. Update the longest target duration if need be to use as a\n      // presentation delay later.\n      this.maxTargetDuration_ = Math.max(\n          targetDuration, this.maxTargetDuration_);\n    }\n  }\n\n  /**\n   * @private\n   */\n  changePresentationTimelineToLive_() {\n    // The live edge will be calculated from segments, so we don't need to\n    // set a presentation start time.  We will assert later that this is\n    // working as expected.\n\n    // The HLS spec (RFC 8216) states in 6.3.3:\n    //\n    // \"The client SHALL choose which Media Segment to play first ... the\n    // client SHOULD NOT choose a segment that starts less than three target\n    // durations from the end of the Playlist file.  Doing so can trigger\n    // playback stalls.\"\n    //\n    // We accomplish this in our DASH-y model by setting a presentation\n    // delay of configured value, or 3 segments duration if not configured.\n    // This will be the \"live edge\" of the presentation.\n    let presentationDelay;\n    if (this.config_.defaultPresentationDelay) {\n      presentationDelay = this.config_.defaultPresentationDelay;\n    } else if (this.lowLatencyPresentationDelay_) {\n      presentationDelay = this.lowLatencyPresentationDelay_;\n    } else {\n      const numberOfSegments = this.config_.hls.liveSegmentsDelay;\n      presentationDelay = this.maxTargetDuration_ * numberOfSegments;\n    }\n\n    this.presentationTimeline_.setPresentationStartTime(0);\n    this.presentationTimeline_.setDelay(presentationDelay);\n    this.presentationTimeline_.setStatic(false);\n  }\n\n  /**\n   * Get the InitSegmentReference for a segment if it has a EXT-X-MAP tag.\n   * @param {string} playlistUri The absolute uri of the media playlist.\n   * @param {!Array.<!shaka.hls.Tag>} tags Segment tags\n   * @param {!Map.<string, string>} variables\n   * @return {shaka.media.InitSegmentReference}\n   * @private\n   */\n  getInitSegmentReference_(playlistUri, tags, variables) {\n    /** @type {?shaka.hls.Tag} */\n    const mapTag = shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-MAP');\n\n    if (!mapTag) {\n      return null;\n    }\n    // Map tag example: #EXT-X-MAP:URI=\"main.mp4\",BYTERANGE=\"720@0\"\n    const verbatimInitSegmentUri = mapTag.getRequiredAttrValue('URI');\n    const absoluteInitSegmentUri = this.variableSubstitution_(\n        shaka.hls.Utils.constructAbsoluteUri(\n            playlistUri, verbatimInitSegmentUri),\n        variables);\n\n    const mapTagKey = [\n      absoluteInitSegmentUri,\n      mapTag.getAttributeValue('BYTERANGE', ''),\n    ].join('-');\n    if (!this.mapTagToInitSegmentRefMap_.has(mapTagKey)) {\n      const initSegmentRef = this.createInitSegmentReference_(\n          absoluteInitSegmentUri, mapTag);\n      this.mapTagToInitSegmentRefMap_.set(mapTagKey, initSegmentRef);\n    }\n    return this.mapTagToInitSegmentRefMap_.get(mapTagKey);\n  }\n\n  /**\n   * Create an InitSegmentReference object for the EXT-X-MAP tag in the media\n   * playlist.\n   * @param {string} absoluteInitSegmentUri\n   * @param {!shaka.hls.Tag} mapTag EXT-X-MAP\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  createInitSegmentReference_(absoluteInitSegmentUri, mapTag) {\n    let startByte = 0;\n    let endByte = null;\n    const byterange = mapTag.getAttributeValue('BYTERANGE');\n    // If a BYTERANGE attribute is not specified, the segment consists\n    // of the entire resource.\n    if (byterange) {\n      const blocks = byterange.split('@');\n      const byteLength = Number(blocks[0]);\n      startByte = Number(blocks[1]);\n      endByte = startByte + byteLength - 1;\n    }\n\n    const initSegmentRef = new shaka.media.InitSegmentReference(\n        () => [absoluteInitSegmentUri],\n        startByte,\n        endByte);\n    return initSegmentRef;\n  }\n\n  /**\n   * Parses one shaka.hls.Segment object into a shaka.media.SegmentReference.\n   *\n   * @param {shaka.media.InitSegmentReference} initSegmentReference\n   * @param {shaka.media.SegmentReference} previousReference\n   * @param {!shaka.hls.Segment} hlsSegment\n   * @param {number} startTime\n   * @param {!Map.<string, string>} variables\n   * @param {string} absoluteMediaPlaylistUri\n   * @param {string} type\n   * @param {shaka.extern.HlsAes128Key=} hlsAes128Key\n   * @return {shaka.media.SegmentReference}\n   * @private\n   */\n  createSegmentReference_(\n      initSegmentReference, previousReference, hlsSegment, startTime,\n      variables, absoluteMediaPlaylistUri, type, hlsAes128Key) {\n    const tags = hlsSegment.tags;\n    const absoluteSegmentUri = this.variableSubstitution_(\n        hlsSegment.absoluteUri, variables);\n    const extinfTag =\n        shaka.hls.Utils.getFirstTagWithName(tags, 'EXTINF');\n\n    let endTime = 0;\n    let startByte = 0;\n    let endByte = null;\n\n    if (hlsSegment.partialSegments.length && !this.lowLatencyMode_) {\n      shaka.log.alwaysWarn('Low-latency HLS live stream detected, but ' +\n                'low-latency streaming mode is not enabled in Shaka ' +\n                'Player. Set streaming.lowLatencyMode configuration to ' +\n                'true, and see https://bit.ly/3clctcj for details.');\n    }\n\n    let syncTime = null;\n    if (!this.config_.hls.ignoreManifestProgramDateTime) {\n      const dateTimeTag =\n          shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-PROGRAM-DATE-TIME');\n      if (dateTimeTag && dateTimeTag.value) {\n        syncTime = shaka.util.XmlUtils.parseDate(dateTimeTag.value);\n        goog.asserts.assert(syncTime != null,\n            'EXT-X-PROGRAM-DATE-TIME format not valid');\n      }\n    }\n\n    let status = shaka.media.SegmentReference.Status.AVAILABLE;\n    if (shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-GAP')) {\n      status = shaka.media.SegmentReference.Status.MISSING;\n    }\n\n    if (!extinfTag) {\n      if (hlsSegment.partialSegments.length == 0) {\n        // EXTINF tag must be available if the segment has no partial segments.\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.MANIFEST,\n            shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING, 'EXTINF');\n      } else if (!this.lowLatencyMode_) {\n        // Without EXTINF and without low-latency mode, partial segments get\n        // ignored.\n        return null;\n      }\n    }\n\n    // Create SegmentReferences for the partial segments.\n    const partialSegmentRefs = [];\n    if (this.lowLatencyMode_) {\n      for (let i = 0; i < hlsSegment.partialSegments.length; i++) {\n        const item = hlsSegment.partialSegments[i];\n        const pPreviousReference = i == 0 ?\n          previousReference : partialSegmentRefs[partialSegmentRefs.length - 1];\n        const pStartTime = (i == 0) ? startTime : pPreviousReference.endTime;\n\n        // If DURATION is missing from this partial segment, use the target\n        // partial duration from the top of the playlist, which is a required\n        // attribute for content with partial segments.\n        const pDuration = Number(item.getAttributeValue('DURATION')) ||\n            this.partialTargetDuration_;\n\n        // If for some reason we have neither an explicit duration, nor a target\n        // partial duration, we should SKIP this partial segment to avoid\n        // duplicating content in the presentation timeline.\n        if (!pDuration) {\n          continue;\n        }\n\n        const pEndTime = pStartTime + pDuration;\n\n        let pStartByte = 0;\n        let pEndByte = null;\n        if (item.name == 'EXT-X-PRELOAD-HINT') {\n          // A preload hinted partial segment may have byterange start info.\n          const pByterangeStart = item.getAttributeValue('BYTERANGE-START');\n          pStartByte = pByterangeStart ? Number(pByterangeStart) : 0;\n        } else {\n          const pByterange = item.getAttributeValue('BYTERANGE');\n          [pStartByte, pEndByte] =\n            this.parseByteRange_(pPreviousReference, pByterange);\n        }\n        const pUri = item.getAttributeValue('URI');\n        if (!pUri) {\n          continue;\n        }\n        const pAbsoluteUri = shaka.hls.Utils.constructAbsoluteUri(\n            absoluteMediaPlaylistUri, pUri);\n\n        let partialStatus = shaka.media.SegmentReference.Status.AVAILABLE;\n        if (item.getAttributeValue('GAP') == 'YES') {\n          partialStatus = shaka.media.SegmentReference.Status.MISSING;\n        }\n\n        // We do not set the AES-128 key information for partial segments, as we\n        // do not support AES-128 and low-latency at the same time.\n        const partial = new shaka.media.SegmentReference(\n            pStartTime,\n            pEndTime,\n            () => [pAbsoluteUri],\n            pStartByte,\n            pEndByte,\n            initSegmentReference,\n            /* timestampOffset= */ 0, // This value is ignored in sequence mode.\n            /* appendWindowStart= */ 0,\n            /* appendWindowEnd= */ Infinity,\n            /* partialReferences= */ [],\n            /* tilesLayout= */ '',\n            /* tileDuration= */ null,\n            /* syncTime= */ null,\n            partialStatus);\n        partialSegmentRefs.push(partial);\n      } // for-loop of hlsSegment.partialSegments\n    }\n\n    // If the segment has EXTINF tag, set the segment's end time, start byte\n    // and end byte based on the duration and byterange information.\n    // Otherwise, calculate the end time, start / end byte based on its partial\n    // segments.\n    // Note that the sum of partial segments durations may be slightly different\n    // from the parent segment's duration. In this case, use the duration from\n    // the parent segment tag.\n    if (extinfTag) {\n      // The EXTINF tag format is '#EXTINF:<duration>,[<title>]'.\n      // We're interested in the duration part.\n      const extinfValues = extinfTag.value.split(',');\n      const duration = Number(extinfValues[0]);\n      endTime = startTime + duration;\n    } else {\n      endTime = partialSegmentRefs[partialSegmentRefs.length - 1].endTime;\n    }\n\n    // If the segment has EXT-X-BYTERANGE tag, set the start byte and end byte\n    // base on the byterange information. If segment has no EXT-X-BYTERANGE tag\n    // and has partial segments, set the start byte and end byte base on the\n    // partial segments.\n    const byterangeTag =\n         shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-BYTERANGE');\n    if (byterangeTag) {\n      [startByte, endByte] =\n          this.parseByteRange_(previousReference, byterangeTag.value);\n    } else if (partialSegmentRefs.length) {\n      startByte = partialSegmentRefs[0].startByte;\n      endByte = partialSegmentRefs[partialSegmentRefs.length - 1].endByte;\n    }\n\n    let tilesLayout = '';\n    let tileDuration = null;\n    if (type == shaka.util.ManifestParserUtils.ContentType.IMAGE) {\n      // By default in HLS the tilesLayout is 1x1\n      tilesLayout = '1x1';\n      const tilesTag =\n          shaka.hls.Utils.getFirstTagWithName(tags, 'EXT-X-TILES');\n      if (tilesTag) {\n        tilesLayout = tilesTag.getRequiredAttrValue('LAYOUT');\n        const duration = tilesTag.getAttributeValue('DURATION');\n        if (duration) {\n          tileDuration = Number(duration);\n        }\n      }\n    }\n\n    return new shaka.media.SegmentReference(\n        startTime,\n        endTime,\n        () => absoluteSegmentUri.length ? [absoluteSegmentUri] : [],\n        startByte,\n        endByte,\n        initSegmentReference,\n        /* timestampOffset= */ 0, // This value is ignored in sequence mode.\n        /* appendWindowStart= */ 0,\n        /* appendWindowEnd= */ Infinity,\n        partialSegmentRefs,\n        tilesLayout,\n        tileDuration,\n        syncTime,\n        status,\n        hlsAes128Key,\n    );\n  }\n\n\n  /**\n   * Parse the startByte and endByte.\n   * @param {shaka.media.SegmentReference} previousReference\n   * @param {?string} byterange\n   * @return {!Array.<number>} An array with the start byte and end byte.\n   * @private\n   */\n  parseByteRange_(previousReference, byterange) {\n    let startByte = 0;\n    let endByte = null;\n    // If BYTERANGE is not specified, the segment consists of the entire\n    // resource.\n    if (byterange) {\n      const blocks = byterange.split('@');\n      const byteLength = Number(blocks[0]);\n      if (blocks[1]) {\n        startByte = Number(blocks[1]);\n      } else {\n        goog.asserts.assert(previousReference,\n            'Cannot refer back to previous HLS segment!');\n        startByte = previousReference.endByte + 1;\n      }\n      endByte = startByte + byteLength - 1;\n    }\n    return [startByte, endByte];\n  }\n\n  /**\n   * Parses shaka.hls.Segment objects into shaka.media.SegmentReferences.\n   *\n   * @param {string} verbatimMediaPlaylistUri\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {string} type\n   * @param {string} mimeType\n   * @param {!Map.<number, number>} mediaSequenceToStartTime\n   * @param {!Map.<string, string>} variables\n   * @return {!Array.<!shaka.media.SegmentReference>}\n   * @private\n   */\n  createSegments_(verbatimMediaPlaylistUri, playlist, type, mimeType,\n      mediaSequenceToStartTime, variables) {\n    /** @type {Array.<!shaka.hls.Segment>} */\n    const hlsSegments = playlist.segments;\n    goog.asserts.assert(hlsSegments.length, 'Playlist should have segments!');\n\n    /** @type {shaka.media.InitSegmentReference} */\n    let initSegmentRef;\n\n    /** @type {shaka.extern.HlsAes128Key|undefined} */\n    let hlsAes128Key = undefined;\n\n    let discontinuitySequence = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n        playlist.tags, 'EXT-X-DISCONTINUITY-SEQUENCE', 0);\n    const mediaSequenceNumber = shaka.hls.Utils.getFirstTagWithNameAsNumber(\n        playlist.tags, 'EXT-X-MEDIA-SEQUENCE', 0);\n    const skipTag = shaka.hls.Utils.getFirstTagWithName(\n        playlist.tags, 'EXT-X-SKIP');\n    const skippedSegments =\n        skipTag ? Number(skipTag.getAttributeValue('SKIPPED-SEGMENTS')) : 0;\n    let position = mediaSequenceNumber + skippedSegments;\n    let firstStartTime = 0;\n\n    // For live stream, use the cached value in the mediaSequenceToStartTime\n    // map if available.\n    if (this.isLive_() && mediaSequenceToStartTime.has(position)) {\n      firstStartTime = mediaSequenceToStartTime.get(position);\n    }\n\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const references = [];\n\n    let previousReference = null;\n\n    for (let i = 0; i < hlsSegments.length; i++) {\n      const item = hlsSegments[i];\n      const startTime =\n          (i == 0) ? firstStartTime : previousReference.endTime;\n      position = mediaSequenceNumber + skippedSegments + i;\n\n      const discontinuityTag = shaka.hls.Utils.getFirstTagWithName(\n          item.tags, 'EXT-X-DISCONTINUITY');\n      if (discontinuityTag) {\n        discontinuitySequence++;\n      }\n\n      // Apply new AES-128 tags as you see them, keeping a running total.\n      for (const drmTag of item.tags) {\n        if (drmTag.name == 'EXT-X-KEY') {\n          if (drmTag.getRequiredAttrValue('METHOD') == 'AES-128') {\n            hlsAes128Key = this.parseAES128DrmTag_(drmTag, playlist);\n          } else {\n            hlsAes128Key = undefined;\n          }\n        }\n      }\n\n      mediaSequenceToStartTime.set(position, startTime);\n\n      initSegmentRef = this.getInitSegmentReference_(playlist.absoluteUri,\n          item.tags, variables);\n\n      // If the stream is low latency and the user has not configured the\n      // lowLatencyMode, but if it has been configured to activate the\n      // lowLatencyMode if a stream of this type is detected, we automatically\n      // activate the lowLatencyMode.\n      if (!this.lowLatencyMode_) {\n        const autoLowLatencyMode = this.playerInterface_.isAutoLowLatencyMode();\n        if (autoLowLatencyMode) {\n          this.playerInterface_.enableLowLatencyMode();\n          this.lowLatencyMode_ = this.playerInterface_.isLowLatencyMode();\n        }\n      }\n\n      const reference = this.createSegmentReference_(\n          initSegmentRef,\n          previousReference,\n          item,\n          startTime,\n          variables,\n          playlist.absoluteUri,\n          type,\n          hlsAes128Key);\n      previousReference = reference;\n\n      if (reference) {\n        reference.discontinuitySequence = discontinuitySequence;\n\n        if (this.config_.hls.ignoreManifestProgramDateTime &&\n            this.minSequenceNumber_ != null &&\n            position < this.minSequenceNumber_) {\n          // This segment is ignored as part of our fallback synchronization\n          // method.\n        } else {\n          references.push(reference);\n        }\n      }\n    }\n\n    // If some segments have sync times, but not all, extrapolate the sync\n    // times of the ones with none.\n    const someSyncTime = references.some((ref) => ref.syncTime != null);\n    if (someSyncTime) {\n      for (let i = 0; i < references.length; i++) {\n        const reference = references[i];\n        if (reference.syncTime != null) {\n          // No need to extrapolate.\n          continue;\n        }\n        // Find the nearest segment with syncTime, in either direction.\n        // This looks forward and backward simultaneously, keeping track of what\n        // to offset the syncTime it finds by as it goes.\n        let forwardAdd = 0;\n        let forwardI = i;\n        /**\n         * Look forwards one reference at a time, summing all durations as we\n         * go, until we find a reference with a syncTime to use as a basis.\n         * This DOES count the original reference, but DOESN'T count the first\n         * reference with a syncTime (as we approach it from behind).\n         * @return {?number}\n         */\n        const lookForward = () => {\n          const other = references[forwardI];\n          if (other) {\n            if (other.syncTime != null) {\n              return other.syncTime + forwardAdd;\n            }\n            forwardAdd -= other.endTime - other.startTime;\n            forwardI += 1;\n          }\n          return null;\n        };\n        let backwardAdd = 0;\n        let backwardI = i;\n        /**\n         * Look backwards one reference at a time, summing all durations as we\n         * go, until we find a reference with a syncTime to use as a basis.\n         * This DOESN'T count the original reference, but DOES count the first\n         * reference with a syncTime (as we approach it from ahead).\n         * @return {?number}\n         */\n        const lookBackward = () => {\n          const other = references[backwardI];\n          if (other) {\n            if (other != reference) {\n              backwardAdd += other.endTime - other.startTime;\n            }\n            if (other.syncTime != null) {\n              return other.syncTime + backwardAdd;\n            }\n            backwardI -= 1;\n          }\n          return null;\n        };\n        while (reference.syncTime == null) {\n          reference.syncTime = lookBackward();\n          if (reference.syncTime == null) {\n            reference.syncTime = lookForward();\n          }\n        }\n      }\n    }\n\n    // Split the sync times properly among partial segments.\n    if (someSyncTime) {\n      for (const reference of references) {\n        let syncTime = reference.syncTime;\n        for (const partial of reference.partialReferences) {\n          partial.syncTime = syncTime;\n          syncTime += partial.endTime - partial.startTime;\n        }\n      }\n    }\n\n    // lowestSyncTime is a value from a previous playlist update.  Use it to\n    // set reference start times.  If this is the first playlist parse, we will\n    // skip this step, and wait until we have sync time across stream types.\n    const lowestSyncTime = this.lowestSyncTime_;\n    if (someSyncTime && lowestSyncTime != Infinity) {\n      for (const reference of references) {\n        reference.syncAgainst(lowestSyncTime);\n      }\n    }\n\n    return references;\n  }\n\n  /**\n   * Replaces the variables of a given URI.\n   *\n   * @param {string} uri\n   * @param {!Map.<string, string>} variables\n   * @return {string}\n   * @private\n   */\n  variableSubstitution_(uri, variables) {\n    let newUri = String(uri).replace(/%7B/g, '{').replace(/%7D/g, '}');\n\n    const uriVariables = newUri.match(/{\\$\\w*}/g);\n    if (uriVariables) {\n      for (const variable of uriVariables) {\n        // Note: All variables have the structure {$...}\n        const variableName = variable.slice(2, variable.length - 1);\n        const replaceValue = variables.get(variableName);\n        if (replaceValue) {\n          newUri = newUri.replace(variable, replaceValue);\n        } else {\n          shaka.log.error('A variable has been found that is not declared',\n              variableName);\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.HLS_VARIABLE_NOT_FOUND,\n              variableName);\n        }\n      }\n    }\n    return newUri;\n  }\n\n  /**\n   * Attempts to guess stream's mime type based on content type and URI.\n   *\n   * @param {string} contentType\n   * @param {string} codecs\n   * @return {?string}\n   * @private\n   */\n  guessMimeTypeBeforeLoading_(contentType, codecs) {\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.TEXT) {\n      if (codecs == 'vtt' || codecs == 'wvtt') {\n        // If codecs is 'vtt', it's WebVTT.\n        return 'text/vtt';\n      } else if (codecs && codecs !== '') {\n        // Otherwise, assume MP4-embedded text, since text-based formats tend\n        // not to have a codecs string at all.\n        return 'application/mp4';\n      }\n    }\n\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.IMAGE) {\n      if (!codecs || codecs == 'jpeg') {\n        return 'image/jpeg';\n      }\n    }\n\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.AUDIO) {\n      // See: https://bugs.chromium.org/p/chromium/issues/detail?id=489520\n      if (codecs == 'mp4a.40.34') {\n        return 'audio/mpeg';\n      }\n    }\n\n    // Not enough information to guess from the content type and codecs.\n    return null;\n  }\n\n  /**\n   * Get a fallback mime type for the content. Used if all the better methods\n   * for determining the mime type have failed.\n   *\n   * @param {string} contentType\n   * @return {string}\n   * @private\n   */\n  guessMimeTypeFallback_(contentType) {\n    if (contentType == shaka.util.ManifestParserUtils.ContentType.TEXT) {\n      // If there was no codecs string and no content-type, assume HLS text\n      // streams are WebVTT.\n      return 'text/vtt';\n    }\n    // If the HLS content is lacking in both MIME type metadata and\n    // segment file extensions, we fall back to assuming it's MP4.\n    const map = shaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_[contentType];\n    return map['mp4'];\n  }\n\n  /**\n   * Attempts to guess stream's mime type based on content type, URI, and\n   * contents of the playlist.\n   *\n   * @param {string} contentType\n   * @param {string} codecs\n   * @param {!shaka.hls.Playlist} playlist\n   * @param {!Map.<string, string>} variables\n   * @return {!Promise.<string>}\n   * @private\n   */\n  async guessMimeType_(contentType, codecs, playlist, variables) {\n    const HlsParser = shaka.hls.HlsParser;\n    const requestType = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n\n    // If you wait long enough, requesting the first segment can fail\n    // because it has fallen off the left edge of DVR, so to be safer,\n    // let's request the middle segment.\n    goog.asserts.assert(playlist.segments.length,\n        'Playlist should have segments!');\n    const middleSegmentIdx = Math.trunc((playlist.segments.length - 1) / 2);\n    const middleSegmentUri = this.variableSubstitution_(\n        playlist.segments[middleSegmentIdx].absoluteUri, variables);\n\n    const parsedUri = new goog.Uri(middleSegmentUri);\n    const extension = parsedUri.getPath().split('.').pop();\n    const map = HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_[contentType];\n\n    let mimeType = map[extension];\n    if (mimeType) {\n      return mimeType;\n    }\n\n    mimeType = HlsParser.RAW_FORMATS_TO_MIME_TYPES_[extension];\n    if (mimeType) {\n      return mimeType;\n    }\n\n    // The extension map didn't work, so guess based on codecs.\n    mimeType = this.guessMimeTypeBeforeLoading_(contentType, codecs);\n    if (mimeType) {\n      return mimeType;\n    }\n\n    // If unable to guess mime type, request a segment and try getting it\n    // from the response.\n    const headRequest = shaka.net.NetworkingEngine.makeRequest(\n        [middleSegmentUri], this.config_.retryParameters);\n    headRequest.method = 'HEAD';\n\n    const response = await this.makeNetworkRequest_(\n        headRequest, requestType);\n\n    const contentMimeType = response.headers['content-type'];\n    if (contentMimeType) {\n      // Split the MIME type in case the server sent additional parameters.\n      return contentMimeType.split(';')[0];\n    }\n\n    return this.guessMimeTypeFallback_(contentType);\n  }\n\n  /**\n   * Returns a tag with a given name.\n   * Throws an error if tag was not found.\n   *\n   * @param {!Array.<shaka.hls.Tag>} tags\n   * @param {string} tagName\n   * @return {!shaka.hls.Tag}\n   * @private\n   */\n  getRequiredTag_(tags, tagName) {\n    const tag = shaka.hls.Utils.getFirstTagWithName(tags, tagName);\n    if (!tag) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING, tagName);\n    }\n\n    return tag;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {?string} width\n   * @param {?string} height\n   * @param {?string} frameRate\n   * @param {?string} videoRange\n   * @private\n   */\n  addVideoAttributes_(stream, width, height, frameRate, videoRange) {\n    if (stream) {\n      stream.width = Number(width) || undefined;\n      stream.height = Number(height) || undefined;\n      stream.frameRate = Number(frameRate) || undefined;\n      stream.hdr = videoRange || undefined;\n    }\n  }\n\n  /**\n   * Makes a network request for the manifest and returns a Promise\n   * with the resulting data.\n   *\n   * @param {string} absoluteUri\n   * @return {!Promise.<!shaka.extern.Response>}\n   * @private\n   */\n  requestManifest_(absoluteUri) {\n    const requestType = shaka.net.NetworkingEngine.RequestType.MANIFEST;\n\n    const request = shaka.net.NetworkingEngine.makeRequest(\n        [absoluteUri], this.config_.retryParameters);\n\n    const format = shaka.util.CmcdManager.StreamingFormat.HLS;\n    this.playerInterface_.modifyManifestRequest(request, {format: format});\n\n    return this.makeNetworkRequest_(request, requestType);\n  }\n\n  /**\n   * Called when the update timer ticks. Because parsing a manifest is async,\n   * this method is async. To work with this, this method will schedule the next\n   * update when it finished instead of using a repeating-start.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  async onUpdate_() {\n    shaka.log.info('Updating manifest...');\n\n    goog.asserts.assert(\n        this.updatePlaylistDelay_ > 0,\n        'We should only call |onUpdate_| when we are suppose to be updating.');\n\n    // Detect a call to stop()\n    if (!this.playerInterface_) {\n      return;\n    }\n\n    try {\n      await this.update();\n\n      // This may have converted to VOD, in which case we stop updating.\n      if (this.isLive_()) {\n        const delay = this.updatePlaylistDelay_;\n        this.updatePlaylistTimer_.tickAfter(/* seconds= */ delay);\n      }\n    } catch (error) {\n      // Detect a call to stop() during this.update()\n      if (!this.playerInterface_) {\n        return;\n      }\n\n      goog.asserts.assert(error instanceof shaka.util.Error,\n          'Should only receive a Shaka error');\n\n      // We will retry updating, so override the severity of the error.\n      error.severity = shaka.util.Error.Severity.RECOVERABLE;\n      this.playerInterface_.onError(error);\n\n      // Try again very soon.\n      this.updatePlaylistTimer_.tickAfter(/* seconds= */ 0.1);\n    }\n  }\n\n\n  /**\n   * @return {boolean}\n   * @private\n   */\n  isLive_() {\n    const PresentationType = shaka.hls.HlsParser.PresentationType_;\n    return this.presentationType_ != PresentationType.VOD;\n  }\n\n\n  /**\n   * @param {shaka.hls.HlsParser.PresentationType_} type\n   * @private\n   */\n  setPresentationType_(type) {\n    this.presentationType_ = type;\n\n    if (this.presentationTimeline_) {\n      this.presentationTimeline_.setStatic(!this.isLive_());\n    }\n\n    // If this manifest is not for live content, then we have no reason to\n    // update it.\n    if (!this.isLive_()) {\n      this.updatePlaylistTimer_.stop();\n    }\n  }\n\n\n  /**\n   * Create a networking request. This will manage the request using the\n   * parser's operation manager. If the parser has already been stopped, the\n   * request will not be made.\n   *\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} type\n   * @return {!Promise.<shaka.extern.Response>}\n   * @private\n   */\n  makeNetworkRequest_(request, type) {\n    if (!this.operationManager_) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.PLAYER,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n\n    const op = this.playerInterface_.networkingEngine.request(type, request);\n    this.operationManager_.manage(op);\n\n    return op.promise;\n  }\n\n  /**\n   * @param {!shaka.hls.Tag} drmTag\n   * @param {string} mimeType\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static fairplayDrmParser_(drmTag, mimeType) {\n    if (mimeType == 'video/mp2t') {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_MSE_ENCRYPTED_MP2T_NOT_SUPPORTED);\n    }\n\n    if (shaka.util.Platform.isMediaKeysPolyfilled()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code\n              .HLS_MSE_ENCRYPTED_LEGACY_APPLE_MEDIA_KEYS_NOT_SUPPORTED);\n    }\n\n    /*\n     * Even if we're not able to construct initData through the HLS tag, adding\n     * a DRMInfo will allow DRM Engine to request a media key system access\n     * with the correct keySystem and initDataType\n     */\n    const drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n        'com.apple.fps', [\n          {initDataType: 'sinf', initData: new Uint8Array(0), keyId: null},\n        ]);\n\n    return drmInfo;\n  }\n\n  /**\n   * @param {!shaka.hls.Tag} drmTag\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static widevineDrmParser_(drmTag) {\n    const method = drmTag.getRequiredAttrValue('METHOD');\n    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR'];\n    if (!VALID_METHODS.includes(method)) {\n      shaka.log.error('Widevine in HLS is only supported with [',\n          VALID_METHODS.join(', '), '], not', method);\n      return null;\n    }\n\n    const uri = drmTag.getRequiredAttrValue('URI');\n    const parsedData = shaka.net.DataUriPlugin.parseRaw(uri);\n\n    // The data encoded in the URI is a PSSH box to be used as init data.\n    const pssh = shaka.util.BufferUtils.toUint8(parsedData.data);\n    const drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n        'com.widevine.alpha', [\n          {initDataType: 'cenc', initData: pssh},\n        ]);\n\n    const keyId = drmTag.getAttributeValue('KEYID');\n    if (keyId) {\n      const keyIdLowerCase = keyId.toLowerCase();\n      // This value should begin with '0x':\n      goog.asserts.assert(\n          keyIdLowerCase.startsWith('0x'), 'Incorrect KEYID format!');\n      // But the output should not contain the '0x':\n      drmInfo.keyIds = new Set([keyIdLowerCase.substr(2)]);\n    }\n    return drmInfo;\n  }\n\n  /**\n   * See: https://docs.microsoft.com/en-us/playready/packaging/mp4-based-formats-supported-by-playready-clients?tabs=case4\n   *\n   * @param {!shaka.hls.Tag} drmTag\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static playreadyDrmParser_(drmTag) {\n    const method = drmTag.getRequiredAttrValue('METHOD');\n    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR'];\n    if (!VALID_METHODS.includes(method)) {\n      shaka.log.error('PlayReady in HLS is only supported with [',\n          VALID_METHODS.join(', '), '], not', method);\n      return null;\n    }\n\n    const uri = drmTag.getRequiredAttrValue('URI');\n    const parsedData = shaka.net.DataUriPlugin.parseRaw(uri);\n\n    // The data encoded in the URI is a PlayReady Pro Object, so we need\n    // convert it to pssh.\n    const data = shaka.util.BufferUtils.toUint8(parsedData.data);\n    const systemId = new Uint8Array([\n      0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86,\n      0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95,\n    ]);\n    const keyIds = new Set();\n    const psshVersion = 0;\n    const pssh =\n        shaka.util.Pssh.createPssh(data, systemId, keyIds, psshVersion);\n    const drmInfo = shaka.util.ManifestParserUtils.createDrmInfo(\n        'com.microsoft.playready', [\n          {initDataType: 'cenc', initData: pssh},\n        ]);\n\n    return drmInfo;\n  }\n\n  /**\n   * See: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-11#section-5.1\n   *\n   * @param {!shaka.hls.Tag} drmTag\n   * @return {?shaka.extern.DrmInfo}\n   * @private\n   */\n  static identityDrmParser_(drmTag) {\n    const method = drmTag.getRequiredAttrValue('METHOD');\n    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR'];\n    if (!VALID_METHODS.includes(method)) {\n      shaka.log.error('Identity (ClearKey) in HLS is only supported with [',\n          VALID_METHODS.join(', '), '], not', method);\n      return null;\n    }\n\n    // NOTE: The ClearKey CDM requires a key-id to key mapping.  HLS doesn't\n    // provide a key ID anywhere.  So although we could use the 'URI' attribute\n    // to fetch the actual 16-byte key, without a key ID, we can't provide this\n    // automatically to the ClearKey CDM.  Instead, the application will have\n    // to use player.configure('drm.clearKeys', { ... }) to provide the key IDs\n    // and keys or player.configure('drm.servers.org\\.w3\\.clearkey', ...) to\n    // provide a ClearKey license server URI.\n    return shaka.util.ManifestParserUtils.createDrmInfo(\n        'org.w3.clearkey', /* initDatas= */ null);\n  }\n};\n\n\n/**\n * @typedef {{\n *   stream: !shaka.extern.Stream,\n *   type: string,\n *   verbatimMediaPlaylistUri: string,\n *   absoluteMediaPlaylistUri: string,\n *   maxTimestamp: number,\n *   mediaSequenceToStartTime: !Map.<number, number>,\n *   canSkipSegments: boolean,\n *   hasEndList: boolean,\n *   firstSequenceNumber: number,\n *   loadedOnce: boolean\n * }}\n *\n * @description\n * Contains a stream and information about it.\n *\n * @property {!shaka.extern.Stream} stream\n *   The Stream itself.\n * @property {string} type\n *   The type value. Could be 'video', 'audio', 'text', or 'image'.\n * @property {string} verbatimMediaPlaylistUri\n *   The verbatim media playlist URI, as it appeared in the master playlist.\n *   This has not been canonicalized into an absolute URI.  This gives us a\n *   consistent key for this playlist, even if redirects cause us to update\n *   from different origins each time.\n * @property {string} absoluteMediaPlaylistUri\n *   The absolute media playlist URI, resolved relative to the master playlist\n *   and updated to reflect any redirects.\n * @property {number} maxTimestamp\n *   The maximum timestamp found in the stream.\n * @property {!Map.<number, number>} mediaSequenceToStartTime\n *   A map of media sequence numbers to media start times.\n *   Only used for VOD content.\n * @property {boolean} canSkipSegments\n *   True if the server supports delta playlist updates, and we can send a\n *   request for a playlist that can skip older media segments.\n * @property {boolean} hasEndList\n *   True if the stream has an EXT-X-ENDLIST tag.\n * @property {number} firstSequenceNumber\n *   The sequence number of the first reference. Only calculated if needed.\n * @property {boolean} loadedOnce\n *   True if the stream has been loaded at least once.\n */\nshaka.hls.HlsParser.StreamInfo;\n\n\n/**\n * @typedef {{\n *   audio: !Array.<shaka.hls.HlsParser.StreamInfo>,\n *   video: !Array.<shaka.hls.HlsParser.StreamInfo>\n * }}\n *\n * @description Audio and video stream infos.\n * @property {!Array.<shaka.hls.HlsParser.StreamInfo>} audio\n * @property {!Array.<shaka.hls.HlsParser.StreamInfo>} video\n */\nshaka.hls.HlsParser.StreamInfos;\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.RAW_FORMATS_TO_MIME_TYPES_ = {\n  'aac': 'audio/aac',\n  'ac3': 'audio/ac3',\n  'ec3': 'audio/ec3',\n  'mp3': 'audio/mpeg',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'audio/mp4',\n  'mp4a': 'audio/mp4',\n  'm4s': 'audio/mp4',\n  'm4i': 'audio/mp4',\n  'm4a': 'audio/mp4',\n  'm4f': 'audio/mp4',\n  'cmfa': 'audio/mp4',\n  // MPEG2-TS also uses video/ for audio: https://bit.ly/TsMse\n  'ts': 'video/mp2t',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'video/mp4',\n  'mp4v': 'video/mp4',\n  'm4s': 'video/mp4',\n  'm4i': 'video/mp4',\n  'm4v': 'video/mp4',\n  'm4f': 'video/mp4',\n  'cmfv': 'video/mp4',\n  'ts': 'video/mp2t',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_ = {\n  'mp4': 'application/mp4',\n  'm4s': 'application/mp4',\n  'm4i': 'application/mp4',\n  'm4f': 'application/mp4',\n  'cmft': 'application/mp4',\n  'vtt': 'text/vtt',\n  'webvtt': 'text/vtt',\n  'ttml': 'application/ttml+xml',\n};\n\n\n/**\n * @const {!Object.<string, string>}\n * @private\n */\nshaka.hls.HlsParser.IMAGE_EXTENSIONS_TO_MIME_TYPES_ = {\n  'jpg': 'image/jpeg',\n  'png': 'image/png',\n  'svg': 'image/svg+xml',\n  'webp': 'image/webp',\n  'avif': 'image/avif',\n};\n\n\n/**\n * @const {!Object.<string, !Object.<string, string>>}\n * @private\n */\nshaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_ = {\n  'audio': shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_,\n  'video': shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_,\n  'text': shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_,\n  'image': shaka.hls.HlsParser.IMAGE_EXTENSIONS_TO_MIME_TYPES_,\n};\n\n\n/**\n * @typedef {function(!shaka.hls.Tag, string):?shaka.extern.DrmInfo}\n * @private\n */\nshaka.hls.HlsParser.DrmParser_;\n\n\n/**\n * @const {!Object.<string, shaka.hls.HlsParser.DrmParser_>}\n * @private\n */\nshaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_ = {\n  'com.apple.streamingkeydelivery':\n      shaka.hls.HlsParser.fairplayDrmParser_,\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed':\n      shaka.hls.HlsParser.widevineDrmParser_,\n  'com.microsoft.playready':\n      shaka.hls.HlsParser.playreadyDrmParser_,\n  'identity':\n      shaka.hls.HlsParser.identityDrmParser_,\n};\n\n\n/**\n * @enum {string}\n * @private\n */\nshaka.hls.HlsParser.PresentationType_ = {\n  VOD: 'VOD',\n  EVENT: 'EVENT',\n  LIVE: 'LIVE',\n};\n\nif (!shaka.util.Platform.isTizen3() &&\n    !shaka.util.Platform.isTizen2() &&\n    !shaka.util.Platform.isWebOS3()) {\n  shaka.media.ManifestParser.registerParserByExtension(\n      'm3u8', () => new shaka.hls.HlsParser());\n  shaka.media.ManifestParser.registerParserByMime(\n      'application/x-mpegurl', () => new shaka.hls.HlsParser());\n  shaka.media.ManifestParser.registerParserByMime(\n      'application/vnd.apple.mpegurl', () => new shaka.hls.HlsParser());\n}\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.util.TextParser');\n\ngoog.require('goog.asserts');\n\n\n/**\n * Reads elements from strings.\n */\nshaka.util.TextParser = class {\n  /**\n   * @param {string} data\n   */\n  constructor(data) {\n    /**\n     * @const\n     * @private {string}\n     */\n    this.data_ = data;\n\n    /** @private {number} */\n    this.position_ = 0;\n  }\n\n\n  /** @return {boolean} Whether it is at the end of the string. */\n  atEnd() {\n    return this.position_ == this.data_.length;\n  }\n\n\n  /**\n   * Reads a line from the parser.  This will read but not return the newline.\n   * Returns null at the end.\n   *\n   * @return {?string}\n   */\n  readLine() {\n    return this.readRegexReturnCapture_(/(.*?)(\\n|$)/gm, 1);\n  }\n\n\n  /**\n   * Reads a word from the parser.  This will not read or return any whitespace\n   * before or after the word (including newlines).  Returns null at the end.\n   *\n   * @return {?string}\n   */\n  readWord() {\n    return this.readRegexReturnCapture_(/[^ \\t\\n]*/gm, 0);\n  }\n\n\n  /**\n   * Skips any continuous whitespace from the parser.  Returns null at the end.\n   */\n  skipWhitespace() {\n    this.readRegex(/[ \\t]+/gm);\n  }\n\n\n  /**\n   * Reads the given regular expression from the parser.  This requires the\n   * match to be at the current position; there is no need to include a head\n   * anchor.\n   * This requires that the regex have the global flag to be set so that it can\n   * set lastIndex to start the search at the current position.  Returns null at\n   * the end or if the regex does not match the current position.\n   *\n   * @param {!RegExp} regex\n   * @return {Array.<string>}\n   */\n  readRegex(regex) {\n    const index = this.indexOf_(regex);\n    if (this.atEnd() || index == null || index.position != this.position_) {\n      return null;\n    }\n\n    this.position_ += index.length;\n    return index.results;\n  }\n\n\n  /**\n   * Reads a regex from the parser and returns the given capture.\n   *\n   * @param {!RegExp} regex\n   * @param {number} index\n   * @return {?string}\n   * @private\n   */\n  readRegexReturnCapture_(regex, index) {\n    if (this.atEnd()) {\n      return null;\n    }\n\n    const ret = this.readRegex(regex);\n    if (!ret) {\n      return null;\n    } else {\n      return ret[index];\n    }\n  }\n\n\n  /**\n   * Returns the index info about a regular expression match.\n   *\n   * @param {!RegExp} regex\n   * @return {?{position: number, length: number, results: !Array.<string>}}\n   * @private\n   */\n  indexOf_(regex) {\n    // The global flag is required to use lastIndex.\n    goog.asserts.assert(regex.global, 'global flag should be set');\n\n    regex.lastIndex = this.position_;\n    const results = regex.exec(this.data_);\n    if (results == null) {\n      return null;\n    } else {\n      return {\n        position: results.index,\n        length: results[0].length,\n        results: results,\n      };\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.hls.ManifestTextParser');\n\ngoog.require('shaka.hls.Attribute');\ngoog.require('shaka.hls.Playlist');\ngoog.require('shaka.hls.PlaylistType');\ngoog.require('shaka.hls.Segment');\ngoog.require('shaka.hls.Tag');\ngoog.require('shaka.hls.Utils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * HlS manifest text parser.\n */\nshaka.hls.ManifestTextParser = class {\n  /** */\n  constructor() {\n    /** @private {number} */\n    this.globalId_ = 0;\n  }\n\n  /**\n   * @param {BufferSource} data\n   * @param {string} absolutePlaylistUri An absolute, final URI after redirects.\n   * @return {!shaka.hls.Playlist}\n   */\n  parsePlaylist(data, absolutePlaylistUri) {\n    const MEDIA_PLAYLIST_TAGS =\n        shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS;\n    const SEGMENT_TAGS = shaka.hls.ManifestTextParser.SEGMENT_TAGS;\n\n    // Get the input as a string.  Normalize newlines to \\n.\n    let str = shaka.util.StringUtils.fromUTF8(data);\n    str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n').trim();\n\n    const lines = str.split(/\\n+/m);\n\n    if (!/^#EXTM3U($|[ \\t\\n])/m.test(lines[0])) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING);\n    }\n\n    /** shaka.hls.PlaylistType */\n    let playlistType = shaka.hls.PlaylistType.MASTER;\n\n    // First, look for media playlist tags, so that we know what the playlist\n    // type really is before we start parsing.\n    // TODO: refactor the for loop for better readability.\n    // Whether to skip the next element; initialize to true to skip first elem.\n    let skip = true;\n    for (const line of lines) {\n      // Ignore comments.\n      if (shaka.hls.Utils.isComment(line) || skip) {\n        skip = false;\n        continue;\n      }\n      const tag = this.parseTag_(line);\n      // These tags won't actually be used, so don't increment the global\n      // id.\n      this.globalId_ -= 1;\n\n      if (MEDIA_PLAYLIST_TAGS.includes(tag.name)) {\n        playlistType = shaka.hls.PlaylistType.MEDIA;\n        break;\n      } else if (tag.name == 'EXT-X-STREAM-INF') {\n        skip = true;\n      }\n    }\n\n    /** {Array.<shaka.hls.Tag>} */\n    const tags = [];\n    // Initialize to \"true\" to skip the first element.\n    skip = true;\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const next = lines[i + 1];\n      // Skip comments\n      if (shaka.hls.Utils.isComment(line) || skip) {\n        skip = false;\n        continue;\n      }\n\n      const tag = this.parseTag_(line);\n      if (SEGMENT_TAGS.includes(tag.name)) {\n        if (playlistType != shaka.hls.PlaylistType.MEDIA) {\n          // Only media playlists should contain segment tags\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.MANIFEST,\n              shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY);\n        }\n\n        const segmentsData = lines.splice(i, lines.length - i);\n        const segments = this.parseSegments_(\n            absolutePlaylistUri, segmentsData, tags);\n        return new shaka.hls.Playlist(\n            absolutePlaylistUri, playlistType, tags, segments);\n      }\n\n      tags.push(tag);\n\n      // An EXT-X-STREAM-INF tag is followed by a URI of a media playlist.\n      // Add the URI to the tag object.\n      if (tag.name == 'EXT-X-STREAM-INF') {\n        const tagUri = new shaka.hls.Attribute('URI', next);\n        tag.addAttribute(tagUri);\n        skip = true;\n      }\n    }\n\n    return new shaka.hls.Playlist(absolutePlaylistUri, playlistType, tags);\n  }\n\n  /**\n   * Parses an array of strings into an array of HLS Segment objects.\n   *\n   * @param {string} absoluteMediaPlaylistUri\n   * @param {!Array.<string>} lines\n   * @param {!Array.<!shaka.hls.Tag>} playlistTags\n   * @return {!Array.<shaka.hls.Segment>}\n   * @private\n   */\n  parseSegments_(absoluteMediaPlaylistUri, lines, playlistTags) {\n    /** @type {!Array.<shaka.hls.Segment>} */\n    const segments = [];\n    /** @type {!Array.<shaka.hls.Tag>} */\n    let segmentTags = [];\n\n    /** @type {!Array.<shaka.hls.Tag>} */\n    let partialSegmentTags = [];\n\n    // The last parsed EXT-X-MAP tag.\n    /** @type {?shaka.hls.Tag} */\n    let currentMapTag = null;\n\n    for (const line of lines) {\n      if (/^(#EXT)/.test(line)) {\n        const tag = this.parseTag_(line);\n        if (shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS.includes(\n            tag.name)) {\n          playlistTags.push(tag);\n        } else {\n          // Mark the the EXT-X-MAP tag, and add it to the segment tags\n          // following it later.\n          if (tag.name == 'EXT-X-MAP') {\n            currentMapTag = tag;\n          } else if (tag.name == 'EXT-X-PART') {\n            partialSegmentTags.push(tag);\n          } else if (tag.name == 'EXT-X-PRELOAD-HINT') {\n            if (tag.getAttributeValue('TYPE') == 'PART') {\n              partialSegmentTags.push(tag);\n            } else if (tag.getAttributeValue('TYPE') == 'MAP') {\n              // Rename the Preload Hint tag to be a Map tag.\n              tag.setName('EXT-X-MAP');\n              currentMapTag = tag;\n            }\n          } else {\n            segmentTags.push(tag);\n          }\n        }\n      } else if (shaka.hls.Utils.isComment(line)) {\n        // Skip comments.\n      } else {\n        const verbatimSegmentUri = line.trim();\n        const absoluteSegmentUri = shaka.hls.Utils.constructAbsoluteUri(\n            absoluteMediaPlaylistUri, verbatimSegmentUri);\n        // Attach the last parsed EXT-X-MAP tag to the segment.\n        if (currentMapTag) {\n          segmentTags.push(currentMapTag);\n        }\n        // The URI appears after all of the tags describing the segment.\n        const segment = new shaka.hls.Segment(absoluteSegmentUri, segmentTags,\n            partialSegmentTags);\n        segments.push(segment);\n        segmentTags = [];\n        partialSegmentTags = [];\n      }\n    }\n    // After all the partial segments of a regular segment is published,\n    // a EXTINF tag and Uri for a regular segment containing the same media\n    // content will get published at last.\n    // If no EXTINF tag follows the list of partial segment tags at the end,\n    // create a segment to wrap the partial segment tags.\n    if (partialSegmentTags.length) {\n      if (currentMapTag) {\n        segmentTags.push(currentMapTag);\n      }\n      const segment = new shaka.hls.Segment('', segmentTags,\n          partialSegmentTags);\n      segments.push(segment);\n    }\n\n    return segments;\n  }\n\n  /**\n   * Parses a string into an HLS Tag object while tracking what id to use next.\n   *\n   * @param {string} word\n   * @return {!shaka.hls.Tag}\n   * @private\n   */\n  parseTag_(word) {\n    return shaka.hls.ManifestTextParser.parseTag(this.globalId_++, word);\n  }\n\n  /**\n   * Parses a string into an HLS Tag object.\n   *\n   * @param {number} id\n   * @param {string} word\n   * @return {!shaka.hls.Tag}\n   */\n  static parseTag(id, word) {\n    /* HLS tags start with '#EXT'. A tag can have a set of attributes\n      (#EXT-<tagname>:<attribute list>) and/or a value (#EXT-<tagname>:<value>).\n      An attribute's format is 'AttributeName=AttributeValue'.\n      The parsing logic goes like this:\n       1. Everything before ':' is a name (we ignore '#').\n       2. Everything after ':' is a list of comma-seprated items,\n            2a. The first item might be a value, if it does not contain '='.\n            2b. Otherwise, items are attributes.\n       3. If there is no \":\", it's a simple tag with no attributes and no value.\n    */\n    const blocks = word.match(/^#(EXT[^:]*)(?::(.*))?$/);\n    if (!blocks) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.MANIFEST,\n          shaka.util.Error.Code.INVALID_HLS_TAG,\n          word);\n    }\n    const name = blocks[1];\n    const data = blocks[2];\n    const attributes = [];\n    let value;\n\n    if (data) {\n      const parser = new shaka.util.TextParser(data);\n      let blockAttrs;\n\n      // Regex: any number of non-equals-sign characters at the beginning\n      // terminated by comma or end of line\n      const valueRegex = /^([^,=]+)(?:,|$)/g;\n\n      const blockValue = parser.readRegex(valueRegex);\n\n      if (blockValue) {\n        value = blockValue[1];\n      }\n\n      // Regex:\n      // 1. Key name ([1])\n      // 2. Equals sign\n      // 3. Either:\n      //   a. A quoted string (everything up to the next quote, [2])\n      //   b. An unquoted string\n      //    (everything up to the next comma or end of line, [3])\n      // 4. Either:\n      //   a. A comma\n      //   b. End of line\n      const attributeRegex = /([^=]+)=(?:\"([^\"]*)\"|([^\",]*))(?:,|$)/g;\n\n      while ((blockAttrs = parser.readRegex(attributeRegex))) {\n        const attrName = blockAttrs[1];\n        const attrValue = blockAttrs[2] || blockAttrs[3];\n        const attribute = new shaka.hls.Attribute(attrName, attrValue);\n        attributes.push(attribute);\n        parser.skipWhitespace();\n      }\n    }\n\n    return new shaka.hls.Tag(id, name, attributes, value);\n  }\n};\n\n\n/**\n * HLS tags that only appear on Media Playlists.\n * Used to determine a playlist type.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGS = [\n  'EXT-X-TARGETDURATION',\n  'EXT-X-MEDIA-SEQUENCE',\n  'EXT-X-DISCONTINUITY-SEQUENCE',\n  'EXT-X-PLAYLIST-TYPE',\n  'EXT-X-I-FRAMES-ONLY',\n  'EXT-X-ENDLIST',\n  'EXT-X-SERVER-CONTROL',\n  'EXT-X-SKIP',\n];\n\n\n/**\n * HLS tags that only appear on Segments in a Media Playlists.\n * Used to determine the start of the segments info.\n *\n * @const {!Array.<string>}\n */\nshaka.hls.ManifestTextParser.SEGMENT_TAGS = [\n  'EXTINF',\n  'EXT-X-BYTERANGE',\n  'EXT-X-DISCONTINUITY',\n  'EXT-X-PROGRAM-DATE-TIME',\n  'EXT-X-KEY',\n  'EXT-X-DATERANGE',\n  'EXT-X-MAP',\n];\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.DataUriPlugin');\n\ngoog.require('shaka.log');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A networking plugin to handle data URIs.\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\n * @export\n */\nshaka.net.DataUriPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated) {\n    try {\n      const parsed = shaka.net.DataUriPlugin.parseRaw(uri);\n\n      /** @type {shaka.extern.Response} */\n      const response = {\n        uri: uri,\n        originalUri: uri,\n        data: parsed.data,\n        headers: {\n          'content-type': parsed.contentType,\n        },\n      };\n\n      return shaka.util.AbortableOperation.completed(response);\n    } catch (error) {\n      return shaka.util.AbortableOperation.failed(error);\n    }\n  }\n\n  /**\n   * @param {string} uri\n   * @return {{data: BufferSource, contentType: string}}\n   */\n  static parseRaw(uri) {\n    // Extract the scheme.\n    const parts = uri.split(':');\n    if (parts.length < 2 || parts[0] != 'data') {\n      shaka.log.error('Bad data URI, failed to parse scheme');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    const path = parts.slice(1).join(':');\n\n    // Extract the encoding and MIME type (required but can be empty).\n    const infoAndData = path.split(',');\n    if (infoAndData.length < 2) {\n      shaka.log.error('Bad data URI, failed to extract encoding and MIME type');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.MALFORMED_DATA_URI,\n          uri);\n    }\n    const info = infoAndData[0];\n    const dataStr = window.decodeURIComponent(infoAndData.slice(1).join(','));\n\n    // The MIME type is always the first thing in the semicolon-separated list\n    // of type parameters.  It may be blank.\n    const typeInfoList = info.split(';');\n    const contentType = typeInfoList[0];\n\n    // Check for base64 encoding, which is always the last in the\n    // semicolon-separated list if present.\n    let base64Encoded = false;\n    if (typeInfoList.length > 1 &&\n        typeInfoList[typeInfoList.length - 1] == 'base64') {\n      base64Encoded = true;\n      typeInfoList.pop();\n    }\n\n    // Convert the data.\n    /** @type {BufferSource} */\n    let data;\n    if (base64Encoded) {\n      data = shaka.util.Uint8ArrayUtils.fromBase64(dataStr);\n    } else {\n      data = shaka.util.StringUtils.toUTF8(dataStr);\n    }\n\n    return {data: data, contentType};\n  }\n};\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'data', shaka.net.DataUriPlugin.parse);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpPluginUtils');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.requireType('shaka.net.NetworkingEngine');\n\n\n/**\n * @summary A set of http networking utility functions.\n * @exportDoc\n */\nshaka.net.HttpPluginUtils = class {\n  /**\n   * @param {!Object.<string,string>} headers\n   * @param {BufferSource} data\n   * @param {number} status\n   * @param {string} uri\n   * @param {string} responseURL\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @return {!shaka.extern.Response}\n   */\n  static makeResponse(headers, data, status, uri, responseURL, requestType) {\n    if (status >= 200 && status <= 299 && status != 202) {\n      // Most 2xx HTTP codes are success cases.\n      /** @type {shaka.extern.Response} */\n      const response = {\n        uri: responseURL || uri,\n        originalUri: uri,\n        data: data,\n        status: status,\n        headers: headers,\n        fromCache: !!headers['x-shaka-from-cache'],\n      };\n      return response;\n    } else {\n      let responseText = null;\n      try {\n        responseText = shaka.util.StringUtils.fromBytesAutoDetect(data);\n      } catch (exception) {}\n      shaka.log.debug('HTTP error text:', responseText);\n\n      const severity = status == 401 || status == 403 ?\n          shaka.util.Error.Severity.CRITICAL :\n          shaka.util.Error.Severity.RECOVERABLE;\n\n      throw new shaka.util.Error(\n          severity,\n          shaka.util.Error.Category.NETWORK,\n          shaka.util.Error.Code.BAD_HTTP_STATUS,\n          uri,\n          status,\n          responseText,\n          headers,\n          requestType);\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpFetchPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.MapUtils');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * @summary A networking plugin to handle http and https URIs via the Fetch API.\n * @export\n */\nshaka.net.HttpFetchPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @param {shaka.extern.HeadersReceived} headersReceived Called when the\n   *   headers for the download are received, but before the body is.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated, headersReceived) {\n    const headers = new shaka.net.HttpFetchPlugin.Headers_();\n    shaka.util.MapUtils.asMap(request.headers).forEach((value, key) => {\n      headers.append(key, value);\n    });\n\n    const controller = new shaka.net.HttpFetchPlugin.AbortController_();\n\n    /** @type {!RequestInit} */\n    const init = {\n      // Edge does not treat null as undefined for body; https://bit.ly/2luyE6x\n      body: request.body || undefined,\n      headers: headers,\n      method: request.method,\n      signal: controller.signal,\n      credentials: request.allowCrossSiteCredentials ? 'include' : undefined,\n    };\n\n    /** @type {shaka.net.HttpFetchPlugin.AbortStatus} */\n    const abortStatus = {\n      canceled: false,\n      timedOut: false,\n    };\n\n    const pendingRequest = shaka.net.HttpFetchPlugin.request_(\n        uri, requestType, init, abortStatus, progressUpdated, headersReceived,\n        request.streamDataCallback);\n\n    /** @type {!shaka.util.AbortableOperation} */\n    const op = new shaka.util.AbortableOperation(pendingRequest, () => {\n      abortStatus.canceled = true;\n      controller.abort();\n      return Promise.resolve();\n    });\n\n    // The fetch API does not timeout natively, so do a timeout manually using\n    // the AbortController.\n    const timeoutMs = request.retryParameters.timeout;\n    if (timeoutMs) {\n      const timer = new shaka.util.Timer(() => {\n        abortStatus.timedOut = true;\n        controller.abort();\n      });\n\n      timer.tickAfter(timeoutMs / 1000);\n\n      // To avoid calling |abort| on the network request after it finished, we\n      // will stop the timer when the requests resolves/rejects.\n      op.finally(() => {\n        timer.stop();\n      });\n    }\n\n    return op;\n  }\n\n  /**\n   * @param {string} uri\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {!RequestInit} init\n   * @param {shaka.net.HttpFetchPlugin.AbortStatus} abortStatus\n   * @param {shaka.extern.ProgressUpdated} progressUpdated\n   * @param {shaka.extern.HeadersReceived} headersReceived\n   * @param {?function(BufferSource):!Promise} streamDataCallback\n   * @return {!Promise<!shaka.extern.Response>}\n   * @private\n   */\n  static async request_(uri, requestType, init, abortStatus, progressUpdated,\n      headersReceived, streamDataCallback) {\n    const fetch = shaka.net.HttpFetchPlugin.fetch_;\n    const ReadableStream = shaka.net.HttpFetchPlugin.ReadableStream_;\n    let response;\n    let arrayBuffer;\n    let loaded = 0;\n    let lastLoaded = 0;\n\n    // Last time stamp when we got a progress event.\n    let lastTime = Date.now();\n\n    try {\n      // The promise returned by fetch resolves as soon as the HTTP response\n      // headers are available. The download itself isn't done until the promise\n      // for retrieving the data (arrayBuffer, blob, etc) has resolved.\n      response = await fetch(uri, init);\n      // At this point in the process, we have the headers of the response, but\n      // not the body yet.\n      headersReceived(shaka.net.HttpFetchPlugin.headersToGenericObject_(\n          response.headers));\n      // Getting the reader in this way allows us to observe the process of\n      // downloading the body, instead of just waiting for an opaque promise to\n      // resolve.\n      // We first clone the response because calling getReader locks the body\n      // stream; if we didn't clone it here, we would be unable to get the\n      // response's arrayBuffer later.\n      const reader = response.clone().body.getReader();\n\n      const contentLengthRaw = response.headers.get('Content-Length');\n      const contentLength =\n          contentLengthRaw ? parseInt(contentLengthRaw, 10) : 0;\n\n      const start = (controller) => {\n        const push = async () => {\n          let readObj;\n          try {\n            readObj = await reader.read();\n          } catch (e) {\n            // If we abort the request, we'll get an error here.  Just ignore it\n            // since real errors will be reported when we read the buffer below.\n            shaka.log.v1('error reading from stream', e.message);\n            return;\n          }\n\n          if (!readObj.done) {\n            loaded += readObj.value.byteLength;\n            if (streamDataCallback) {\n              await streamDataCallback(readObj.value);\n            }\n          }\n\n          const currentTime = Date.now();\n          // If the time between last time and this time we got progress event\n          // is long enough, or if a whole segment is downloaded, call\n          // progressUpdated().\n          if (currentTime - lastTime > 100 || readObj.done) {\n            progressUpdated(currentTime - lastTime, loaded - lastLoaded,\n                contentLength - loaded);\n            lastLoaded = loaded;\n            lastTime = currentTime;\n          }\n\n          if (readObj.done) {\n            goog.asserts.assert(!readObj.value,\n                'readObj should be unset when \"done\" is true.');\n            controller.close();\n          } else {\n            controller.enqueue(readObj.value);\n            push();\n          }\n        };\n        push();\n      };\n      // Create a ReadableStream to use the reader. We don't need to use the\n      // actual stream for anything, though, as we are using the response's\n      // arrayBuffer method to get the body, so we don't store the\n      // ReadableStream.\n      new ReadableStream({start}); // eslint-disable-line no-new\n      arrayBuffer = await response.arrayBuffer();\n    } catch (error) {\n      if (abortStatus.canceled) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.OPERATION_ABORTED,\n            uri, requestType);\n      } else if (abortStatus.timedOut) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            uri, requestType);\n      } else {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.HTTP_ERROR,\n            uri, error, requestType);\n      }\n    }\n\n    const headers = shaka.net.HttpFetchPlugin.headersToGenericObject_(\n        response.headers);\n\n    return shaka.net.HttpPluginUtils.makeResponse(\n        headers, arrayBuffer, response.status, uri, response.url, requestType);\n  }\n\n  /**\n   * @param {!Headers} headers\n   * @return {!Object.<string, string>}\n   * @private\n   */\n  static headersToGenericObject_(headers) {\n    const headersObj = {};\n    headers.forEach((value, key) => {\n      // Since Edge incorrectly return the header with a leading new line\n      // character ('\\n'), we trim the header here.\n      headersObj[key.trim()] = value;\n    });\n    return headersObj;\n  }\n\n  /**\n   * Determine if the Fetch API is supported in the browser. Note: this is\n   * deliberately exposed as a method to allow the client app to use the same\n   * logic as Shaka when determining support.\n   * @return {boolean}\n   * @export\n   */\n  static isSupported() {\n    // On Edge, ReadableStream exists, but attempting to construct it results in\n    // an error. See https://bit.ly/2zwaFLL\n    // So this has to check that ReadableStream is present AND usable.\n    if (window.ReadableStream) {\n      try {\n        new ReadableStream({}); // eslint-disable-line no-new\n      } catch (e) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n    return !!(window.fetch && window.AbortController);\n  }\n};\n\n\n/**\n * @typedef {{\n *   canceled: boolean,\n *   timedOut: boolean\n * }}\n * @property {boolean} canceled\n *   Indicates if the request was canceled.\n * @property {boolean} timedOut\n *   Indicates if the request timed out.\n */\nshaka.net.HttpFetchPlugin.AbortStatus;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(string, !RequestInit)}\n * @private\n */\nshaka.net.HttpFetchPlugin.fetch_ = window.fetch;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: AbortController)}\n * @private\n */\nshaka.net.HttpFetchPlugin.AbortController_ = window.AbortController;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: ReadableStream, !Object)}\n * @private\n */\nshaka.net.HttpFetchPlugin.ReadableStream_ = window.ReadableStream;\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: Headers)}\n * @private\n */\nshaka.net.HttpFetchPlugin.Headers_ = window.Headers;\n\n\nif (shaka.net.HttpFetchPlugin.isSupported()) {\n  shaka.net.NetworkingEngine.registerScheme(\n      'http', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED,\n      /* progressSupport= */ true);\n  shaka.net.NetworkingEngine.registerScheme(\n      'https', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED,\n      /* progressSupport= */ true);\n  shaka.net.NetworkingEngine.registerScheme(\n      'blob', shaka.net.HttpFetchPlugin.parse,\n      shaka.net.NetworkingEngine.PluginPriority.PREFERRED,\n      /* progressSupport= */ true);\n}\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.net.HttpXHRPlugin');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.HttpPluginUtils');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary A networking plugin to handle http and https URIs via XHR.\n * @export\n */\nshaka.net.HttpXHRPlugin = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @param {shaka.extern.HeadersReceived} headersReceived Called when the\n   *   headers for the download are received, but before the body is.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static parse(uri, request, requestType, progressUpdated, headersReceived) {\n    const xhr = new shaka.net.HttpXHRPlugin.Xhr_();\n\n    // Last time stamp when we got a progress event.\n    let lastTime = Date.now();\n    // Last number of bytes loaded, from progress event.\n    let lastLoaded = 0;\n\n    const promise = new Promise(((resolve, reject) => {\n      xhr.open(request.method, uri, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.timeout = request.retryParameters.timeout;\n      xhr.withCredentials = request.allowCrossSiteCredentials;\n\n      xhr.onabort = () => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.OPERATION_ABORTED,\n            uri, requestType));\n      };\n      let calledHeadersReceived = false;\n      xhr.onreadystatechange = (event) => {\n        // See if the readyState is 2 (\"HEADERS_RECEIVED\").\n        if (xhr.readyState == 2 && !calledHeadersReceived) {\n          const headers = shaka.net.HttpXHRPlugin.headersToGenericObject_(xhr);\n          headersReceived(headers);\n          // Don't send out this event twice.\n          calledHeadersReceived = true;\n        }\n      };\n      xhr.onload = (event) => {\n        const headers = shaka.net.HttpXHRPlugin.headersToGenericObject_(xhr);\n        goog.asserts.assert(xhr.response instanceof ArrayBuffer,\n            'XHR should have a response by now!');\n        const xhrResponse = xhr.response;\n\n        try {\n          const response = shaka.net.HttpPluginUtils.makeResponse(headers,\n              xhrResponse, xhr.status, uri, xhr.responseURL, requestType);\n          resolve(response);\n        } catch (error) {\n          goog.asserts.assert(error instanceof shaka.util.Error,\n              'Wrong error type!');\n          reject(error);\n        }\n      };\n      xhr.onerror = (event) => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.HTTP_ERROR,\n            uri, event, requestType));\n      };\n      xhr.ontimeout = (event) => {\n        reject(new shaka.util.Error(\n            shaka.util.Error.Severity.RECOVERABLE,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.TIMEOUT,\n            uri, requestType));\n      };\n      xhr.onprogress = (event) => {\n        const currentTime = Date.now();\n        // If the time between last time and this time we got progress event\n        // is long enough, or if a whole segment is downloaded, call\n        // progressUpdated().\n        if (currentTime - lastTime > 100 ||\n            (event.lengthComputable && event.loaded == event.total)) {\n          progressUpdated(currentTime - lastTime, event.loaded - lastLoaded,\n              event.total - event.loaded);\n          lastLoaded = event.loaded;\n          lastTime = currentTime;\n        }\n      };\n\n      for (const key in request.headers) {\n        // The Fetch API automatically normalizes outgoing header keys to\n        // lowercase. For consistency's sake, do it here too.\n        const lowercasedKey = key.toLowerCase();\n        xhr.setRequestHeader(lowercasedKey, request.headers[key]);\n      }\n      xhr.send(request.body);\n    }));\n\n    return new shaka.util.AbortableOperation(\n        promise,\n        () => {\n          xhr.abort();\n          return Promise.resolve();\n        });\n  }\n\n  /**\n   * @param {!XMLHttpRequest} xhr\n   * @return {!Object.<string, string>}\n   * @private\n   */\n  static headersToGenericObject_(xhr) {\n    // Since Edge incorrectly return the header with a leading new\n    // line character ('\\n'), we trim the header here.\n    const headerLines = xhr.getAllResponseHeaders().trim().split('\\r\\n');\n    const headers = {};\n    for (const header of headerLines) {\n      /** @type {!Array.<string>} */\n      const parts = header.split(': ');\n      headers[parts[0].toLowerCase()] = parts.slice(1).join(': ');\n    }\n    return headers;\n  }\n};\n\n\n/**\n * Overridden in unit tests, but compiled out in production.\n *\n * @const {function(new: XMLHttpRequest)}\n * @private\n */\nshaka.net.HttpXHRPlugin.Xhr_ = window.XMLHttpRequest;\n\n\nshaka.net.NetworkingEngine.registerScheme(\n    'http', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK,\n    /* progressSupport= */ true);\nshaka.net.NetworkingEngine.registerScheme(\n    'https', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK,\n    /* progressSupport= */ true);\nshaka.net.NetworkingEngine.registerScheme(\n    'blob', shaka.net.HttpXHRPlugin.parse,\n    shaka.net.NetworkingEngine.PluginPriority.FALLBACK,\n    /* progressSupport= */ true);\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadInfo');\n\ngoog.require('shaka.util.Networking');\ngoog.requireType('shaka.media.InitSegmentReference');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * An object that represents a single segment, that the storage system will soon\n * download, but has not yet started downloading.\n */\nshaka.offline.DownloadInfo = class {\n  /**\n   * @param {shaka.media.SegmentReference|shaka.media.InitSegmentReference} ref\n   * @param {number} estimateId\n   * @param {number} groupId\n   * @param {boolean} isInitSegment\n   */\n  constructor(ref, estimateId, groupId, isInitSegment) {\n    /** @type {shaka.media.SegmentReference|shaka.media.InitSegmentReference} */\n    this.ref = ref;\n\n    /** @type {number} */\n    this.estimateId = estimateId;\n\n    /** @type {number} */\n    this.groupId = groupId;\n\n    /** @type {boolean} */\n    this.isInitSegment = isInitSegment;\n  }\n\n  /**\n   * Creates an ID that encapsulates all important information in the ref, which\n   * can then be used to check for equality.\n   * @param {shaka.media.SegmentReference|shaka.media.InitSegmentReference} ref\n   * @return {string}\n   */\n  static idForSegmentRef(ref) {\n    // Escape the URIs using encodeURI, to make sure that a weirdly formed URI\n    // cannot cause two unrelated refs to be considered equivalent.\n    return ref.getUris().map((uri) => '{' + encodeURI(uri) + '}').join('') +\n        ':' + ref.startByte + ':' + ref.endByte;\n  }\n\n  /** @return {string} */\n  getRefId() {\n    return shaka.offline.DownloadInfo.idForSegmentRef(this.ref);\n  }\n\n  /**\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!shaka.extern.Request}\n   */\n  makeSegmentRequest(config) {\n    return shaka.util.Networking.createSegmentRequest(\n        this.ref.getUris(),\n        this.ref.startByte,\n        this.ref.endByte,\n        config.streaming.retryParameters);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadProgressEstimator');\n\n\n/**\n * The download progress estimator class encapsulates all the logic for tracking\n * how much content has been downloaded and estimating its progress.\n *\n * @final\n */\nshaka.offline.DownloadProgressEstimator = class {\n  /** */\n  constructor() {\n    /**\n     * This is the sum of all estimates passed to |open|. This is used as the\n     * denominator when measuring progress.\n     *\n     * @private {number}\n     */\n    this.estimatedTotal_ = 0;\n\n    /**\n     * This is the sum of all estimates pass to |open| but only after |close|\n     * has been called. This is used as the numerator when measuring progress so\n     * that |estimatedTotal_ == estimatedDownloaded_| after everything is\n     * downloaded.\n     *\n     * @private {number}\n     */\n    this.estimatedDownloaded_ = 0;\n\n    /**\n     * This is the total number of bytes actually downloaded. This will most\n     * likely differ from |estimatedTotal_| after everything is downloaded since\n     * our estimates will be off.\n     *\n     * @private {number}\n     */\n    this.actualDownloaded_ = 0;\n\n    /**\n     * This is a map of all pending downloads. This maps their download id (an\n     * internal id) to the estimate. This will allow us to update\n     * |estimatedDownloaded_| when |close| is called.\n     *\n     * @private {!Map.<number, number>}\n     */\n    this.pending_ = new Map();\n\n    /**\n     * This number is used to provide unique (to estimator) ids for each\n     * download. This allows us to track each download in |pending_|.\n     *\n     * @private {number}\n     */\n    this.nextId_ = 0;\n  }\n\n  /**\n   * Open a new download in the progress estimator. This will create an entry so\n   * that we can track the download progress.\n   *\n   * This will return an id for the download. This id must be passed to |close|\n   * in order for the |close| to be paired with this call to |open|.\n   *\n   * @param {number} estimate\n   * @return {number}\n   */\n  open(estimate) {\n    this.estimatedTotal_ += estimate;\n\n    const id = this.nextId_;\n    this.nextId_++;\n\n    this.pending_.set(id, estimate);\n    return id;\n  }\n\n  /**\n   * Close a download in the estimator. This will signal that we have finished\n   * downloading a segment and we can update the progress estimate.\n   *\n   * @param {number} id\n   * @param {number} actual\n   */\n  close(id, actual) {\n    if (!this.pending_.has(id)) {\n      return;\n    }\n\n    const estimate = this.pending_.get(id);\n    this.pending_.delete(id);\n\n    this.estimatedDownloaded_ += estimate;\n    this.actualDownloaded_ += actual;\n  }\n\n  /**\n   * Get the current estimate for how much progress we've made downloading the\n   * content. Progress will be between 0 and 1.\n   *\n   * Depending on the order of calls to |open| and |close|,\n   * |getEstimatedProgress| will fluctuate and is not guaranteed to always be\n   * increasing.\n   *\n   * @return {number}\n   */\n  getEstimatedProgress() {\n    return this.estimatedTotal_ == 0 ?\n           0 :\n           this.estimatedDownloaded_ / this.estimatedTotal_;\n  }\n\n  /**\n   * Get the total number of bytes that were actually downloaded.\n   *\n   * @return {number}\n   */\n  getTotalDownloaded() {\n    return this.actualDownloaded_;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.DownloadManager');\n\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadProgressEstimator');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Pssh');\n\n\n/**\n * This manages downloading segments.\n *\n * @implements {shaka.util.IDestroyable}\n * @final\n */\nshaka.offline.DownloadManager = class {\n  /**\n   * Create a new download manager. It will use (but not own) |networkingEngine|\n   * and call |onProgress| after each download.\n   *\n   * @param {!shaka.net.NetworkingEngine} networkingEngine\n   */\n  constructor(networkingEngine) {\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = networkingEngine;\n\n    /**\n     * We group downloads. Within each group, the requests are executed in\n     * series. Between groups, the requests are executed in parallel. We store\n     * the promise chain that is doing the work.\n     *\n     * @private {!Map.<number, !Promise>}\n     */\n    this.groups_ = new Map();\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(() => {\n      // Add a \"catch\" block to stop errors from being returned.\n      return this.abortAll().catch(() => {});\n    });\n\n    /**\n     * A list of callback functions to cancel any in-progress downloads.\n     *\n     * @private {!Array.<function():!Promise>}\n     */\n    this.abortCallbacks_ = [];\n\n    /**\n     * A callback for when a segment has been downloaded. The first parameter\n     * is the progress of all segments, a number between 0.0 (0% complete) and\n     * 1.0 (100% complete). The second parameter is the total number of bytes\n     * that have been downloaded.\n     *\n     * @private {function(number, number)}\n     */\n    this.onProgress_ = (progress, size) => {};\n\n    /**\n     * A callback for when a segment has new PSSH data and we pass\n     * on the initData to storage\n     *\n     * @private {function(!Uint8Array, string)}\n     */\n    this.onInitData_ = (initData, systemId) => {};\n\n    /** @private {shaka.offline.DownloadProgressEstimator} */\n    this.estimator_ = new shaka.offline.DownloadProgressEstimator();\n  }\n\n  /** @override */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * @param {function(number, number)} onProgress\n   * @param {function(!Uint8Array, string)} onInitData\n   */\n  setCallbacks(onProgress, onInitData) {\n    this.onProgress_ = onProgress;\n    this.onInitData_ = onInitData;\n  }\n\n  /**\n   * Aborts all in-progress downloads.\n   * @return {!Promise} A promise that will resolve once the downloads are fully\n   *   aborted.\n   */\n  abortAll() {\n    const promises = this.abortCallbacks_.map((callback) => callback());\n    this.abortCallbacks_ = [];\n    return Promise.all(promises);\n  }\n\n  /**\n   * Adds a byte length to the download estimate.\n   *\n   * @param {number} estimatedByteLength\n   * @return {number} estimateId\n   */\n  addDownloadEstimate(estimatedByteLength) {\n    return this.estimator_.open(estimatedByteLength);\n  }\n\n  /**\n   * Add a request to be downloaded as part of a group.\n   *\n   * @param {number} groupId\n   *    The group to add this segment to. If the group does not exist, a new\n   *    group will be created.\n   * @param {shaka.extern.Request} request\n   * @param {number} estimateId\n   * @param {boolean} isInitSegment\n   * @param {function(BufferSource):!Promise} onDownloaded\n   *   The callback for when this request has been downloaded. Downloading for\n   *   |group| will pause until the promise returned by |onDownloaded| resolves.\n   * @return {!Promise} Resolved when this request is complete.\n   */\n  queue(groupId, request, estimateId, isInitSegment, onDownloaded) {\n    this.destroyer_.ensureNotDestroyed();\n\n    const group = this.groups_.get(groupId) || Promise.resolve();\n\n    // Add another download to the group.\n    const newPromise = group.then(async () => {\n      const response = await this.fetchSegment_(request);\n\n      // Make sure we stop downloading if we have been destroyed.\n      if (this.destroyer_.destroyed()) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.OPERATION_ABORTED);\n      }\n\n      // Update initData\n      if (isInitSegment) {\n        const segmentBytes = shaka.util.BufferUtils.toUint8(response);\n        const pssh = new shaka.util.Pssh(segmentBytes);\n        for (const key in pssh.data) {\n          const index = Number(key);\n          const data = pssh.data[index];\n          const systemId = pssh.systemIds[index];\n          this.onInitData_(data, systemId);\n        }\n      }\n\n      // Update all our internal stats.\n      this.estimator_.close(estimateId, response.byteLength);\n      this.onProgress_(\n          this.estimator_.getEstimatedProgress(),\n          this.estimator_.getTotalDownloaded());\n\n      return onDownloaded(response);\n    });\n\n    this.groups_.set(groupId, newPromise);\n    return newPromise;\n  }\n\n  /**\n   * Add additional async work to the group work queue.\n   *\n   * @param {number} groupId\n   *    The group to add this group to. If the group does not exist, a new\n   *    group will be created.\n   * @param {function():!Promise} callback\n   *   The callback for the async work.  Downloading for this group will be\n   *   blocked until the Promise returned by |callback| resolves.\n   * @return {!Promise} Resolved when this work is complete.\n   */\n  queueWork(groupId, callback) {\n    this.destroyer_.ensureNotDestroyed();\n    const group = this.groups_.get(groupId) || Promise.resolve();\n    const newPromise = group.then(async () => {\n      await callback();\n    });\n    this.groups_.set(groupId, newPromise);\n    return newPromise;\n  }\n\n  /**\n   * Get a promise that will resolve when all currently queued downloads have\n   * finished.\n   *\n   * @return {!Promise.<number>}\n   */\n  async waitToFinish() {\n    await Promise.all(this.groups_.values());\n    return this.estimator_.getTotalDownloaded();\n  }\n\n  /**\n   * Download a segment and return the data in the response.\n   *\n   * @param {shaka.extern.Request} request\n   * @return {!Promise.<BufferSource>}\n   * @private\n   */\n  async fetchSegment_(request) {\n    const type = shaka.net.NetworkingEngine.RequestType.SEGMENT;\n    /** @type {!shaka.net.NetworkingEngine.PendingRequest} */\n    const action = this.networkingEngine_.request(type, request);\n    const abortCallback = () => {\n      return action.abort();\n    };\n    this.abortCallbacks_.push(abortCallback);\n    const response = await action.promise;\n    shaka.util.ArrayUtils.remove(this.abortCallbacks_, abortCallback);\n    return response.data;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.DBOperation');\n\n\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * A DBOperation wraps an IndexedDB transaction in a promise.\n */\nshaka.offline.indexeddb.DBOperation = class {\n  /**\n   * @param {IDBTransaction} transaction\n   * @param {string} storeName\n   */\n  constructor(transaction, storeName) {\n    /** @private {IDBTransaction} */\n    this.transaction_ = transaction;\n    /** @private {IDBObjectStore} */\n    this.store_ = transaction.objectStore(storeName);\n    /** @private {!shaka.util.PublicPromise} */\n    this.promise_ = new shaka.util.PublicPromise();\n\n    // Connect the transaction and the promise together.\n    // |event.preventDefault()| is used on all non-successful callbacks to\n    // prevent Firefox from surfacing the error on the main thread.\n    transaction.onabort = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.onerror = (event) => {\n      event.preventDefault();\n      this.promise_.reject();\n    };\n    transaction.oncomplete = (event) => {\n      this.promise_.resolve();\n    };\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  async abort() {\n    try {\n      this.transaction_.abort();\n    } catch (e) {\n      // Ignore any exceptions that may be thrown as a result of aborting\n      // the transaction.\n    }\n\n    try {\n      // Wait for the promise to be rejected, but ignore the rejection error.\n      await this.promise_;\n    } catch (e) {}\n  }\n\n  /**\n   * Calls the given callback for each entry in the database.\n   *\n   * @param {function(!IDBKeyType, T, !IDBCursorWithValue=):(Promise|undefined)}\n   *   callback\n   * @return {!Promise}\n   * @template T\n   */\n  forEachEntry(callback) {\n    return new Promise((resolve, reject) => {\n      const req = this.store_.openCursor();\n      req.onerror = reject;\n      req.onsuccess = async (event) => {\n        // When we reach the end of the data that the cursor is iterating over,\n        // |req.result| will be null to signal the end of the iteration.\n        // https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/continue\n        if (req.result == null) {\n          resolve();\n          return;\n        }\n\n        /** @type {!IDBCursorWithValue} */\n        const cursor = req.result;\n        await callback(cursor.key, cursor.value, cursor);\n        cursor.continue();\n      };\n    });\n  }\n\n  /**\n   * Get the store that the operation can interact with. Requests can be made\n   * on the store. All requests made on the store will complete successfully\n   * before the operation's promise will resolve. If any request fails, the\n   * operation's promise will be rejected.\n   *\n   * @return {IDBObjectStore}\n   */\n  store() { return this.store_; }\n\n  /**\n   * Get the promise that wraps the transaction. This promise will resolve when\n   * all requests on the object store complete successfully and the transaction\n   * completes. If any request fails or the operation is aborted, the promise\n   * will be rejected.\n   *\n   * @return {!Promise}\n   */\n  promise() { return this.promise_; }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.DBConnection');\n\ngoog.require('shaka.offline.indexeddb.DBOperation');\ngoog.require('shaka.util.ArrayUtils');\n\n\n/**\n * DBConnection is used to manage an IndexedDB connection. It can create new\n * operations. If the connection is killed (via |destroy|) all pending\n * operations will be cancelled.\n */\nshaka.offline.indexeddb.DBConnection = class {\n  /**\n   * @param {IDBDatabase} connection A connection to an IndexedDB instance.\n   */\n  constructor(connection) {\n    /** @private {IDBDatabase} */\n    this.connection_ = connection;\n    /** @private {!Array.<shaka.offline.indexeddb.DBOperation>} */\n    this.pending_ = [];\n  }\n\n  /**\n   * @return {!Promise}\n   */\n  destroy() {\n    return Promise.all(this.pending_.map((op) => {\n      return op.abort();\n    }));\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadOnlyOperation(store) {\n    return this.startOperation_(store, 'readonly');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   */\n  startReadWriteOperation(store) {\n    return this.startOperation_(store, 'readwrite');\n  }\n\n  /**\n   * @param {string} store The name of the store that the operation should\n   *                       occur on.\n   * @param {string} type The type of operation being performed on the store.\n   *                      This determines what commands may be performed. This\n   *                      can either be \"readonly\" or \"readwrite\".\n   * @return {!shaka.offline.indexeddb.DBOperation}\n   * @private\n   */\n  startOperation_(store, type) {\n    const transaction = this.connection_.transaction([store], type);\n    const operation =\n        new shaka.offline.indexeddb.DBOperation(transaction, store);\n\n    this.pending_.push(operation);\n\n    // Once the operation is done (regardless of outcome) stop tracking it.\n    operation.promise().then(\n        () => this.stopTracking_(operation),\n        () => this.stopTracking_(operation));\n\n    return operation;\n  }\n\n  /**\n   * @param {!shaka.offline.indexeddb.DBOperation} operation\n   * @private\n   */\n  stopTracking_(operation) {\n    shaka.util.ArrayUtils.remove(this.pending_, operation);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.BaseStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.require('shaka.util.Error');\ngoog.requireType('shaka.offline.indexeddb.DBOperation');\n\n\n/**\n * indexeddb.StorageCellBase is a base class for all stores that use IndexedDB.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.BaseStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} segmentStore\n   * @param {string} manifestStore\n   */\n  constructor(connection, segmentStore, manifestStore) {\n    /** @protected {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @protected {string} */\n    this.segmentStore_ = segmentStore;\n\n    /** @protected {string} */\n    this.manifestStore_ = manifestStore;\n  }\n\n  /** @override */\n  destroy() {\n    return this.connection_.destroy();\n  }\n\n  /** @override */\n  hasFixedKeySpace() {\n    // By default, all IDB stores are read-only.  The latest one will need to\n    // override this default to be read-write.\n    return true;\n  }\n\n  /** @override */\n  addSegments(segments) {\n    // By default, reject all additions.\n    return this.rejectAdd(this.segmentStore_);\n  }\n\n  /** @override */\n  removeSegments(keys, onRemove) {\n    return this.remove_(this.segmentStore_, keys, onRemove);\n  }\n\n  /** @override */\n  async getSegments(keys) {\n    const rawSegments = await this.get_(this.segmentStore_, keys);\n    return rawSegments.map((s) => this.convertSegmentData(s));\n  }\n\n  /** @override */\n  addManifests(manifests) {\n    // By default, reject all additions.\n    return this.rejectAdd(this.manifestStore_);\n  }\n\n  /** @override */\n  updateManifest(key, manifest) {\n    // By default, reject all updates.\n    return this.rejectUpdate(this.manifestStore_);\n  }\n\n  /**\n   * @param {number} key\n   * @param {!shaka.extern.ManifestDB} manifest\n   * @return {!Promise}\n   * @protected\n   */\n  updateManifestImplementation(key, manifest) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    const store = op.store();\n    store.get(key).onsuccess = (e) => {\n      store.put(manifest, key);\n    };\n\n    return op.promise();\n  }\n\n  /** @override */\n  updateManifestExpiration(key, newExpiration) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n    const store = op.store();\n    store.get(key).onsuccess = (e) => {\n      const manifest = e.target.result;\n      // If we can't find the value, then there is nothing for us to update.\n      if (manifest) {\n        manifest.expiration = newExpiration;\n        store.put(manifest, key);\n      }\n    };\n\n    return op.promise();\n  }\n\n  /** @override */\n  removeManifests(keys, onRemove) {\n    return this.remove_(this.manifestStore_, keys, onRemove);\n  }\n\n  /** @override */\n  async getManifests(keys) {\n    const rawManifests = await this.get_(this.manifestStore_, keys);\n    return Promise.all(rawManifests.map((m) => this.convertManifest(m)));\n  }\n\n  /** @override */\n  async getAllManifests() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.manifestStore_);\n\n    /** @type {!Map.<number, shaka.extern.ManifestDB>} */\n    const values = new Map();\n\n    await op.forEachEntry(async (key, value) => {\n      const manifest = await this.convertManifest(value);\n      values.set(/** @type {number} */(key), manifest);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /**\n   * @param {?} old\n   * @return {shaka.extern.SegmentDataDB}\n   * @protected\n   */\n  convertSegmentData(old) {\n    // Conversion is specific to each subclass.  By default, do nothing.\n    return /** @type {shaka.extern.SegmentDataDB} */(old);\n  }\n\n  /**\n   * @param {?} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   * @protected\n   */\n  convertManifest(old) {\n    // Conversion is specific to each subclass.  By default, do nothing.\n    return Promise.resolve(/** @type {shaka.extern.ManifestDB} */(old));\n  }\n\n  /**\n   * @param {string} storeName\n   * @return {!Promise}\n   * @protected\n   */\n  rejectAdd(storeName) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED,\n        'Cannot add new value to ' + storeName));\n  }\n\n  /**\n   * @param {string} storeName\n   * @return {!Promise}\n   * @protected\n   */\n  rejectUpdate(storeName) {\n    return Promise.reject(new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MODIFY_OPERATION_NOT_SUPPORTED,\n        'Cannot modify values in ' + storeName));\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<T>} values\n   * @return {!Promise.<!Array.<number>>}\n   * @template T\n   * @protected\n   */\n  async add(storeName, values) {\n    const op = this.connection_.startReadWriteOperation(storeName);\n    const store = op.store();\n\n    /** @type {!Array.<number>} */\n    const keys = [];\n\n    // Write each segment out. When each request completes, the key will\n    // be in |request.result| as can be seen in\n    // https://w3c.github.io/IndexedDB/#key-generator-construct.\n    for (const value of values) {\n      const request = store.add(value);\n      request.onsuccess = (event) => {\n        const key = request.result;\n        keys.push(key);\n      };\n    }\n\n    // Wait until the operation completes or else |keys| will not be fully\n    // populated.\n    await op.promise();\n    return keys;\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @param {function(number)} onRemove\n   * @return {!Promise}\n   * @private\n   */\n  remove_(storeName, keys, onRemove) {\n    const op = this.connection_.startReadWriteOperation(storeName);\n    const store = op.store();\n\n    for (const key of keys) {\n      store.delete(key).onsuccess = () => onRemove(key);\n    }\n\n    return op.promise();\n  }\n\n  /**\n   * @param {string} storeName\n   * @param {!Array.<number>} keys\n   * @return {!Promise.<!Array.<T>>}\n   * @template T\n   * @private\n   */\n  async get_(storeName, keys) {\n    const op = this.connection_.startReadOnlyOperation(storeName);\n    const store = op.store();\n\n    const values = {};\n    /** @type {!Array.<number>} */\n    const missing = [];\n\n    // Use a map to store the objects so that we can reorder the results to\n    // match the order of |keys|.\n    for (const key of keys) {\n      const request = store.get(key);\n      request.onsuccess = () => {\n        // Make sure a defined value was found. Indexeddb treats no-value found\n        // as a success with an undefined result.\n        if (request.result == undefined) {\n          missing.push(key);\n        }\n\n        values[key] = request.result;\n      };\n    }\n\n    // Wait until the operation completes or else values may be missing from\n    // |values|. Use the original key list to convert the map to a list so that\n    // the order will match.\n    await op.promise();\n    if (missing.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.KEY_NOT_FOUND,\n          'Could not find values for ' + missing);\n    }\n\n    return keys.map((key) => values[key]);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.EmeSessionStorageCell');\n\ngoog.require('shaka.offline.indexeddb.DBConnection');\ngoog.requireType('shaka.offline.indexeddb.DBOperation');\n\n\n/**\n * The implementation of the EME session storage cell.\n *\n * @implements {shaka.extern.EmeSessionStorageCell}\n */\nshaka.offline.indexeddb.EmeSessionStorageCell = class {\n  /**\n   * @param {IDBDatabase} connection\n   * @param {string} store\n   */\n  constructor(connection, store) {\n    /** @private {!shaka.offline.indexeddb.DBConnection} */\n    this.connection_ = new shaka.offline.indexeddb.DBConnection(connection);\n\n    /** @private {string} */\n    this.store_ = store;\n  }\n\n  /** @override */\n  destroy() { return this.connection_.destroy(); }\n\n  /** @override */\n  async getAll() {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadOnlyOperation(this.store_);\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const values = [];\n\n    await op.forEachEntry((key, value) => {\n      values.push(value);\n    });\n\n    await op.promise();\n    return values;\n  }\n\n  /** @override */\n  add(sessions) {\n    const op = this.connection_.startReadWriteOperation(this.store_);\n    const store = op.store();\n\n    for (const session of sessions) {\n      store.add(session);\n    }\n\n    return op.promise();\n  }\n\n  /** @override */\n  async remove(sessionIds) {\n    /** @type {!shaka.offline.indexeddb.DBOperation} */\n    const op = this.connection_.startReadWriteOperation(this.store_);\n\n    await op.forEachEntry((key, value, cursor) => {\n      if (sessionIds.includes(value.sessionId)) {\n        cursor.delete();\n      }\n    });\n\n    await op.promise();\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StorageCellHandle');\ngoog.provide('shaka.offline.StorageCellPath');\ngoog.provide('shaka.offline.StorageMuxer');\n\ngoog.require('shaka.log');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\n\n/**\n * @typedef {{\n *  mechanism: string,\n *  cell: string\n * }}\n *\n * @property {string} mechanism\n *  The name of the mechanism that holds the cell.\n * @property {string} cell\n *  The name of the cell in the mechanism.\n */\nshaka.offline.StorageCellPath;\n\n\n/**\n * @typedef {{\n *   path: shaka.offline.StorageCellPath,\n *   cell: !shaka.extern.StorageCell\n * }}\n *\n * @property {shaka.offline.StorageCellPath} path\n *   The path that maps to the cell.\n * @property {shaka.extern.StorageCell} cell\n *   The storage cell that the path points to within the storage muxer.\n */\nshaka.offline.StorageCellHandle;\n\n\n// TODO: revisit this when Closure Compiler supports partially-exported classes.\n/**\n * StorageMuxer is responsible for managing StorageMechanisms and addressing\n * cells. The primary purpose of the muxer is to give the caller the correct\n * cell for the operations they want to perform.\n *\n * |findActive| will be used when the caller wants a cell that supports\n * add-operations. This will be used when saving new content to storage.\n *\n * |findAll| will be used when the caller want to look at all the content\n * in storage.\n *\n * |resolvePath| will be used to convert a path (from |findActive| and\n * |findAll|) into a cell, which it then returns.\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.StorageMuxer = class {\n  /** */\n  constructor() {\n    /**\n     * A key in this map is the name given when registering a StorageMechanism.\n     *\n     * @private {!Map.<string, !shaka.extern.StorageMechanism>}\n     */\n    this.mechanisms_ = new Map();\n  }\n\n  // TODO: revisit this when the compiler supports partially-exported classes.\n  /**\n   * Free all resources used by the muxer, mechanisms, and cells. This should\n   * not affect the stored content.\n   *\n   * @override\n   * @export\n   */\n  destroy() {\n    /** @type {!Array.<!Promise>} */\n    const destroys = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      destroys.push(mechanism.destroy());\n    }\n\n    // Empty the map so that subsequent calls will be no-ops.\n    this.mechanisms_.clear();\n\n    return Promise.all(destroys);\n  }\n\n  /**\n   * Initialize the storage muxer. This must be called before any other calls.\n   * This will initialize the muxer to use all mechanisms that have been\n   * registered with |StorageMuxer.register|.\n   *\n   * @return {!Promise}\n   */\n  init() {\n    // Add the new instance of each mechanism to the muxer.\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    registry.forEach((factory, name) => {\n      const mech = factory();\n      if (mech) {\n        this.mechanisms_.set(name, mech);\n      } else {\n        shaka.log.info(\n            'Skipping ' + name + ' as it is not supported on this platform');\n      }\n    });\n\n    /** @type {!Array.<!Promise>} */\n    const initPromises = [];\n    for (const mechanism of this.mechanisms_.values()) {\n      initPromises.push(mechanism.init());\n    }\n\n    return Promise.all(initPromises);\n  }\n\n  /**\n   * Get a promise that will resolve with a storage cell that supports\n   * add-operations. If no cell can be found, the promise will be rejected.\n   *\n   * @return {shaka.offline.StorageCellHandle}\n   */\n  getActive() {\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let handle = null;\n\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        // If this cell is not useful to us or we already have a handle, then\n        // we don't need to make a new handle.\n        if (cell.hasFixedKeySpace() || handle) {\n          return;\n        }\n\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        handle = {\n          path: path,\n          cell: cell,\n        };\n      });\n    });\n\n    if (handle) {\n      return /** @type {shaka.offline.StorageCellHandle} */(handle);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MISSING_STORAGE_CELL,\n        'Could not find a cell that supports add-operations');\n  }\n\n  /**\n   * @param {function(!shaka.offline.StorageCellPath,\n   *                  !shaka.extern.StorageCell)} callback\n   */\n  forEachCell(callback) {\n    this.mechanisms_.forEach((mechanism, mechanismName) => {\n      mechanism.getCells().forEach((cell, cellName) => {\n        const path = {\n          mechanism: mechanismName,\n          cell: cellName,\n        };\n\n        callback(path, cell);\n      });\n    });\n  }\n\n  /**\n   * Get a specific storage cell. The promise will resolve with the storage\n   * cell if it is found. If the storage cell is not found, the promise will\n   * be rejected.\n   *\n   * @param {string} mechanismName\n   * @param {string} cellName\n   * @return {!shaka.extern.StorageCell}\n   */\n  getCell(mechanismName, cellName) {\n    const mechanism = this.mechanisms_.get(mechanismName);\n    if (!mechanism) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find mechanism with name ' + mechanismName);\n    }\n\n    const cell = mechanism.getCells().get(cellName);\n    if (!cell) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MISSING_STORAGE_CELL,\n          'Could not find cell with name ' + cellName);\n    }\n\n    return cell;\n  }\n\n  /**\n   * @param {function(!shaka.extern.EmeSessionStorageCell)} callback\n   */\n  forEachEmeSessionCell(callback) {\n    this.mechanisms_.forEach((mechanism, name) => {\n      callback(mechanism.getEmeSessionCell());\n    });\n  }\n\n  /**\n   * Gets an arbitrary EME session cell that can be used for storing new session\n   * info.\n   *\n   * @return {!shaka.extern.EmeSessionStorageCell}\n   */\n  getEmeSessionCell() {\n    const mechanisms = Array.from(this.mechanisms_.keys());\n    if (!mechanisms.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED,\n          'No supported storage mechanisms found');\n    }\n\n    return this.mechanisms_.get(mechanisms[0]).getEmeSessionCell();\n  }\n\n  /**\n   * Find the cell that the path points to. A path is made up of a mount point\n   * and a cell id. If a cell can be found, the cell will be returned. If no\n   * cell is found, null will be returned.\n   *\n   * @param {shaka.offline.StorageCellPath} path\n   * @return {shaka.extern.StorageCell}\n   */\n  resolvePath(path) {\n    const mechanism = this.mechanisms_.get(path.mechanism);\n\n    if (!mechanism) {\n      return null;\n    }\n\n    return mechanism.getCells().get(path.cell);\n  }\n\n  /**\n   * This will erase all previous content from storage. Using paths obtained\n   * before calling |erase| is discouraged, as cells may have changed during a\n   * erase.\n   *\n   * @return {!Promise}\n   */\n  async erase() {\n    // If we have initialized, we will use the existing mechanism instances.\n    /** @type {!Array.<!shaka.extern.StorageMechanism>} */\n    const mechanisms = Array.from(this.mechanisms_.values());\n    const alreadyInitialized = mechanisms.length > 0;\n\n    // If we have not initialized, we should still be able to erase.  This is\n    // critical to our ability to wipe the DB in case of a version mismatch.\n    // If there are no instances, create temporary ones and destroy them later.\n    if (!alreadyInitialized) {\n      const registry = shaka.offline.StorageMuxer.getRegistry_();\n      registry.forEach((factory, name) => {\n        const mech = factory();\n        if (mech) {\n          mechanisms.push(mech);\n        }\n      });\n    }\n\n    // Erase all storage mechanisms.\n    await Promise.all(mechanisms.map((m) => m.erase()));\n\n    // If we were erasing temporary instances, destroy them, too.\n    if (!alreadyInitialized) {\n      await Promise.all(mechanisms.map((m) => m.destroy()));\n    }\n  }\n\n  /**\n   * Register a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name\n   * @param {function():shaka.extern.StorageMechanism} factory\n   * @export\n   */\n  static register(name, factory) {\n    shaka.offline.StorageMuxer.registry_.set(name, factory);\n  }\n\n\n  /**\n   * Unregister a storage mechanism for use with the default storage muxer. This\n   * will have no effect on any storage muxer already in main memory.\n   *\n   * @param {string} name The name that the storage mechanism was registered\n   *                      under.\n   * @export\n   */\n  static unregister(name) {\n    shaka.offline.StorageMuxer.registry_.delete(name);\n  }\n\n  /**\n   * Check if there is support for storage on this platform. It is assumed that\n   * if there are any mechanisms registered, it means that storage is supported\n   * on this platform. We do not check if the mechanisms have any cells.\n   *\n   * @return {boolean}\n   */\n  static support() {\n    const registry = shaka.offline.StorageMuxer.getRegistry_();\n    // Make sure that we will have SOME mechanisms created by creating a\n    // mechanism and immediately destroying it.\n    for (const create of registry.values()) {\n      const instance = create();\n\n      if (instance) {\n        instance.destroy();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Replace the mechanism map used by the muxer. This should only be used\n   * in testing.\n   *\n   * @param {Map.<string, function():shaka.extern.StorageMechanism>} map\n   */\n  static overrideSupport(map) {\n    shaka.offline.StorageMuxer.override_ = map;\n  }\n\n  /**\n   * Undo a previous call to |overrideSupport|.\n   */\n  static clearOverride() {\n    shaka.offline.StorageMuxer.override_ = null;\n  }\n\n  /**\n   * Get the registry. If the support has been disabled, this will always\n   * an empty registry. Reading should always be done via |getRegistry_|.\n   *\n   * @return {!Map.<string, function():shaka.extern.StorageMechanism>}\n   * @private\n   */\n  static getRegistry_() {\n    const override = shaka.offline.StorageMuxer.override_;\n    const registry = shaka.offline.StorageMuxer.registry_;\n\n    if (COMPILED) {\n      return registry;\n    } else {\n      return override || registry;\n    }\n  }\n};\n\n\n/**\n * @private {Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.override_ = null;\n\n\n/**\n * @private {!Map.<string, function():shaka.extern.StorageMechanism>}\n */\nshaka.offline.StorageMuxer.registry_ = new Map();\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.StorageMechanism');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.indexeddb.EmeSessionStorageCell');\ngoog.require('shaka.offline.indexeddb.V1StorageCell');\ngoog.require('shaka.offline.indexeddb.V2StorageCell');\ngoog.require('shaka.offline.indexeddb.V5StorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.Timer');\n\n\n/**\n * A storage mechanism to manage storage cells for an indexed db instance.\n * The cells are just for interacting with the stores that are found in the\n * database instance. The mechanism is responsible for creating new stores\n * when opening the database. If the database is too old of a version, a\n * cell will be added for the old stores but the cell won't support add\n * operations. The mechanism will create the new versions of the stores and\n * will allow add operations for those stores.\n *\n * @implements {shaka.extern.StorageMechanism}\n */\nshaka.offline.indexeddb.StorageMechanism = class {\n  /** */\n  constructor() {\n    /** @private {IDBDatabase} */\n    this.db_ = null;\n\n    /** @private {shaka.extern.StorageCell} */\n    this.v1_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v2_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v3_ = null;\n    /** @private {shaka.extern.StorageCell} */\n    this.v5_ = null;\n    /** @private {shaka.extern.EmeSessionStorageCell} */\n    this.sessions_ = null;\n  }\n\n  /**\n   * @override\n   */\n  init() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n    const version = shaka.offline.indexeddb.StorageMechanism.VERSION;\n\n    const p = new shaka.util.PublicPromise();\n\n    // Add a timeout mechanism, for the (rare?) case where no callbacks are\n    // called at all, so that this method doesn't hang forever.\n    let timedOut = false;\n    const timeOutTimer = new shaka.util.Timer(() => {\n      timedOut = true;\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_INIT_TIMED_OUT));\n    });\n    timeOutTimer.tickAfter(2);\n\n    const open = window.indexedDB.open(name, version);\n    open.onsuccess = (event) => {\n      if (timedOut) {\n        // Too late, we have already given up on opening the storage mechanism.\n        return;\n      }\n      const db = open.result;\n      this.db_ = db;\n      this.v1_ = shaka.offline.indexeddb.StorageMechanism.createV1_(db);\n      this.v2_ = shaka.offline.indexeddb.StorageMechanism.createV2_(db);\n      this.v3_ = shaka.offline.indexeddb.StorageMechanism.createV3_(db);\n      // NOTE: V4 of the database was when we introduced a special table to\n      // store EME session IDs.  It has no separate storage cell, so we skip to\n      // V5.\n      this.v5_ = shaka.offline.indexeddb.StorageMechanism.createV5_(db);\n      this.sessions_ =\n          shaka.offline.indexeddb.StorageMechanism.createEmeSessionCell_(db);\n      timeOutTimer.stop();\n      p.resolve();\n    };\n    open.onupgradeneeded = (event) => {\n      // Add object stores for the latest version only.\n      this.createStores_(open.result);\n    };\n    open.onerror = (event) => {\n      if (timedOut) {\n        // Too late, we have already given up on opening the storage mechanism.\n        return;\n      }\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          open.error));\n      timeOutTimer.stop();\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n\n  /**\n   * @override\n   */\n  async destroy() {\n    if (this.v1_) {\n      await this.v1_.destroy();\n    }\n    if (this.v2_) {\n      await this.v2_.destroy();\n    }\n    if (this.v3_) {\n      await this.v3_.destroy();\n    }\n    if (this.v5_) {\n      await this.v5_.destroy();\n    }\n    if (this.sessions_) {\n      await this.sessions_.destroy();\n    }\n\n    // If we were never initialized, then |db_| will still be null.\n    if (this.db_) {\n      this.db_.close();\n    }\n  }\n\n  /**\n   * @override\n   */\n  getCells() {\n    const map = new Map();\n\n    if (this.v1_) {\n      map.set('v1', this.v1_);\n    }\n    if (this.v2_) {\n      map.set('v2', this.v2_);\n    }\n    if (this.v3_) {\n      map.set('v3', this.v3_);\n    }\n    if (this.v5_) {\n      map.set('v5', this.v5_);\n    }\n\n    return map;\n  }\n\n  /**\n   * @override\n   */\n  getEmeSessionCell() {\n    goog.asserts.assert(this.sessions_, 'Cannot be destroyed.');\n    return this.sessions_;\n  }\n\n  /**\n   * @override\n   */\n  async erase() {\n    // Not all cells may have been created, so only destroy the ones that\n    // were created.\n    if (this.v1_) {\n      await this.v1_.destroy();\n    }\n    if (this.v2_) {\n      await this.v2_.destroy();\n    }\n    if (this.v3_) {\n      await this.v3_.destroy();\n    }\n    if (this.v5_) {\n      await this.v5_.destroy();\n    }\n\n    // |db_| will only be null if the muxer was not initialized. We need to\n    // close the connection in order delete the database without it being\n    // blocked.\n    if (this.db_) {\n      this.db_.close();\n    }\n\n    await shaka.offline.indexeddb.StorageMechanism.deleteAll_();\n\n    // Reset before initializing.\n    this.db_ = null;\n    this.v1_ = null;\n    this.v2_ = null;\n    this.v3_ = null;\n    this.v5_ = null;\n\n    await this.init();\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV1_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V1_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V1_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v1 idb storage cell');\n\n      return new shaka.offline.indexeddb.V1StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV2_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V2_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V2_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v2 idb storage cell');\n\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV3_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V3_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V3_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v3 idb storage cell');\n\n      // Version 3 uses the same structure as version 2, so we can use the same\n      // cells but it can support new entries.\n      return new shaka.offline.indexeddb.V2StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.StorageCell}\n   * @private\n   */\n  static createV5_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const segmentStore = StorageMechanism.V5_SEGMENT_STORE;\n    const manifestStore = StorageMechanism.V5_MANIFEST_STORE;\n    const stores = db.objectStoreNames;\n    if (stores.contains(manifestStore) && stores.contains(segmentStore)) {\n      shaka.log.debug('Mounting v5 idb storage cell');\n\n      return new shaka.offline.indexeddb.V5StorageCell(\n          db,\n          segmentStore,\n          manifestStore);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @return {shaka.extern.EmeSessionStorageCell}\n   * @private\n   */\n  static createEmeSessionCell_(db) {\n    const StorageMechanism = shaka.offline.indexeddb.StorageMechanism;\n    const store = StorageMechanism.SESSION_ID_STORE;\n    if (db.objectStoreNames.contains(store)) {\n      shaka.log.debug('Mounting session ID idb storage cell');\n      return new shaka.offline.indexeddb.EmeSessionStorageCell(db, store);\n    }\n    return null;\n  }\n\n  /**\n   * @param {!IDBDatabase} db\n   * @private\n   */\n  createStores_(db) {\n    const storeNames = [\n      shaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE,\n      shaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE,\n      shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE,\n    ];\n\n    for (const name of storeNames) {\n      if (!db.objectStoreNames.contains(name)) {\n        db.createObjectStore(name, {autoIncrement: true});\n      }\n    }\n  }\n\n  /**\n   * Delete the indexed db instance so that all stores are deleted and cleared.\n   * This will force the database to a like-new state next time it opens.\n   *\n   * @return {!Promise}\n   * @private\n   */\n  static deleteAll_() {\n    const name = shaka.offline.indexeddb.StorageMechanism.DB_NAME;\n\n    const p = new shaka.util.PublicPromise();\n\n    const del = window.indexedDB.deleteDatabase(name);\n    del.onblocked = (event) => {\n      shaka.log.warning('Deleting', name, 'is being blocked', event);\n    };\n    del.onsuccess = (event) => {\n      p.resolve();\n    };\n    del.onerror = (event) => {\n      p.reject(new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.INDEXED_DB_ERROR,\n          del.error));\n\n      // Firefox will raise an error on the main thread unless we stop it here.\n      event.preventDefault();\n    };\n\n    return p;\n  }\n};\n\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.DB_NAME = 'shaka_offline_db';\n/** @const {number} */\nshaka.offline.indexeddb.StorageMechanism.VERSION = 5;\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE = 'segment';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE = 'segment-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE = 'segment-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE = 'segment-v5';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE = 'manifest';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE = 'manifest-v2';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE = 'manifest-v3';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE = 'manifest-v5';\n/** @const {string} */\nshaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE = 'session-ids';\n\n\n// Since this may be called before the polyfills remove indexeddb support from\n// some platforms (looking at you Chromecast), we need to check for support\n// when we create the mechanism.\n//\n// Thankfully the storage muxer api allows us to return a null mechanism\n// to indicate that the mechanism is not supported on this platform.\nshaka.offline.StorageMuxer.register(\n    'idb',\n    () => {\n      // Offline storage is not supported on the Chromecast or Xbox One\n      // platforms.\n      if (shaka.util.Platform.isChromecast() ||\n          shaka.util.Platform.isXboxOne()) {\n        return null;\n      }\n      // Offline storage requires the IndexedDB API.\n      if (!window.indexedDB) {\n        return null;\n      }\n      return new shaka.offline.indexeddb.StorageMechanism();\n    });\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V1StorageCell');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.ManifestParserUtils');\ngoog.require('shaka.util.PeriodCombiner');\ngoog.require('shaka.util.PublicPromise');\n\n\n/**\n * The V1StorageCell is for all stores that follow the shaka.externs V1 offline\n * types, introduced in Shaka Player v2.0 and deprecated in v2.3.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V1StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /** @override */\n  async updateManifestExpiration(key, newExpiration) {\n    const op = this.connection_.startReadWriteOperation(this.manifestStore_);\n\n    /** @type {IDBObjectStore} */\n    const store = op.store();\n\n    /** @type {!shaka.util.PublicPromise} */\n    const p = new shaka.util.PublicPromise();\n\n    store.get(key).onsuccess = (event) => {\n      // Make sure a defined value was found. Indexeddb treats \"no value found\"\n      // as a success with an undefined result.\n      const manifest = /** @type {shaka.extern.ManifestDBV1} */(\n        event.target.result);\n\n      // Indexeddb does not fail when you get a value that is not in the\n      // database. It will return an undefined value. However, we expect\n      // the value to never be null, so something is wrong if we get a\n      // falsey value.\n      if (manifest) {\n        // Since this store's scheme uses in-line keys, we don't specify the key\n        // with |put|.  This difference is why we must override the base class.\n        goog.asserts.assert(\n            manifest.key == key,\n            'With in-line keys, the keys should match');\n\n        manifest.expiration = newExpiration;\n        store.put(manifest);\n\n        p.resolve();\n      } else {\n        p.reject(new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.KEY_NOT_FOUND,\n            'Could not find values for ' + key));\n      }\n    };\n\n    await Promise.all([op.promise(), p]);\n  }\n\n  /**\n   * @override\n   * @param {shaka.extern.ManifestDBV1} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   */\n  async convertManifest(old) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    const streamsPerPeriod = [];\n\n    for (let i = 0; i < old.periods.length; ++i) {\n      // The last period ends at the end of the presentation.\n      const periodEnd = i == old.periods.length - 1 ?\n          old.duration : old.periods[i + 1].startTime;\n      const duration = periodEnd - old.periods[i].startTime;\n      const streams = V1StorageCell.convertPeriod_(old.periods[i], duration);\n\n      streamsPerPeriod.push(streams);\n    }\n\n    const streams = await shaka.util.PeriodCombiner.combineDbStreams(\n        streamsPerPeriod);\n\n    return {\n      creationTime: 0,\n      originalManifestUri: old.originalManifestUri,\n      duration: old.duration,\n      size: old.size,\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      streams,\n      sessionIds: old.sessionIds,\n      drmInfo: old.drmInfo,\n      appMetadata: old.appMetadata,\n      sequenceMode: false,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.PeriodDBV1} old\n   * @param {number} periodDuration\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  static convertPeriod_(old, periodDuration) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // In the case that this is really old (like really old, like dinosaurs\n    // roaming the Earth old) there may be no variants, so we need to add those.\n    V1StorageCell.fillMissingVariants_(old);\n\n    for (const stream of old.streams) {\n      const message = 'After filling in missing variants, ' +\n                      'each stream should have variant ids';\n      goog.asserts.assert(stream.variantIds, message);\n    }\n\n    return old.streams.map((stream) => V1StorageCell.convertStream_(\n        stream, old.startTime, periodDuration));\n  }\n\n  /**\n   * @param {shaka.extern.StreamDBV1} old\n   * @param {number} periodStart\n   * @param {number} periodDuration\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  static convertStream_(old, periodStart, periodDuration) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    const initSegmentKey = old.initSegmentUri ?\n        V1StorageCell.getKeyFromSegmentUri_(old.initSegmentUri) : null;\n\n    // timestampOffset in the new format is the inverse of\n    // presentationTimeOffset in the old format.  Also, PTO did not include the\n    // period start, while TO does.\n    const timestampOffset = periodStart + old.presentationTimeOffset;\n\n    const appendWindowStart = periodStart;\n    const appendWindowEnd = periodStart + periodDuration;\n\n    return {\n      id: old.id,\n      originalId: null,\n      primary: old.primary,\n      type: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      pixelAspectRatio: undefined,\n      hdr: undefined,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      initSegmentKey: initSegmentKey,\n      encrypted: old.encrypted,\n      keyIds: new Set([old.keyId]),\n      segments: old.segments.map((segment) => V1StorageCell.convertSegment_(\n          segment, initSegmentKey, appendWindowStart, appendWindowEnd,\n          timestampOffset)),\n      variantIds: old.variantIds,\n      roles: [],\n      forced: false,\n      audioSamplingRate: null,\n      channelsCount: null,\n      spatialAudio: false,\n      closedCaptions: null,\n      tilesLayout: undefined,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.SegmentDBV1} old\n   * @param {?number} initSegmentKey\n   * @param {number} appendWindowStart\n   * @param {number} appendWindowEnd\n   * @param {number} timestampOffset\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  static convertSegment_(\n      old, initSegmentKey, appendWindowStart, appendWindowEnd,\n      timestampOffset) {\n    const V1StorageCell = shaka.offline.indexeddb.V1StorageCell;\n\n    // Since we don't want to use the uri anymore, we need to parse the key\n    // from it.\n    const dataKey = V1StorageCell.getKeyFromSegmentUri_(old.uri);\n\n    return {\n      startTime: appendWindowStart + old.startTime,\n      endTime: appendWindowStart + old.endTime,\n      dataKey,\n      initSegmentKey,\n      appendWindowStart,\n      appendWindowEnd,\n      timestampOffset,\n      tilesLayout: '',\n    };\n  }\n\n  /**\n   * @override\n   * @param {shaka.extern.SegmentDataDBV1} old\n   * @return {shaka.extern.SegmentDataDB}\n   */\n  convertSegmentData(old) {\n    return {data: old.data};\n  }\n\n  /**\n   * @param {string} uri\n   * @return {number}\n   * @private\n   */\n  static getKeyFromSegmentUri_(uri) {\n    let parts = null;\n\n    // Try parsing the uri as the original Shaka Player 2.0 uri.\n    parts = /^offline:[0-9]+\\/[0-9]+\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    // Just before Shaka Player 2.3 the uri format was changed to remove some\n    // of the un-used information from the uri and make the segment uri and\n    // manifest uri follow a similar format. However the old storage system\n    // was still in place, so it is possible for Storage V1 Cells to have\n    // Storage V2 uris.\n    parts = /^offline:segment\\/([0-9]+)$/.exec(uri);\n    if (parts) {\n      return Number(parts[1]);\n    }\n\n    throw new shaka.util.Error(\n        shaka.util.Error.Severity.CRITICAL,\n        shaka.util.Error.Category.STORAGE,\n        shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n        'Could not parse uri ' + uri);\n  }\n\n  /**\n   * Take a period and check if the streams need to have variants generated.\n   * Before Shaka Player moved to its variants model, there were no variants.\n   * This will fill missing variants into the given object.\n   *\n   * @param {shaka.extern.PeriodDBV1} period\n   * @private\n   */\n  static fillMissingVariants_(period) {\n    const AUDIO = shaka.util.ManifestParserUtils.ContentType.AUDIO;\n    const VIDEO = shaka.util.ManifestParserUtils.ContentType.VIDEO;\n\n    // There are three cases:\n    //  1. All streams' variant ids are null\n    //  2. All streams' variant ids are non-null\n    //  3. Some streams' variant ids are null and other are non-null\n    // Case 3 is invalid and should never happen in production.\n\n    const audio = period.streams.filter((s) => s.contentType == AUDIO);\n    const video = period.streams.filter((s) => s.contentType == VIDEO);\n\n    // Case 2 - There is nothing we need to do, so let's just get out of here.\n    if (audio.every((s) => s.variantIds) && video.every((s) => s.variantIds)) {\n      return;\n    }\n\n    // Case 3... We don't want to be in case three.\n    goog.asserts.assert(\n        audio.every((s) => !s.variantIds),\n        'Some audio streams have variant ids and some do not.');\n    goog.asserts.assert(\n        video.every((s) => !s.variantIds),\n        'Some video streams have variant ids and some do not.');\n\n    // Case 1 - Populate all the variant ids (putting us back to case 2).\n    // Since all the variant ids are null, we need to first make them into\n    // valid arrays.\n    for (const s of audio) {\n      s.variantIds = [];\n    }\n    for (const s of video) {\n      s.variantIds = [];\n    }\n\n    let nextId = 0;\n\n    // It is not possible in Shaka Player's pre-variant world to have audio-only\n    // and video-only content mixed in with audio-video content. So we can\n    // assume that there is only audio-only or video-only if one group is empty.\n\n    // Everything is video-only content - so each video stream gets to be its\n    // own variant.\n    if (video.length && !audio.length) {\n      shaka.log.debug('Found video-only content. Creating variants for video.');\n      const variantId = nextId++;\n      for (const s of video) {\n        s.variantIds.push(variantId);\n      }\n    }\n\n    // Everything is audio-only content - so each audio stream gets to be its\n    // own variant.\n    if (!video.length && audio.length) {\n      shaka.log.debug('Found audio-only content. Creating variants for audio.');\n      const variantId = nextId++;\n      for (const s of audio) {\n        s.variantIds.push(variantId);\n      }\n    }\n\n    // Everything is audio-video content.\n    if (video.length && audio.length) {\n      shaka.log.debug('Found audio-video content. Creating variants.');\n      for (const a of audio) {\n        for (const v of video) {\n          const variantId = nextId++;\n          a.variantIds.push(variantId);\n          v.variantIds.push(variantId);\n        }\n      }\n    }\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V2StorageCell');\n\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\ngoog.require('shaka.util.PeriodCombiner');\n\n\n/**\n * The V2StorageCell is for all stores that follow the shaka.externs V2 and V3\n * offline types.  V2 was introduced in Shaka Player v2.3.0 and quickly\n * replaced with V3 in Shaka Player v2.3.2.  V3 was then deprecated in v3.0.\n *\n * Upgrading from V1 to V2 initially broke the database in a way that prevented\n * adding new records.  The problem was with the upgrade process, not with the\n * database format.  Once database upgrades were removed, we increased the\n * database version to V3 and marked V2 as read-only.  Therefore, V2 and V3\n * databases can both be read by this cell.\n *\n * The manifest and segment stores didn't change in database V4, but a separate\n * table for session IDs was added.  So this cell also covers DB V4.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V2StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /**\n   * @override\n   * @param {shaka.extern.ManifestDBV2} old\n   * @return {!Promise.<shaka.extern.ManifestDB>}\n   */\n  async convertManifest(old) {\n    const streamsPerPeriod = [];\n\n    for (let i = 0; i < old.periods.length; ++i) {\n      // The last period ends at the end of the presentation.\n      const periodEnd = i == old.periods.length - 1 ?\n          old.duration : old.periods[i + 1].startTime;\n      const duration = periodEnd - old.periods[i].startTime;\n      const streams = this.convertPeriod_(old.periods[i], duration);\n\n      streamsPerPeriod.push(streams);\n    }\n\n    const streams = await shaka.util.PeriodCombiner.combineDbStreams(\n        streamsPerPeriod);\n\n    return {\n      appMetadata: old.appMetadata,\n      creationTime: 0,\n      drmInfo: old.drmInfo,\n      duration: old.duration,\n      // JSON serialization turns Infinity into null, so turn it back now.\n      expiration: old.expiration == null ? Infinity : old.expiration,\n      originalManifestUri: old.originalManifestUri,\n      sessionIds: old.sessionIds,\n      size: old.size,\n      streams,\n      sequenceMode: false,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.PeriodDBV2} period\n   * @param {number} periodDuration\n   * @return {!Array.<shaka.extern.StreamDB>}\n   * @private\n   */\n  convertPeriod_(period, periodDuration) {\n    const streams = [];\n    for (const stream of period.streams) {\n      // The v4 version of the database as written by v2.5.0 - v2.5.9 might have\n      // been corrupted slightly.  A bug caused the stream metadata from all\n      // periods to be written to each period.  This was corrected in v2.5.10.\n      // To fix this, we can identify the extra streams by their lack of\n      // variantIds and skip them.\n      if (stream.variantIds.length == 0) {\n        continue;\n      }\n\n      streams.push(this.convertStream_(\n          stream, period.startTime, period.startTime + periodDuration));\n    }\n    return streams;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDBV2} old\n   * @param {number} periodStart\n   * @param {number} periodEnd\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  convertStream_(old, periodStart, periodEnd) {\n    return {\n      id: old.id,\n      originalId: old.originalId,\n      primary: old.primary,\n      type: old.contentType,\n      mimeType: old.mimeType,\n      codecs: old.codecs,\n      frameRate: old.frameRate,\n      pixelAspectRatio: old.pixelAspectRatio,\n      hdr: undefined,\n      kind: old.kind,\n      language: old.language,\n      label: old.label,\n      width: old.width,\n      height: old.height,\n      encrypted: old.encrypted,\n      keyIds: new Set([old.keyId]),\n      segments: old.segments.map((segment) =>\n        this.convertSegment_(\n            segment, old.initSegmentKey, periodStart, periodEnd,\n            old.presentationTimeOffset)),\n      variantIds: old.variantIds,\n      roles: [],\n      forced: false,\n      audioSamplingRate: null,\n      channelsCount: null,\n      spatialAudio: false,\n      closedCaptions: null,\n      tilesLayout: undefined,\n    };\n  }\n\n  /**\n   * @param {shaka.extern.SegmentDBV2} old\n   * @param {?number} initSegmentKey\n   * @param {number} periodStart\n   * @param {number} periodEnd\n   * @param {number} presentationTimeOffset\n   * @return {shaka.extern.SegmentDB}\n   * @private\n   */\n  convertSegment_(\n      old, initSegmentKey, periodStart, periodEnd, presentationTimeOffset) {\n    const timestampOffset = periodStart - presentationTimeOffset;\n\n    return {\n      startTime: periodStart + old.startTime,\n      endTime: periodStart + old.endTime,\n      initSegmentKey,\n      appendWindowStart: periodStart,\n      appendWindowEnd: periodEnd,\n      timestampOffset,\n      dataKey: old.dataKey,\n      tilesLayout: '',\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.indexeddb.V5StorageCell');\n\ngoog.require('shaka.offline.indexeddb.BaseStorageCell');\n\n\n/**\n * The V5StorageCell is for all stores that follow the shaka.externs V5 offline\n * types introduced in v3.0.\n *\n * @implements {shaka.extern.StorageCell}\n */\nshaka.offline.indexeddb.V5StorageCell = class\n  extends shaka.offline.indexeddb.BaseStorageCell {\n  /** @override */\n  hasFixedKeySpace() {\n    // This makes the cell read-write.\n    return false;\n  }\n\n  /** @override */\n  addSegments(segments) {\n    return this.add(this.segmentStore_, segments);\n  }\n\n  /** @override */\n  addManifests(manifests) {\n    return this.add(this.manifestStore_, manifests);\n  }\n\n  /** @override */\n  updateManifest(key, manifest) {\n    return this.updateManifestImplementation(key, manifest);\n  }\n\n  /** @override */\n  convertManifest(old) {\n    // JSON serialization turns Infinity into null, so turn it back now.\n    if (old.expiration == null) {\n      old.expiration = Infinity;\n    }\n    return Promise.resolve(/** @type {shaka.extern.ManifestDB} */(old));\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineUri');\n\n\n/**\n * The OfflineUri class contains all the components that make up the offline\n * uri. The components are:\n *    TYPE: Used to know what type of data the uri points to. It can either\n *          be \"manifest\" or \"segment\".\n *    MECHANISM: The name of the mechanism that manages the storage cell that\n *               holds the data.\n *    CELL: The name of the cell that holds the data.\n *    KEY: The key that the data is stored under in the cell.\n */\nshaka.offline.OfflineUri = class {\n  /**\n   * @param {string} type\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   */\n  constructor(type, mechanism, cell, key) {\n    /**\n     * @private {string}\n     * @const\n     */\n    this.type_ = type;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.mechanism_ = mechanism;\n    /**\n     * @private {string}\n     * @const\n     */\n    this.cell_ = cell;\n    /**\n     * @private {number}\n     * @const\n     */\n    this.key_ = key;\n\n    /**\n     * @private {string}\n     * @const\n     */\n    this.asString_ = [\n      'offline:', type, '/', mechanism, '/', cell, '/', key,\n    ].join('');\n  }\n\n  /** @return {boolean} */\n  isManifest() { return this.type_ == 'manifest'; }\n\n  /** @return {boolean} */\n  isSegment() { return this.type_ == 'segment'; }\n\n  /** @return {string} */\n  mechanism() { return this.mechanism_; }\n\n  /** @return {string} */\n  cell() { return this.cell_; }\n\n  /** @return {number} */\n  key() { return this.key_; }\n\n  /** @override */\n  toString() { return this.asString_; }\n\n  /**\n   * @param {string} uri\n   * @return {?shaka.offline.OfflineUri}\n   */\n  static parse(uri) {\n    const parts = /^offline:([a-z]+)\\/([^/]+)\\/([^/]+)\\/([0-9]+)$/.exec(uri);\n    if (parts == null) {\n      return null;\n    }\n\n    const type = parts[1];\n    if (type != 'manifest' && type != 'segment') {\n      return null;\n    }\n\n    const mechanism = parts[2];\n    if (!mechanism) {\n      return null;\n    }\n\n    const cell = parts[3];\n    if (!cell) {\n      return null;\n    }\n\n    const key = Number(parts[4]);\n    if (type == null) {\n      return null;\n    }\n\n    return new shaka.offline.OfflineUri(type, mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static manifest(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('manifest', mechanism, cell, key);\n  }\n\n  /**\n   * @param {string} mechanism\n   * @param {string} cell\n   * @param {number} key\n   * @return {!shaka.offline.OfflineUri}\n   */\n  static segment(mechanism, cell, key) {\n    return new shaka.offline.OfflineUri('segment', mechanism, cell, key);\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.ManifestConverter');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.media.InitSegmentReference');\ngoog.require('shaka.media.PresentationTimeline');\ngoog.require('shaka.media.SegmentIndex');\ngoog.require('shaka.media.SegmentReference');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.ManifestParserUtils');\n\n\n/**\n * Utility class for converting database manifest objects back to normal\n * player-ready objects. Used by the offline system to convert on-disk\n * objects back to the in-memory objects.\n */\nshaka.offline.ManifestConverter = class {\n  /**\n   * Create a new manifest converter. Need to know the mechanism and cell that\n   * the manifest is from so that all segments paths can be created.\n   *\n   * @param {string} mechanism\n   * @param {string} cell\n   */\n  constructor(mechanism, cell) {\n    /** @private {string} */\n    this.mechanism_ = mechanism;\n\n    /** @private {string} */\n    this.cell_ = cell;\n  }\n\n  /**\n   * Convert a |shaka.extern.ManifestDB| object to a |shaka.extern.Manifest|\n   * object.\n   *\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.Manifest}\n   */\n  fromManifestDB(manifestDB) {\n    const timeline = new shaka.media.PresentationTimeline(null, 0);\n    timeline.setDuration(manifestDB.duration);\n\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    const audioStreams =\n        manifestDB.streams.filter((streamDB) => this.isAudio_(streamDB));\n\n    /** @type {!Array.<shaka.extern.StreamDB>} */\n    const videoStreams =\n        manifestDB.streams.filter((streamDB) => this.isVideo_(streamDB));\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variants = this.createVariants(audioStreams, videoStreams, timeline);\n\n    /** @type {!Array.<shaka.extern.Stream>} */\n    const textStreams =\n        manifestDB.streams.filter((streamDB) => this.isText_(streamDB))\n            .map((streamDB) => this.fromStreamDB_(streamDB, timeline));\n\n    /** @type {!Array.<shaka.extern.Stream>} */\n    const imageStreams =\n        manifestDB.streams.filter((streamDB) => this.isImage_(streamDB))\n            .map((streamDB) => this.fromStreamDB_(streamDB, timeline));\n\n    const drmInfos = manifestDB.drmInfo ? [manifestDB.drmInfo] : [];\n    if (manifestDB.drmInfo) {\n      for (const variant of variants.values()) {\n        if (variant.audio && variant.audio.encrypted) {\n          variant.audio.drmInfos = drmInfos;\n        }\n        if (variant.video && variant.video.encrypted) {\n          variant.video.drmInfos = drmInfos;\n        }\n      }\n    }\n\n    return {\n      presentationTimeline: timeline,\n      minBufferTime: 2,\n      offlineSessionIds: manifestDB.sessionIds,\n      variants: Array.from(variants.values()),\n      textStreams: textStreams,\n      imageStreams: imageStreams,\n      sequenceMode: manifestDB.sequenceMode || false,\n    };\n  }\n\n  /**\n   * Recreates Variants from audio and video StreamDB collections.\n   *\n   * @param {!Array.<!shaka.extern.StreamDB>} audios\n   * @param {!Array.<!shaka.extern.StreamDB>} videos\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {!Map.<number, !shaka.extern.Variant>}\n   */\n  createVariants(audios, videos, timeline) {\n    // Get all the variant ids from all audio and video streams.\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    for (const streamDB of audios) {\n      for (const id of streamDB.variantIds) {\n        variantIds.add(id);\n      }\n    }\n    for (const streamDB of videos) {\n      for (const id of streamDB.variantIds) {\n        variantIds.add(id);\n      }\n    }\n\n    /** @type {!Map.<number, shaka.extern.Variant>} */\n    const variantMap = new Map();\n    for (const id of variantIds) {\n      variantMap.set(id, this.createEmptyVariant_(id));\n    }\n\n    // Assign each audio stream to its variants.\n    for (const audio of audios) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(audio, timeline);\n\n      for (const variantId of audio.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.audio, 'A variant should only have one audio stream');\n\n        variant.language = stream.language;\n        variant.primary = variant.primary || stream.primary;\n        variant.audio = stream;\n      }\n    }\n\n    // Assign each video stream to its variants.\n    for (const video of videos) {\n      /** @type {shaka.extern.Stream} */\n      const stream = this.fromStreamDB_(video, timeline);\n\n      for (const variantId of video.variantIds) {\n        const variant = variantMap.get(variantId);\n\n        goog.asserts.assert(\n            !variant.video, 'A variant should only have one video stream');\n\n        variant.primary = variant.primary || stream.primary;\n        variant.video = stream;\n      }\n    }\n\n    return variantMap;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @param {shaka.media.PresentationTimeline} timeline\n   * @return {shaka.extern.Stream}\n   * @private\n   */\n  fromStreamDB_(streamDB, timeline) {\n    /** @type {!Array.<!shaka.media.SegmentReference>} */\n    const segments = streamDB.segments.map(\n        (segment, index) => this.fromSegmentDB_(index, segment));\n\n    timeline.notifySegments(segments);\n\n    /** @type {!shaka.media.SegmentIndex} */\n    const segmentIndex = new shaka.media.SegmentIndex(segments);\n\n    /** @type {shaka.extern.Stream} */\n    const stream = {\n      id: streamDB.id,\n      originalId: streamDB.originalId,\n      createSegmentIndex: () => Promise.resolve(),\n      segmentIndex,\n      mimeType: streamDB.mimeType,\n      codecs: streamDB.codecs,\n      width: streamDB.width || undefined,\n      height: streamDB.height || undefined,\n      frameRate: streamDB.frameRate,\n      pixelAspectRatio: streamDB.pixelAspectRatio,\n      hdr: streamDB.hdr,\n      kind: streamDB.kind,\n      encrypted: streamDB.encrypted,\n      drmInfos: [],\n      keyIds: streamDB.keyIds,\n      language: streamDB.language,\n      label: streamDB.label,\n      type: streamDB.type,\n      primary: streamDB.primary,\n      trickModeVideo: null,\n      emsgSchemeIdUris: null,\n      roles: streamDB.roles,\n      forced: streamDB.forced,\n      channelsCount: streamDB.channelsCount,\n      audioSamplingRate: streamDB.audioSamplingRate,\n      spatialAudio: streamDB.spatialAudio,\n      closedCaptions: streamDB.closedCaptions,\n      tilesLayout: streamDB.tilesLayout,\n    };\n\n    return stream;\n  }\n\n  /**\n   * @param {number} index\n   * @param {shaka.extern.SegmentDB} segmentDB\n   * @return {!shaka.media.SegmentReference}\n   * @private\n   */\n  fromSegmentDB_(index, segmentDB) {\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, segmentDB.dataKey);\n\n    const initSegmentReference = segmentDB.initSegmentKey != null ?\n        this.fromInitSegmentDB_(segmentDB.initSegmentKey) : null;\n\n    return new shaka.media.SegmentReference(\n        segmentDB.startTime,\n        segmentDB.endTime,\n        () => [uri.toString()],\n        /* startByte= */ 0,\n        /* endByte= */ null,\n        initSegmentReference,\n        segmentDB.timestampOffset,\n        segmentDB.appendWindowStart,\n        segmentDB.appendWindowEnd,\n        /* partialReferences= */ [],\n        segmentDB.tilesLayout || '');\n  }\n\n  /**\n   * @param {number} key\n   * @return {!shaka.media.InitSegmentReference}\n   * @private\n   */\n  fromInitSegmentDB_(key) {\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = shaka.offline.OfflineUri.segment(\n        this.mechanism_, this.cell_, key);\n\n    return new shaka.media.InitSegmentReference(\n        () => [uri.toString()],\n        /* startBytes= */ 0,\n        /* endBytes= */ null );\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isAudio_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.AUDIO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isVideo_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.VIDEO;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isText_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.TEXT;\n  }\n\n  /**\n   * @param {shaka.extern.StreamDB} streamDB\n   * @return {boolean}\n   * @private\n   */\n  isImage_(streamDB) {\n    const ContentType = shaka.util.ManifestParserUtils.ContentType;\n    return streamDB.type == ContentType.IMAGE;\n  }\n\n  /**\n   * Creates an empty Variant.\n   *\n   * @param {number} id\n   * @return {!shaka.extern.Variant}\n   * @private\n   */\n  createEmptyVariant_(id) {\n    return {\n      id: id,\n      language: '',\n      disabledUntilTime: 0,\n      primary: false,\n      audio: null,\n      video: null,\n      bandwidth: 0,\n      allowedByApplication: true,\n      allowedByKeySystem: true,\n      decodingInfos: [],\n    };\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.OfflineScheme');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.Error');\n\n\n/**\n * @summary A plugin that handles requests for offline content.\n * @export\n */\nshaka.offline.OfflineScheme = class {\n  /**\n   * @param {string} uri\n   * @param {shaka.extern.Request} request\n   * @param {shaka.net.NetworkingEngine.RequestType} requestType\n   * @param {shaka.extern.ProgressUpdated} progressUpdated Called when a\n   *   progress event happened.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @export\n   */\n  static plugin(uri, request, requestType, progressUpdated) {\n    const offlineUri = shaka.offline.OfflineUri.parse(uri);\n\n    if (offlineUri && offlineUri.isManifest()) {\n      return shaka.offline.OfflineScheme.getManifest_(uri);\n    }\n\n    if (offlineUri && offlineUri.isSegment()) {\n      return shaka.offline.OfflineScheme.getSegment_(\n          offlineUri.key(), offlineUri);\n    }\n\n    return shaka.util.AbortableOperation.failed(\n        new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.NETWORK,\n            shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n            uri));\n  }\n\n  /**\n   * @param {string} uri\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @private\n   */\n  static getManifest_(uri) {\n    /** @type {shaka.extern.Response} */\n    const response = {\n      uri: uri,\n      originalUri: uri,\n      data: new ArrayBuffer(0),\n      headers: {'content-type': 'application/x-offline-manifest'},\n    };\n\n    return shaka.util.AbortableOperation.completed(response);\n  }\n\n  /**\n   * @param {number} id\n   * @param {!shaka.offline.OfflineUri} uri\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.Response>}\n   * @private\n   */\n  static getSegment_(id, uri) {\n    goog.asserts.assert(\n        uri.isSegment(),\n        'Only segment uri\\'s should be given to getSegment');\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    return shaka.util.AbortableOperation.completed(undefined)\n        .chain(() => muxer.init())\n        .chain(() => muxer.getCell(uri.mechanism(), uri.cell()))\n        .chain((cell) => cell.getSegments([uri.key()]))\n        .chain((segments) => {\n          const segment = segments[0];\n\n          return {\n            uri: uri,\n            data: segment.data,\n            headers: {},\n          };\n        })\n        .finally(() => muxer.destroy());\n  }\n};\n\nshaka.net.NetworkingEngine.registerScheme(\n    'offline', shaka.offline.OfflineScheme.plugin);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.SessionDeleter');\n\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.requireType('shaka.net.NetworkingEngine');\n\n\n/**\n * Contains a utility method to delete persistent EME sessions.\n */\nshaka.offline.SessionDeleter = class {\n  /**\n   * Deletes the given sessions.  This never fails and instead logs the error.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Promise.<!Array.<string>>} The session IDs that were deleted.\n   */\n  async delete(config, netEngine, sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    let deleted = [];\n    for (const bucket of SessionDeleter.createBuckets_(sessions)) {\n      // Run these sequentially to avoid creating multiple CDM instances at one\n      // time.  Some embedded platforms may not support multiples.\n      const p = this.doDelete_(config, netEngine, bucket);\n      const cur = await p;  // eslint-disable-line no-await-in-loop\n      deleted = deleted.concat(cur);\n    }\n    return deleted;\n  }\n\n\n  /**\n   * Performs the deletion of the given session IDs.\n   *\n   * @param {shaka.extern.DrmConfiguration} config\n   * @param {!shaka.net.NetworkingEngine} netEngine\n   * @param {shaka.offline.SessionDeleter.Bucket_} bucket\n   * @return {!Promise.<!Array.<string>>} The sessions that were deleted\n   * @private\n   */\n  async doDelete_(config, netEngine, bucket) {\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: netEngine,\n      onError: () => {},\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    try {\n      drmEngine.configure(config);\n      await drmEngine.initForRemoval(\n          bucket.info.keySystem, bucket.info.licenseUri,\n          bucket.info.serverCertificate,\n          bucket.info.audioCapabilities, bucket.info.videoCapabilities);\n    } catch (e) {\n      shaka.log.warning('Error initializing EME', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    try {\n      await drmEngine.setServerCertificate();\n    } catch (e) {\n      shaka.log.warning('Error setting server certificate', e);\n      await drmEngine.destroy();\n      return [];\n    }\n\n    /** @type {!Array.<string>} */\n    const sessionIds = [];\n    await Promise.all(bucket.sessionIds.map(async (sessionId) => {\n      // This method is in a .map(), so this starts multiple removes at once,\n      // so this removes the sessions in parallel.\n      try {\n        await drmEngine.removeSession(sessionId);\n        sessionIds.push(sessionId);\n      } catch (e) {\n        shaka.log.warning('Error deleting offline session', e);\n      }\n    }));\n    await drmEngine.destroy();\n    return sessionIds;\n  }\n\n\n  /**\n   * Collects the given sessions into buckets that can be done at the same time.\n   * Since querying with different parameters can give us back different CDMs,\n   * we can't just use one CDM instance to delete everything.\n   *\n   * @param {!Array.<shaka.extern.EmeSessionDB>} sessions\n   * @return {!Array.<shaka.offline.SessionDeleter.Bucket_>}\n   * @private\n   */\n  static createBuckets_(sessions) {\n    const SessionDeleter = shaka.offline.SessionDeleter;\n\n    /** @type {!Array.<shaka.offline.SessionDeleter.Bucket_>} */\n    const ret = [];\n    for (const session of sessions) {\n      let found = false;\n      for (const bucket of ret) {\n        if (SessionDeleter.isCompatible_(bucket.info, session)) {\n          bucket.sessionIds.push(session.sessionId);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        ret.push({info: session, sessionIds: [session.sessionId]});\n      }\n    }\n\n    return ret;\n  }\n\n\n  /**\n   * Returns whether the given session infos are compatible with each other.\n   * @param {shaka.extern.EmeSessionDB} a\n   * @param {shaka.extern.EmeSessionDB} b\n   * @return {boolean}\n   * @private\n   */\n  static isCompatible_(a, b) {\n    const ArrayUtils = shaka.util.ArrayUtils;\n\n    // TODO: Add a way to change the license server in DrmEngine to avoid\n    // resetting EME for different license servers.\n    const comp = (x, y) =>\n      x.robustness == y.robustness && x.contentType == y.contentType;\n    return a.keySystem == b.keySystem && a.licenseUri == b.licenseUri &&\n        ArrayUtils.hasSameElements(\n            a.audioCapabilities, b.audioCapabilities, comp) &&\n        ArrayUtils.hasSameElements(\n            a.videoCapabilities, b.videoCapabilities, comp);\n  }\n};\n\n\n/**\n * @typedef {{\n *   info: shaka.extern.EmeSessionDB,\n *   sessionIds: !Array.<string>\n * }}\n */\nshaka.offline.SessionDeleter.Bucket_;\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StoredContentUtils');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.offline.ManifestConverter');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.util.StreamUtils');\n\n\n/**\n * A utility class used to create |shaka.extern.StoredContent| from different\n * types of input.\n */\nshaka.offline.StoredContentUtils = class {\n  /**\n   * @param {string} originalUri\n   * @param {shaka.extern.Manifest} manifest\n   * @param {number} size\n   * @param {!Object} metadata\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifest(originalUri, manifest, size, metadata) {\n    goog.asserts.assert(\n        manifest.variants.length,\n        'Cannot create stored content from manifest with no variants.');\n\n    /** @type {number} */\n    const duration = manifest.presentationTimeline.getDuration();\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const tracks = shaka.offline.StoredContentUtils.getTracks_(manifest);\n\n    /** @type {shaka.extern.StoredContent} */\n    const content = {\n      offlineUri: null,\n      originalManifestUri: originalUri,\n      duration: duration,\n      size: size,\n      // This expiration value is temporary and will be used in progress reports\n      // during the storage process.  The real value would have to come from\n      // DrmEngine.\n      expiration: Infinity,\n      tracks: tracks,\n      appMetadata: metadata,\n      isIncomplete: false,\n    };\n\n    return content;\n  }\n\n  /**\n   * @param {!shaka.offline.OfflineUri} offlineUri\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @return {shaka.extern.StoredContent}\n   */\n  static fromManifestDB(offlineUri, manifestDB) {\n    goog.asserts.assert(\n        manifestDB.streams.length,\n        'Cannot create stored content from manifestDB with no streams.');\n\n    const converter = new shaka.offline.ManifestConverter(\n        offlineUri.mechanism(), offlineUri.cell());\n\n    /** @type {shaka.extern.Manifest} */\n    const manifest = converter.fromManifestDB(manifestDB);\n\n    /** @type {!Object} */\n    const metadata = manifestDB.appMetadata || {};\n\n    /** @type {!Array.<shaka.extern.Track>} */\n    const tracks = shaka.offline.StoredContentUtils.getTracks_(manifest);\n\n    goog.asserts.assert(\n        manifestDB.expiration != null,\n        'Manifest expiration must be set by now!');\n\n    /** @type {shaka.extern.StoredContent} */\n    const content = {\n      offlineUri: offlineUri.toString(),\n      originalManifestUri: manifestDB.originalManifestUri,\n      duration: manifestDB.duration,\n      size: manifestDB.size,\n      expiration: manifestDB.expiration,\n      tracks: tracks,\n      appMetadata: metadata,\n      isIncomplete: (manifestDB.isIncomplete || false),\n    };\n\n    return content;\n  }\n\n  /**\n   * Gets track representations of all playable variants and all text streams.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @return {!Array.<shaka.extern.Track>}\n   * @private\n   */\n  static getTracks_(manifest) {\n    const StreamUtils = shaka.util.StreamUtils;\n\n    const tracks = [];\n\n    const variants = StreamUtils.getPlayableVariants(manifest.variants);\n    for (const variant of variants) {\n      tracks.push(StreamUtils.variantToTrack(variant));\n    }\n\n    const textStreams = manifest.textStreams;\n    for (const stream of textStreams) {\n      tracks.push(StreamUtils.textStreamToTrack(stream));\n    }\n\n    return tracks;\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.StreamBandwidthEstimator');\n\ngoog.require('shaka.log');\ngoog.requireType('shaka.media.SegmentReference');\n\n\n/**\n * A utility class to help estimate the size of streams based on stream and\n * variant bandwidths. This class's main purpose is to isolate the logic in\n * creating non-zero bandwidth estimates for all streams so that each stream\n * will have some influence over the progress of the download.\n */\nshaka.offline.StreamBandwidthEstimator = class {\n  /** */\n  constructor() {\n    /** @private {!Object.<number, number>} */\n    this.estimateByStreamId_ = {};\n  }\n\n  /**\n   * Add a new variant to the estimator. This will update the estimates for all\n   * streams in the variant.\n   *\n   * @param {shaka.extern.Variant} variant\n   */\n  addVariant(variant) {\n    // Three cases:\n    //  1 - Only Audio\n    //  2 - Only Video\n    //  3 - Audio and Video\n\n    const audio = variant.audio;\n    const video = variant.video;\n\n    // Case 1\n    if (audio && !video) {\n      const audioBitRate = audio.bandwidth || variant.bandwidth;\n      this.setBitrate_(audio.id, audioBitRate);\n    }\n\n    // Case 2\n    if (!audio && video) {\n      const videoBitRate = video.bandwidth || variant.bandwidth;\n      this.setBitrate_(video.id, videoBitRate);\n    }\n\n    // Case 3\n    if (audio && video) {\n      // Get the audio's bandwidth. If it is missing, default to our default\n      // audio bandwidth.\n      const audioBitRate =\n          audio.bandwidth ||\n          shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_;\n\n      // Get the video's bandwidth. If it is missing, use the variant bandwidth\n      // less the audio. If we get a negative bit rate, fall back to our\n      // default video bandwidth.\n      let videoBitRate = video.bandwidth || (variant.bandwidth - audioBitRate);\n      if (videoBitRate <= 0) {\n        shaka.log.warning(\n            'Audio bit rate consumes variants bandwidth. Setting video ' +\n            'bandwidth to match variant\\'s bandwidth.');\n        videoBitRate = variant.bandwidth;\n      }\n\n      this.setBitrate_(audio.id, audioBitRate);\n      this.setBitrate_(video.id, videoBitRate);\n    }\n  }\n\n  /**\n   * @param {number} stream\n   * @param {number} bitRate\n   * @private\n   */\n  setBitrate_(stream, bitRate) {\n    this.estimateByStreamId_[stream] = bitRate;\n  }\n\n  /**\n   * Create an estimate for the text stream.\n   *\n   * @param {shaka.extern.Stream} text\n   */\n  addText(text) {\n    this.estimateByStreamId_[text.id] =\n        shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_;\n  }\n\n  /**\n   * Create an estimate for the image stream.\n   *\n   * @param {shaka.extern.Stream} image\n   */\n  addImage(image) {\n    this.estimateByStreamId_[image.id] = image.bandwidth ||\n        shaka.offline.StreamBandwidthEstimator.DEFAULT_IMAGE_BITRATE_;\n  }\n\n  /**\n   * Get the estimate for a segment that is part of a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @param {!shaka.media.SegmentReference} segment\n   * @return {number}\n   */\n  getSegmentEstimate(id, segment) {\n    const duration = segment.endTime - segment.startTime;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * Get the estimate for an init segment for a stream that has already\n   * added to the estimator.\n   *\n   * @param {number} id\n   * @return {number}\n   */\n  getInitSegmentEstimate(id) {\n    // Assume that the init segment is worth approximately half a second of\n    // content.\n    const duration = 0.5;\n    return this.getEstimate_(id) * duration;\n  }\n\n  /**\n   * @param {number} id\n   * @return {number}\n   * @private\n   */\n  getEstimate_(id) {\n    let bitRate = this.estimateByStreamId_[id];\n\n    if (bitRate == null) {\n      bitRate = 0;\n      shaka.log.error(\n          'Asking for bitrate of stream not given to the estimator');\n    }\n\n    if (bitRate == 0) {\n      shaka.log.warning(\n          'Using bitrate of 0, this stream won\\'t affect progress');\n    }\n\n    return bitRate;\n  }\n};\n\n\n/**\n * Since audio bandwidth does not vary much, we are going to use a constant\n * approximation for audio bit rate allowing use to more accurately guess at\n * the video bitrate.\n *\n * YouTube's suggested bitrate for stereo audio is 384 kbps so we are going to\n * assume that: https://support.google.com/youtube/answer/1722171?hl=en\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_ = 393216;\n\n\n/**\n * Since we don't normally get the bitrate for text, we still want to create\n * some approximation so that it can influence progress. This will use the\n * bitrate from \"Tears of Steal\" to give some kind of data-driven result.\n *\n * The file size for English subtitles is 4.7 KB. The video is 12:14 long,\n * which means that the text's bit rate is around 52 bps.\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_ = 52;\n\n\n/**\n * Since we don't normally get the bitrate for image, we still want to create\n * some approximation so that it can influence progress.\n *\n * The size of the thumbnail usually is 2KB.\n *\n * @const {number}\n * @private\n */\nshaka.offline.StreamBandwidthEstimator.DEFAULT_IMAGE_BITRATE_ = 2048;\n\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.offline.Storage');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.Player');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.media.ManifestParser');\ngoog.require('shaka.net.NetworkingEngine');\ngoog.require('shaka.offline.DownloadInfo');\ngoog.require('shaka.offline.DownloadManager');\ngoog.require('shaka.offline.OfflineUri');\ngoog.require('shaka.offline.SessionDeleter');\ngoog.require('shaka.offline.StorageMuxer');\ngoog.require('shaka.offline.StoredContentUtils');\ngoog.require('shaka.offline.StreamBandwidthEstimator');\ngoog.require('shaka.util.AbortableOperation');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.ConfigUtils');\ngoog.require('shaka.util.Destroyer');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.IDestroyable');\ngoog.require('shaka.util.Iterables');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\ngoog.require('shaka.util.PlayerConfiguration');\ngoog.require('shaka.util.StreamUtils');\ngoog.requireType('shaka.media.SegmentReference');\ngoog.requireType('shaka.offline.StorageCellHandle');\n\n\n/**\n * @summary\n * This manages persistent offline data including storage, listing, and deleting\n * stored manifests.  Playback of offline manifests are done through the Player\n * using a special URI (see shaka.offline.OfflineUri).\n *\n * First, check support() to see if offline is supported by the platform.\n * Second, configure() the storage object with callbacks to your application.\n * Third, call store(), remove(), or list() as needed.\n * When done, call destroy().\n *\n * @implements {shaka.util.IDestroyable}\n * @export\n */\nshaka.offline.Storage = class {\n  /**\n   * @param {!shaka.Player=} player\n   *    A player instance to share a networking engine and configuration with.\n   *    When initializing with a player, storage is only valid as long as\n   *    |destroy| has not been called on the player instance. When omitted,\n   *    storage will manage its own networking engine and configuration.\n   */\n  constructor(player) {\n    // It is an easy mistake to make to pass a Player proxy from CastProxy.\n    // Rather than throw a vague exception later, throw an explicit and clear\n    // one now.\n    //\n    // TODO(vaage): After we decide whether or not we want to support\n    //  initializing storage with a player proxy, we should either remove\n    //  this error or rename the error.\n    if (player && player.constructor != shaka.Player) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED);\n    }\n\n    /** @private {?shaka.extern.PlayerConfiguration} */\n    this.config_ = null;\n\n    /** @private {shaka.net.NetworkingEngine} */\n    this.networkingEngine_ = null;\n\n    // Initialize |config_| and |networkingEngine_| based on whether or not\n    // we were given a player instance.\n    if (player) {\n      this.config_ = player.getSharedConfiguration();\n      this.networkingEngine_ = player.getNetworkingEngine();\n\n      goog.asserts.assert(\n          this.networkingEngine_,\n          'Storage should not be initialized with a player that had ' +\n              '|destroy| called on it.');\n    } else {\n      this.config_ = shaka.util.PlayerConfiguration.createDefault();\n      this.networkingEngine_ = new shaka.net.NetworkingEngine();\n    }\n\n    /**\n     * A list of open operations that are being performed by this instance of\n     * |shaka.offline.Storage|.\n     *\n     * @private {!Array.<!Promise>}\n     */\n    this.openOperations_ = [];\n\n    /**\n     * A list of open download managers that are being used to download things.\n     *\n     * @private {!Array.<!shaka.offline.DownloadManager>}\n     */\n    this.openDownloadManagers_ = [];\n\n    /**\n     * Storage should only destroy the networking engine if it was initialized\n     * without a player instance. Store this as a flag here to avoid including\n     * the player object in the destoyer's closure.\n     *\n     * @type {boolean}\n     */\n    const destroyNetworkingEngine = !player;\n\n    /** @private {!shaka.util.Destroyer} */\n    this.destroyer_ = new shaka.util.Destroyer(async () => {\n      // Cancel all in-progress store operations.\n      await Promise.all(this.openDownloadManagers_.map((dl) => dl.abortAll()));\n\n      // Wait for all remaining open operations to end. Wrap each operations so\n      // that a single rejected promise won't cause |Promise.all| to return\n      // early or to return a rejected Promise.\n      const noop = () => {};\n      const awaits = [];\n      for (const op of this.openOperations_) {\n        awaits.push(op.then(noop, noop));\n      }\n      await Promise.all(awaits);\n\n      // Wait until after all the operations have finished before we destroy\n      // the networking engine to avoid any unexpected errors.\n      if (destroyNetworkingEngine) {\n        await this.networkingEngine_.destroy();\n      }\n\n      // Drop all references to internal objects to help with GC.\n      this.config_ = null;\n      this.networkingEngine_ = null;\n    });\n  }\n\n\n  /**\n   * Gets whether offline storage is supported.  Returns true if offline storage\n   * is supported for clear content.  Support for offline storage of encrypted\n   * content will not be determined until storage is attempted.\n   *\n   * @return {boolean}\n   * @export\n   */\n  static support() {\n    // Our Storage system is useless without MediaSource.  MediaSource allows us\n    // to pull data from anywhere (including our Storage system) and feed it to\n    // the video element.\n    if (!shaka.util.Platform.supportsMediaSource()) {\n      return false;\n    }\n\n    return shaka.offline.StorageMuxer.support();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  destroy() {\n    return this.destroyer_.destroy();\n  }\n\n  /**\n   * Sets configuration values for Storage.  This is associated with\n   * Player.configure and will change the player instance given at\n   * initialization.\n   *\n   * @param {string|!Object} config This should either be a field name or an\n   *   object following the form of {@link shaka.extern.PlayerConfiguration},\n   *   where you may omit any field you do not wish to change.\n   * @param {*=} value This should be provided if the previous parameter\n   *   was a string field name.\n   * @return {boolean}\n   * @export\n   */\n  configure(config, value) {\n    goog.asserts.assert(typeof(config) == 'object' || arguments.length == 2,\n        'String configs should have values!');\n\n    // ('fieldName', value) format\n    if (arguments.length == 2 && typeof(config) == 'string') {\n      config = shaka.util.ConfigUtils.convertToConfigObject(config, value);\n    }\n    goog.asserts.assert(typeof(config) == 'object', 'Should be an object!');\n\n    goog.asserts.assert(\n        this.config_, 'Cannot reconfigure storage after calling destroy.');\n    return shaka.util.PlayerConfiguration.mergeConfigObjects(\n        /* destination= */ this.config_, /* updates= */ config );\n  }\n\n  /**\n   * Return a copy of the current configuration.  Modifications of the returned\n   * value will not affect the Storage instance's active configuration.  You\n   * must call storage.configure() to make changes.\n   *\n   * @return {shaka.extern.PlayerConfiguration}\n   * @export\n   */\n  getConfiguration() {\n    goog.asserts.assert(this.config_, 'Config must not be null!');\n\n    const ret = shaka.util.PlayerConfiguration.createDefault();\n    shaka.util.PlayerConfiguration.mergeConfigObjects(\n        ret, this.config_, shaka.util.PlayerConfiguration.createDefault());\n    return ret;\n  }\n\n  /**\n   * Return the networking engine that storage is using. If storage was\n   * initialized with a player instance, then the networking engine returned\n   * will be the same as |player.getNetworkingEngine()|.\n   *\n   * The returned value will only be null if |destroy| was called before\n   * |getNetworkingEngine|.\n   *\n   * @return {shaka.net.NetworkingEngine}\n   * @export\n   */\n  getNetworkingEngine() {\n    return this.networkingEngine_;\n  }\n\n  /**\n   * Stores the given manifest.  If the content is encrypted, and encrypted\n   * content cannot be stored on this platform, the Promise will be rejected\n   * with error code 6001, REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE.\n   * Multiple assets can be downloaded at the same time, but note that since\n   * the storage instance has a single networking engine, multiple storage\n   * objects will be necessary if some assets require unique network filters.\n   * This snapshots the storage config at the time of the call, so it will not\n   * honor any changes to config mid-store operation.\n   *\n   * @param {string} uri The URI of the manifest to store.\n   * @param {!Object=} appMetadata An arbitrary object from the application\n   *   that will be stored along-side the offline content.  Use this for any\n   *   application-specific metadata you need associated with the stored\n   *   content.  For details on the data types that can be stored here, please\n   *   refer to {@link https://bit.ly/StructClone}\n   * @param {string=} mimeType\n   *   The mime type for the content |manifestUri| points to.\n   * @return {!shaka.extern.IAbortableOperation.<shaka.extern.StoredContent>}\n   *   An AbortableOperation that resolves with a structure representing what\n   *   was stored.  The \"offlineUri\" member is the URI that should be given to\n   *   Player.load() to play this piece of content offline.  The \"appMetadata\"\n   *   member is the appMetadata argument you passed to store().\n   *   If you want to cancel this download, call the \"abort\" method on\n   *   AbortableOperation.\n   * @export\n   */\n  store(uri, appMetadata, mimeType) {\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Cannot call |store| after calling |destroy|.');\n\n    // Get a copy of the current config.\n    const config = this.getConfiguration();\n\n    const getParser = async () => {\n      goog.asserts.assert(\n          this.networkingEngine_, 'Should not call |store| after |destroy|');\n\n      const factory = await shaka.media.ManifestParser.getFactory(\n          uri,\n          this.networkingEngine_,\n          config.manifest.retryParameters,\n          mimeType || null);\n\n      return factory();\n    };\n\n    /** @type {!shaka.offline.DownloadManager} */\n    const downloader =\n        new shaka.offline.DownloadManager(this.networkingEngine_);\n    this.openDownloadManagers_.push(downloader);\n\n    const storeOp = this.store_(\n        uri, appMetadata || {}, getParser, config, downloader);\n    const abortableStoreOp = new shaka.util.AbortableOperation(storeOp, () => {\n      return downloader.abortAll();\n    });\n    abortableStoreOp.finally(() => {\n      shaka.util.ArrayUtils.remove(this.openDownloadManagers_, downloader);\n    });\n\n    return this.startAbortableOperation_(abortableStoreOp);\n  }\n\n  /**\n   * See |shaka.offline.Storage.store| for details.\n   *\n   * @param {string} uri\n   * @param {!Object} appMetadata\n   * @param {function():!Promise.<shaka.extern.ManifestParser>} getParser\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @return {!Promise.<shaka.extern.StoredContent>}\n   * @private\n   */\n  async store_(uri, appMetadata, getParser, config, downloader) {\n    this.requireSupport_();\n\n    // Since we will need to use |parser|, |drmEngine|, |activeHandle|, and\n    // |muxer| in the catch/finally blocks, we need to define them out here.\n    // Since they may not get initialized when we enter the catch/finally block,\n    // we need to assume that they may be null/undefined when we get there.\n\n    /** @type {?shaka.extern.ManifestParser} */\n    let parser = null;\n    /** @type {?shaka.media.DrmEngine} */\n    let drmEngine = null;\n    /** @type {shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    /** @type {?shaka.offline.StorageCellHandle} */\n    let activeHandle = null;\n    /** @type {?number} */\n    let manifestId = null;\n\n    // This will be used to store any errors from drm engine. Whenever drm\n    // engine is passed to another function to do work, we should check if this\n    // was set.\n    let drmError = null;\n\n    try {\n      parser = await getParser();\n\n      const manifest = await this.parseManifest(uri, parser, config);\n\n      // Check if we were asked to destroy ourselves while we were \"away\"\n      // downloading the manifest.\n      this.ensureNotDestroyed_();\n\n      // Check if we can even download this type of manifest before trying to\n      // create the drm engine.\n      const canDownload = !manifest.presentationTimeline.isLive() &&\n                          !manifest.presentationTimeline.isInProgress();\n      if (!canDownload) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE,\n            uri);\n      }\n\n      // Create the DRM engine, and load the keys in the manifest.\n      drmEngine = await this.createDrmEngine(\n          manifest,\n          (e) => { drmError = drmError || e; },\n          config);\n\n      // We could have been asked to destroy ourselves while we were \"away\"\n      // creating the drm engine.\n      this.ensureNotDestroyed_();\n      if (drmError) {\n        throw drmError;\n      }\n\n      await this.filterManifest_(manifest, drmEngine, config);\n\n      await muxer.init();\n      this.ensureNotDestroyed_();\n\n      // Get the cell that we are saving the manifest to. Once we get a cell\n      // we will only reference the cell and not the muxer so that the manifest\n      // and segments will all be saved to the same cell.\n      activeHandle = await muxer.getActive();\n      this.ensureNotDestroyed_();\n\n      goog.asserts.assert(drmEngine, 'drmEngine should be non-null here.');\n      const {manifestDB, toDownload} = this.makeManifestDB_(\n          drmEngine, manifest, uri, appMetadata, config, downloader);\n\n      // Store the empty manifest, before downloading the segments.\n      const ids = await activeHandle.cell.addManifests([manifestDB]);\n      this.ensureNotDestroyed_();\n      manifestId = ids[0];\n\n      goog.asserts.assert(drmEngine, 'drmEngine should be non-null here.');\n      this.ensureNotDestroyed_();\n      if (drmError) {\n        throw drmError;\n      }\n\n      await this.downloadSegments_(toDownload, manifestId, manifestDB,\n          downloader, config, activeHandle.cell, manifest, drmEngine);\n      this.ensureNotDestroyed_();\n\n      const offlineUri = shaka.offline.OfflineUri.manifest(\n          activeHandle.path.mechanism, activeHandle.path.cell, manifestId);\n\n      return shaka.offline.StoredContentUtils.fromManifestDB(\n          offlineUri, manifestDB);\n    } catch (e) {\n      if (manifestId != null) {\n        await shaka.offline.Storage.cleanStoredManifest(manifestId);\n      }\n\n      // If we already had an error, ignore this error to avoid hiding\n      // the original error.\n      throw drmError || e;\n    } finally {\n      await muxer.destroy();\n\n      if (parser) {\n        await parser.stop();\n      }\n\n      if (drmEngine) {\n        await drmEngine.destroy();\n      }\n    }\n  }\n\n  /**\n   * Download and then store the contents of each segment.\n   * The promise this returns will wait for local downloads.\n   *\n   * @param {!Array.<!shaka.offline.DownloadInfo>} toDownload\n   * @param {number} manifestId\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {shaka.extern.StorageCell} storage\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @return {!Promise}\n   * @private\n   */\n  async downloadSegments_(\n      toDownload, manifestId, manifestDB, downloader, config, storage,\n      manifest, drmEngine) {\n    let pendingManifestUpdates = {};\n    let pendingDataSize = 0;\n\n    /**\n     * @param {!Array.<!shaka.offline.DownloadInfo>} toDownload\n     * @param {boolean} updateDRM\n     */\n    const download = async (toDownload, updateDRM) => {\n      for (const download of toDownload) {\n        const request = download.makeSegmentRequest(config);\n        const estimateId = download.estimateId;\n        const isInitSegment = download.isInitSegment;\n\n        const onDownloaded = async (data) => {\n          // Store the data.\n          const dataKeys = await storage.addSegments([{data}]);\n          this.ensureNotDestroyed_();\n\n          // Store the necessary update to the manifest, to be processed later.\n          const ref = /** @type {!shaka.media.SegmentReference} */ (\n            download.ref);\n          const id = shaka.offline.DownloadInfo.idForSegmentRef(ref);\n          pendingManifestUpdates[id] = dataKeys[0];\n          pendingDataSize += data.byteLength;\n        };\n\n        downloader.queue(download.groupId,\n            request, estimateId, isInitSegment, onDownloaded);\n      }\n      await downloader.waitToFinish();\n\n      if (updateDRM) {\n        // Re-store the manifest, to attach session IDs.\n        // These were (maybe) discovered inside the downloader; we can only add\n        // them now, at the end, since the manifestDB is in flux during the\n        // process of downloading and storing, and assignSegmentsToManifest\n        // does not know about the DRM engine.\n        this.ensureNotDestroyed_();\n        this.setManifestDrmFields_(manifest, manifestDB, drmEngine, config);\n        await storage.updateManifest(manifestId, manifestDB);\n      }\n    };\n\n    const usingBgFetch = false; // TODO: Get.\n\n    try {\n      if (this.getManifestIsEncrypted_(manifest) && usingBgFetch &&\n          !this.getManifestIncludesInitData_(manifest)) {\n        // Background fetch can't make DRM sessions, so if we have to get the\n        // init data from the init segments, download those first before\n        // anything else.\n        await download(toDownload.filter((info) => info.isInitSegment), true);\n        this.ensureNotDestroyed_();\n        toDownload = toDownload.filter((info) => !info.isInitSegment);\n\n        // Copy these and reset them now, before calling await.\n        const manifestUpdates = pendingManifestUpdates;\n        const dataSize = pendingDataSize;\n        pendingManifestUpdates = {};\n        pendingDataSize = 0;\n\n        await shaka.offline.Storage.assignSegmentsToManifest(\n            storage, manifestId, manifestDB, manifestUpdates, dataSize,\n            () => this.ensureNotDestroyed_());\n        this.ensureNotDestroyed_();\n      }\n\n      if (!usingBgFetch) {\n        await download(toDownload, false);\n        this.ensureNotDestroyed_();\n\n        // Copy these and reset them now, before calling await.\n        const manifestUpdates = pendingManifestUpdates;\n        const dataSize = pendingDataSize;\n        pendingManifestUpdates = {};\n        pendingDataSize = 0;\n\n        await shaka.offline.Storage.assignSegmentsToManifest(\n            storage, manifestId, manifestDB, manifestUpdates, dataSize,\n            () => this.ensureNotDestroyed_());\n        this.ensureNotDestroyed_();\n\n        goog.asserts.assert(\n            !manifestDB.isIncomplete, 'The manifest should be complete by now');\n      } else {\n        // TODO: Send the request to the service worker. Don't await the result.\n      }\n    } catch (error) {\n      const dataKeys = Object.values(pendingManifestUpdates);\n      // Remove these pending segments that are not yet linked to the manifest.\n      await storage.removeSegments(dataKeys, (key) => {});\n\n      throw error;\n    }\n  }\n\n  /**\n   * Removes all of the contents for a given manifest, statelessly.\n   *\n   * @param {number} manifestId\n   * @return {!Promise}\n   */\n  static async cleanStoredManifest(manifestId) {\n    const muxer = new shaka.offline.StorageMuxer();\n    await muxer.init();\n    const activeHandle = await muxer.getActive();\n    const uri = shaka.offline.OfflineUri.manifest(\n        activeHandle.path.mechanism,\n        activeHandle.path.cell,\n        manifestId);\n    await muxer.destroy();\n    const storage = new shaka.offline.Storage();\n    await storage.remove(uri.toString());\n  }\n\n  /**\n   * Updates the given manifest, assigns database keys to segments, then stores\n   * the updated manifest.\n   *\n   * It is up to the caller to ensure that this method is not called\n   * concurrently on the same manifest.\n   *\n   * @param {shaka.extern.StorageCell} storage\n   * @param {number} manifestId\n   * @param {!shaka.extern.ManifestDB} manifestDB\n   * @param {!Object.<string, number>} manifestUpdates\n   * @param {number} dataSizeUpdate\n   * @param {function()} throwIfAbortedFn  A function that should throw if the\n   *   download has been aborted.\n   * @return {!Promise}\n   */\n  static async assignSegmentsToManifest(\n      storage, manifestId, manifestDB, manifestUpdates, dataSizeUpdate,\n      throwIfAbortedFn) {\n    let manifestUpdated = false;\n\n    try {\n      // Assign the stored data to the manifest.\n      let complete = true;\n      for (const stream of manifestDB.streams) {\n        for (const segment of stream.segments) {\n          let dataKey = segment.pendingSegmentRefId ?\n              manifestUpdates[segment.pendingSegmentRefId] : null;\n          if (dataKey != null) {\n            segment.dataKey = dataKey;\n            // Now that the segment has been associated with the appropriate\n            // dataKey, the pendingSegmentRefId is no longer necessary.\n            segment.pendingSegmentRefId = undefined;\n          }\n\n          dataKey = segment.pendingInitSegmentRefId ?\n              manifestUpdates[segment.pendingInitSegmentRefId] : null;\n          if (dataKey != null) {\n            segment.initSegmentKey = dataKey;\n            // Now that the init segment has been associated with the\n            // appropriate initSegmentKey, the pendingInitSegmentRefId is no\n            // longer necessary.\n            segment.pendingInitSegmentRefId = undefined;\n          }\n\n          if (segment.pendingSegmentRefId) {\n            complete = false;\n          }\n          if (segment.pendingInitSegmentRefId) {\n            complete = false;\n          }\n        }\n      }\n\n      // Update the size of the manifest.\n      manifestDB.size += dataSizeUpdate;\n\n      // Mark the manifest as complete, if all segments are downloaded.\n      if (complete) {\n        manifestDB.isIncomplete = false;\n      }\n\n      // Update the manifest.\n      await storage.updateManifest(manifestId, manifestDB);\n      manifestUpdated = true;\n      throwIfAbortedFn();\n    } catch (e) {\n      await shaka.offline.Storage.cleanStoredManifest(manifestId);\n\n      if (!manifestUpdated) {\n        const dataKeys = Object.values(manifestUpdates);\n        // The cleanStoredManifest method will not \"see\" any segments that have\n        // been downloaded but not assigned to the manifest yet. So un-store\n        // them separately.\n        await storage.removeSegments(dataKeys, (key) => {});\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Filter |manifest| such that it will only contain the variants and text\n   * streams that we want to store and can actually play.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise}\n   * @private\n   */\n  async filterManifest_(manifest, drmEngine, config) {\n    // Filter the manifest based on the restrictions given in the player\n    // configuration.\n    const maxHwRes = {width: Infinity, height: Infinity};\n    shaka.util.StreamUtils.filterByRestrictions(\n        manifest, config.restrictions, maxHwRes);\n\n    // Filter the manifest based on what we know MediaCapabilities will be able\n    // to play later (no point storing something we can't play).\n    await shaka.util.StreamUtils.filterManifestByMediaCapabilities(\n        manifest, config.offline.usePersistentLicense);\n\n    // Gather all tracks.\n    const allTracks = [];\n\n    // Choose the codec that has the lowest average bandwidth.\n    const preferredAudioChannelCount = config.preferredAudioChannelCount;\n    const preferredDecodingAttributes = config.preferredDecodingAttributes;\n    const preferredVideoCodecs = config.preferredVideoCodecs;\n    const preferredAudioCodecs = config.preferredAudioCodecs;\n\n    shaka.util.StreamUtils.chooseCodecsAndFilterManifest(\n        manifest, preferredVideoCodecs, preferredAudioCodecs,\n        preferredAudioChannelCount, preferredDecodingAttributes);\n\n    for (const variant of manifest.variants) {\n      goog.asserts.assert(\n          shaka.util.StreamUtils.isPlayable(variant),\n          'We should have already filtered by \"is playable\"');\n\n      allTracks.push(shaka.util.StreamUtils.variantToTrack(variant));\n    }\n\n    for (const text of manifest.textStreams) {\n      allTracks.push(shaka.util.StreamUtils.textStreamToTrack(text));\n    }\n\n    for (const image of manifest.imageStreams) {\n      allTracks.push(shaka.util.StreamUtils.imageStreamToTrack(image));\n    }\n\n    // Let the application choose which tracks to store.\n    const chosenTracks =\n        await config.offline.trackSelectionCallback(allTracks);\n    const duration = manifest.presentationTimeline.getDuration();\n    let sizeEstimate = 0;\n    for (const track of chosenTracks) {\n      const trackSize = track.bandwidth * duration / 8;\n      sizeEstimate += trackSize;\n    }\n    try {\n      const allowedDownload =\n          await config.offline.downloadSizeCallback(sizeEstimate);\n      if (!allowedDownload) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.STORAGE,\n            shaka.util.Error.Code.STORAGE_LIMIT_REACHED);\n      }\n    } catch (e) {\n      // It is necessary to be able to catch the STORAGE_LIMIT_REACHED error\n      if (e instanceof shaka.util.Error) {\n        throw e;\n      }\n      shaka.log.warning(\n          'downloadSizeCallback has produced an unexpected error', e);\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.DOWNLOAD_SIZE_CALLBACK_ERROR);\n    }\n\n    /** @type {!Set.<number>} */\n    const variantIds = new Set();\n    /** @type {!Set.<number>} */\n    const textIds = new Set();\n    /** @type {!Set.<number>} */\n    const imageIds = new Set();\n\n    // Collect the IDs of the chosen tracks.\n    for (const track of chosenTracks) {\n      if (track.type == 'variant') {\n        variantIds.add(track.id);\n      }\n      if (track.type == 'text') {\n        textIds.add(track.id);\n      }\n      if (track.type == 'image') {\n        imageIds.add(track.id);\n      }\n    }\n\n    // Filter the manifest to keep only what the app chose.\n    manifest.variants =\n        manifest.variants.filter((variant) => variantIds.has(variant.id));\n    manifest.textStreams =\n        manifest.textStreams.filter((stream) => textIds.has(stream.id));\n    manifest.imageStreams =\n        manifest.imageStreams.filter((stream) => imageIds.has(stream.id));\n\n    // Check the post-filtered manifest for characteristics that may indicate\n    // issues with how the app selected tracks.\n    shaka.offline.Storage.validateManifest_(manifest);\n  }\n\n  /**\n   * Create a download manager and download the manifest.\n   * This also sets up download infos for each segment to be downloaded.\n   *\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {string} uri\n   * @param {!Object} metadata\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @return {{\n   *   manifestDB: shaka.extern.ManifestDB,\n   *   toDownload: !Array.<!shaka.offline.DownloadInfo>\n   * }}\n   * @private\n   */\n  makeManifestDB_(drmEngine, manifest, uri, metadata, config, downloader) {\n    const pendingContent = shaka.offline.StoredContentUtils.fromManifest(\n        uri, manifest, /* size= */ 0, metadata);\n    // In https://github.com/shaka-project/shaka-player/issues/2652, we found\n    // that this callback would be removed by the compiler if we reference the\n    // config in the onProgress closure below.  Reading it into a local\n    // variable first seems to work around this apparent compiler bug.\n    const progressCallback = config.offline.progressCallback;\n\n    const onProgress = (progress, size) => {\n      // Update the size of the stored content before issuing a progress\n      // update.\n      pendingContent.size = size;\n      progressCallback(pendingContent, progress);\n    };\n    const onInitData = (initData, systemId) => {\n      if (needsInitData && config.offline.usePersistentLicense &&\n          currentSystemId == systemId) {\n        drmEngine.newInitData('cenc', initData);\n      }\n    };\n    downloader.setCallbacks(onProgress, onInitData);\n\n    const needsInitData = this.getManifestIsEncrypted_(manifest) &&\n                          !this.getManifestIncludesInitData_(manifest);\n\n    let currentSystemId = null;\n    if (needsInitData) {\n      const drmInfo = drmEngine.getDrmInfo();\n      currentSystemId =\n          shaka.offline.Storage.defaultSystemIds_.get(drmInfo.keySystem);\n    }\n\n    // Make the estimator, which is used to make the download registries.\n    const estimator = new shaka.offline.StreamBandwidthEstimator();\n    for (const stream of manifest.textStreams) {\n      estimator.addText(stream);\n    }\n    for (const stream of manifest.imageStreams) {\n      estimator.addImage(stream);\n    }\n    for (const variant of manifest.variants) {\n      estimator.addVariant(variant);\n    }\n    const {streams, toDownload} = this.createStreams_(\n        downloader, estimator, drmEngine, manifest, config);\n\n    const drmInfo = drmEngine.getDrmInfo();\n    const usePersistentLicense = config.offline.usePersistentLicense;\n    if (drmInfo && usePersistentLicense) {\n      // Don't store init data, since we have stored sessions.\n      drmInfo.initData = [];\n    }\n\n    const manifestDB = {\n      creationTime: Date.now(),\n      originalManifestUri: uri,\n      duration: manifest.presentationTimeline.getDuration(),\n      size: 0,\n      expiration: drmEngine.getExpiration(),\n      streams,\n      sessionIds: usePersistentLicense ? drmEngine.getSessionIds() : [],\n      drmInfo,\n      appMetadata: metadata,\n      isIncomplete: true,\n      sequenceMode: manifest.sequenceMode,\n    };\n\n    return {manifestDB, toDownload};\n  }\n\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @return {boolean}\n   * @private\n   */\n  getManifestIsEncrypted_(manifest) {\n    return manifest.variants.some((variant) => {\n      const videoEncrypted = variant.video && variant.video.encrypted;\n      const audioEncrypted = variant.audio && variant.audio.encrypted;\n      return videoEncrypted || audioEncrypted;\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @return {boolean}\n   * @private\n   */\n  getManifestIncludesInitData_(manifest) {\n    return manifest.variants.some((variant) => {\n      const videoDrmInfos = variant.video ? variant.video.drmInfos : [];\n      const audioDrmInfos = variant.audio ? variant.audio.drmInfos : [];\n      const drmInfos = videoDrmInfos.concat(audioDrmInfos);\n      return drmInfos.some((drmInfos) => {\n        return drmInfos.initData && drmInfos.initData.length;\n      });\n    });\n  }\n\n  /**\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.ManifestDB} manifestDB\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @private\n   */\n  setManifestDrmFields_(manifest, manifestDB, drmEngine, config) {\n    manifestDB.expiration = drmEngine.getExpiration();\n\n    const sessions = drmEngine.getSessionIds();\n    manifestDB.sessionIds = config.offline.usePersistentLicense ?\n        sessions : [];\n\n    if (this.getManifestIsEncrypted_(manifest) &&\n        config.offline.usePersistentLicense && !sessions.length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE);\n    }\n  }\n\n  /**\n   * Removes the given stored content.  This will also attempt to release the\n   * licenses, if any.\n   *\n   * @param {string} contentUri\n   * @return {!Promise}\n   * @export\n   */\n  remove(contentUri) {\n    return this.startOperation_(this.remove_(contentUri));\n  }\n\n  /**\n   * See |shaka.offline.Storage.remove| for details.\n   *\n   * @param {string} contentUri\n   * @return {!Promise}\n   * @private\n   */\n  async remove_(contentUri) {\n    this.requireSupport_();\n\n    const nullableUri = shaka.offline.OfflineUri.parse(contentUri);\n    if (nullableUri == null || !nullableUri.isManifest()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.MALFORMED_OFFLINE_URI,\n          contentUri);\n    }\n\n    /** @type {!shaka.offline.OfflineUri} */\n    const uri = nullableUri;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n\n    try {\n      await muxer.init();\n\n      const cell = await muxer.getCell(uri.mechanism(), uri.cell());\n      const manifests = await cell.getManifests([uri.key()]);\n      const manifest = manifests[0];\n\n      await Promise.all([\n        this.removeFromDRM_(uri, manifest, muxer),\n        this.removeFromStorage_(cell, uri, manifest),\n      ]);\n    } finally {\n      await muxer.destroy();\n    }\n  }\n\n  /**\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @param {boolean} isVideo\n   * @return {!Array.<MediaKeySystemMediaCapability>}\n   * @private\n   */\n  static getCapabilities_(manifestDb, isVideo) {\n    const MimeUtils = shaka.util.MimeUtils;\n\n    const ret = [];\n    for (const stream of manifestDb.streams) {\n      if (isVideo && stream.type == 'video') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.videoRobustness,\n        });\n      } else if (!isVideo && stream.type == 'audio') {\n        ret.push({\n          contentType: MimeUtils.getFullType(stream.mimeType, stream.codecs),\n          robustness: manifestDb.drmInfo.audioRobustness,\n        });\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * @param {!shaka.offline.OfflineUri} uri\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @param {!shaka.offline.StorageMuxer} muxer\n   * @return {!Promise}\n   * @private\n   */\n  async removeFromDRM_(uri, manifestDb, muxer) {\n    goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n    await shaka.offline.Storage.deleteLicenseFor_(\n        this.networkingEngine_, this.config_.drm, muxer, manifestDb);\n  }\n\n  /**\n   * @param {shaka.extern.StorageCell} storage\n   * @param {!shaka.offline.OfflineUri} uri\n   * @param {shaka.extern.ManifestDB} manifest\n   * @return {!Promise}\n   * @private\n   */\n  removeFromStorage_(storage, uri, manifest) {\n    /** @type {!Array.<number>} */\n    const segmentIds = shaka.offline.Storage.getAllSegmentIds_(manifest);\n\n    // Count(segments) + Count(manifests)\n    const toRemove = segmentIds.length + 1;\n    let removed = 0;\n\n    const pendingContent = shaka.offline.StoredContentUtils.fromManifestDB(\n        uri, manifest);\n\n    const onRemove = (key) => {\n      removed += 1;\n      this.config_.offline.progressCallback(pendingContent, removed / toRemove);\n    };\n\n    return Promise.all([\n      storage.removeSegments(segmentIds, onRemove),\n      storage.removeManifests([uri.key()], onRemove),\n    ]);\n  }\n\n  /**\n   * Removes any EME sessions that were not successfully removed before.  This\n   * returns whether all the sessions were successfully removed.\n   *\n   * @return {!Promise.<boolean>}\n   * @export\n   */\n  removeEmeSessions() {\n    return this.startOperation_(this.removeEmeSessions_());\n  }\n\n  /**\n   * @return {!Promise.<boolean>}\n   * @private\n   */\n  async removeEmeSessions_() {\n    this.requireSupport_();\n\n    goog.asserts.assert(this.networkingEngine_, 'Cannot be destroyed');\n    const net = this.networkingEngine_;\n    const config = this.config_.drm;\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    /** @type {!shaka.offline.SessionDeleter} */\n    const deleter = new shaka.offline.SessionDeleter();\n\n    let hasRemaining = false;\n\n    try {\n      await muxer.init();\n\n      /** @type {!Array.<shaka.extern.EmeSessionStorageCell>} */\n      const cells = [];\n      muxer.forEachEmeSessionCell((c) => cells.push(c));\n\n      // Run these sequentially to avoid creating too many DrmEngine instances\n      // and having multiple CDMs alive at once.  Some embedded platforms may\n      // not support that.\n      for (const sessionIdCell of cells) {\n        /* eslint-disable no-await-in-loop */\n        const sessions = await sessionIdCell.getAll();\n        const deletedSessionIds = await deleter.delete(config, net, sessions);\n        await sessionIdCell.remove(deletedSessionIds);\n\n        if (deletedSessionIds.length != sessions.length) {\n          hasRemaining = true;\n        }\n        /* eslint-enable no-await-in-loop */\n      }\n    } finally {\n      await muxer.destroy();\n    }\n\n    return !hasRemaining;\n  }\n\n  /**\n   * Lists all the stored content available.\n   *\n   * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}  A Promise to an\n   *   array of structures representing all stored content.  The \"offlineUri\"\n   *   member of the structure is the URI that should be given to Player.load()\n   *   to play this piece of content offline.  The \"appMetadata\" member is the\n   *   appMetadata argument you passed to store().\n   * @export\n   */\n  list() {\n    return this.startOperation_(this.list_());\n  }\n\n  /**\n   * See |shaka.offline.Storage.list| for details.\n   *\n   * @return {!Promise.<!Array.<shaka.extern.StoredContent>>}\n   * @private\n   */\n  async list_() {\n    this.requireSupport_();\n\n    /** @type {!Array.<shaka.extern.StoredContent>} */\n    const result = [];\n\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    try {\n      await muxer.init();\n\n      let p = Promise.resolve();\n      muxer.forEachCell((path, cell) => {\n        p = p.then(async () => {\n          const manifests = await cell.getAllManifests();\n\n          manifests.forEach((manifest, key) => {\n            const uri = shaka.offline.OfflineUri.manifest(\n                path.mechanism,\n                path.cell,\n                key);\n\n            const content = shaka.offline.StoredContentUtils.fromManifestDB(\n                uri,\n                manifest);\n\n            result.push(content);\n          });\n        });\n      });\n\n      await p;\n    } finally {\n      await muxer.destroy();\n    }\n\n    return result;\n  }\n\n\n  /**\n   * This method is public so that it can be overridden in testing.\n   *\n   * @param {string} uri\n   * @param {shaka.extern.ManifestParser} parser\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<shaka.extern.Manifest>}\n   */\n  async parseManifest(uri, parser, config) {\n    let error = null;\n\n    const networkingEngine = this.networkingEngine_;\n    goog.asserts.assert(networkingEngine, 'Should be initialized!');\n\n    /** @type {shaka.extern.ManifestParser.PlayerInterface} */\n    const playerInterface = {\n      networkingEngine: networkingEngine,\n\n      // No need to apply CMCD data for offline requests\n      modifyManifestRequest: (request, manifestInfo) => {},\n      modifySegmentRequest: (request, segmentInfo) => {},\n\n      // Don't bother filtering now. We will do that later when we have all the\n      // information we need to filter.\n      filter: () => Promise.resolve(),\n\n      // The responsibility for making mock text streams for closed captions is\n      // handled inside shaka.offline.OfflineManifestParser, before playback.\n      makeTextStreamsForClosedCaptions: (manifest) => {},\n\n      onTimelineRegionAdded: () => {},\n      onEvent: () => {},\n\n      // Used to capture an error from the manifest parser. We will check the\n      // error before returning.\n      onError: (e) => {\n        error = e;\n      },\n      isLowLatencyMode: () => false,\n      isAutoLowLatencyMode: () => false,\n      enableLowLatencyMode: () => {},\n      updateDuration: () => {},\n      newDrmInfo: (stream) => {},\n    };\n\n    parser.configure(config.manifest);\n\n    // We may have been destroyed while we were waiting on |getParser| to\n    // resolve.\n    this.ensureNotDestroyed_();\n\n    const manifest = await parser.start(uri, playerInterface);\n\n    // We may have been destroyed while we were waiting on |start| to\n    // resolve.\n    this.ensureNotDestroyed_();\n\n    // Get all the streams that are used in the manifest.\n    const streams =\n        shaka.offline.Storage.getAllStreamsFromManifest_(manifest);\n\n    // Wait for each stream to create their segment indexes.\n    await Promise.all(shaka.util.Iterables.map(streams, (stream) => {\n      return stream.createSegmentIndex();\n    }));\n\n    // We may have been destroyed while we were waiting on\n    // |createSegmentIndex| to resolve for each stream.\n    this.ensureNotDestroyed_();\n\n    // If we saw an error while parsing, surface the error.\n    if (error) {\n      throw error;\n    }\n\n    return manifest;\n  }\n\n  /**\n   * This method is public so that it can be override in testing.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @param {function(shaka.util.Error)} onError\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {!Promise.<!shaka.media.DrmEngine>}\n   */\n  async createDrmEngine(manifest, onError, config) {\n    goog.asserts.assert(\n        this.networkingEngine_,\n        'Cannot call |createDrmEngine| after |destroy|');\n\n    /** @type {!shaka.media.DrmEngine} */\n    const drmEngine = new shaka.media.DrmEngine({\n      netEngine: this.networkingEngine_,\n      onError: onError,\n      onKeyStatus: () => {},\n      onExpirationUpdated: () => {},\n      onEvent: () => {},\n    });\n\n    drmEngine.configure(config.drm);\n    await drmEngine.initForStorage(\n        manifest.variants, config.offline.usePersistentLicense);\n    await drmEngine.setServerCertificate();\n    await drmEngine.createOrLoad();\n\n    return drmEngine;\n  }\n\n  /**\n   * Converts manifest Streams to database Streams.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {!shaka.media.DrmEngine} drmEngine\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @return {{\n   *   streams: !Array.<shaka.extern.StreamDB>,\n   *   toDownload: !Array.<!shaka.offline.DownloadInfo>\n   * }}\n   * @private\n   */\n  createStreams_(downloader, estimator, drmEngine, manifest, config) {\n    // Download infos are stored based on their refId, to dedup them.\n    /** @type {!Map.<string, !shaka.offline.DownloadInfo>} */\n    const toDownload = new Map();\n\n    // Find the streams we want to download and create a stream db instance\n    // for each of them.\n    const streamSet =\n        shaka.offline.Storage.getAllStreamsFromManifest_(manifest);\n    const streamDBs = new Map();\n\n    for (const stream of streamSet) {\n      const streamDB = this.createStream_(\n          downloader, estimator, manifest, stream, config, toDownload);\n      streamDBs.set(stream.id, streamDB);\n    }\n\n    // Connect streams and variants together.\n    for (const variant of manifest.variants) {\n      if (variant.audio) {\n        streamDBs.get(variant.audio.id).variantIds.push(variant.id);\n      }\n      if (variant.video) {\n        streamDBs.get(variant.video.id).variantIds.push(variant.id);\n      }\n    }\n\n    return {\n      streams: Array.from(streamDBs.values()),\n      toDownload: Array.from(toDownload.values()),\n    };\n  }\n\n  /**\n   * Converts a manifest stream to a database stream.  This will search the\n   * segment index and add all the segments to the download infos.\n   *\n   * @param {!shaka.offline.DownloadManager} downloader\n   * @param {shaka.offline.StreamBandwidthEstimator} estimator\n   * @param {shaka.extern.Manifest} manifest\n   * @param {shaka.extern.Stream} stream\n   * @param {shaka.extern.PlayerConfiguration} config\n   * @param {!Map.<string, !shaka.offline.DownloadInfo>} toDownload\n   * @return {shaka.extern.StreamDB}\n   * @private\n   */\n  createStream_(downloader, estimator, manifest, stream, config, toDownload) {\n    /** @type {shaka.extern.StreamDB} */\n    const streamDb = {\n      id: stream.id,\n      originalId: stream.originalId,\n      primary: stream.primary,\n      type: stream.type,\n      mimeType: stream.mimeType,\n      codecs: stream.codecs,\n      frameRate: stream.frameRate,\n      pixelAspectRatio: stream.pixelAspectRatio,\n      hdr: stream.hdr,\n      kind: stream.kind,\n      language: stream.language,\n      label: stream.label,\n      width: stream.width || null,\n      height: stream.height || null,\n      encrypted: stream.encrypted,\n      keyIds: stream.keyIds,\n      segments: [],\n      variantIds: [],\n      roles: stream.roles,\n      forced: stream.forced,\n      channelsCount: stream.channelsCount,\n      audioSamplingRate: stream.audioSamplingRate,\n      spatialAudio: stream.spatialAudio,\n      closedCaptions: stream.closedCaptions,\n      tilesLayout: stream.tilesLayout,\n    };\n\n    const startTime =\n        manifest.presentationTimeline.getSegmentAvailabilityStart();\n\n    const numberOfParallelDownloads = config.offline.numberOfParallelDownloads;\n    let groupId = 0;\n\n    shaka.offline.Storage.forEachSegment_(stream, startTime, (segment) => {\n      const pendingSegmentRefId =\n          shaka.offline.DownloadInfo.idForSegmentRef(segment);\n      let pendingInitSegmentRefId = undefined;\n\n      // Set up the download for the segment, which will be downloaded later,\n      // perhaps in a service worker.\n      if (!toDownload.has(pendingSegmentRefId)) {\n        const estimateId = downloader.addDownloadEstimate(\n            estimator.getSegmentEstimate(stream.id, segment));\n        const segmentDownload = new shaka.offline.DownloadInfo(\n            segment,\n            estimateId,\n            groupId,\n            /* isInitSegment= */ false);\n        toDownload.set(pendingSegmentRefId, segmentDownload);\n      }\n\n      // Set up the download for the init segment, similarly, if there is one.\n      if (segment.initSegmentReference) {\n        pendingInitSegmentRefId = shaka.offline.DownloadInfo.idForSegmentRef(\n            segment.initSegmentReference);\n        if (!toDownload.has(pendingInitSegmentRefId)) {\n          const estimateId = downloader.addDownloadEstimate(\n              estimator.getInitSegmentEstimate(stream.id));\n          const initDownload = new shaka.offline.DownloadInfo(\n              segment.initSegmentReference,\n              estimateId,\n              groupId,\n              /* isInitSegment= */ true);\n          toDownload.set(pendingInitSegmentRefId, initDownload);\n        }\n      }\n\n      /** @type {!shaka.extern.SegmentDB} */\n      const segmentDB = {\n        pendingInitSegmentRefId,\n        initSegmentKey: pendingInitSegmentRefId ? 0 : null,\n        startTime: segment.startTime,\n        endTime: segment.endTime,\n        appendWindowStart: segment.appendWindowStart,\n        appendWindowEnd: segment.appendWindowEnd,\n        timestampOffset: segment.timestampOffset,\n        tilesLayout: segment.tilesLayout,\n        pendingSegmentRefId,\n        dataKey: 0,\n      };\n      streamDb.segments.push(segmentDB);\n      groupId = (groupId + 1) % numberOfParallelDownloads;\n    });\n\n    return streamDb;\n  }\n\n  /**\n   * @param {shaka.extern.Stream} stream\n   * @param {number} startTime\n   * @param {function(!shaka.media.SegmentReference)} callback\n   * @private\n   */\n  static forEachSegment_(stream, startTime, callback) {\n    /** @type {?number} */\n    let i = stream.segmentIndex.find(startTime);\n\n    if (i == null) {\n      return;\n    }\n\n    /** @type {?shaka.media.SegmentReference} */\n    let ref = stream.segmentIndex.get(i);\n    while (ref) {\n      callback(ref);\n      ref = stream.segmentIndex.get(++i);\n    }\n  }\n\n  /**\n   * Throws an error if the object is destroyed.\n   * @private\n   */\n  ensureNotDestroyed_() {\n    if (this.destroyer_.destroyed()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.OPERATION_ABORTED);\n    }\n  }\n\n  /**\n   * Used by functions that need storage support to ensure that the current\n   * platform has storage support before continuing. This should only be\n   * needed to be used at the start of public methods.\n   *\n   * @private\n   */\n  requireSupport_() {\n    if (!shaka.offline.Storage.support()) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.STORAGE,\n          shaka.util.Error.Code.STORAGE_NOT_SUPPORTED);\n    }\n  }\n\n  /**\n   * Perform an action. Track the action's progress so that when we destroy\n   * we will wait until all the actions have completed before allowing destroy\n   * to resolve.\n   *\n   * @param {!Promise<T>} action\n   * @return {!Promise<T>}\n   * @template T\n   * @private\n   */\n  async startOperation_(action) {\n    this.openOperations_.push(action);\n\n    try {\n      // Await |action| so we can use the finally statement to remove |action|\n      // from |openOperations_| when we still have a reference to |action|.\n      return await action;\n    } finally {\n      shaka.util.ArrayUtils.remove(this.openOperations_, action);\n    }\n  }\n\n  /**\n   * The equivalent of startOperation_, but for abortable operations.\n   *\n   * @param {!shaka.extern.IAbortableOperation<T>} action\n   * @return {!shaka.extern.IAbortableOperation<T>}\n   * @template T\n   * @private\n   */\n  startAbortableOperation_(action) {\n    const promise = action.promise;\n    this.openOperations_.push(promise);\n\n    // Remove the open operation once the action has completed. So that we\n    // can still return the AbortableOperation, this is done using a |finally|\n    // block, rather than awaiting the result.\n    return action.finally(() => {\n      shaka.util.ArrayUtils.remove(this.openOperations_, promise);\n    });\n  }\n\n  /**\n   * @param {shaka.extern.ManifestDB} manifest\n   * @return {!Array.<number>}\n   * @private\n   */\n  static getAllSegmentIds_(manifest) {\n    /** @type {!Set.<number>} */\n    const ids = new Set();\n\n    // Get every segment for every stream in the manifest.\n    for (const stream of manifest.streams) {\n      for (const segment of stream.segments) {\n        if (segment.initSegmentKey != null) {\n          ids.add(segment.initSegmentKey);\n        }\n\n        ids.add(segment.dataKey);\n      }\n    }\n\n    return Array.from(ids);\n  }\n\n  /**\n   * Delete the on-disk storage and all the content it contains. This should not\n   * be done in normal circumstances. Only do it when storage is rendered\n   * unusable, such as by a version mismatch. No business logic will be run, and\n   * licenses will not be released.\n   *\n   * @return {!Promise}\n   * @export\n   */\n  static async deleteAll() {\n    /** @type {!shaka.offline.StorageMuxer} */\n    const muxer = new shaka.offline.StorageMuxer();\n    try {\n      // Wipe all content from all storage mechanisms.\n      await muxer.erase();\n    } finally {\n      // Destroy the muxer, whether or not erase() succeeded.\n      await muxer.destroy();\n    }\n  }\n\n  /**\n   * @param {!shaka.net.NetworkingEngine} net\n   * @param {!shaka.extern.DrmConfiguration} drmConfig\n   * @param {!shaka.offline.StorageMuxer} muxer\n   * @param {shaka.extern.ManifestDB} manifestDb\n   * @return {!Promise}\n   * @private\n   */\n  static async deleteLicenseFor_(net, drmConfig, muxer, manifestDb) {\n    if (!manifestDb.drmInfo) {\n      return;\n    }\n\n    const sessionIdCell = muxer.getEmeSessionCell();\n\n    /** @type {!Array.<shaka.extern.EmeSessionDB>} */\n    const sessions = manifestDb.sessionIds.map((sessionId) => {\n      return {\n        sessionId: sessionId,\n        keySystem: manifestDb.drmInfo.keySystem,\n        licenseUri: manifestDb.drmInfo.licenseServerUri,\n        serverCertificate: manifestDb.drmInfo.serverCertificate,\n        audioCapabilities: shaka.offline.Storage.getCapabilities_(\n            manifestDb,\n            /* isVideo= */ false),\n        videoCapabilities: shaka.offline.Storage.getCapabilities_(\n            manifestDb,\n            /* isVideo= */ true),\n      };\n    });\n    // Try to delete the sessions; any sessions that weren't deleted get stored\n    // in the database so we can try to remove them again later.  This allows us\n    // to still delete the stored content but not \"forget\" about these sessions.\n    // Later, we can remove the sessions to free up space.\n    const deleter = new shaka.offline.SessionDeleter();\n    const deletedSessionIds = await deleter.delete(drmConfig, net, sessions);\n    await sessionIdCell.remove(deletedSessionIds);\n    await sessionIdCell.add(sessions.filter(\n        (session) => !deletedSessionIds.includes(session.sessionId)));\n  }\n\n  /**\n   * Get the set of all streams in |manifest|.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @return {!Set.<shaka.extern.Stream>}\n   * @private\n   */\n  static getAllStreamsFromManifest_(manifest) {\n    /** @type {!Set.<shaka.extern.Stream>} */\n    const set = new Set();\n\n    for (const text of manifest.textStreams) {\n      set.add(text);\n    }\n\n    for (const image of manifest.imageStreams) {\n      set.add(image);\n    }\n\n    for (const variant of manifest.variants) {\n      if (variant.audio) {\n        set.add(variant.audio);\n      }\n      if (variant.video) {\n        set.add(variant.video);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * Go over a manifest and issue warnings for any suspicious properties.\n   *\n   * @param {shaka.extern.Manifest} manifest\n   * @private\n   */\n  static validateManifest_(manifest) {\n    const videos = new Set(manifest.variants.map((v) => v.video));\n    const audios = new Set(manifest.variants.map((v) => v.audio));\n    const texts = manifest.textStreams;\n\n    if (videos.size > 1) {\n      shaka.log.warning('Multiple video tracks selected to be stored');\n    }\n\n    for (const audio1 of audios) {\n      for (const audio2 of audios) {\n        if (audio1 != audio2 && audio1.language == audio2.language) {\n          shaka.log.warning(\n              'Similar audio tracks were selected to be stored',\n              audio1.id,\n              audio2.id);\n        }\n      }\n    }\n\n    for (const text1 of texts) {\n      for (const text2 of texts) {\n        if (text1 != text2 && text1.language == text2.language) {\n          shaka.log.warning(\n              'Similar text tracks were selected to be stored',\n              text1.id,\n              text2.id);\n        }\n      }\n    }\n  }\n};\n\nshaka.offline.Storage.defaultSystemIds_ = new Map()\n    .set('org.w3.clearkey', '1077efecc0b24d02ace33c1e52e2fb4b')\n    .set('com.widevine.alpha', 'edef8ba979d64acea3c827dcd51d21ed')\n    .set('com.microsoft.playready', '9a04f07998404286ab92e65be0885f95')\n    .set('com.microsoft.playready.recommendation',\n        '9a04f07998404286ab92e65be0885f95')\n    .set('com.microsoft.playready.software',\n        '9a04f07998404286ab92e65be0885f95')\n    .set('com.microsoft.playready.hardware',\n        '9a04f07998404286ab92e65be0885f95')\n    .set('com.adobe.primetime', 'f239e769efa348509c16a903c6932efb');\n\nshaka.Player.registerSupportPlugin('offline', shaka.offline.Storage.support);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill');\n\ngoog.require('shaka.log');\n\n\n/**\n * @summary A one-stop installer for all polyfills.\n * @see http://enwp.org/polyfill\n * @export\n */\nshaka.polyfill = class {\n  /**\n   * Install all polyfills.\n   * @export\n   */\n  static installAll() {\n    for (const polyfill of shaka.polyfill.polyfills_) {\n      try {\n        polyfill.callback();\n      } catch (error) {\n        shaka.log.alwaysWarn('Error installing polyfill!', error);\n      }\n    }\n  }\n\n  /**\n   * Registers a new polyfill to be installed.\n   *\n   * @param {function()} polyfill\n   * @param {number=} priority An optional number priority.  Higher priorities\n   *   will be executed before lower priority ones.  Default is 0.\n   * @export\n   */\n  static register(polyfill, priority) {\n    const newItem = {priority: priority || 0, callback: polyfill};\n    for (let i = 0; i < shaka.polyfill.polyfills_.length; i++) {\n      const item = shaka.polyfill.polyfills_[i];\n      if (item.priority < newItem.priority) {\n        shaka.polyfill.polyfills_.splice(i, 0, newItem);\n        return;\n      }\n    }\n    shaka.polyfill.polyfills_.push(newItem);\n  }\n};\n\n\n/**\n * Contains the polyfills that will be installed.\n * @private {!Array.<{priority: number, callback: function()}>}\n */\nshaka.polyfill.polyfills_ = [];\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.AbortController');\n\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\n\n/**\n * @summary A polyfill for systems that do not implement AbortController.\n * This is used both with the fetch API for HTTP requests and inside the HLS\n * parser.\n * @export\n * @extends AbortController\n */\nshaka.polyfill.AbortController = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (window.AbortController) {\n      // Not needed.\n      return;\n    }\n\n    window.AbortController = shaka.polyfill.AbortController;\n    window.AbortSignal = shaka.polyfill.AbortController.AbortSignal;\n  }\n\n  /** */\n  constructor() {\n    /** @private {!shaka.polyfill.AbortController.AbortSignal} */\n    this.signal_ = new shaka.polyfill.AbortController.AbortSignal();\n  }\n\n  /**\n   * @override\n   * @suppress {const|duplicate} Since the original is defined as \"const\", we\n   *   need this suppression to override it.\n   */\n  get signal() {\n    return this.signal_;\n  }\n\n  /**\n   * @param {*=} reason\n   * @override\n   */\n  abort(reason) {\n    this.signal_.doAbort_(reason);\n  }\n};\n\n/**\n * @summary A polyfill for AbortSignal, part of the AbortController API.\n * @implements {AbortSignal}\n */\nshaka.polyfill.AbortController.AbortSignal =\nclass extends shaka.util.FakeEventTarget {\n  /** */\n  constructor() {\n    super();\n\n    /** @private {boolean} */\n    this.aborted_ = false;\n\n    /** @private {*} */\n    this.reason_ = undefined;\n\n    /** @type {?function(!Event)} */\n    this.onabort = null;\n  }\n\n  /** @override */\n  get aborted() {\n    return this.aborted_;\n  }\n\n  /** @return {*} */\n  get reason() {\n    return this.reason_;\n  }\n\n  /**\n   * @param {*} reason\n   * @private\n   */\n  doAbort_(reason) {\n    if (this.aborted_) {\n      return;\n    }\n\n    this.aborted_ = true;\n    this.reason_ = reason;\n    if (this.reason_ === undefined) {\n      // This is equivalent to a native implementation.\n      this.reason_ = new DOMException(\n          'signal is aborted without reason', 'AbortError');\n    }\n\n    // According to MDN:\n    // \"Event type - A generic Event with no added properties.\"\n    const event = new shaka.util.FakeEvent('abort');\n    if (this.onabort) {\n      this.onabort(event);\n    }\n    this.dispatchEvent(event);\n  }\n\n\n  /**\n   * @param {*=} reason\n   * @return {!AbortSignal}\n   */\n  static abort(reason) {\n    const signal = new shaka.polyfill.AbortController.AbortSignal();\n    signal.doAbort_(reason);\n    return signal;\n  }\n\n  /**\n   * @param {number} timeMs\n   * @return {!AbortSignal}\n   */\n  static timeout(timeMs) {\n    const signal = new shaka.polyfill.AbortController.AbortSignal();\n\n    window.setTimeout(() => {\n      // This is equivalent to a native implementation.\n      signal.doAbort_(new DOMException('signal timed out', 'TimeoutError'));\n    }, timeMs);\n\n    return signal;\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.AbortController.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Aria');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to add support for the ARIAMixin interface mixin, for\n * browsers that do not implement it (e.g. Firefox).\n * Note that IE also does not support ARIAMixin, but this polyfill does not work\n * for that platform, as it relies on getters and setters.\n * @see https://w3c.github.io/aria/#ARIAMixin\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Element\n * @export\n */\nshaka.polyfill.Aria = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    // eslint-disable-next-line no-restricted-syntax\n    if (Object.getOwnPropertyDescriptor(Element.prototype, 'ariaHidden')) {\n      shaka.log.info('Using native ARIAMixin interface.');\n      return;\n    }\n    shaka.log.info('ARIAMixin interface not detected. Installing polyfill.');\n\n    // Define a list of all of the ARIAMixin properties that we have externs\n    // for.\n    const attributes = [\n      'ariaHidden',\n      'ariaLabel',\n      'ariaPressed',\n      'ariaSelected',\n    ];\n\n    // Add each attribute, one by one.\n    for (const attribute of attributes) {\n      shaka.polyfill.Aria.addARIAMixinAttribute_(attribute);\n    }\n  }\n\n  /**\n   * Adds an attribute with the given name.\n   * @param {string} name The name of the attribute, in camelCase.\n   * @private\n   */\n  static addARIAMixinAttribute_(name) {\n    const baseName = name.toLowerCase().replace(/^aria/, '');\n    // NOTE: All the attributes listed in the method above begin with \"aria\".\n    // However, to add extra protection against the possibility of XSS attacks\n    // through this method, this enforces \"aria-\" at the beginning of the\n    // snake-case name, even if somehow \"aria\" were missing from the input.\n    const snakeCaseName = `aria-${baseName}`;\n\n    /* eslint-disable no-restricted-syntax */\n    Object.defineProperty(Element.prototype, name, {\n      get() {\n        const element = /** @type {!Element} */ (this);\n        return element.getAttribute(snakeCaseName);\n      },\n      set(value) {\n        const element = /** @type {!Element} */ (this);\n        if (value == null || value == undefined) {\n          element.removeAttribute(snakeCaseName);\n        } else {\n          element.setAttribute(snakeCaseName, value);\n        }\n      },\n    });\n    /* eslint-enable no-restricted-syntax */\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Aria.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.EncryptionScheme');\n\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to add support for EncryptionScheme queries in EME.\n * @see https://wicg.github.io/encrypted-media-encryption-scheme/\n * @see https://github.com/w3c/encrypted-media/pull/457\n * @see https://github.com/shaka-project/eme-encryption-scheme-polyfill\n * @export\n */\nshaka.polyfill.EncryptionScheme = class {\n  /**\n   * Install the polyfill if needed.\n   *\n   * @suppress {missingRequire}\n   * @export\n   */\n  static install() {\n    EncryptionSchemePolyfills.install();\n  }\n};\n\n// Install at a low priority so that other EME polyfills go first.\nshaka.polyfill.register(shaka.polyfill.EncryptionScheme.install, -2);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Fullscreen');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to unify fullscreen APIs across browsers.\n * Many browsers have prefixed fullscreen methods on Element and document.\n * See {@link https://mzl.la/2K0xcHo Using fullscreen mode} on MDN for more\n * information.\n * @export\n */\nshaka.polyfill.Fullscreen = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.Document) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    let proto = Element.prototype;\n    proto.requestFullscreen = proto.requestFullscreen ||\n                              proto.mozRequestFullScreen ||\n                              proto.msRequestFullscreen ||\n                              proto.webkitRequestFullscreen;\n\n    // eslint-disable-next-line no-restricted-syntax\n    proto = Document.prototype;\n    proto.exitFullscreen = proto.exitFullscreen ||\n                           proto.mozCancelFullScreen ||\n                           proto.msExitFullscreen ||\n                           proto.webkitCancelFullScreen;\n\n    if (!('fullscreenElement' in document)) {\n      Object.defineProperty(document, 'fullscreenElement', {\n        get: () => {\n          return document.mozFullScreenElement ||\n                 document.msFullscreenElement ||\n                 document.webkitCurrentFullScreenElement ||\n                 document.webkitFullscreenElement;\n        },\n      });\n      Object.defineProperty(document, 'fullscreenEnabled', {\n        get: () => {\n          return document.mozFullScreenEnabled ||\n                 document.msFullscreenEnabled ||\n                 document.webkitFullscreenEnabled;\n        },\n      });\n    }\n\n    const proxy = shaka.polyfill.Fullscreen.proxyEvent_;\n    document.addEventListener('webkitfullscreenchange', proxy);\n    document.addEventListener('webkitfullscreenerror', proxy);\n    document.addEventListener('mozfullscreenchange', proxy);\n    document.addEventListener('mozfullscreenerror', proxy);\n    document.addEventListener('MSFullscreenChange', proxy);\n    document.addEventListener('MSFullscreenError', proxy);\n  }\n\n  /**\n   * Proxy fullscreen events after changing their name.\n   * @param {!Event} event\n   * @private\n   */\n  static proxyEvent_(event) {\n    const eventType = event.type.replace(/^(webkit|moz|MS)/, '').toLowerCase();\n\n    const newEvent = document.createEvent('Event');\n    newEvent.initEvent(eventType, event.bubbles, event.cancelable);\n\n    event.target.dispatchEvent(newEvent);\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Fullscreen.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.MediaCapabilities');\n\ngoog.require('shaka.log');\ngoog.require('shaka.media.Capabilities');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @summary A polyfill to provide navigator.mediaCapabilities on all browsers.\n * This is necessary for Tizen 3, Xbox One and possibly others we have yet to\n * discover.\n * @export\n */\nshaka.polyfill.MediaCapabilities = class {\n  /**\n   * Install the polyfill if needed.\n   * @suppress {const}\n   * @export\n   */\n  static install() {\n    // Since MediaCapabilities implementation is buggy on the Chromecast\n    // platform (see https://github.com/shaka-project/shaka-player/issues/4569),\n    // we should always install polyfills on all Chromecast models.\n    // TODO: re-evaluate MediaCapabilities in the future versions of Chromecast.\n    // Since MediaCapabilities implementation is buggy in Apple browsers, we\n    // should always install polyfill for Apple browsers.\n    // See: https://github.com/shaka-project/shaka-player/issues/3530\n    // TODO: re-evaluate MediaCapabilities in the future versions of Apple\n    // Browsers.\n    // Since MediaCapabilities implementation is buggy in PS5 browsers, we\n    // should always install polyfill for PS5 browsers.\n    // See: https://github.com/shaka-project/shaka-player/issues/3582\n    // TODO: re-evaluate MediaCapabilities in the future versions of PS5\n    // Browsers.\n    // Since MediaCapabilities implementation does not exist in PS4 browsers, we\n    // should always install polyfill.\n    // Since MediaCapabilities implementation is buggy in Tizen browsers, we\n    // should always install polyfill for Tizen browsers.\n    // Since MediaCapabilities implementation is buggy in WebOS browsers, we\n    // should always install polyfill for WebOS browsers.\n    // Since MediaCapabilities implementation is buggy in EOS browsers, we\n    // should always install polyfill for EOS browsers.\n    // Since MediaCapabilities implementation is buggy in Hisense browsers, we\n    // should always install polyfill for Hisense browsers.\n    let canUseNativeMCap = true;\n    if (shaka.util.Platform.isApple() ||\n        shaka.util.Platform.isPS5() ||\n        shaka.util.Platform.isPS4() ||\n        shaka.util.Platform.isWebOS() ||\n        shaka.util.Platform.isTizen() ||\n        shaka.util.Platform.isChromecast() ||\n        shaka.util.Platform.isEOS() ||\n        shaka.util.Platform.isHisense()) {\n      canUseNativeMCap = false;\n    }\n    if (canUseNativeMCap && navigator.mediaCapabilities) {\n      shaka.log.info(\n          'MediaCapabilities: Native mediaCapabilities support found.');\n      return;\n    }\n\n    shaka.log.info('MediaCapabilities: install');\n\n    if (!navigator.mediaCapabilities) {\n      navigator.mediaCapabilities = /** @type {!MediaCapabilities} */ ({});\n    }\n\n    // Keep the patched MediaCapabilities object from being garbage-collected in\n    // Safari.\n    // See https://github.com/shaka-project/shaka-player/issues/3696#issuecomment-1009472718\n    shaka.polyfill.MediaCapabilities.originalMcap =\n        navigator.mediaCapabilities;\n\n    navigator.mediaCapabilities.decodingInfo =\n        shaka.polyfill.MediaCapabilities.decodingInfo_;\n  }\n\n  /**\n   * @param {!MediaDecodingConfiguration} mediaDecodingConfig\n   * @return {!Promise.<!MediaCapabilitiesDecodingInfo>}\n   * @private\n   */\n  static async decodingInfo_(mediaDecodingConfig) {\n    const res = {\n      supported: false,\n      powerEfficient: true,\n      smooth: true,\n      keySystemAccess: null,\n      configuration: mediaDecodingConfig,\n    };\n\n    if (!mediaDecodingConfig) {\n      return res;\n    }\n\n    const videoConfig = mediaDecodingConfig['video'];\n    const audioConfig = mediaDecodingConfig['audio'];\n\n    const Capabilities = shaka.media.Capabilities;\n\n    if (mediaDecodingConfig.type == 'media-source') {\n      if (!shaka.util.Platform.supportsMediaSource()) {\n        return res;\n      }\n      // Use 'shaka.media.Capabilities.isTypeSupported'to check if\n      // the stream is supported.\n      // Cast platforms will additionally check canDisplayType(), which\n      // accepts extended MIME type parameters.\n      // See: https://github.com/shaka-project/shaka-player/issues/4726\n      if (videoConfig) {\n        let isSupported;\n        if (shaka.util.Platform.isChromecast()) {\n          isSupported =\n              shaka.polyfill.MediaCapabilities.canCastDisplayType_(videoConfig);\n        } else {\n          isSupported = Capabilities.isTypeSupported(videoConfig.contentType);\n        }\n        if (!isSupported) {\n          return res;\n        }\n      }\n\n      if (audioConfig) {\n        const contentType = audioConfig.contentType;\n        const isSupported = Capabilities.isTypeSupported(contentType);\n        if (!isSupported) {\n          return res;\n        }\n      }\n    } else if (mediaDecodingConfig.type == 'file') {\n      if (videoConfig) {\n        const contentType = videoConfig.contentType;\n        const isSupported = shaka.util.Platform.supportsMediaType(contentType);\n        if (!isSupported) {\n          return res;\n        }\n      }\n\n      if (audioConfig) {\n        const contentType = audioConfig.contentType;\n        const isSupported = shaka.util.Platform.supportsMediaType(contentType);\n        if (!isSupported) {\n          return res;\n        }\n      }\n    } else {\n      // Otherwise not supported.\n      return res;\n    }\n\n    if (!mediaDecodingConfig.keySystemConfiguration) {\n      // The variant is supported if it's unencrypted.\n      res.supported = true;\n      return Promise.resolve(res);\n    } else {\n      // Get the MediaKeySystemAccess for the key system.\n      // Convert the MediaDecodingConfiguration object to a\n      // MediaKeySystemConfiguration object.\n\n      /** @type {MediaCapabilitiesKeySystemConfiguration} */\n      const mediaCapkeySystemConfig =\n          mediaDecodingConfig.keySystemConfiguration;\n      const audioCapabilities = [];\n      const videoCapabilities = [];\n\n      if (mediaCapkeySystemConfig.audio) {\n        const capability = {\n          robustness: mediaCapkeySystemConfig.audio.robustness || '',\n          contentType: mediaDecodingConfig.audio.contentType,\n        };\n        audioCapabilities.push(capability);\n      }\n\n      if (mediaCapkeySystemConfig.video) {\n        const capability = {\n          robustness: mediaCapkeySystemConfig.video.robustness || '',\n          contentType: mediaDecodingConfig.video.contentType,\n        };\n        videoCapabilities.push(capability);\n      }\n\n      /** @type {MediaKeySystemConfiguration} */\n      const mediaKeySystemConfig = {\n        initDataTypes: [mediaCapkeySystemConfig.initDataType],\n        distinctiveIdentifier: mediaCapkeySystemConfig.distinctiveIdentifier,\n        persistentState: mediaCapkeySystemConfig.persistentState,\n        sessionTypes: mediaCapkeySystemConfig.sessionTypes,\n      };\n\n      // Only add the audio video capabilities if they have valid data.\n      // Otherwise the query will fail.\n      if (audioCapabilities.length) {\n        mediaKeySystemConfig.audioCapabilities = audioCapabilities;\n      }\n      if (videoCapabilities.length) {\n        mediaKeySystemConfig.videoCapabilities = videoCapabilities;\n      }\n\n      let keySystemAccess;\n      try {\n        keySystemAccess = await navigator.requestMediaKeySystemAccess(\n            mediaCapkeySystemConfig.keySystem, [mediaKeySystemConfig]);\n      } catch (e) {\n        shaka.log.info('navigator.requestMediaKeySystemAccess failed.');\n      }\n\n      if (keySystemAccess) {\n        res.supported = true;\n        res.keySystemAccess = keySystemAccess;\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Checks if the given media parameters of the video or audio streams are\n   * supported by the Cast platform.\n   * @param {!VideoConfiguration} videoConfig The 'video' field of the\n   *     MediaDecodingConfiguration.\n   * @return {boolean} `true` when the stream can be displayed on a Cast device.\n   * @private\n   */\n  static canCastDisplayType_(videoConfig) {\n    if (!(window.cast)) {\n      shaka.log.error('Expected cast namespace to be available!');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.CAST,\n          shaka.util.Error.Code.CAST_API_UNAVAILABLE);\n    } else if (!(cast.__platform__ && cast.__platform__.canDisplayType)) {\n      shaka.log.warning('Expected cast APIs to be available! Falling back to ' +\n          'shaka.media.Capabilities.isTypeSupported() for type support.');\n      return shaka.media.Capabilities.isTypeSupported(videoConfig.contentType);\n    }\n\n    let displayType = videoConfig.contentType;\n    if (videoConfig.width && videoConfig.height) {\n      displayType +=\n          `; width=${videoConfig.width}; height=${videoConfig.height}`;\n    }\n    if (videoConfig.framerate) {\n      displayType += `; framerate=${videoConfig.framerate}`;\n    }\n    if (videoConfig.transferFunction === 'pq') {\n      // A \"PQ\" transfer function indicates this is an HDR-capable stream;\n      // \"smpte2084\" is the published standard. We need to inform the platform\n      // this query is specifically for HDR.\n      displayType += '; eotf=smpte2084';\n    }\n    return cast.__platform__.canDisplayType(displayType);\n  }\n};\n\n/**\n * A copy of the MediaCapabilities instance, to prevent Safari from\n * garbage-collecting the polyfilled method on it.  We make it public and export\n * it to ensure that it is not stripped out by the compiler.\n *\n * @type {MediaCapabilities}\n * @export\n */\nshaka.polyfill.MediaCapabilities.originalMcap = null;\n\n// Install at a lower priority than MediaSource polyfill, so that we have\n// MediaSource available first.\nshaka.polyfill.register(shaka.polyfill.MediaCapabilities.install, -1);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysApple');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.MediaReadyState');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @summary A polyfill to implement modern, standardized EME on top of Apple's\n * prefixed EME in Safari.\n * @export\n */\nshaka.polyfill.PatchedMediaKeysApple = class {\n  /**\n   * Installs the polyfill if needed.\n   * @param {boolean=} enableUninstall enables uninstalling the polyfill\n   * @export\n   */\n  static install(enableUninstall = false) {\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    if (!window.HTMLVideoElement || !window.WebKitMediaKeys) {\n      // No HTML5 video or no prefixed EME.\n      return;\n    }\n\n    if (enableUninstall) {\n      PatchedMediaKeysApple.enableUninstall = true;\n      PatchedMediaKeysApple.originalHTMLMediaElementPrototypeMediaKeys =\n        /** @type {!Object} */ (\n          Object.getOwnPropertyDescriptor(\n              // eslint-disable-next-line no-restricted-syntax\n              HTMLMediaElement.prototype, 'mediaKeys',\n          )\n        );\n      PatchedMediaKeysApple.originalHTMLMediaElementPrototypeSetMediaKeys =\n          // eslint-disable-next-line no-restricted-syntax\n          HTMLMediaElement.prototype.setMediaKeys;\n      PatchedMediaKeysApple.originalWindowMediaKeys = window.MediaKeys;\n      PatchedMediaKeysApple.originalWindowMediaKeySystemAccess =\n          window.MediaKeySystemAccess;\n      PatchedMediaKeysApple.originalNavigatorRequestMediaKeySystemAccess =\n          navigator.requestMediaKeySystemAccess;\n    }\n\n    shaka.log.info('Using Apple-prefixed EME');\n\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysApple.setMediaKeys;\n\n    // Install patches\n    window.MediaKeys = PatchedMediaKeysApple.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysApple.MediaKeySystemAccess;\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysApple.requestMediaKeySystemAccess;\n\n    window.shakaMediaKeysPolyfill = true;\n  }\n\n  /**\n   * Uninstalls the polyfill if needed and enabled.\n   * @export\n   */\n  static uninstall() {\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    if (!PatchedMediaKeysApple.enableUninstall) {\n      return;\n    }\n\n    shaka.log.info('Un-installing Apple-prefixed EME');\n\n    PatchedMediaKeysApple.enableUninstall = false;\n    Object.defineProperty(\n        // eslint-disable-next-line no-restricted-syntax\n        HTMLMediaElement.prototype,\n        'mediaKeys',\n        PatchedMediaKeysApple.originalHTMLMediaElementPrototypeMediaKeys,\n    );\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysApple.originalHTMLMediaElementPrototypeSetMediaKeys;\n    window.MediaKeys = PatchedMediaKeysApple.originalWindowMediaKeys;\n    window.MediaKeySystemAccess =\n        PatchedMediaKeysApple.originalWindowMediaKeySystemAccess;\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysApple.originalNavigatorRequestMediaKeySystemAccess;\n\n    PatchedMediaKeysApple.originalWindowMediaKeys = null;\n    PatchedMediaKeysApple.originalWindowMediaKeySystemAccess = null;\n    PatchedMediaKeysApple.originalHTMLMediaElementPrototypeSetMediaKeys = null;\n    PatchedMediaKeysApple.originalNavigatorRequestMediaKeySystemAccess = null;\n    PatchedMediaKeysApple.originalHTMLMediaElementPrototypeMediaKeys = null;\n\n    window.shakaMediaKeysPolyfill = false;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysApple.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n    try {\n      const access = new PatchedMediaKeysApple.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysApple.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(\n          oldMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // in case there is an existing getter\n    this['mediaKeys'] = mediaKeys;  // work around read-only declaration\n\n    if (newMediaKeys) {\n      goog.asserts.assert(\n          newMediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      return newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Handler for the native media elements webkitneedkey event.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  static onWebkitNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitNeedKey_', event);\n\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n    const mediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysApple.MediaKeys} */(\n        this.mediaKeys);\n    goog.asserts.assert(mediaKeys instanceof PatchedMediaKeysApple.MediaKeys,\n        'non-polyfill instance of newMediaKeys');\n\n    goog.asserts.assert(event.initData != null, 'missing init data!');\n\n    // Convert the prefixed init data to match the native 'encrypted' event.\n    const uint8 = shaka.util.BufferUtils.toUint8(event.initData);\n    const dataview = shaka.util.BufferUtils.toDataView(uint8);\n    // The first part is a 4 byte little-endian int, which is the length of\n    // the second part.\n    const length = dataview.getUint32(\n        /* position= */ 0, /* littleEndian= */ true);\n    if (length + 4 != uint8.byteLength) {\n      throw new RangeError('Malformed FairPlay init data');\n    }\n    // The remainder is a UTF-16 skd URL.  Convert this to UTF-8 and pass on.\n    const str = shaka.util.StringUtils.fromUTF16(\n        uint8.subarray(4), /* littleEndian= */ true);\n    const initData = shaka.util.StringUtils.toUTF8(str);\n\n    // NOTE: Because \"this\" is a real EventTarget, the event we dispatch here\n    // must also be a real Event.\n    const event2 = new Event('encrypted');\n\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    encryptedEvent.initDataType = 'skd';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(initData);\n\n    this.dispatchEvent(event2);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    // Optimization: WebKitMediaKeys.isTypeSupported delays responses by a\n    // significant amount of time, possibly to discourage fingerprinting.\n    // Since we know only FairPlay is supported here, let's skip queries for\n    // anything else to speed up the process.\n    if (keySystem.startsWith('com.apple.fps')) {\n      for (const cfg of supportedConfigurations) {\n        const newCfg = this.checkConfig_(cfg);\n        if (newCfg) {\n          this.configuration_ = newCfg;\n          return;\n        }\n      }\n    }\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedKeySystemError = new Error('Unsupported keySystem');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedKeySystemError;\n  }\n\n  /**\n   * Check a single config for MediaKeySystemAccess.\n   *\n   * @param {MediaKeySystemConfiguration} cfg The requested config.\n   * @return {?MediaKeySystemConfiguration} A matching config we can support, or\n   *   null if the input is not supportable.\n   * @private\n   */\n  checkConfig_(cfg) {\n    if (cfg.persistentState == 'required') {\n      // Not supported by the prefixed API.\n      return null;\n    }\n\n    // Create a new config object and start adding in the pieces which we find\n    // support for.  We will return this from getConfiguration() later if\n    // asked.\n\n    /** @type {!MediaKeySystemConfiguration} */\n    const newCfg = {\n      'audioCapabilities': [],\n      'videoCapabilities': [],\n      // It is technically against spec to return these as optional, but we\n      // don't truly know their values from the prefixed API:\n      'persistentState': 'optional',\n      'distinctiveIdentifier': 'optional',\n      // Pretend the requested init data types are supported, since we don't\n      // really know that either:\n      'initDataTypes': cfg.initDataTypes,\n      'sessionTypes': ['temporary'],\n      'label': cfg.label,\n    };\n\n    // PatchedMediaKeysApple tests for key system availability through\n    // WebKitMediaKeys.isTypeSupported.\n    let ranAnyTests = false;\n    let success = false;\n\n    if (cfg.audioCapabilities) {\n      for (const cap of cfg.audioCapabilities) {\n        if (cap.contentType) {\n          ranAnyTests = true;\n\n          const contentType = cap.contentType.split(';')[0];\n          if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.audioCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (cfg.videoCapabilities) {\n      for (const cap of cfg.videoCapabilities) {\n        if (cap.contentType) {\n          ranAnyTests = true;\n\n          const contentType = cap.contentType.split(';')[0];\n          if (WebKitMediaKeys.isTypeSupported(this.keySystem, contentType)) {\n            newCfg.videoCapabilities.push(cap);\n            success = true;\n          }\n        }\n      }\n    }\n\n    if (!ranAnyTests) {\n      // If no specific types were requested, we check all common types to\n      // find out if the key system is present at all.\n      success = WebKitMediaKeys.isTypeSupported(this.keySystem, 'video/mp4');\n    }\n\n    if (success) {\n      return newCfg;\n    }\n    return null;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    const mediaKeys = new PatchedMediaKeysApple.MediaKeys(this.keySystem);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeys = class {\n  /** @param {string} keySystem */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys');\n\n    /** @private {!WebKitMediaKeys} */\n    this.nativeMediaKeys_ = new WebKitMediaKeys(keySystem);\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    // For now, only the 'temporary' type is supported.\n    if (sessionType != 'temporary') {\n      throw new TypeError('Session type ' + sessionType +\n      ' is unsupported on this platform.');\n    }\n\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    return new PatchedMediaKeysApple.MediaKeySession(\n        this.nativeMediaKeys_, sessionType);\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeys.setServerCertificate');\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   * @return {!Promise}\n   */\n  setMedia(media) {\n    // Alias\n    const PatchedMediaKeysApple = shaka.polyfill.PatchedMediaKeysApple;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    // It is valid for media to be null; null is used to flag that event\n    // handlers need to be cleaned up.\n    if (!media) {\n      return Promise.resolve();\n    }\n\n    // Intercept and translate these prefixed EME events.\n    this.eventManager_.listen(media, 'webkitneedkey',\n    /** @type {shaka.util.EventManager.ListenerType} */\n        (PatchedMediaKeysApple.onWebkitNeedKey_));\n\n    // Wrap native HTMLMediaElement.webkitSetMediaKeys with a Promise.\n    try {\n      // Some browsers require that readyState >=1 before mediaKeys can be\n      // set, so check this and wait for loadedmetadata if we are not in the\n      // correct state\n      shaka.util.MediaReadyState.waitForReadyState(media,\n          HTMLMediaElement.HAVE_METADATA,\n          this.eventManager_, () => {\n            media.webkitSetMediaKeys(this.nativeMediaKeys_);\n          });\n\n      return Promise.resolve();\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {WebKitMediaKeys} nativeMediaKeys\n   * @param {string} sessionType\n   */\n  constructor(nativeMediaKeys, sessionType) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession');\n    super();\n\n    /**\n     * The native MediaKeySession, which will be created in generateRequest.\n     * @private {WebKitMediaKeySession}\n     */\n    this.nativeMediaKeySession_ = null;\n\n    /** @private {WebKitMediaKeys} */\n    this.nativeMediaKeys_ = nativeMediaKeys;\n\n    // Promises that are resolved later\n    /** @private {shaka.util.PublicPromise} */\n    this.generateRequestPromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap();\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug(\n        'PatchedMediaKeysApple.MediaKeySession.generateRequest');\n\n    this.generateRequestPromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // This EME spec version requires a MIME content type as the 1st param to\n      // createSession, but doesn't seem to matter what the value is.\n      // It also only accepts Uint8Array, not ArrayBuffer, so explicitly make\n      // initData into a Uint8Array.\n      const session = this.nativeMediaKeys_.createSession(\n          'video/mp4', shaka.util.BufferUtils.toUint8(initData));\n      this.nativeMediaKeySession_ = session;\n      this.sessionId = session.sessionId || '';\n\n      // Attach session event handlers here.\n      this.eventManager_.listen(\n          this.nativeMediaKeySession_, 'webkitkeymessage',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyMessage_(event)));\n      this.eventManager_.listen(session, 'webkitkeyadded',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyAdded_(event)));\n      this.eventManager_.listen(session, 'webkitkeyerror',\n          /** @type {shaka.util.EventManager.ListenerType} */\n          ((event) => this.onWebkitKeyError_(event)));\n\n      this.updateKeyStatus_('status-pending');\n    } catch (exception) {\n      this.generateRequestPromise_.reject(exception);\n    }\n\n    return this.generateRequestPromise_;\n  }\n\n  /** @override */\n  load() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.load');\n\n    return Promise.reject(new Error('MediaKeySession.load not yet supported'));\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.update');\n\n    this.updatePromise_ = new shaka.util.PublicPromise();\n\n    try {\n      // Pass through to the native session.\n      this.nativeMediaKeySession_.update(\n          shaka.util.BufferUtils.toUint8(response));\n    } catch (exception) {\n      this.updatePromise_.reject(exception);\n    }\n\n    return this.updatePromise_;\n  }\n\n  /** @override */\n  close() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.close');\n\n    try {\n      // Pass through to the native session.\n      this.nativeMediaKeySession_.close();\n\n      this.closed.resolve();\n      this.eventManager_.removeAll();\n    } catch (exception) {\n      this.closed.reject(exception);\n    }\n\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysApple.MediaKeySession.remove');\n\n    return Promise.reject(new Error(\n        'MediaKeySession.remove is only applicable for persistent licenses, ' +\n        'which are not supported on this platform'));\n  }\n\n  /**\n   * Handler for the native keymessage event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyMessage_', event);\n\n    // We can now resolve this.generateRequestPromise, which should be non-null.\n    goog.asserts.assert(this.generateRequestPromise_,\n        'generateRequestPromise_ should be set before now!');\n    if (this.generateRequestPromise_) {\n      this.generateRequestPromise_.resolve();\n      this.generateRequestPromise_ = null;\n    }\n\n    const isNew = this.keyStatuses.getStatus() == undefined;\n\n    const data = new Map()\n        .set('messageType', isNew ? 'license-request' : 'license-renewal')\n        .set('message', shaka.util.BufferUtils.toArrayBuffer(event.message));\n    const event2 = new shaka.util.FakeEvent('message', data);\n\n    this.dispatchEvent(event2);\n  }\n\n  /**\n   * Handler for the native keyadded event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyAdded_', event);\n\n    // This shouldn't fire while we're in the middle of generateRequest,\n    // but if it does, we will need to change the logic to account for it.\n    goog.asserts.assert(!this.generateRequestPromise_,\n        'Key added during generate!');\n\n    // We can now resolve this.updatePromise, which should be non-null.\n    goog.asserts.assert(this.updatePromise_,\n        'updatePromise_ should be set before now!');\n    if (this.updatePromise_) {\n      this.updateKeyStatus_('usable');\n      this.updatePromise_.resolve();\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Handler for the native keyerror event on WebKitMediaKeySession.\n   *\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysApple.onWebkitKeyError_', event);\n\n    const error = new Error('EME PatchedMediaKeysApple key error');\n    error['errorCode'] = this.nativeMediaKeySession_.error;\n\n    if (this.generateRequestPromise_ != null) {\n      this.generateRequestPromise_.reject(error);\n      this.generateRequestPromise_ = null;\n    } else if (this.updatePromise_ != null) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // Unexpected error - map native codes to standardised key statuses.\n      // Possible values of this.nativeMediaKeySession_.error.code:\n      // MEDIA_KEYERR_UNKNOWN        = 1\n      // MEDIA_KEYERR_CLIENT         = 2\n      // MEDIA_KEYERR_SERVICE        = 3\n      // MEDIA_KEYERR_OUTPUT         = 4\n      // MEDIA_KEYERR_HARDWARECHANGE = 5\n      // MEDIA_KEYERR_DOMAIN         = 6\n\n      switch (this.nativeMediaKeySession_.error.code) {\n        case WebKitMediaKeyError.MEDIA_KEYERR_OUTPUT:\n        case WebKitMediaKeyError.MEDIA_KEYERR_HARDWARECHANGE:\n          this.updateKeyStatus_('output-not-allowed');\n          break;\n        default:\n          this.updateKeyStatus_('internal-error');\n          break;\n      }\n    }\n  }\n\n  /**\n   * Updates key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n};\n\n\n/**\n * @summary An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap = class {\n  /** */\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for the compiler.');\n  }\n};\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.MediaSource');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.MimeUtils');\ngoog.require('shaka.util.Platform');\n\n/**\n * @summary A polyfill to patch MSE bugs.\n * @export\n */\nshaka.polyfill.MediaSource = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('MediaSource.install');\n\n    // MediaSource bugs are difficult to detect without checking for the\n    // affected platform.  SourceBuffer is not always exposed on window, for\n    // example, and instances are only accessible after setting up MediaSource\n    // on a video element.  Because of this, we use UA detection and other\n    // platform detection tricks to decide which patches to install.\n    const safariVersion = shaka.util.Platform.safariVersion();\n\n    if (!window.MediaSource) {\n      shaka.log.info('No MSE implementation available.');\n    } else if (window.cast && cast.__platform__ &&\n               cast.__platform__.canDisplayType) {\n      shaka.log.info('Patching Chromecast MSE bugs.');\n      // Chromecast cannot make accurate determinations via isTypeSupported.\n      shaka.polyfill.MediaSource.patchCastIsTypeSupported_();\n    } else if (safariVersion) {\n      // NOTE:  shaka.Player.isBrowserSupported() has its own restrictions on\n      // Safari version.\n      if (safariVersion <= 12) {\n        shaka.log.info('Patching Safari 11 & 12 MSE bugs.');\n        // Safari 11 & 12 do not correctly implement abort() on SourceBuffer.\n        // Calling abort() before appending a segment causes that segment to be\n        // incomplete in the buffer.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n        shaka.polyfill.MediaSource.stubAbort_();\n\n        // If you remove up to a keyframe, Safari 11 & 12 incorrectly will also\n        // remove that keyframe and the content up to the next.\n        // Offsetting the end of the removal range seems to help.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=177884\n        shaka.polyfill.MediaSource.patchRemovalRange_();\n      } else {\n        shaka.log.info('Patching Safari 13 MSE bugs.');\n        // Safari 13 does not correctly implement abort() on SourceBuffer.\n        // Calling abort() before appending a segment causes that segment to be\n        // incomplete in the buffer.\n        // Bug filed: https://bugs.webkit.org/show_bug.cgi?id=165342\n        shaka.polyfill.MediaSource.stubAbort_();\n      }\n    } else if (shaka.util.Platform.isTizen2() ||\n        shaka.util.Platform.isTizen3() ||\n        shaka.util.Platform.isTizen4()) {\n      shaka.log.info('Rejecting Opus.');\n      // Tizen's implementation of MSE does not work well with opus. To prevent\n      // the player from trying to play opus on Tizen, we will override media\n      // source to always reject opus content.\n      shaka.polyfill.MediaSource.rejectCodec_('opus');\n    } else {\n      shaka.log.info('Using native MSE as-is.');\n    }\n\n    if (window.MediaSource &&\n        MediaSource.isTypeSupported('video/webm; codecs=\"vp9\"') &&\n        !MediaSource.isTypeSupported('video/webm; codecs=\"vp09.00.10.08\"')) {\n      shaka.log.info('Patching vp09 support queries.');\n      // Only the old, deprecated style of VP9 codec strings is supported.\n      // This occurs on older smart TVs.\n      // Patch isTypeSupported to translate the new strings into the old one.\n      shaka.polyfill.MediaSource.patchVp09_();\n    }\n  }\n\n  /**\n   * Stub out abort().  On some buggy MSE implementations, calling abort()\n   * causes various problems.\n   *\n   * @private\n   */\n  static stubAbort_() {\n    /* eslint-disable no-restricted-syntax */\n    const addSourceBuffer = MediaSource.prototype.addSourceBuffer;\n    MediaSource.prototype.addSourceBuffer = function(...varArgs) {\n      const sourceBuffer = addSourceBuffer.apply(this, varArgs);\n      sourceBuffer.abort = function() {}; // Stub out for buggy implementations.\n      return sourceBuffer;\n    };\n    /* eslint-enable no-restricted-syntax */\n  }\n\n  /**\n   * Patch remove().  On Safari 11, if you call remove() to remove the content\n   * up to a keyframe, Safari will also remove the keyframe and all of the data\n   * up to the next one. For example, if the keyframes are at 0s, 5s, and 10s,\n   * and you tried to remove 0s-5s, it would instead remove 0s-10s.\n   *\n   * Offsetting the end of the range seems to be a usable workaround.\n   *\n   * @private\n   */\n  static patchRemovalRange_() {\n    // eslint-disable-next-line no-restricted-syntax\n    const originalRemove = SourceBuffer.prototype.remove;\n\n    // eslint-disable-next-line no-restricted-syntax\n    SourceBuffer.prototype.remove = function(startTime, endTime) {\n      // eslint-disable-next-line no-restricted-syntax\n      return originalRemove.call(this, startTime, endTime - 0.001);\n    };\n  }\n\n  /**\n   * Patch |MediaSource.isTypeSupported| to always reject |codec|. This is used\n   * when we know that we are on a platform that does not work well with a given\n   * codec.\n   *\n   * @param {string} codec\n   * @private\n   */\n  static rejectCodec_(codec) {\n    const isTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      const actualCodec = shaka.util.MimeUtils.getCodecBase(mimeType);\n      return actualCodec != codec && isTypeSupported(mimeType);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to chain to a private API on the Chromecast which\n   * can query for support of detailed content parameters.\n   *\n   * @private\n   */\n  static patchCastIsTypeSupported_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Parse the basic MIME type from its parameters.\n      const pieces = mimeType.split(/ *; */);\n      pieces.shift();  // Remove basic MIME type from pieces.\n\n      const hasCodecs = pieces.some((piece) => piece.startsWith('codecs='));\n      if (!hasCodecs) {\n        // Though the original reason for this special case was not documented,\n        // it is presumed to be because the platform won't accept a MIME type\n        // without codecs in canDisplayType.  It is valid, however, in\n        // isTypeSupported.\n        return originalIsTypeSupported(mimeType);\n      }\n\n      // Only canDisplayType can check extended MIME type parameters on this\n      // platform (such as frame rate, resolution, etc).\n      // In previous versions of this polyfill, the MIME type parameters were\n      // manipulated, filtered, or extended.  This is no longer true, so we pass\n      // the full MIME type to the platform as we received it.\n      return cast.__platform__.canDisplayType(mimeType);\n    };\n  }\n\n  /**\n   * Patch isTypeSupported() to translate vp09 codec strings into vp9, to allow\n   * such content to play on older smart TVs.\n   *\n   * @private\n   */\n  static patchVp09_() {\n    const originalIsTypeSupported = MediaSource.isTypeSupported;\n\n    if (shaka.util.Platform.isWebOS()) {\n      // Don't do this on LG webOS as otherwise it is unable\n      // to play vp09 at all.\n      return;\n    }\n\n    MediaSource.isTypeSupported = (mimeType) => {\n      // Split the MIME type into its various parameters.\n      const pieces = mimeType.split(/ *; */);\n\n      const codecsIndex =\n          pieces.findIndex((piece) => piece.startsWith('codecs='));\n      if (codecsIndex < 0) {\n        // No codec? Call the original without modifying the MIME type.\n        return originalIsTypeSupported(mimeType);\n      }\n\n      const codecsParam = pieces[codecsIndex];\n      const codecs = codecsParam\n          .replace('codecs=', '').replace(/\"/g, '').split(/\\s*,\\s*/);\n\n      const vp09Index = codecs.findIndex(\n          (codecName) => codecName.startsWith('vp09'));\n      if (vp09Index >= 0) {\n        // vp09? Replace it with vp9.\n        codecs[vp09Index] = 'vp9';\n        pieces[codecsIndex] = 'codecs=\"' + codecs.join(',') + '\"';\n        mimeType = pieces.join('; ');\n      }\n\n      return originalIsTypeSupported(mimeType);\n    };\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.MediaSource.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.Orientation');\n\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill for systems that do not implement screen.orientation.\n * For now, this only handles systems that implement the deprecated\n * window.orientation feature... e.g. iPad.\n * @export\n */\nshaka.polyfill.Orientation = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (screen.orientation) {\n      // Not needed.\n      return;\n    }\n\n    // There is no way to check to see if the 'orientationchange' event exists\n    // on window, which could theoretically lead to this making a\n    // screen.orientation object that doesn't actually work.\n    // However, it looks like all platforms that support the deprecated\n    // window.orientation feature also support that event.\n    if (window.orientation != undefined) {\n      shaka.polyfill.Orientation.installBasedOnWindowMethods_();\n    }\n  }\n\n  /**\n   * Makes a polyfill for orientation, based on window methods.\n   * Note that some of the features this is based on are deprecated, so this\n   * will not necessarily work on all platforms.\n   * @private\n   */\n  static installBasedOnWindowMethods_() {\n    const orientation = new shaka.polyfill.Orientation.FakeOrientation();\n    screen.orientation = /** @type {!ScreenOrientation} */ (orientation);\n    const setValues = () => {\n      switch (window.orientation) {\n        case -90:\n          orientation.type = 'landscape-secondary';\n          orientation.angle = 270;\n          break;\n        case 0:\n          orientation.type = 'portrait-primary';\n          orientation.angle = 0;\n          break;\n        case 90:\n          orientation.type = 'landscape-primary';\n          orientation.angle = 90;\n          break;\n        case 180:\n          orientation.type = 'portrait-secondary';\n          orientation.angle = 180;\n          break;\n      }\n    };\n\n    setValues();\n    window.addEventListener('orientationchange', () => {\n      setValues();\n      orientation.dispatchChangeEvent();\n    });\n  }\n};\n\n\nshaka.polyfill.Orientation.FakeOrientation =\nclass extends shaka.util.FakeEventTarget {\n  /** */\n  constructor() {\n    super();\n\n    /** @type {string} */\n    this.type = '';\n\n    /** @type {number} */\n    this.angle = 0;\n  }\n\n  /** Dispatch a 'change' event. */\n  dispatchChangeEvent() {\n    const event = new shaka.util.FakeEvent('change');\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * @param {string} orientation\n   * @return {!Promise}\n   */\n  lock(orientation) {\n    /**\n     * @param {string} orientation\n     * @return {boolean}\n     */\n    const lockOrientation = (orientation) => {\n      if (screen.lockOrientation) {\n        return screen.lockOrientation(orientation);\n      }\n      if (screen.mozLockOrientation) {\n        return screen.mozLockOrientation(orientation);\n      }\n      if (screen.msLockOrientation) {\n        return screen.msLockOrientation(orientation);\n      }\n      return false;\n    };\n\n    let success = false;\n    // The set of input strings for screen.orientation.lock and for\n    // screen.lockOrientation are almost, but not entirely, the same.\n    switch (orientation) {\n      case 'natural':\n        success = lockOrientation('default');\n        break;\n      case 'any':\n        // It's not quite clear what locking the screen orientation to 'any'\n        // is supposed to mean... presumably, that's equivalent to not being\n        // locked?\n        success = true;\n        this.unlock();\n        break;\n      default:\n        success = lockOrientation(orientation);\n        break;\n    }\n    // According to the docs, there \"may be a delay\" between the\n    // lockOrientation method being called and the screen actually being\n    // locked.  Unfortunately, without any idea as to how long that delay is,\n    // and with no events to listen for, we cannot account for it here.\n    if (success) {\n      return Promise.resolve();\n    }\n    // Either locking was not available, or the process failed... either way,\n    // reject this with a mock error.\n    // This should be a DOMException, but there is not a public constructor for\n    // that.  So we make this look-alike instead.\n    const unsupportedKeySystemError =\n        new Error('screen.orientation.lock() is not available on this device');\n    unsupportedKeySystemError.name = 'NotSupportedError';\n    unsupportedKeySystemError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    return Promise.reject(unsupportedKeySystemError);\n  }\n\n  /** Unlock the screen orientation. */\n  unlock() {\n    // screen.unlockOrientation has a return value, but\n    // screen.orientation.unlock does not. So ignore the return value.\n    if (screen.unlockOrientation) {\n      screen.unlockOrientation();\n    } else if (screen.mozUnlockOrientation) {\n      screen.mozUnlockOrientation();\n    } else if (screen.msUnlockOrientation) {\n      screen.msUnlockOrientation();\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Orientation.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysNop');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to stub out\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on browsers without\n * EME.\n * All methods will fail.\n * @export\n */\nshaka.polyfill.PatchedMediaKeysNop = class {\n  /**\n   * Installs the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    shaka.log.info('EME not available.');\n\n    // Alias.\n    const PatchedMediaKeysNop = shaka.polyfill.PatchedMediaKeysNop;\n\n    // Install patches.\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysNop.requestMediaKeySystemAccess;\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys = PatchedMediaKeysNop.setMediaKeys;\n    // These are not usable, but allow Player.isBrowserSupported to pass.\n    window.MediaKeys = PatchedMediaKeysNop.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysNop.MediaKeySystemAccess;\n\n    window.shakaMediaKeysPolyfill = true;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysNop.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    return Promise.reject(new Error(\n        'The key system specified is not supported.'));\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysNop.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    if (mediaKeys == null) {\n      return Promise.resolve();\n    }\n\n    return Promise.reject(new Error('MediaKeys not supported.'));\n  }\n};\n\n\n/**\n * An unusable constructor for MediaKeys.\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeys = class {\n  /** */\n  constructor() {\n    throw new TypeError('Illegal constructor.');\n  }\n\n  /** @override */\n  createSession() {}\n\n  /** @override */\n  setServerCertificate() {}\n};\n\n\n/**\n * An unusable constructor for MediaKeySystemAccess.\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess = class {\n  /** */\n  constructor() {\n    /** @override */\n    this.keySystem = '';  // For the compiler.\n\n    throw new TypeError('Illegal constructor.');\n  }\n\n  /** @override */\n  getConfiguration() {}\n\n  /** @override */\n  createMediaKeys() {}\n};\n\n\n// A low priority ensures this is the last and acts as a fallback.\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysNop.install, -10);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PatchedMediaKeysWebkit');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.media.DrmEngine');\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.EventManager');\ngoog.require('shaka.util.FakeEvent');\ngoog.require('shaka.util.FakeEventTarget');\ngoog.require('shaka.util.PublicPromise');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.Timer');\ngoog.require('shaka.util.Uint8ArrayUtils');\n\n\n/**\n * @summary A polyfill to implement\n * {@link https://bit.ly/EmeMar15 EME draft 12 March 2015} on top of\n * webkit-prefixed {@link https://bit.ly/Eme01b EME v0.1b}.\n * @export\n */\nshaka.polyfill.PatchedMediaKeysWebkit = class {\n  /**\n   * Installs the polyfill if needed.\n   * @export\n   */\n  static install() {\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (!window.HTMLVideoElement ||\n        (navigator.requestMediaKeySystemAccess &&\n         // eslint-disable-next-line no-restricted-syntax\n         MediaKeySystemAccess.prototype.getConfiguration)) {\n      return;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    if (HTMLMediaElement.prototype.webkitGenerateKeyRequest) {\n      shaka.log.info('Using webkit-prefixed EME v0.1b');\n      PatchedMediaKeysWebkit.prefix_ = 'webkit';\n      // eslint-disable-next-line no-restricted-syntax\n    } else if (HTMLMediaElement.prototype.generateKeyRequest) {\n      shaka.log.info('Using nonprefixed EME v0.1b');\n    } else {\n      return;\n    }\n\n    goog.asserts.assert(\n        // eslint-disable-next-line no-restricted-syntax\n        HTMLMediaElement.prototype[\n            PatchedMediaKeysWebkit.prefixApi_('generateKeyRequest')],\n        'PatchedMediaKeysWebkit APIs not available!');\n\n    // Install patches.\n    navigator.requestMediaKeySystemAccess =\n        PatchedMediaKeysWebkit.requestMediaKeySystemAccess;\n    // Delete mediaKeys to work around strict mode compatibility issues.\n    // eslint-disable-next-line no-restricted-syntax\n    delete HTMLMediaElement.prototype['mediaKeys'];\n    // Work around read-only declaration for mediaKeys by using a string.\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype['mediaKeys'] = null;\n    // eslint-disable-next-line no-restricted-syntax\n    HTMLMediaElement.prototype.setMediaKeys =\n        PatchedMediaKeysWebkit.setMediaKeys;\n    window.MediaKeys = PatchedMediaKeysWebkit.MediaKeys;\n    window.MediaKeySystemAccess = PatchedMediaKeysWebkit.MediaKeySystemAccess;\n\n    window.shakaMediaKeysPolyfill = true;\n  }\n\n  /**\n   * Prefix the api with the stored prefix.\n   *\n   * @param {string} api\n   * @return {string}\n   * @private\n   */\n  static prefixApi_(api) {\n    const prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n    if (prefix) {\n      return prefix + api.charAt(0).toUpperCase() + api.slice(1);\n    }\n    return api;\n  }\n\n  /**\n   * An implementation of navigator.requestMediaKeySystemAccess.\n   * Retrieves a MediaKeySystemAccess object.\n   *\n   * @this {!Navigator}\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   * @return {!Promise.<!MediaKeySystemAccess>}\n   */\n  static requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysWebkit.requestMediaKeySystemAccess');\n    goog.asserts.assert(this == navigator,\n        'bad \"this\" for requestMediaKeySystemAccess');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n    try {\n      const access = new PatchedMediaKeysWebkit.MediaKeySystemAccess(\n          keySystem, supportedConfigurations);\n      return Promise.resolve(/** @type {!MediaKeySystemAccess} */ (access));\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n  }\n\n  /**\n   * An implementation of HTMLMediaElement.prototype.setMediaKeys.\n   * Attaches a MediaKeys object to the media element.\n   *\n   * @this {!HTMLMediaElement}\n   * @param {MediaKeys} mediaKeys\n   * @return {!Promise}\n   */\n  static setMediaKeys(mediaKeys) {\n    shaka.log.debug('PatchedMediaKeysWebkit.setMediaKeys');\n    goog.asserts.assert(this instanceof HTMLMediaElement,\n        'bad \"this\" for setMediaKeys');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    const newMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n        mediaKeys);\n    const oldMediaKeys =\n    /** @type {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys} */ (\n        this.mediaKeys);\n\n    if (oldMediaKeys && oldMediaKeys != newMediaKeys) {\n      goog.asserts.assert(\n          oldMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n          'non-polyfill instance of oldMediaKeys');\n      // Have the old MediaKeys stop listening to events on the video tag.\n      oldMediaKeys.setMedia(null);\n    }\n\n    delete this['mediaKeys'];  // In case there is an existing getter.\n    this['mediaKeys'] = mediaKeys;  // Work around the read-only declaration.\n\n    if (newMediaKeys) {\n      goog.asserts.assert(\n          newMediaKeys instanceof PatchedMediaKeysWebkit.MediaKeys,\n          'non-polyfill instance of newMediaKeys');\n      newMediaKeys.setMedia(this);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * For some of this polyfill's implementation, we need to query a video\n   * element.  But for some embedded systems, it is memory-expensive to create\n   * multiple video elements.  Therefore, we check the document to see if we can\n   * borrow one to query before we fall back to creating one temporarily.\n   *\n   * @return {!HTMLVideoElement}\n   * @private\n   */\n  static getVideoElement_() {\n    const videos = document.getElementsByTagName('video');\n    const video = videos.length ? videos[0] : document.createElement('video');\n    return /** @type {!HTMLVideoElement} */(video);\n  }\n};\n\n\n/**\n * An implementation of MediaKeySystemAccess.\n *\n * @implements {MediaKeySystemAccess}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess = class {\n  /**\n   * @param {string} keySystem\n   * @param {!Array.<!MediaKeySystemConfiguration>} supportedConfigurations\n   */\n  constructor(keySystem, supportedConfigurations) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySystemAccess');\n\n    /** @type {string} */\n    this.keySystem = keySystem;\n\n    /** @private {string} */\n    this.internalKeySystem_ = keySystem;\n\n    /** @private {!MediaKeySystemConfiguration} */\n    this.configuration_;\n\n    // This is only a guess, since we don't really know from the prefixed API.\n    let allowPersistentState = false;\n\n    if (keySystem == 'org.w3.clearkey') {\n      // ClearKey's string must be prefixed in v0.1b.\n      this.internalKeySystem_ = 'webkit-org.w3.clearkey';\n      // ClearKey doesn't support persistence.\n      allowPersistentState = false;\n    }\n\n    let success = false;\n    const tmpVideo = shaka.polyfill.PatchedMediaKeysWebkit.getVideoElement_();\n    for (const cfg of supportedConfigurations) {\n      // Create a new config object and start adding in the pieces which we\n      // find support for.  We will return this from getConfiguration() if\n      // asked.\n      /** @type {!MediaKeySystemConfiguration} */\n      const newCfg = {\n        'audioCapabilities': [],\n        'videoCapabilities': [],\n        // It is technically against spec to return these as optional, but we\n        // don't truly know their values from the prefixed API:\n        'persistentState': 'optional',\n        'distinctiveIdentifier': 'optional',\n        // Pretend the requested init data types are supported, since we don't\n        // really know that either:\n        'initDataTypes': cfg.initDataTypes,\n        'sessionTypes': ['temporary'],\n        'label': cfg.label,\n      };\n\n      // v0.1b tests for key system availability with an extra argument on\n      // canPlayType.\n      let ranAnyTests = false;\n      if (cfg.audioCapabilities) {\n        for (const cap of cfg.audioCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            // In Chrome <= 40, if you ask about Widevine-encrypted audio\n            // support, you get a false-negative when you specify codec\n            // information. Work around this by stripping codec info for audio\n            // types.\n            const contentType = cap.contentType.split(';')[0];\n            if (tmpVideo.canPlayType(contentType, this.internalKeySystem_)) {\n              newCfg.audioCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n      if (cfg.videoCapabilities) {\n        for (const cap of cfg.videoCapabilities) {\n          if (cap.contentType) {\n            ranAnyTests = true;\n            if (tmpVideo.canPlayType(\n                cap.contentType, this.internalKeySystem_)) {\n              newCfg.videoCapabilities.push(cap);\n              success = true;\n            }\n          }\n        }\n      }\n\n      if (!ranAnyTests) {\n        // If no specific types were requested, we check all common types to\n        // find out if the key system is present at all.\n        success =\n            tmpVideo.canPlayType('video/mp4', this.internalKeySystem_) ||\n            tmpVideo.canPlayType('video/webm', this.internalKeySystem_);\n      }\n      if (cfg.persistentState == 'required') {\n        if (allowPersistentState) {\n          newCfg.persistentState = 'required';\n          newCfg.sessionTypes = ['persistent-license'];\n        } else {\n          success = false;\n        }\n      }\n\n      if (success) {\n        this.configuration_ = newCfg;\n        return;\n      }\n    }  // for each cfg in supportedConfigurations\n\n    let message = 'Unsupported keySystem';\n    if (keySystem == 'org.w3.clearkey' || keySystem == 'com.widevine.alpha') {\n      message = 'None of the requested configurations were supported.';\n    }\n\n    // According to the spec, this should be a DOMException, but there is not a\n    // public constructor for that.  So we make this look-alike instead.\n    const unsupportedError = new Error(message);\n    unsupportedError.name = 'NotSupportedError';\n    unsupportedError['code'] = DOMException.NOT_SUPPORTED_ERR;\n    throw unsupportedError;\n  }\n\n  /** @override */\n  createMediaKeys() {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySystemAccess.createMediaKeys');\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n    const mediaKeys =\n    new PatchedMediaKeysWebkit.MediaKeys(this.internalKeySystem_);\n    return Promise.resolve(/** @type {!MediaKeys} */ (mediaKeys));\n  }\n\n  /** @override */\n  getConfiguration() {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySystemAccess.getConfiguration');\n    return this.configuration_;\n  }\n};\n\n\n/**\n * An implementation of MediaKeys.\n *\n * @implements {MediaKeys}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeys = class {\n  /**\n   * @param {string} keySystem\n   */\n  constructor(keySystem) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys');\n\n    /** @private {string} */\n    this.keySystem_ = keySystem;\n\n    /** @private {HTMLMediaElement} */\n    this.media_ = null;\n\n    /** @private {!shaka.util.EventManager} */\n    this.eventManager_ = new shaka.util.EventManager();\n\n    /**\n     * @private {Array.<!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n     */\n    this.newSessions_ = [];\n\n    /**\n     * @private {!Map.<string,\n     *                 !shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession>}\n     */\n    this.sessionMap_ = new Map();\n  }\n\n  /**\n   * @param {HTMLMediaElement} media\n   * @protected\n   */\n  setMedia(media) {\n    this.media_ = media;\n\n    // Remove any old listeners.\n    this.eventManager_.removeAll();\n\n    const prefix = shaka.polyfill.PatchedMediaKeysWebkit.prefix_;\n    if (media) {\n      // Intercept and translate these prefixed EME events.\n      this.eventManager_.listen(media, prefix + 'needkey',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitNeedKey_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keymessage',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyMessage_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keyadded',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyAdded_(event)));\n\n      this.eventManager_.listen(media, prefix + 'keyerror',\n      /** @type {shaka.util.EventManager.ListenerType} */ (\n            (event) => this.onWebkitKeyError_(event)));\n    }\n  }\n\n  /** @override */\n  createSession(sessionType) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.createSession');\n\n    sessionType = sessionType || 'temporary';\n    if (sessionType != 'temporary' && sessionType != 'persistent-license') {\n      throw new TypeError('Session type ' + sessionType +\n                      ' is unsupported on this platform.');\n    }\n\n    // Alias.\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    // Unprefixed EME allows for session creation without a video tag or src.\n    // Prefixed EME requires both a valid HTMLMediaElement and a src.\n    const media = this.media_ || /** @type {!HTMLMediaElement} */(\n      document.createElement('video'));\n    if (!media.src) {\n      media.src = 'about:blank';\n    }\n\n    const session = new PatchedMediaKeysWebkit.MediaKeySession(\n        media, this.keySystem_, sessionType);\n    this.newSessions_.push(session);\n    return session;\n  }\n\n  /** @override */\n  setServerCertificate(serverCertificate) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeys.setServerCertificate');\n\n    // There is no equivalent in v0.1b, so return failure.\n    return Promise.resolve(false);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @suppress {constantProperty} We reassign what would be const on a real\n   *   MediaEncryptedEvent, but in our look-alike event.\n   * @private\n   */\n  onWebkitNeedKey_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitNeedKey_', event);\n    goog.asserts.assert(this.media_, 'media_ not set in onWebkitNeedKey_');\n\n    const event2 = new CustomEvent('encrypted');\n    const encryptedEvent =\n      /** @type {!MediaEncryptedEvent} */(/** @type {?} */(event2));\n    // initDataType is not used by v0.1b EME, so any valid value is fine here.\n    encryptedEvent.initDataType = 'cenc';\n    encryptedEvent.initData = shaka.util.BufferUtils.toArrayBuffer(\n        event.initData);\n\n    this.media_.dispatchEvent(event2);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyMessage_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyMessage_', event);\n\n    const session = this.findSession_(event.sessionId);\n    if (!session) {\n      shaka.log.error('Session not found', event.sessionId);\n      return;\n    }\n\n    const isNew = session.keyStatuses.getStatus() == undefined;\n\n    const data = new Map()\n        .set('messageType', isNew ? 'licenserequest' : 'licenserenewal')\n        .set('message', event.message);\n    const event2 = new shaka.util.FakeEvent('message', data);\n\n    session.generated();\n    session.dispatchEvent(event2);\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyAdded_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyAdded_', event);\n\n    const session = this.findSession_(event.sessionId);\n    goog.asserts.assert(\n        session, 'unable to find session in onWebkitKeyAdded_');\n    if (session) {\n      session.ready();\n    }\n  }\n\n  /**\n   * @param {!MediaKeyEvent} event\n   * @private\n   */\n  onWebkitKeyError_(event) {\n    shaka.log.debug('PatchedMediaKeysWebkit.onWebkitKeyError_', event);\n\n    const session = this.findSession_(event.sessionId);\n    goog.asserts.assert(\n        session, 'unable to find session in onWebkitKeyError_');\n    if (session) {\n      session.handleError(event);\n    }\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession}\n   * @private\n   */\n  findSession_(sessionId) {\n    let session = this.sessionMap_.get(sessionId);\n    if (session) {\n      shaka.log.debug(\n          'PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n      return session;\n    }\n\n    session = this.newSessions_.shift();\n    if (session) {\n      session.sessionId = sessionId;\n      this.sessionMap_.set(sessionId, session);\n      shaka.log.debug(\n          'PatchedMediaKeysWebkit.MediaKeys.findSession_', session);\n      return session;\n    }\n\n    return null;\n  }\n};\n\n\n/**\n * An implementation of MediaKeySession.\n *\n * @implements {MediaKeySession}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession =\nclass extends shaka.util.FakeEventTarget {\n  /**\n   * @param {!HTMLMediaElement} media\n   * @param {string} keySystem\n   * @param {string} sessionType\n   */\n  constructor(media, keySystem, sessionType) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession');\n    super();\n\n    /** @private {!HTMLMediaElement} */\n    this.media_ = media;\n\n    /** @private {boolean} */\n    this.initialized_ = false;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.generatePromise_ = null;\n\n    /** @private {shaka.util.PublicPromise} */\n    this.updatePromise_ = null;\n\n    /** @private {string} */\n    this.keySystem_ = keySystem;\n\n    /** @private {string} */\n    this.type_ = sessionType;\n\n    /** @type {string} */\n    this.sessionId = '';\n\n    /** @type {number} */\n    this.expiration = NaN;\n\n    /** @type {!shaka.util.PublicPromise} */\n    this.closed = new shaka.util.PublicPromise();\n\n    /** @type {!shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap} */\n    this.keyStatuses =\n        new shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap();\n  }\n\n  /**\n   * Signals that the license request has been generated.  This resolves the\n   * 'generateRequest' promise.\n   *\n   * @protected\n   */\n  generated() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generated');\n\n    if (this.generatePromise_) {\n      this.generatePromise_.resolve();\n      this.generatePromise_ = null;\n    }\n  }\n\n  /**\n   * Signals that the session is 'ready', which is the terminology used in older\n   * versions of EME.  The new signal is to resolve the 'update' promise.  This\n   * translates between the two.\n   *\n   * @protected\n   */\n  ready() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.ready');\n\n    this.updateKeyStatus_('usable');\n\n    if (this.updatePromise_) {\n      this.updatePromise_.resolve();\n    }\n    this.updatePromise_ = null;\n  }\n\n  /**\n   * Either rejects a promise, or dispatches an error event, as appropriate.\n   *\n   * @param {!MediaKeyEvent} event\n   */\n  handleError(event) {\n    shaka.log.debug(\n        'PatchedMediaKeysWebkit.MediaKeySession.handleError', event);\n\n    // This does not match the DOMException we get in current WD EME, but it\n    // will at least provide some information which can be used to look into the\n    // problem.\n    const error = new Error('EME v0.1b key error');\n    const errorCode = event.errorCode;\n    errorCode.systemCode = event.systemCode;\n    error['errorCode'] = errorCode;\n\n    // The presence or absence of sessionId indicates whether this corresponds\n    // to generateRequest() or update().\n    if (!event.sessionId && this.generatePromise_) {\n      if (event.systemCode == 45) {\n        error.message = 'Unsupported session type.';\n      }\n      this.generatePromise_.reject(error);\n      this.generatePromise_ = null;\n    } else if (event.sessionId && this.updatePromise_) {\n      this.updatePromise_.reject(error);\n      this.updatePromise_ = null;\n    } else {\n      // This mapping of key statuses is imperfect at best.\n      const code = event.errorCode.code;\n      const systemCode = event.systemCode;\n      if (code == MediaKeyError['MEDIA_KEYERR_OUTPUT']) {\n        this.updateKeyStatus_('output-restricted');\n      } else if (systemCode == 1) {\n        this.updateKeyStatus_('expired');\n      } else {\n        this.updateKeyStatus_('internal-error');\n      }\n    }\n  }\n\n  /**\n   * Logic which is shared between generateRequest() and load(), both of which\n   * are ultimately implemented with webkitGenerateKeyRequest in prefixed EME.\n   *\n   * @param {?BufferSource} initData\n   * @param {?string} offlineSessionId\n   * @return {!Promise}\n   * @private\n   */\n  generate_(initData, offlineSessionId) {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (this.initialized_) {\n      const error = new Error('The session is already initialized.');\n      return Promise.reject(error);\n    }\n\n    this.initialized_ = true;\n\n    /** @type {!Uint8Array} */\n    let mangledInitData;\n\n    try {\n      if (this.type_ == 'persistent-license') {\n        const StringUtils = shaka.util.StringUtils;\n        if (!offlineSessionId) {\n          goog.asserts.assert(initData, 'expecting init data');\n          // Persisting the initial license.\n          // Prefix the init data with a tag to indicate persistence.\n          const prefix = StringUtils.toUTF8('PERSISTENT|');\n          mangledInitData = shaka.util.Uint8ArrayUtils.concat(prefix, initData);\n        } else {\n          // Loading a stored license.\n          // Prefix the init data (which is really a session ID) with a tag to\n          // indicate that we are loading a persisted session.\n          mangledInitData = shaka.util.BufferUtils.toUint8(\n              StringUtils.toUTF8('LOAD_SESSION|' + offlineSessionId));\n        }\n      } else {\n        // Streaming.\n        goog.asserts.assert(this.type_ == 'temporary',\n            'expected temporary session');\n        goog.asserts.assert(!offlineSessionId,\n            'unexpected offline session ID');\n        goog.asserts.assert(initData, 'expecting init data');\n        mangledInitData = shaka.util.BufferUtils.toUint8(initData);\n      }\n\n      goog.asserts.assert(mangledInitData, 'init data not set!');\n    } catch (exception) {\n      return Promise.reject(exception);\n    }\n\n    goog.asserts.assert(this.generatePromise_ == null,\n        'generatePromise_ should be null');\n    this.generatePromise_ = new shaka.util.PublicPromise();\n\n    // Because we are hacking media.src in createSession to better emulate\n    // unprefixed EME's ability to create sessions and license requests without\n    // a video tag, we can get ourselves into trouble.  It seems that sometimes,\n    // the setting of media.src hasn't been processed by some other thread, and\n    // GKR can throw an exception.  If this occurs, wait 10 ms and try again at\n    // most once.  This situation should only occur when init data is available\n    // ahead of the 'needkey' event.\n\n    const generateKeyRequestName =\n        PatchedMediaKeysWebkit.prefixApi_('generateKeyRequest');\n    try {\n      this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n    } catch (exception) {\n      if (exception.name != 'InvalidStateError') {\n        this.generatePromise_ = null;\n        return Promise.reject(exception);\n      }\n\n      const timer = new shaka.util.Timer(() => {\n        try {\n          this.media_[generateKeyRequestName](this.keySystem_, mangledInitData);\n        } catch (exception2) {\n          this.generatePromise_.reject(exception2);\n          this.generatePromise_ = null;\n        }\n      });\n\n      timer.tickAfter(/* seconds= */ 0.01);\n    }\n\n    return this.generatePromise_;\n  }\n\n  /**\n   * An internal version of update which defers new calls while old ones are in\n   * progress.\n   *\n   * @param {!shaka.util.PublicPromise} promise  The promise associated with\n   *   this call.\n   * @param {BufferSource} response\n   * @private\n   */\n  update_(promise, response) {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    if (this.updatePromise_) {\n      // We already have an update in-progress, so defer this one until after\n      // the old one is resolved.  Execute this whether the original one\n      // succeeds or fails.\n      this.updatePromise_.then(() => this.update_(promise, response))\n          .catch(() => this.update_(promise, response));\n      return;\n    }\n\n    this.updatePromise_ = promise;\n\n    let key;\n    let keyId;\n\n    if (this.keySystem_ == 'webkit-org.w3.clearkey') {\n      // The current EME version of clearkey wants a structured JSON response.\n      // The v0.1b version wants just a raw key.  Parse the JSON response and\n      // extract the key and key ID.\n      const StringUtils = shaka.util.StringUtils;\n      const Uint8ArrayUtils = shaka.util.Uint8ArrayUtils;\n      const licenseString = StringUtils.fromUTF8(response);\n      const jwkSet = /** @type {JWKSet} */ (JSON.parse(licenseString));\n      const kty = jwkSet.keys[0].kty;\n      if (kty != 'oct') {\n        // Reject the promise.\n        this.updatePromise_.reject(new Error(\n            'Response is not a valid JSON Web Key Set.'));\n        this.updatePromise_ = null;\n      }\n      key = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].k);\n      keyId = Uint8ArrayUtils.fromBase64(jwkSet.keys[0].kid);\n    } else {\n      // The key ID is not required.\n      key = shaka.util.BufferUtils.toUint8(response);\n      keyId = null;\n    }\n\n    const addKeyName = PatchedMediaKeysWebkit.prefixApi_('addKey');\n    try {\n      this.media_[addKeyName](this.keySystem_, key, keyId, this.sessionId);\n    } catch (exception) {\n      // Reject the promise.\n      this.updatePromise_.reject(exception);\n      this.updatePromise_ = null;\n    }\n  }\n\n  /**\n   * Update key status and dispatch a 'keystatuseschange' event.\n   *\n   * @param {string} status\n   * @private\n   */\n  updateKeyStatus_(status) {\n    this.keyStatuses.setStatus(status);\n    const event = new shaka.util.FakeEvent('keystatuseschange');\n    this.dispatchEvent(event);\n  }\n\n  /** @override */\n  generateRequest(initDataType, initData) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.generateRequest');\n    return this.generate_(initData, null);\n  }\n\n  /** @override */\n  load(sessionId) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.load');\n    if (this.type_ == 'persistent-license') {\n      return this.generate_(null, sessionId);\n    } else {\n      return Promise.reject(new Error('Not a persistent session.'));\n    }\n  }\n\n  /** @override */\n  update(response) {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.update', response);\n    goog.asserts.assert(this.sessionId, 'update without session ID');\n\n    const nextUpdatePromise = new shaka.util.PublicPromise();\n    this.update_(nextUpdatePromise, response);\n    return nextUpdatePromise;\n  }\n\n  /** @override */\n  close() {\n    const PatchedMediaKeysWebkit = shaka.polyfill.PatchedMediaKeysWebkit;\n\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.close');\n\n    // This will remove a persistent session, but it's also the only way to free\n    // CDM resources on v0.1b.\n    if (this.type_ != 'persistent-license') {\n      // sessionId may reasonably be null if no key request has been generated\n      // yet.  Unprefixed EME will return a rejected promise in this case.  We\n      // will use the same error message that Chrome 41 uses in its EME\n      // implementation.\n      if (!this.sessionId) {\n        this.closed.reject(new Error('The session is not callable.'));\n        return this.closed;\n      }\n\n      // This may throw an exception, but we ignore it because we are only using\n      // it to clean up resources in v0.1b.  We still consider the session\n      // closed. We can't let the exception propagate because\n      // MediaKeySession.close() should not throw.\n      const cancelKeyRequestName =\n          PatchedMediaKeysWebkit.prefixApi_('cancelKeyRequest');\n      try {\n        this.media_[cancelKeyRequestName](this.keySystem_, this.sessionId);\n      } catch (exception) {}\n    }\n\n    // Resolve the 'closed' promise and return it.\n    this.closed.resolve();\n    return this.closed;\n  }\n\n  /** @override */\n  remove() {\n    shaka.log.debug('PatchedMediaKeysWebkit.MediaKeySession.remove');\n\n    if (this.type_ != 'persistent-license') {\n      return Promise.reject(new Error('Not a persistent session.'));\n    }\n\n    return this.close();\n  }\n};\n\n\n/**\n * An implementation of MediaKeyStatusMap.\n * This fakes a map with a single key ID.\n *\n * @todo Consolidate the MediaKeyStatusMap types in these polyfills.\n * @implements {MediaKeyStatusMap}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap = class {\n  /** */\n  constructor() {\n    /**\n     * @type {number}\n     */\n    this.size = 0;\n\n    /**\n     * @private {string|undefined}\n     */\n    this.status_ = undefined;\n  }\n\n  /**\n   * An internal method used by the session to set key status.\n   * @param {string|undefined} status\n   */\n  setStatus(status) {\n    this.size = status == undefined ? 0 : 1;\n    this.status_ = status;\n  }\n\n  /**\n   * An internal method used by the session to get key status.\n   * @return {string|undefined}\n   */\n  getStatus() {\n    return this.status_;\n  }\n\n  /** @override */\n  forEach(fn) {\n    if (this.status_) {\n      fn(this.status_, shaka.media.DrmEngine.DUMMY_KEY_ID.value());\n    }\n  }\n\n  /** @override */\n  get(keyId) {\n    if (this.has(keyId)) {\n      return this.status_;\n    }\n    return undefined;\n  }\n\n  /** @override */\n  has(keyId) {\n    const fakeKeyId = shaka.media.DrmEngine.DUMMY_KEY_ID.value();\n    if (this.status_ && shaka.util.BufferUtils.equal(keyId, fakeKeyId)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  entries() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  keys() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n\n  /**\n   * @suppress {missingReturn}\n   * @override\n   */\n  values() {\n    goog.asserts.assert(false, 'Not used!  Provided only for compiler.');\n  }\n};\n\n\n/**\n * Store api prefix.\n *\n * @private {string}\n */\nshaka.polyfill.PatchedMediaKeysWebkit.prefix_ = '';\n\n\nshaka.polyfill.register(shaka.polyfill.PatchedMediaKeysWebkit.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.PiPWebkit');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide PiP support in Safari.\n * Note that Safari only supports PiP on video elements, not audio.\n * @export\n */\nshaka.polyfill.PiPWebkit = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = HTMLVideoElement.prototype;\n    if (proto.requestPictureInPicture &&\n      document.exitPictureInPicture) {\n      // No polyfill needed.\n      return;\n    }\n\n    if (!proto.webkitSupportsPresentationMode) {\n      // No Webkit PiP API available.\n      return;\n    }\n\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    shaka.log.debug('PiPWebkit.install');\n\n    // Polyfill document.pictureInPictureEnabled.\n    // It's definitely enabled now.  :-)\n    document.pictureInPictureEnabled = true;\n\n    // Polyfill document.pictureInPictureElement.\n    // This is initially empty.  We don't need getter or setter because we don't\n    // need any special handling when this is set.  We assume in good faith that\n    // applications won't try to set this directly.\n    document.pictureInPictureElement = null;\n\n    // Polyfill HTMLVideoElement.requestPictureInPicture.\n    proto.requestPictureInPicture = PiPWebkit.requestPictureInPicture_;\n\n    // Polyfill HTMLVideoElement.disablePictureInPicture.\n    Object.defineProperty(proto, 'disablePictureInPicture', {\n      get: PiPWebkit.getDisablePictureInPicture_,\n      set: PiPWebkit.setDisablePictureInPicture_,\n      // You should be able to discover this property.\n      enumerable: true,\n      // And maybe we're not so smart.  Let someone else change it if they want.\n      configurable: true,\n    });\n\n    // Polyfill document.exitPictureInPicture.\n    document.exitPictureInPicture = PiPWebkit.exitPictureInPicture_;\n\n    // Use the \"capturing\" event phase to get the webkit presentation mode event\n    // from the document.  This way, we get the event on its way from document\n    // to the target element without having to intercept events in every\n    // possible video element.\n    document.addEventListener(\n        'webkitpresentationmodechanged', PiPWebkit.proxyEvent_,\n        /* useCapture= */ true);\n  }\n\n  /**\n   * @param {!Event} event\n   * @private\n   */\n  static proxyEvent_(event) {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    const element = /** @type {!HTMLVideoElement} */(event.target);\n\n    if (element.webkitPresentationMode == PiPWebkit.PIP_MODE_) {\n      // Keep track of the PiP element.  This element just entered PiP mode.\n      document.pictureInPictureElement = element;\n\n      // Dispatch a standard event to match.\n      const event2 = new Event('enterpictureinpicture');\n      element.dispatchEvent(event2);\n    } else {\n      // Keep track of the PiP element.  This element just left PiP mode.\n      // If something else hasn't already take its place, clear it.\n      if (document.pictureInPictureElement == element) {\n        document.pictureInPictureElement = null;\n      }\n\n      // Dispatch a standard event to match.\n      const event2 = new Event('leavepictureinpicture');\n      element.dispatchEvent(event2);\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {!Promise}\n   * @private\n   */\n  static requestPictureInPicture_() {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    // NOTE: \"this\" here is the video element.\n\n    // Check if PiP is enabled for this element.\n    if (!this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_)) {\n      const error = new Error('PiP not allowed by video element');\n      return Promise.reject(error);\n    } else {\n      // Enter PiP mode.\n      this.webkitSetPresentationMode(PiPWebkit.PIP_MODE_);\n      document.pictureInPictureElement = this;\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * @this {Document}\n   * @return {!Promise}\n   * @private\n   */\n  static exitPictureInPicture_() {\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n\n    const pipElement =\n    /** @type {HTMLVideoElement} */(document.pictureInPictureElement);\n    if (pipElement) {\n      // Exit PiP mode.\n      pipElement.webkitSetPresentationMode(PiPWebkit.INLINE_MODE_);\n      document.pictureInPictureElement = null;\n      return Promise.resolve();\n    } else {\n      const error = new Error('No picture in picture element found');\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {boolean}\n   * @private\n   */\n  static getDisablePictureInPicture_() {\n    // This respects the HTML attribute, which may have been set in HTML or\n    // through the JS setter.\n    if (this.hasAttribute('disablePictureInPicture')) {\n      return true;\n    }\n\n    // Use Apple's non-standard API to know if PiP is allowed on this\n    // device for this content. If not, say that PiP is disabled, even\n    // if not specified by the user through the setter or HTML attribute.\n    const PiPWebkit = shaka.polyfill.PiPWebkit;\n    return !this.webkitSupportsPresentationMode(PiPWebkit.PIP_MODE_);\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @param {boolean} value\n   * @private\n   */\n  static setDisablePictureInPicture_(value) {\n    // This mimics how the JS setter works in browsers that implement the spec.\n    if (value) {\n      this.setAttribute('disablePictureInPicture', '');\n    } else {\n      this.removeAttribute('disablePictureInPicture');\n    }\n  }\n};\n\n\n/**\n * The presentation mode string used to indicate PiP mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.PIP_MODE_ = 'picture-in-picture';\n\n\n/**\n * The presentation mode string used to indicate inline mode in Safari.\n *\n * @const {string}\n * @private\n */\nshaka.polyfill.PiPWebkit.INLINE_MODE_ = 'inline';\n\n\nshaka.polyfill.register(shaka.polyfill.PiPWebkit.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\ngoog.provide('shaka.polyfill.RandomUUID');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide window.crypto.randomUUID in all browsers.\n * @export\n */\nshaka.polyfill.RandomUUID = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('randomUUID.install');\n\n    if (!window.crypto) {\n      // See: https://caniuse.com/cryptography\n      shaka.log.debug(\n          'window.crypto must be available to install randomUUID polyfill.');\n      return;\n    }\n\n    if ('randomUUID' in window.crypto) {\n      shaka.log.debug(\n          'RandomUUID: Native window.crypto.randomUUID() support found.');\n      return;\n    }\n\n    window.crypto.randomUUID = shaka.polyfill.RandomUUID.randomUUID_;\n  }\n\n  /**\n   * @return {string}\n   * @private\n   */\n  static randomUUID_() {\n    const url = URL.createObjectURL(new Blob());\n    const uuid = url.toString();\n    URL.revokeObjectURL(url);\n    return uuid.substr(uuid.lastIndexOf('/') + 1);\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.RandomUUID.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.StorageEstimate');\n\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide navigator.storage.estimate in old\n * webkit browsers.\n * See: https://developers.google.com/web/updates/2017/08/estimating-available-storage-space#the-present\n * @export\n */\nshaka.polyfill.StorageEstimate = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (navigator.storage && navigator.storage.estimate) {\n      // No need.\n      return;\n    }\n\n    if (navigator.webkitTemporaryStorage &&\n        navigator.webkitTemporaryStorage.queryUsageAndQuota) {\n      if (!('storage' in navigator)) {\n        navigator.storage = /** @type {!StorageManager} */ ({});\n      }\n      navigator.storage.estimate =\n          shaka.polyfill.StorageEstimate.storageEstimate_;\n    }\n  }\n\n  /**\n   * @this {StorageManager}\n   * @return {!Promise}\n   * @private\n   */\n  static storageEstimate_() {\n    return new Promise((resolve, reject) => {\n      navigator.webkitTemporaryStorage.queryUsageAndQuota(\n          (usage, quota) => {\n            resolve({usage: usage, quota: quota});\n          },\n          reject,\n      );\n    });\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.StorageEstimate.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\ngoog.provide('shaka.polyfill.Symbol');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n/**\n * @summary A polyfill to provide Symbol.prototype.description in all browsers.\n * See: https://caniuse.com/mdn-javascript_builtins_symbol_description\n * @export\n */\nshaka.polyfill.Symbol = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('Symbol.install');\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = Symbol.prototype;\n\n    if (!('description' in proto)) {\n      Object.defineProperty(proto, 'description', {\n        get: shaka.polyfill.Symbol.getSymbolDescription_,\n      });\n    }\n  }\n\n  /**\n   * @this {Symbol}\n   * @return {(string|undefined)}\n   * @private\n   */\n  static getSymbolDescription_() {\n    const m = /\\((.*)\\)/.exec(this.toString());\n    return m ? m[1] : undefined;\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.Symbol.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VideoPlayPromise');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to silence the play() Promise in HTML5 video.\n * @export\n */\nshaka.polyfill.VideoPlayPromise = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    shaka.log.debug('VideoPlayPromise.install');\n\n    if (window.HTMLMediaElement) {\n      // eslint-disable-next-line no-restricted-syntax\n      const originalPlay = HTMLMediaElement.prototype.play;\n      // eslint-disable-next-line no-restricted-syntax\n      HTMLMediaElement.prototype.play = function() {\n        // eslint-disable-next-line no-restricted-syntax\n        const p = originalPlay.apply(this);\n        if (p) {\n          // This browser is returning a Promise from play().\n          // If the play() call fails or is interrupted, the Promise will be\n          // rejected.  Some apps, however, don't listen to this Promise,\n          // especially since it is not available cross-browser.  If the Promise\n          // is rejected without anyone listening for the failure, an error will\n          // appear in the JS console.\n          // To avoid confusion over this innocuous \"error\", we will install a\n          // catch handler on the Promise.  This does not prevent the app from\n          // also catching failures and handling them.  It only prevents the\n          // console message.\n          p.catch(() => {});\n        }\n        return p;\n      };\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlayPromise.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VideoPlaybackQuality');\n\ngoog.require('shaka.polyfill');\ngoog.require('shaka.util.Platform');\n\n\n/**\n * @summary A polyfill to provide MSE VideoPlaybackQuality metrics.\n * Many browsers do not yet provide this API, and Chrome currently provides\n * similar data through individual prefixed attributes on HTMLVideoElement.\n * @export\n */\nshaka.polyfill.VideoPlaybackQuality = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (!window.HTMLVideoElement) {\n      // Avoid errors on very old browsers.\n      return;\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    const proto = HTMLVideoElement.prototype;\n    if (proto.getVideoPlaybackQuality) {\n      // No polyfill needed.\n      return;\n    }\n\n    if ('webkitDroppedFrameCount' in proto ||\n        shaka.util.Platform.isWebOS3()) {\n      proto.getVideoPlaybackQuality =\n          shaka.polyfill.VideoPlaybackQuality.webkit_;\n    }\n  }\n\n  /**\n   * @this {HTMLVideoElement}\n   * @return {!VideoPlaybackQuality}\n   * @private\n   */\n  static webkit_() {\n    return {\n      'droppedVideoFrames': this.webkitDroppedFrameCount,\n      'totalVideoFrames': this.webkitDecodedFrameCount,\n      // Not provided by this polyfill:\n      'corruptedVideoFrames': 0,\n      'creationTime': NaN,\n      'totalFrameDelay': 0,\n    };\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VideoPlaybackQuality.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.polyfill.VTTCue');\n\ngoog.require('shaka.log');\ngoog.require('shaka.polyfill');\n\n\n/**\n * @summary A polyfill to provide VTTCue.\n * @export\n */\nshaka.polyfill.VTTCue = class {\n  /**\n   * Install the polyfill if needed.\n   * @export\n   */\n  static install() {\n    if (window.VTTCue) {\n      shaka.log.info('Using native VTTCue.');\n      return;\n    }\n\n    if (!window.TextTrackCue) {\n      shaka.log.error('VTTCue not available.');\n      return;\n    }\n\n    /** @type {?function(number, number, string):!TextTrackCue} */\n    let replacement = null;\n    const constructorLength = TextTrackCue.length;\n    if (constructorLength == 3) {\n      shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n    } else if (constructorLength == 6) {\n      shaka.log.info('Using VTTCue polyfill from 6 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from6ArgsTextTrackCue_;\n    } else if (shaka.polyfill.VTTCue.canUse3ArgsTextTrackCue_()) {\n      shaka.log.info('Using VTTCue polyfill from 3 argument TextTrackCue.');\n      replacement = shaka.polyfill.VTTCue.from3ArgsTextTrackCue_;\n    }\n\n    if (!replacement) {\n      shaka.log.error('No recognized signature for TextTrackCue found!');\n      return;\n    }\n\n    // The polyfilled VTTCue must be callable with \"new\", but the static methods\n    // in this class cannot be called that way on legacy Edge.  So we must wrap\n    // the replacement in a plain function.\n    // eslint-disable-next-line no-restricted-syntax\n    window['VTTCue'] = function(start, end, text) {\n      return replacement(start, end, text);\n    };\n  }\n\n  /**\n   * Draft spec TextTrackCue with 3 constructor arguments.\n   * @see {@link https://bit.ly/2IdyKbA W3C Working Draft 25 October 2012}.\n   *\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} text\n   * @return {!TextTrackCue}\n   * @private\n   */\n  static from3ArgsTextTrackCue_(startTime, endTime, text) {\n    return new window.TextTrackCue(startTime, endTime, text);\n  }\n\n  /**\n   * Draft spec TextTrackCue with 6 constructor arguments (5th & 6th are\n   * optional).\n   * @see {@link https://bit.ly/2KaGSP2 W3C Working Draft 29 March 2012}.\n   *\n   * @param {number} startTime\n   * @param {number} endTime\n   * @param {string} text\n   * @return {!TextTrackCue}\n   * @private\n   */\n  static from6ArgsTextTrackCue_(startTime, endTime, text) {\n    const id = startTime + '-' + endTime + '-' + text;\n    // Quoting the access to the TextTrackCue object to satisfy the compiler.\n    return new window['TextTrackCue'](id, startTime, endTime, text);\n  }\n\n  /**\n   * Edge returns TextTrackCue.length = 0, although it accepts 3\n   * constructor arguments.\n   *\n   * @return {boolean}\n   * @private\n   */\n  static canUse3ArgsTextTrackCue_() {\n    try {\n      return !!shaka.polyfill.VTTCue.from3ArgsTextTrackCue_(1, 2, '');\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\n\nshaka.polyfill.register(shaka.polyfill.VTTCue.install);\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.LrcTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * LRC file format: https://en.wikipedia.org/wiki/LRC_(file_format)\n *\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.LrcTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'LRC does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const StringUtils = shaka.util.StringUtils;\n    const LrcTextParser = shaka.text.LrcTextParser;\n\n    // Get the input as a string.\n    const str = StringUtils.fromUTF8(data);\n\n    /** @type {shaka.extern.Cue} */\n    let prevCue = null;\n\n    /** @type {!Array.<!shaka.extern.Cue>} */\n    const cues = [];\n    const lines = str.split(/\\r?\\n/);\n    for (const line of lines) {\n      if (!line || /^\\s+$/.test(line)) {\n        continue;\n      }\n\n      // LRC content\n      const match = LrcTextParser.lyricLine_.exec(line);\n      if (match) {\n        const startTime = LrcTextParser.parseTime_(match[1]);\n        // This time can be overwritten by a subsequent cue.\n        // By default we add 2 seconds of duration.\n        const endTime = time.segmentEnd ? time.segmentEnd : startTime + 2;\n        const payload = match[2];\n        const cue = new shaka.text.Cue(startTime, endTime, payload);\n\n        // Update previous\n        if (prevCue) {\n          prevCue.endTime = startTime;\n          cues.push(prevCue);\n        }\n        prevCue = cue;\n        continue;\n      }\n      shaka.log.warning('LrcTextParser encountered an unknown line.', line);\n    }\n    if (prevCue) {\n      cues.push(prevCue);\n    }\n\n    return cues;\n  }\n\n  /**\n   * Parses a LRC time from the given parser.\n   *\n   * @param {string} string\n   * @return {number}\n   * @private\n   */\n  static parseTime_(string) {\n    const LrcTextParser = shaka.text.LrcTextParser;\n    const match = LrcTextParser.timeFormat_.exec(string);\n    const minutes = parseInt(match[1], 10);\n    const seconds = parseFloat(match[2].replace(',', '.'));\n    return minutes * 60 + seconds;\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example [00:12.0]Text or [00:12.00]Text or [00:12.000]Text or\n * [00:12,0]Text or [00:12,00]Text or [00:12,000]Text\n */\nshaka.text.LrcTextParser.lyricLine_ =\n    /^\\[(\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\](.*)/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:12.0 or 00:12.00 or 00:12.000 or\n * 00:12,0 or 00:12,00 or 00:12,000\n */\nshaka.text.LrcTextParser.timeFormat_ =\n    /^(\\d+):(\\d{1,2}(?:[.,]\\d{1,3})?)$/;\n\nshaka.text.TextEngine.registerParser(\n    'application/x-subtitle-lrc', () => new shaka.text.LrcTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.TtmlTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.ArrayUtils');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.TtmlTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'TTML does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttpNs = TtmlTextParser.parameterNs_;\n    const ttsNs = TtmlTextParser.styleNs_;\n    const str = shaka.util.StringUtils.fromUTF8(data);\n    const cues = [];\n\n    // dont try to parse empty string as\n    // DOMParser will not throw error but return an errored xml\n    if (str == '') {\n      return cues;\n    }\n\n    const tt = XmlUtils.parseXmlString(str, 'tt');\n    if (!tt) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML,\n          'Failed to parse TTML.');\n    }\n\n    const body = tt.getElementsByTagName('body')[0];\n    if (!body) {\n      return [];\n    }\n\n    // Get the framerate, subFrameRate and frameRateMultiplier if applicable.\n    const frameRate = XmlUtils.getAttributeNSList(tt, ttpNs, 'frameRate');\n    const subFrameRate = XmlUtils.getAttributeNSList(\n        tt, ttpNs, 'subFrameRate');\n    const frameRateMultiplier =\n        XmlUtils.getAttributeNSList(tt, ttpNs, 'frameRateMultiplier');\n    const tickRate = XmlUtils.getAttributeNSList(tt, ttpNs, 'tickRate');\n\n    const cellResolution = XmlUtils.getAttributeNSList(\n        tt, ttpNs, 'cellResolution');\n    const spaceStyle = tt.getAttribute('xml:space') || 'default';\n    const extent = XmlUtils.getAttributeNSList(tt, ttsNs, 'extent');\n\n    if (spaceStyle != 'default' && spaceStyle != 'preserve') {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_XML,\n          'Invalid xml:space value: ' + spaceStyle);\n    }\n    const whitespaceTrim = spaceStyle == 'default';\n\n    const rateInfo = new TtmlTextParser.RateInfo_(\n        frameRate, subFrameRate, frameRateMultiplier, tickRate);\n\n    const cellResolutionInfo =\n      TtmlTextParser.getCellResolution_(cellResolution);\n\n    const metadata = tt.getElementsByTagName('metadata')[0];\n    const metadataElements = metadata ? XmlUtils.getChildren(metadata) : [];\n    const styles = Array.from(tt.getElementsByTagName('style'));\n    const regionElements = Array.from(tt.getElementsByTagName('region'));\n\n    const cueRegions = [];\n    for (const region of regionElements) {\n      const cueRegion =\n          TtmlTextParser.parseCueRegion_(region, styles, extent);\n      if (cueRegion) {\n        cueRegions.push(cueRegion);\n      }\n    }\n\n    // A <body> element should only contain <div> elements, not <p> or <span>\n    // elements.  We used to allow this, but it is non-compliant, and the\n    // loose nature of our previous parser made it difficult to implement TTML\n    // nesting more fully.\n    if (XmlUtils.findChildren(body, 'p').length) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE,\n          '<p> can only be inside <div> in TTML');\n    }\n\n    for (const div of XmlUtils.findChildren(body, 'div')) {\n      // A <div> element should only contain <p>, not <span>.\n      if (XmlUtils.findChildren(div, 'span').length) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_TEXT_CUE,\n            '<span> can only be inside <p> in TTML');\n      }\n    }\n\n    const cue = TtmlTextParser.parseCue_(\n        body, time, rateInfo, metadataElements, styles,\n        regionElements, cueRegions, whitespaceTrim,\n        cellResolutionInfo, /* parentCueElement= */ null,\n        /* isContent= */ false);\n    if (cue) {\n      // According to the TTML spec, backgrounds default to transparent.\n      // So default the background of the top-level element to transparent.\n      // Nested elements may override that background color already.\n      if (!cue.backgroundColor) {\n        cue.backgroundColor = 'transparent';\n      }\n      cues.push(cue);\n    }\n\n    return cues;\n  }\n\n  /**\n   * Parses a TTML node into a Cue.\n   *\n   * @param {!Node} cueNode\n   * @param {shaka.extern.TextParser.TimeContext} timeContext\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {!Array.<!Element>} metadataElements\n   * @param {!Array.<!Element>} styles\n   * @param {!Array.<!Element>} regionElements\n   * @param {!Array.<!shaka.text.CueRegion>} cueRegions\n   * @param {boolean} whitespaceTrim\n   * @param {?{columns: number, rows: number}} cellResolution\n   * @param {?Element} parentCueElement\n   * @param {boolean} isContent\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseCue_(\n      cueNode, timeContext, rateInfo, metadataElements, styles, regionElements,\n      cueRegions, whitespaceTrim, cellResolution, parentCueElement, isContent) {\n    /** @type {Element} */\n    let cueElement;\n    /** @type {Element} */\n    let parentElement = /** @type {Element} */ (cueNode.parentNode);\n\n    if (cueNode.nodeType == Node.COMMENT_NODE) {\n      // The comments do not contain information that interests us here.\n      return null;\n    }\n\n    if (cueNode.nodeType == Node.TEXT_NODE) {\n      if (!isContent) {\n        // Ignore text elements outside the content. For example, whitespace\n        // on the same lexical level as the <p> elements, in a document with\n        // xml:space=\"preserve\", should not be renderer.\n        return null;\n      }\n      // This should generate an \"anonymous span\" according to the TTML spec.\n      // So pretend the element was a <span>.  parentElement was set above, so\n      // we should still be able to correctly traverse up for timing\n      // information later.\n      const span = document.createElement('span');\n      span.textContent = cueNode.textContent;\n      cueElement = span;\n    } else {\n      goog.asserts.assert(cueNode.nodeType == Node.ELEMENT_NODE,\n          'nodeType should be ELEMENT_NODE!');\n      cueElement = /** @type {!Element} */(cueNode);\n    }\n    goog.asserts.assert(cueElement, 'cueElement should be non-null!');\n\n    let imageElement = null;\n    for (const nameSpace of shaka.text.TtmlTextParser.smpteNsList_) {\n      imageElement = shaka.text.TtmlTextParser.getElementsFromCollection_(\n          cueElement, 'backgroundImage', metadataElements, '#',\n          nameSpace)[0];\n      if (imageElement) {\n        break;\n      }\n    }\n\n    const parentIsContent = isContent;\n    if (cueNode.nodeName == 'p' || imageElement) {\n      isContent = true;\n    }\n\n    const spaceStyle = cueElement.getAttribute('xml:space') ||\n        (whitespaceTrim ? 'default' : 'preserve');\n\n    const localWhitespaceTrim = spaceStyle == 'default';\n\n    // Parse any nested cues first.\n    const isTextNode = (node) => {\n      return node.nodeType == Node.TEXT_NODE;\n    };\n    const isLeafNode = Array.from(cueElement.childNodes).every(isTextNode);\n    const nestedCues = [];\n    if (!isLeafNode) {\n      // Otherwise, recurse into the children.  Text nodes will convert into\n      // anonymous spans, which will then be leaf nodes.\n      for (const childNode of cueElement.childNodes) {\n        const nestedCue = shaka.text.TtmlTextParser.parseCue_(\n            childNode,\n            timeContext,\n            rateInfo,\n            metadataElements,\n            styles,\n            regionElements,\n            cueRegions,\n            localWhitespaceTrim,\n            cellResolution,\n            cueElement,\n            isContent,\n        );\n\n        // This node may or may not generate a nested cue.\n        if (nestedCue) {\n          nestedCues.push(nestedCue);\n        }\n      }\n    }\n\n    const isNested = /** @type {boolean} */ (parentCueElement != null);\n\n    // In this regex, \"\\S\" means \"non-whitespace character\".\n    const hasTextContent = /\\S/.test(cueElement.textContent);\n    const hasTimeAttributes =\n        cueElement.hasAttribute('begin') ||\n        cueElement.hasAttribute('end') ||\n        cueElement.hasAttribute('dur');\n\n    if (!hasTimeAttributes && !hasTextContent && cueElement.tagName != 'br' &&\n        nestedCues.length == 0) {\n      if (!isNested) {\n        // Disregards empty <p> elements without time attributes nor content.\n        // <p begin=\"...\" smpte:backgroundImage=\"...\" /> will go through,\n        // as some information could be held by its attributes.\n        // <p /> won't, as it would not be displayed.\n        return null;\n      } else if (localWhitespaceTrim) {\n        // Disregards empty anonymous spans when (local) trim is true.\n        return null;\n      }\n    }\n\n    // Get local time attributes.\n    let {start, end} = shaka.text.TtmlTextParser.parseTime_(\n        cueElement, rateInfo);\n    // Resolve local time relative to parent elements.  Time elements can appear\n    // all the way up to 'body', but not 'tt'.\n    while (parentElement && parentElement.nodeType == Node.ELEMENT_NODE &&\n        parentElement.tagName != 'tt') {\n      ({start, end} = shaka.text.TtmlTextParser.resolveTime_(\n          parentElement, rateInfo, start, end));\n      parentElement = /** @type {Element} */(parentElement.parentNode);\n    }\n\n    if (start == null) {\n      start = 0;\n    }\n    start += timeContext.periodStart;\n\n    // If end is null, that means the duration is effectively infinite.\n    if (end == null) {\n      end = Infinity;\n    } else {\n      end += timeContext.periodStart;\n    }\n\n    // Clip times to segment boundaries.\n    // https://github.com/shaka-project/shaka-player/issues/4631\n    start = Math.max(start, timeContext.segmentStart);\n    end = Math.min(end, timeContext.segmentEnd);\n\n    if (!hasTimeAttributes && nestedCues.length > 0) {\n      // If no time is defined for this cue, base the timing information on\n      // the time of the nested cues. In the case of multiple nested cues with\n      // different start times, it is the text displayer's responsibility to\n      // make sure that only the appropriate nested cue is drawn at any given\n      // time.\n      start = Infinity;\n      end = 0;\n      for (const cue of nestedCues) {\n        start = Math.min(start, cue.startTime);\n        end = Math.max(end, cue.endTime);\n      }\n    }\n\n    if (cueElement.tagName == 'br') {\n      const cue = new shaka.text.Cue(start, end, '');\n      cue.lineBreak = true;\n      return cue;\n    }\n\n    let payload = '';\n    if (isLeafNode) {\n      // If the childNodes are all text, this is a leaf node.  Get the payload.\n      payload = cueElement.textContent;\n      if (localWhitespaceTrim) {\n        // Trim leading and trailing whitespace.\n        payload = payload.trim();\n        // Collapse multiple spaces into one.\n        payload = payload.replace(/\\s+/g, ' ');\n      }\n    }\n\n    const cue = new shaka.text.Cue(start, end, payload);\n    cue.nestedCues = nestedCues;\n\n    if (!isContent) {\n      // If this is not a <p> element or a <div> with images, and it has no\n      // parent that was a <p> element, then it's part of the outer containers\n      // (e.g. the <body> or a normal <div> element within it).\n      cue.isContainer = true;\n    }\n\n    if (cellResolution) {\n      cue.cellResolution = cellResolution;\n    }\n\n    // Get other properties if available.\n    const regionElement = shaka.text.TtmlTextParser.getElementsFromCollection_(\n        cueElement, 'region', regionElements, /* prefix= */ '')[0];\n    // Do not actually apply that region unless it is non-inherited, though.\n    // This makes it so that, if a parent element has a region, the children\n    // don't also all independently apply the positioning of that region.\n    if (cueElement.hasAttribute('region')) {\n      if (regionElement && regionElement.getAttribute('xml:id')) {\n        const regionId = regionElement.getAttribute('xml:id');\n        cue.region = cueRegions.filter((region) => region.id == regionId)[0];\n      }\n    }\n\n    let regionElementForStyle = regionElement;\n    if (parentCueElement && isNested && !cueElement.getAttribute('region') &&\n      !cueElement.getAttribute('style')) {\n      regionElementForStyle =\n          shaka.text.TtmlTextParser.getElementsFromCollection_(\n              parentCueElement, 'region', regionElements, /* prefix= */ '')[0];\n    }\n\n    shaka.text.TtmlTextParser.addStyle_(\n        cue,\n        cueElement,\n        regionElementForStyle,\n        imageElement,\n        styles,\n        /** isNested= */ parentIsContent, // \"nested in a <div>\" doesn't count.\n        /** isLeaf= */ (nestedCues.length == 0));\n\n    return cue;\n  }\n\n  /**\n   * Parses an Element into a TextTrackCue or VTTCue.\n   *\n   * @param {!Element} regionElement\n   * @param {!Array.<!Element>} styles Defined in the top of tt  element and\n   * used principally for images.\n   * @param {?string} globalExtent\n   * @return {shaka.text.CueRegion}\n   * @private\n   */\n  static parseCueRegion_(regionElement, styles, globalExtent) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const region = new shaka.text.CueRegion();\n    const id = regionElement.getAttribute('xml:id');\n    if (!id) {\n      shaka.log.warning('TtmlTextParser parser encountered a region with ' +\n                        'no id. Region will be ignored.');\n      return null;\n    }\n    region.id = id;\n\n    let globalResults = null;\n    if (globalExtent) {\n      globalResults = TtmlTextParser.percentValues_.exec(globalExtent) ||\n        TtmlTextParser.pixelValues_.exec(globalExtent);\n    }\n    const globalWidth = globalResults ? Number(globalResults[1]) : null;\n    const globalHeight = globalResults ? Number(globalResults[2]) : null;\n\n    let results = null;\n    let percentage = null;\n    const extent = TtmlTextParser.getStyleAttributeFromRegion_(\n        regionElement, styles, 'extent');\n    if (extent) {\n      percentage = TtmlTextParser.percentValues_.exec(extent);\n      results = percentage || TtmlTextParser.pixelValues_.exec(extent);\n      if (results != null) {\n        region.width = Number(results[1]);\n        region.height = Number(results[2]);\n\n        if (!percentage) {\n          if (globalWidth != null) {\n            region.width = region.width * 100 / globalWidth;\n          }\n          if (globalHeight != null) {\n            region.height = region.height * 100 / globalHeight;\n          }\n        }\n\n        region.widthUnits = percentage || globalWidth != null ?\n                           shaka.text.CueRegion.units.PERCENTAGE :\n                           shaka.text.CueRegion.units.PX;\n\n        region.heightUnits = percentage || globalHeight != null ?\n                           shaka.text.CueRegion.units.PERCENTAGE :\n                           shaka.text.CueRegion.units.PX;\n      }\n    }\n\n    const origin = TtmlTextParser.getStyleAttributeFromRegion_(\n        regionElement, styles, 'origin');\n    if (origin) {\n      percentage = TtmlTextParser.percentValues_.exec(origin);\n      results = percentage || TtmlTextParser.pixelValues_.exec(origin);\n      if (results != null) {\n        region.viewportAnchorX = Number(results[1]);\n        region.viewportAnchorY = Number(results[2]);\n\n        if (!percentage) {\n          if (globalHeight != null) {\n            region.viewportAnchorY = region.viewportAnchorY * 100 /\n              globalHeight;\n          }\n          if (globalWidth != null) {\n            region.viewportAnchorX = region.viewportAnchorX * 100 /\n              globalWidth;\n          }\n        }\n\n        region.viewportAnchorUnits = percentage || globalWidth != null ?\n                  shaka.text.CueRegion.units.PERCENTAGE :\n                  shaka.text.CueRegion.units.PX;\n      }\n    }\n\n    return region;\n  }\n\n  /**\n   * Adds applicable style properties to a cue.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {!Element} cueElement\n   * @param {Element} region\n   * @param {Element} imageElement\n   * @param {!Array.<!Element>} styles\n   * @param {boolean} isNested\n   * @param {boolean} isLeaf\n   * @private\n   */\n  static addStyle_(\n      cue, cueElement, region, imageElement, styles, isNested, isLeaf) {\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const Cue = shaka.text.Cue;\n\n    // Styles should be inherited from regions, if a style property is not\n    // associated with a Content element (or an anonymous span).\n    const shouldInheritRegionStyles = isNested || isLeaf;\n\n    const direction = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'direction', shouldInheritRegionStyles);\n    if (direction == 'rtl') {\n      cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n    }\n\n    // Direction attribute specifies one-dimentional writing direction\n    // (left to right or right to left). Writing mode specifies that\n    // plus whether text is vertical or horizontal.\n    // They should not contradict each other. If they do, we give\n    // preference to writing mode.\n    const writingMode = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'writingMode', shouldInheritRegionStyles);\n    // Set cue's direction if the text is horizontal, and cue's writingMode if\n    // it's vertical.\n    if (writingMode == 'tb' || writingMode == 'tblr') {\n      cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n    } else if (writingMode == 'tbrl') {\n      cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n    } else if (writingMode == 'rltb' || writingMode == 'rl') {\n      cue.direction = Cue.direction.HORIZONTAL_RIGHT_TO_LEFT;\n    } else if (writingMode) {\n      cue.direction = Cue.direction.HORIZONTAL_LEFT_TO_RIGHT;\n    }\n\n    const align = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'textAlign', true);\n    if (align) {\n      cue.positionAlign = TtmlTextParser.textAlignToPositionAlign_[align];\n      cue.lineAlign = TtmlTextParser.textAlignToLineAlign_[align];\n\n      goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n          align.toUpperCase() + ' Should be in Cue.textAlign values!');\n\n      cue.textAlign = Cue.textAlign[align.toUpperCase()];\n    } else {\n      // Default value is START in the TTML spec: https://bit.ly/32OGmvo\n      // But to make the subtitle render consitent with other players and the\n      // shaka.text.Cue we use CENTER\n      cue.textAlign = Cue.textAlign.CENTER;\n    }\n\n    const displayAlign = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'displayAlign', true);\n    if (displayAlign) {\n      goog.asserts.assert(displayAlign.toUpperCase() in Cue.displayAlign,\n          displayAlign.toUpperCase() +\n                          ' Should be in Cue.displayAlign values!');\n      cue.displayAlign = Cue.displayAlign[displayAlign.toUpperCase()];\n    }\n\n    const color = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'color', shouldInheritRegionStyles);\n    if (color) {\n      cue.color = color;\n    }\n\n    // Background color should not be set on a container.  If this is a nested\n    // cue, you can set the background.  If it's a top-level that happens to\n    // also be a leaf, you can set the background.\n    // See https://github.com/shaka-project/shaka-player/issues/2623\n    // This used to be handled in the displayer, but that is confusing.  The Cue\n    // structure should reflect what you want to happen in the displayer, and\n    // the displayer shouldn't have to know about TTML.\n    const backgroundColor = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'backgroundColor',\n        shouldInheritRegionStyles);\n    if (backgroundColor) {\n      cue.backgroundColor = backgroundColor;\n    }\n\n    const border = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'border', shouldInheritRegionStyles);\n    if (border) {\n      cue.border = border;\n    }\n\n    const fontFamily = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontFamily', shouldInheritRegionStyles);\n    // See https://github.com/sandflow/imscJS/blob/1.1.3/src/main/js/html.js#L1384\n    if (fontFamily) {\n      switch (fontFamily) {\n        case 'monospaceSerif':\n          cue.fontFamily = 'Courier New,Liberation Mono,Courier,monospace';\n          break;\n        case 'proportionalSansSerif':\n          cue.fontFamily = 'Arial,Helvetica,Liberation Sans,sans-serif';\n          break;\n        case 'sansSerif':\n          cue.fontFamily = 'sans-serif';\n          break;\n        case 'monospaceSansSerif':\n          cue.fontFamily = 'Consolas,monospace';\n          break;\n        case 'proportionalSerif':\n          cue.fontFamily = 'serif';\n          break;\n        default:\n          cue.fontFamily = fontFamily;\n          break;\n      }\n    }\n\n    const fontWeight = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontWeight', shouldInheritRegionStyles);\n    if (fontWeight && fontWeight == 'bold') {\n      cue.fontWeight = Cue.fontWeight.BOLD;\n    }\n\n    const wrapOption = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'wrapOption', shouldInheritRegionStyles);\n    if (wrapOption && wrapOption == 'noWrap') {\n      cue.wrapLine = false;\n    } else {\n      cue.wrapLine = true;\n    }\n\n    const lineHeight = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'lineHeight', shouldInheritRegionStyles);\n    if (lineHeight && lineHeight.match(TtmlTextParser.unitValues_)) {\n      cue.lineHeight = lineHeight;\n    }\n\n    const fontSize = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontSize', shouldInheritRegionStyles);\n    if (fontSize) {\n      const isValidFontSizeUnit =\n          fontSize.match(TtmlTextParser.unitValues_) ||\n          fontSize.match(TtmlTextParser.percentValue_);\n\n      if (isValidFontSizeUnit) {\n        cue.fontSize = fontSize;\n      }\n    }\n\n    const fontStyle = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'fontStyle', shouldInheritRegionStyles);\n    if (fontStyle) {\n      goog.asserts.assert(fontStyle.toUpperCase() in Cue.fontStyle,\n          fontStyle.toUpperCase() +\n                          ' Should be in Cue.fontStyle values!');\n      cue.fontStyle = Cue.fontStyle[fontStyle.toUpperCase()];\n    }\n\n    if (imageElement) {\n      // According to the spec, we should use imageType (camelCase), but\n      // historically we have checked for imagetype (lowercase).\n      // This was the case since background image support was first introduced\n      // in PR #1859, in April 2019, and first released in v2.5.0.\n      // Now we check for both, although only imageType (camelCase) is to spec.\n      const backgroundImageType =\n          imageElement.getAttribute('imageType') ||\n          imageElement.getAttribute('imagetype');\n      const backgroundImageEncoding = imageElement.getAttribute('encoding');\n      const backgroundImageData = imageElement.textContent.trim();\n      if (backgroundImageType == 'PNG' &&\n          backgroundImageEncoding == 'Base64' &&\n          backgroundImageData) {\n        cue.backgroundImage = 'data:image/png;base64,' + backgroundImageData;\n      }\n    }\n\n    const textOutline = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'textOutline', shouldInheritRegionStyles);\n    if (textOutline) {\n      // tts:textOutline isn't natively supported by browsers, but it can be\n      // mostly replicated using the non-standard -webkit-text-stroke-width and\n      // -webkit-text-stroke-color properties.\n      const split = textOutline.split(' ');\n      if (split[0].match(TtmlTextParser.unitValues_)) {\n        // There is no defined color, so default to the text color.\n        cue.textStrokeColor = cue.color;\n      } else {\n        cue.textStrokeColor = split[0];\n        split.shift();\n      }\n      if (split[0] && split[0].match(TtmlTextParser.unitValues_)) {\n        cue.textStrokeWidth = split[0];\n      } else {\n        // If there is no width, or the width is not a number, don't draw a\n        // border.\n        cue.textStrokeColor = '';\n      }\n      // There is an optional blur radius also, but we have no way of\n      // replicating that, so ignore it.\n    }\n\n    const letterSpacing = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'letterSpacing', shouldInheritRegionStyles);\n    if (letterSpacing && letterSpacing.match(TtmlTextParser.unitValues_)) {\n      cue.letterSpacing = letterSpacing;\n    }\n\n    const linePadding = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'linePadding', shouldInheritRegionStyles);\n    if (linePadding && linePadding.match(TtmlTextParser.unitValues_)) {\n      cue.linePadding = linePadding;\n    }\n\n    const opacity = TtmlTextParser.getStyleAttribute_(\n        cueElement, region, styles, 'opacity', shouldInheritRegionStyles);\n    if (opacity) {\n      cue.opacity = parseFloat(opacity);\n    }\n\n    // Text decoration is an array of values which can come both from the\n    // element's style or be inherited from elements' parent nodes. All of those\n    // values should be applied as long as they don't contradict each other. If\n    // they do, elements' own style gets preference.\n    const textDecorationRegion = TtmlTextParser.getStyleAttributeFromRegion_(\n        region, styles, 'textDecoration');\n    if (textDecorationRegion) {\n      TtmlTextParser.addTextDecoration_(cue, textDecorationRegion);\n    }\n\n    const textDecorationElement = TtmlTextParser.getStyleAttributeFromElement_(\n        cueElement, styles, 'textDecoration');\n    if (textDecorationElement) {\n      TtmlTextParser.addTextDecoration_(cue, textDecorationElement);\n    }\n  }\n\n  /**\n   * Parses text decoration values and adds/removes them to/from the cue.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {string} decoration\n   * @private\n   */\n  static addTextDecoration_(cue, decoration) {\n    const Cue = shaka.text.Cue;\n    for (const value of decoration.split(' ')) {\n      switch (value) {\n        case 'underline':\n          if (!cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n            cue.textDecoration.push(Cue.textDecoration.UNDERLINE);\n          }\n          break;\n        case 'noUnderline':\n          if (cue.textDecoration.includes(Cue.textDecoration.UNDERLINE)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.UNDERLINE);\n          }\n          break;\n        case 'lineThrough':\n          if (!cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n            cue.textDecoration.push(Cue.textDecoration.LINE_THROUGH);\n          }\n          break;\n        case 'noLineThrough':\n          if (cue.textDecoration.includes(Cue.textDecoration.LINE_THROUGH)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.LINE_THROUGH);\n          }\n          break;\n        case 'overline':\n          if (!cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n            cue.textDecoration.push(Cue.textDecoration.OVERLINE);\n          }\n          break;\n        case 'noOverline':\n          if (cue.textDecoration.includes(Cue.textDecoration.OVERLINE)) {\n            shaka.util.ArrayUtils.remove(cue.textDecoration,\n                Cue.textDecoration.OVERLINE);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Finds a specified attribute on either the original cue element or its\n   * associated region and returns the value if the attribute was found.\n   *\n   * @param {!Element} cueElement\n   * @param {Element} region\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @param {boolean=} shouldInheritRegionStyles\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttribute_(cueElement, region, styles, attribute,\n      shouldInheritRegionStyles=true) {\n    // An attribute can be specified on region level or in a styling block\n    // associated with the region or original element.\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n    const attr = TtmlTextParser.getStyleAttributeFromElement_(\n        cueElement, styles, attribute);\n    if (attr) {\n      return attr;\n    }\n\n    if (shouldInheritRegionStyles) {\n      return TtmlTextParser.getStyleAttributeFromRegion_(\n          region, styles, attribute);\n    }\n    return null;\n  }\n\n  /**\n   * Finds a specified attribute on the element's associated region\n   * and returns the value if the attribute was found.\n   *\n   * @param {Element} region\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttributeFromRegion_(region, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n    if (!region) {\n      return null;\n    }\n\n    const attr = XmlUtils.getAttributeNSList(region, ttsNs, attribute);\n    if (attr) {\n      return attr;\n    }\n\n    return shaka.text.TtmlTextParser.getInheritedStyleAttribute_(\n        region, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on the cue element and returns the value\n   * if the attribute was found.\n   *\n   * @param {!Element} cueElement\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getStyleAttributeFromElement_(cueElement, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n\n    // Styling on elements should take precedence\n    // over the main styling attributes\n    const elementAttribute = XmlUtils.getAttributeNSList(\n        cueElement,\n        ttsNs,\n        attribute);\n\n    if (elementAttribute) {\n      return elementAttribute;\n    }\n    return shaka.text.TtmlTextParser.getInheritedStyleAttribute_(\n        cueElement, styles, attribute);\n  }\n\n  /**\n   * Finds a specified attribute on an element's styles and the styles those\n   * styles inherit from.\n   *\n   * @param {!Element} element\n   * @param {!Array.<!Element>} styles\n   * @param {string} attribute\n   * @return {?string}\n   * @private\n   */\n  static getInheritedStyleAttribute_(element, styles, attribute) {\n    const XmlUtils = shaka.util.XmlUtils;\n    const ttsNs = shaka.text.TtmlTextParser.styleNs_;\n    const ebuttsNs = shaka.text.TtmlTextParser.styleEbuttsNs_;\n\n    const inheritedStyles =\n        shaka.text.TtmlTextParser.getElementsFromCollection_(\n            element, 'style', styles, /* prefix= */ '');\n\n    let styleValue = null;\n\n    // The last value in our styles stack takes the precedence over the others\n    for (let i = 0; i < inheritedStyles.length; i++) {\n      // Check ebu namespace first.\n      let styleAttributeValue = XmlUtils.getAttributeNS(\n          inheritedStyles[i],\n          ebuttsNs,\n          attribute);\n\n      if (!styleAttributeValue) {\n        // Fall back to tts namespace.\n        styleAttributeValue = XmlUtils.getAttributeNSList(\n            inheritedStyles[i],\n            ttsNs,\n            attribute);\n      }\n\n      if (!styleAttributeValue) {\n        // Next, check inheritance.\n        // Styles can inherit from other styles, so traverse up that chain.\n        styleAttributeValue =\n            shaka.text.TtmlTextParser.getStyleAttributeFromElement_(\n                inheritedStyles[i], styles, attribute);\n      }\n\n      if (styleAttributeValue) {\n        styleValue = styleAttributeValue;\n      }\n    }\n\n    return styleValue;\n  }\n\n\n  /**\n   * Selects items from |collection| whose id matches |attributeName|\n   * from |element|.\n   *\n   * @param {Element} element\n   * @param {string} attributeName\n   * @param {!Array.<Element>} collection\n   * @param {string} prefixName\n   * @param {string=} nsName\n   * @return {!Array.<!Element>}\n   * @private\n   */\n  static getElementsFromCollection_(\n      element, attributeName, collection, prefixName, nsName) {\n    const items = [];\n\n    if (!element || collection.length < 1) {\n      return items;\n    }\n\n    const attributeValue = shaka.text.TtmlTextParser.getInheritedAttribute_(\n        element, attributeName, nsName);\n\n    if (attributeValue) {\n      // There could be multiple items in one attribute\n      // <span style=\"style1 style2\">A cue</span>\n      const itemNames = attributeValue.split(' ');\n\n      for (const name of itemNames) {\n        for (const item of collection) {\n          if ((prefixName + item.getAttribute('xml:id')) == name) {\n            items.push(item);\n            break;\n          }\n        }\n      }\n    }\n\n    return items;\n  }\n\n\n  /**\n   * Traverses upwards from a given node until a given attribute is found.\n   *\n   * @param {!Element} element\n   * @param {string} attributeName\n   * @param {string=} nsName\n   * @return {?string}\n   * @private\n   */\n  static getInheritedAttribute_(element, attributeName, nsName) {\n    let ret = null;\n    const XmlUtils = shaka.util.XmlUtils;\n    while (element) {\n      ret = nsName ?\n          XmlUtils.getAttributeNS(element, nsName, attributeName) :\n          element.getAttribute(attributeName);\n      if (ret) {\n        break;\n      }\n\n      // Element.parentNode can lead to XMLDocument, which is not an Element and\n      // has no getAttribute().\n      const parentNode = element.parentNode;\n      if (parentNode instanceof Element) {\n        element = parentNode;\n      } else {\n        break;\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Factor parent/ancestor time attributes into the parsed time of a\n   * child/descendent.\n   *\n   * @param {!Element} parentElement\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {?number} start The child's start time\n   * @param {?number} end The child's end time\n   * @return {{start: ?number, end: ?number}}\n   * @private\n   */\n  static resolveTime_(parentElement, rateInfo, start, end) {\n    const parentTime = shaka.text.TtmlTextParser.parseTime_(\n        parentElement, rateInfo);\n\n    if (start == null) {\n      // No start time of your own?  Inherit from the parent.\n      start = parentTime.start;\n    } else {\n      // Otherwise, the start time is relative to the parent's start time.\n      if (parentTime.start != null) {\n        start += parentTime.start;\n      }\n    }\n\n    if (end == null) {\n      // No end time of your own?  Inherit from the parent.\n      end = parentTime.end;\n    } else {\n      // Otherwise, the end time is relative to the parent's _start_ time.\n      // This is not a typo.  Both times are relative to the parent's _start_.\n      if (parentTime.start != null) {\n        end += parentTime.start;\n      }\n    }\n\n    return {start, end};\n  }\n\n  /**\n   * Parse TTML time attributes from the given element.\n   *\n   * @param {!Element} element\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @return {{start: ?number, end: ?number}}\n   * @private\n   */\n  static parseTime_(element, rateInfo) {\n    const start = shaka.text.TtmlTextParser.parseTimeAttribute_(\n        element.getAttribute('begin'), rateInfo);\n    let end = shaka.text.TtmlTextParser.parseTimeAttribute_(\n        element.getAttribute('end'), rateInfo);\n    const duration = shaka.text.TtmlTextParser.parseTimeAttribute_(\n        element.getAttribute('dur'), rateInfo);\n    if (end == null && duration != null) {\n      end = start + duration;\n    }\n    return {start, end};\n  }\n\n  /**\n   * Parses a TTML time from the given attribute text.\n   *\n   * @param {string} text\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @return {?number}\n   * @private\n   */\n  static parseTimeAttribute_(text, rateInfo) {\n    let ret = null;\n    const TtmlTextParser = shaka.text.TtmlTextParser;\n\n    if (TtmlTextParser.timeColonFormatFrames_.test(text)) {\n      ret = TtmlTextParser.parseColonTimeWithFrames_(rateInfo, text);\n    } else if (TtmlTextParser.timeColonFormat_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeColonFormat_, text);\n    } else if (TtmlTextParser.timeColonFormatMilliseconds_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeColonFormatMilliseconds_, text);\n    } else if (TtmlTextParser.timeFramesFormat_.test(text)) {\n      ret = TtmlTextParser.parseFramesTime_(rateInfo, text);\n    } else if (TtmlTextParser.timeTickFormat_.test(text)) {\n      ret = TtmlTextParser.parseTickTime_(rateInfo, text);\n    } else if (TtmlTextParser.timeHMSFormat_.test(text)) {\n      ret = TtmlTextParser.parseTimeFromRegex_(\n          TtmlTextParser.timeHMSFormat_, text);\n    } else if (text) {\n      // It's not empty or null, but it doesn't match a known format.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE,\n          'Could not parse cue time range in TTML');\n    }\n\n    return ret;\n  }\n\n  /**\n   * Parses a TTML time in frame format.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseFramesTime_(rateInfo, text) {\n    // 75f or 75.5f\n    const results = shaka.text.TtmlTextParser.timeFramesFormat_.exec(text);\n    const frames = Number(results[1]);\n\n    return frames / rateInfo.frameRate;\n  }\n\n  /**\n   * Parses a TTML time in tick format.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseTickTime_(rateInfo, text) {\n    // 50t or 50.5t\n    const results = shaka.text.TtmlTextParser.timeTickFormat_.exec(text);\n    const ticks = Number(results[1]);\n\n    return ticks / rateInfo.tickRate;\n  }\n\n  /**\n   * Parses a TTML colon formatted time containing frames.\n   *\n   * @param {!shaka.text.TtmlTextParser.RateInfo_} rateInfo\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseColonTimeWithFrames_(rateInfo, text) {\n    // 01:02:43:07 ('07' is frames) or 01:02:43:07.1 (subframes)\n    const results = shaka.text.TtmlTextParser.timeColonFormatFrames_.exec(text);\n\n    const hours = Number(results[1]);\n    const minutes = Number(results[2]);\n    let seconds = Number(results[3]);\n    let frames = Number(results[4]);\n    const subframes = Number(results[5]) || 0;\n\n    frames += subframes / rateInfo.subFrameRate;\n    seconds += frames / rateInfo.frameRate;\n\n    return seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * Parses a TTML time with a given regex. Expects regex to be some\n   * sort of a time-matcher to match hours, minutes, seconds and milliseconds\n   *\n   * @param {!RegExp} regex\n   * @param {string} text\n   * @return {?number}\n   * @private\n   */\n  static parseTimeFromRegex_(regex, text) {\n    const results = regex.exec(text);\n    if (results == null || results[0] == '') {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]) || 0;\n    const seconds = Number(results[3]) || 0;\n    const milliseconds = Number(results[4]) || 0;\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * If ttp:cellResolution provided returns cell resolution info\n   * with number of columns and rows into which the Root Container\n   * Region area is divided\n   *\n   * @param {?string} cellResolution\n   * @return {?{columns: number, rows: number}}\n   * @private\n   */\n  static getCellResolution_(cellResolution) {\n    if (!cellResolution) {\n      return null;\n    }\n    const matches = /^(\\d+) (\\d+)$/.exec(cellResolution);\n\n    if (!matches) {\n      return null;\n    }\n\n    const columns = parseInt(matches[1], 10);\n    const rows = parseInt(matches[2], 10);\n\n    return {columns, rows};\n  }\n};\n\n/**\n * @summary\n * Contains information about frame/subframe rate\n * and frame rate multiplier for time in frame format.\n *\n * @example 01:02:03:04(4 frames) or 01:02:03:04.1(4 frames, 1 subframe)\n * @private\n */\nshaka.text.TtmlTextParser.RateInfo_ = class {\n  /**\n   * @param {?string} frameRate\n   * @param {?string} subFrameRate\n   * @param {?string} frameRateMultiplier\n   * @param {?string} tickRate\n   */\n  constructor(frameRate, subFrameRate, frameRateMultiplier, tickRate) {\n    /**\n     * @type {number}\n     */\n    this.frameRate = Number(frameRate) || 30;\n\n    /**\n     * @type {number}\n     */\n    this.subFrameRate = Number(subFrameRate) || 1;\n\n    /**\n     * @type {number}\n     */\n    this.tickRate = Number(tickRate);\n    if (this.tickRate == 0) {\n      if (frameRate) {\n        this.tickRate = this.frameRate * this.subFrameRate;\n      } else {\n        this.tickRate = 1;\n      }\n    }\n\n    if (frameRateMultiplier) {\n      const multiplierResults = /^(\\d+) (\\d+)$/g.exec(frameRateMultiplier);\n      if (multiplierResults) {\n        const numerator = Number(multiplierResults[1]);\n        const denominator = Number(multiplierResults[2]);\n        const multiplierNum = numerator / denominator;\n        this.frameRate *= multiplierNum;\n      }\n    }\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50.17% 10%\n */\nshaka.text.TtmlTextParser.percentValues_ =\n    /^(\\d{1,2}(?:\\.\\d+)?|100(?:\\.0+)?)% (\\d{1,2}(?:\\.\\d+)?|100(?:\\.0+)?)%$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 0.6% 90%\n */\nshaka.text.TtmlTextParser.percentValue_ = /^(\\d{1,2}(?:\\.\\d+)?|100)%$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px, 8em, 0.80c\n */\nshaka.text.TtmlTextParser.unitValues_ = /^(\\d+px|\\d+em|\\d*\\.?\\d+c)$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 100px\n */\nshaka.text.TtmlTextParser.pixelValues_ = /^(\\d+)px (\\d+)px$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)\n */\nshaka.text.TtmlTextParser.timeColonFormatFrames_ =\n    /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00:40 or 00:40\n */\nshaka.text.TtmlTextParser.timeColonFormat_ = /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2})$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 01:02:43.0345555 or 02:43.03\n */\nshaka.text.TtmlTextParser.timeColonFormatMilliseconds_ =\n    /^(?:(\\d{2,}):)?(\\d{2}):(\\d{2}\\.\\d{2,})$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 75f or 75.5f\n */\nshaka.text.TtmlTextParser.timeFramesFormat_ = /^(\\d*(?:\\.\\d*)?)f$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 50t or 50.5t\n */\nshaka.text.TtmlTextParser.timeTickFormat_ = /^(\\d*(?:\\.\\d*)?)t$/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 3.45h, 3m or 4.20s\n */\nshaka.text.TtmlTextParser.timeHMSFormat_ =\n    new RegExp(['^(?:(\\\\d*(?:\\\\.\\\\d*)?)h)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)m)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)s)?',\n      '(?:(\\\\d*(?:\\\\.\\\\d*)?)ms)?$'].join(''));\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.lineAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToLineAlign_ = {\n  'left': shaka.text.Cue.lineAlign.START,\n  'center': shaka.text.Cue.lineAlign.CENTER,\n  'right': shaka.text.Cue.lineAlign.END,\n  'start': shaka.text.Cue.lineAlign.START,\n  'end': shaka.text.Cue.lineAlign.END,\n};\n\n/**\n * @const\n * @private {!Object.<string, shaka.text.Cue.positionAlign>}\n */\nshaka.text.TtmlTextParser.textAlignToPositionAlign_ = {\n  'left': shaka.text.Cue.positionAlign.LEFT,\n  'center': shaka.text.Cue.positionAlign.CENTER,\n  'right': shaka.text.Cue.positionAlign.RIGHT,\n};\n\n/**\n * The namespace URL for TTML parameters.  Can be assigned any name in the TTML\n * document, not just \"ttp:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.text.TtmlTextParser.parameterNs_ = [\n  'http://www.w3.org/ns/ttml#parameter',\n  'http://www.w3.org/2006/10/ttaf1#parameter',\n];\n\n/**\n * The namespace URL for TTML styles.  Can be assigned any name in the TTML\n * document, not just \"tts:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {!Array.<string>}\n * @private\n */\nshaka.text.TtmlTextParser.styleNs_ = [\n  'http://www.w3.org/ns/ttml#styling',\n  'http://www.w3.org/2006/10/ttaf1#styling',\n];\n\n/**\n * The namespace URL for EBU TTML styles.  Can be assigned any name in the TTML\n * document, not just \"ebutts:\", so we use this with getAttributeNS() to ensure\n * that we support arbitrary namespace names.\n *\n * @const {string}\n * @private\n */\nshaka.text.TtmlTextParser.styleEbuttsNs_ = 'urn:ebu:tt:style';\n\n/**\n * The supported namespace URLs for SMPTE fields.\n * @const {!Array.<string>}\n * @private\n */\nshaka.text.TtmlTextParser.smpteNsList_ = [\n  'http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt',\n  'http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt',\n];\n\nshaka.text.TextEngine.registerParser(\n    'application/ttml+xml', () => new shaka.text.TtmlTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Mp4TtmlParser');\n\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.TtmlTextParser');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Mp4Parser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.Mp4TtmlParser = class {\n  /** */\n  constructor() {\n    /**\n     * @type {!shaka.extern.TextParser}\n     * @private\n     */\n    this.parser_ = new shaka.text.TtmlTextParser();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawSTPP = false;\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n        .box('stpp', (box) => {\n          sawSTPP = true;\n          box.parser.stop();\n        }).parse(data);\n\n    if (!sawSTPP) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_TTML);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawMDAT = false;\n    let payload = [];\n\n    const parser = new Mp4Parser()\n        .box('mdat', Mp4Parser.allData((data) => {\n          sawMDAT = true;\n          // Join this to any previous payload, in case the mp4 has multiple\n          // mdats.\n          payload = payload.concat(this.parser_.parseMedia(data, time));\n        }));\n    parser.parse(data, /* partialOkay= */ false);\n\n    if (!sawMDAT) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_TTML);\n    }\n\n    return payload;\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp\"', () => new shaka.text.Mp4TtmlParser());\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.ttml\"',\n    () => new shaka.text.Mp4TtmlParser());\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.ttml.im1t\"',\n    () => new shaka.text.Mp4TtmlParser());\n// Legacy codec string uses capital \"TTML\", i.e.: prior to HLS rfc8216bis:\n//   Note that if a Variant Stream specifies one or more Renditions that\n//   include IMSC subtitles, the CODECS attribute MUST indicate this with a\n//   format identifier such as \"stpp.ttml.im1t\".\n// (https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-05#section-4.4.5.2)\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"stpp.TTML.im1t\"',\n    () => new shaka.text.Mp4TtmlParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.VttTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.CueRegion');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\ngoog.require('shaka.util.XmlUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.VttTextParser = class {\n  /** Constructs a VTT parser. */\n  constructor() {\n    /** @private {boolean} */\n    this.sequenceMode_ = false;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'VTT does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    this.sequenceMode_ = sequenceMode;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const VttTextParser = shaka.text.VttTextParser;\n    // Get the input as a string.  Normalize newlines to \\n.\n    let str = shaka.util.StringUtils.fromUTF8(data);\n    str = str.replace(/\\r\\n|\\r(?=[^\\n]|$)/gm, '\\n');\n    const blocks = str.split(/\\n{2,}/m);\n\n    if (!/^WEBVTT($|[ \\t\\n])/m.test(blocks[0])) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_HEADER);\n    }\n\n    // Depending on \"segmentRelativeVttTiming\" configuration,\n    // \"vttOffset\" will correspond to either \"periodStart\" (default)\n    // or \"segmentStart\", for segmented VTT where timings are relative\n    // to the beginning of each segment.\n    // NOTE: \"periodStart\" is the timestamp offset applied via TextEngine.\n    // It is no longer closely tied to periods, but the name stuck around.\n    // NOTE: This offset and the flag choosing its meaning have no effect on\n    // HLS content, which should use X-TIMESTAMP-MAP and periodStart instead.\n    let offset = time.vttOffset;\n\n    // Only use 'X-TIMESTAMP-MAP' in sequence mode, as that is currently\n    // shorthand for HLS.  Note that an offset based on the first video\n    // timestamp has already been extracted, and appears in periodStart.\n    // The relative offset from X-TIMESTAMP-MAP will be added to that for HLS.\n    if (blocks[0].includes('X-TIMESTAMP-MAP') && this.sequenceMode_) {\n      // https://bit.ly/2K92l7y\n      // The 'X-TIMESTAMP-MAP' header is used in HLS to align text with\n      // the rest of the media.\n      // The header format is 'X-TIMESTAMP-MAP=MPEGTS:n,LOCAL:m'\n      // (the attributes can go in any order)\n      // where n is MPEG-2 time and m is cue time it maps to.\n      // For example 'X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000'\n      // means an offset of 10 seconds\n      // 900000/MPEG_TIMESCALE - cue time.\n      const cueTimeMatch =\n            blocks[0].match(/LOCAL:((?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{3}))/m);\n\n      const mpegTimeMatch = blocks[0].match(/MPEGTS:(\\d+)/m);\n      if (cueTimeMatch && mpegTimeMatch) {\n        const parser = new shaka.util.TextParser(cueTimeMatch[1]);\n        const cueTime = shaka.text.VttTextParser.parseTime_(parser);\n        if (cueTime == null) {\n          throw new shaka.util.Error(\n              shaka.util.Error.Severity.CRITICAL,\n              shaka.util.Error.Category.TEXT,\n              shaka.util.Error.Code.INVALID_TEXT_HEADER);\n        }\n\n        let mpegTime = Number(mpegTimeMatch[1]);\n        const mpegTimescale = shaka.text.VttTextParser.MPEG_TIMESCALE_;\n\n        const rolloverSeconds =\n            shaka.text.VttTextParser.TS_ROLLOVER_ / mpegTimescale;\n        let segmentStart = time.segmentStart - time.periodStart;\n        while (segmentStart >= rolloverSeconds) {\n          segmentStart -= rolloverSeconds;\n          mpegTime += shaka.text.VttTextParser.TS_ROLLOVER_;\n        }\n\n        offset = time.periodStart + mpegTime / mpegTimescale - cueTime;\n      }\n    }\n\n    // Parse VTT regions.\n    /* !Array.<!shaka.extern.CueRegion> */\n    const regions = [];\n    for (const line of blocks[0].split('\\n')) {\n      if (/^Region:/.test(line)) {\n        const region = VttTextParser.parseRegion_(line);\n        regions.push(region);\n      }\n    }\n\n    /** @type {!Map.<string, shaka.text.Cue>} */\n    const styles = new Map();\n    VttTextParser.addDefaultTextColor_(styles);\n\n    // Parse cues.\n    const ret = [];\n    for (const block of blocks.slice(1)) {\n      const lines = block.split('\\n');\n      VttTextParser.parseStyle_(lines, styles);\n      const cue = VttTextParser.parseCue_(lines, offset, regions, styles);\n      if (cue) {\n        ret.push(cue);\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Add default color\n   *\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @private\n   */\n  static addDefaultTextColor_(styles) {\n    const textColor = shaka.text.Cue.defaultTextColor;\n    for (const [key, value] of Object.entries(textColor)) {\n      const cue = new shaka.text.Cue(0, 0, '');\n      cue.color = value;\n      styles.set('.' + key, cue);\n    }\n\n    const bgColor = shaka.text.Cue.defaultTextBackgroundColor;\n    for (const [key, value] of Object.entries(bgColor)) {\n      const cue = new shaka.text.Cue(0, 0, '');\n      cue.backgroundColor = value;\n      styles.set('.' + key, cue);\n    }\n  }\n\n  /**\n   * Parses a string into a Region object.\n   *\n   * @param {string} text\n   * @return {!shaka.extern.CueRegion}\n   * @private\n   */\n  static parseRegion_(text) {\n    const VttTextParser = shaka.text.VttTextParser;\n    const parser = new shaka.util.TextParser(text);\n    // The region string looks like this:\n    // Region: id=fred width=50% lines=3 regionanchor=0%,100%\n    //         viewportanchor=10%,90% scroll=up\n    const region = new shaka.text.CueRegion();\n\n    // Skip 'Region:'\n    parser.readWord();\n    parser.skipWhitespace();\n\n    let word = parser.readWord();\n    while (word) {\n      if (!VttTextParser.parseRegionSetting_(region, word)) {\n        shaka.log.warning(\n            'VTT parser encountered an invalid VTTRegion setting: ', word,\n            ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n\n    return region;\n  }\n\n  /**\n   * Parses a style block into a Cue object.\n   *\n   * @param {!Array.<string>} text\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @private\n   */\n  static parseStyle_(text, styles) {\n    // Skip empty blocks.\n    if (text.length == 1 && !text[0]) {\n      return;\n    }\n\n    // Skip comment blocks.\n    if (/^NOTE($|[ \\t])/.test(text[0])) {\n      return;\n    }\n\n    // Only style block are allowed.\n    if (text[0] != 'STYLE') {\n      return;\n    }\n\n    /** @type {!Array.<!Array.<string>>} */\n    const styleBlocks = [];\n    let lastBlockIndex = -1;\n    for (let i = 1; i < text.length; i++) {\n      if (text[i].includes('::cue')) {\n        styleBlocks.push([]);\n        lastBlockIndex = styleBlocks.length - 1;\n      }\n      if (lastBlockIndex == -1) {\n        continue;\n      }\n      styleBlocks[lastBlockIndex].push(text[i]);\n      if (text[i].includes('}')) {\n        lastBlockIndex = -1;\n      }\n    }\n\n    for (const styleBlock of styleBlocks) {\n      let styleSelector = 'global';\n      // Look for what is within parentheses. For example:\n      // <code>:: cue (b) {</code>, what we are looking for is <code>b</code>\n      const selector = styleBlock[0].match(/\\((.*)\\)/);\n      if (selector) {\n        styleSelector = selector.pop();\n      }\n\n      // We start at 1 to avoid '::cue' and end earlier to avoid '}'\n      let propertyLines = styleBlock.slice(1, -1);\n      if (styleBlock[0].includes('}')) {\n        const payload = /\\{(.*?)\\}/.exec(styleBlock[0]);\n        if (payload) {\n          propertyLines = payload[1].split(';');\n        }\n      }\n\n      // Continue styles over multiple selectors if necessary.\n      // For example,\n      //   ::cue(b) { background: white; } ::cue(b) { color: blue; }\n      // should set both the background and foreground of bold tags.\n      let cue = styles.get(styleSelector);\n      if (!cue) {\n        cue = new shaka.text.Cue(0, 0, '');\n      }\n\n      let validStyle = false;\n      for (let i = 0; i < propertyLines.length; i++) {\n        // We look for CSS properties. As a general rule they are separated by\n        // <code>:</code>. Eg: <code>color: red;</code>\n        const lineParts = /^\\s*([^:]+):\\s*(.*)/.exec(propertyLines[i]);\n        if (lineParts) {\n          const name = lineParts[1].trim();\n          const value = lineParts[2].trim().replace(';', '');\n          switch (name) {\n            case 'background-color':\n            case 'background':\n              validStyle = true;\n              cue.backgroundColor = value;\n              break;\n            case 'color':\n              validStyle = true;\n              cue.color = value;\n              break;\n            case 'font-family':\n              validStyle = true;\n              cue.fontFamily = value;\n              break;\n            case 'font-size':\n              validStyle = true;\n              cue.fontSize = value;\n              break;\n            case 'font-weight':\n              if (parseInt(value, 10) >= 700 || value == 'bold') {\n                validStyle = true;\n                cue.fontWeight = shaka.text.Cue.fontWeight.BOLD;\n              }\n              break;\n            case 'font-style':\n              switch (value) {\n                case 'normal':\n                  validStyle = true;\n                  cue.fontStyle = shaka.text.Cue.fontStyle.NORMAL;\n                  break;\n                case 'italic':\n                  validStyle = true;\n                  cue.fontStyle = shaka.text.Cue.fontStyle.ITALIC;\n                  break;\n                case 'oblique':\n                  validStyle = true;\n                  cue.fontStyle = shaka.text.Cue.fontStyle.OBLIQUE;\n                  break;\n              }\n              break;\n            case 'opacity':\n              validStyle = true;\n              cue.opacity = parseFloat(value);\n              break;\n            case 'text-shadow':\n              validStyle = true;\n              cue.textShadow = value;\n              break;\n            case 'white-space':\n              validStyle = true;\n              cue.wrapLine = value != 'noWrap';\n              break;\n            default:\n              shaka.log.warning('VTT parser encountered an unsupported style: ',\n                  lineParts);\n              break;\n          }\n        }\n      }\n\n      if (validStyle) {\n        styles.set(styleSelector, cue);\n      }\n    }\n  }\n\n  /**\n   * Parses a text block into a Cue object.\n   *\n   * @param {!Array.<string>} text\n   * @param {number} timeOffset\n   * @param {!Array.<!shaka.extern.CueRegion>} regions\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseCue_(text, timeOffset, regions, styles) {\n    const VttTextParser = shaka.text.VttTextParser;\n\n    // Skip empty blocks.\n    if (text.length == 1 && !text[0]) {\n      return null;\n    }\n\n    // Skip comment blocks.\n    if (/^NOTE($|[ \\t])/.test(text[0])) {\n      return null;\n    }\n\n    // Skip style and region blocks.\n    if (text[0] == 'STYLE' || text[0] == 'REGION') {\n      return null;\n    }\n\n    let id = null;\n    if (!text[0].includes('-->')) {\n      id = text[0];\n      text.splice(0, 1);\n    }\n\n    // Parse the times.\n    const parser = new shaka.util.TextParser(text[0]);\n    let start = VttTextParser.parseTime_(parser);\n    const expect = parser.readRegex(/[ \\t]+-->[ \\t]+/g);\n    let end = VttTextParser.parseTime_(parser);\n\n    if (start == null || expect == null || end == null) {\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_TEXT_CUE,\n          'Could not parse cue time range in WebVTT');\n    }\n\n    start += timeOffset;\n    end += timeOffset;\n\n    // Get the payload.\n    const payload = VttTextParser.htmlUnescape_(\n        text.slice(1).join('\\n').trim());\n\n    let cue = null;\n    if (styles.has('global')) {\n      cue = styles.get('global').clone();\n      cue.startTime = start;\n      cue.endTime = end;\n      cue.payload = '';\n    } else {\n      cue = new shaka.text.Cue(start, end, '');\n    }\n\n    VttTextParser.parseCueStyles(payload, cue, styles);\n\n    // Parse optional settings.\n    parser.skipWhitespace();\n    let word = parser.readWord();\n    while (word) {\n      if (!VttTextParser.parseCueSetting(cue, word, regions)) {\n        shaka.log.warning('VTT parser encountered an invalid VTT setting: ',\n            word,\n            ' The setting will be ignored.');\n      }\n      parser.skipWhitespace();\n      word = parser.readWord();\n    }\n\n    if (id != null) {\n      cue.id = id;\n    }\n    return cue;\n  }\n\n  /**\n   * Parses a WebVTT styles from the given payload.\n   *\n   * @param {string} payload\n   * @param {!shaka.text.Cue} rootCue\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   */\n  static parseCueStyles(payload, rootCue, styles) {\n    const VttTextParser = shaka.text.VttTextParser;\n    if (styles.size === 0) {\n      VttTextParser.addDefaultTextColor_(styles);\n    }\n    payload = VttTextParser.replaceColorPayload_(payload);\n    payload = VttTextParser.replaceKaraokeStylePayload_(payload);\n    payload = VttTextParser.replaceVoiceStylePayload_(payload);\n    const xmlPayload = '<span>' + payload + '</span>';\n    const element = shaka.util.XmlUtils.parseXmlString(xmlPayload, 'span');\n    if (element) {\n      /** @type {!Array.<!shaka.extern.Cue>} */\n      const cues = [];\n      const childNodes = element.childNodes;\n      if (childNodes.length == 1) {\n        const childNode = childNodes[0];\n        if (childNode.nodeType == Node.TEXT_NODE ||\n            childNode.nodeType == Node.CDATA_SECTION_NODE) {\n          rootCue.payload = payload;\n          return;\n        }\n      }\n      for (const childNode of childNodes) {\n        VttTextParser.generateCueFromElement_(\n            childNode, rootCue, cues, styles);\n      }\n      rootCue.nestedCues = cues;\n    } else {\n      shaka.log.warning('The cue\\'s markup could not be parsed: ', payload);\n      rootCue.payload = payload;\n    }\n  }\n\n  /**\n   * Converts voice style tag to be valid for xml parsing\n   * For example,\n   * input: <v Shaka>Test\n   * output: <v.voice-Shaka>Test</v.voice-Shaka>\n   *\n   * @param {string} payload\n   * @return {string} processed payload\n   * @private\n   */\n  static replaceVoiceStylePayload_(payload) {\n    const voiceTag = 'v';\n    const names = [];\n    let nameStart = -1;\n    let newPayload = '';\n    let hasVoiceEndTag = false;\n    for (let i = 0; i < payload.length; i++) {\n      // This condition is used to manage tags that have end tags.\n      if (payload[i] === '/') {\n        const end = payload.indexOf('>', i);\n        if (end === -1) {\n          return payload;\n        }\n        const tagEnd = payload.substring(i + 1, end);\n        if (!tagEnd || tagEnd != voiceTag) {\n          newPayload += payload[i];\n          continue;\n        }\n        hasVoiceEndTag = true;\n        let tagStart = null;\n        if (names.length) {\n          tagStart = names[names.length -1];\n        }\n        if (!tagStart) {\n          newPayload += payload[i];\n        } else if (tagStart === tagEnd) {\n          newPayload += '/' + tagEnd + '>';\n          i += tagEnd.length + 1;\n        } else {\n          if (!tagStart.startsWith(voiceTag)) {\n            newPayload += payload[i];\n            continue;\n          }\n          newPayload += '/' + tagStart + '>';\n          i += tagEnd.length + 1;\n        }\n      } else {\n        // Here we only want the tag name, not any other payload.\n        if (payload[i] === '<') {\n          nameStart = i + 1;\n          if (payload[nameStart] != voiceTag) {\n            nameStart = -1;\n          }\n        } else if (payload[i] === '>') {\n          if (nameStart > 0) {\n            names.push(payload.substr(nameStart, i - nameStart));\n            nameStart = -1;\n          }\n        }\n        newPayload += payload[i];\n      }\n    }\n    for (const name of names) {\n      const newName = name.replace(' ', '.voice-');\n      newPayload = newPayload.replace(`<${name}>`, `<${newName}>`);\n      newPayload = newPayload.replace(`</${name}>`, `</${newName}>`);\n      if (!hasVoiceEndTag) {\n        newPayload += `</${newName}>`;\n      }\n    }\n    return newPayload;\n  }\n\n  /**\n   * Converts karaoke style tag to be valid for xml parsing\n   * For example,\n   * input: Text <00:00:00.450> time <00:00:01.450> 1\n   * output: Text <div time=\"00:00:00.450\"> time\n   *         <div time=\"00:00:01.450\"> 1</div></div>\n   *\n   * @param {string} payload\n   * @return {string} processed payload\n   * @private\n   */\n  static replaceKaraokeStylePayload_(payload) {\n    const names = [];\n    let nameStart = -1;\n    for (let i = 0; i < payload.length; i++) {\n      if (payload[i] === '<') {\n        nameStart = i + 1;\n      } else if (payload[i] === '>') {\n        if (nameStart > 0) {\n          const name = payload.substr(nameStart, i - nameStart);\n          if (name.match(shaka.text.VttTextParser.timeFormat_)) {\n            names.push(name);\n          }\n          nameStart = -1;\n        }\n      }\n    }\n    let newPayload = payload;\n    for (const name of names) {\n      const replaceTag = '<' + name + '>';\n      const startTag = '<div time=\"' + name + '\">';\n      const endTag = '</div>';\n      newPayload = newPayload.replace(replaceTag, startTag);\n      newPayload += endTag;\n    }\n    return newPayload;\n  }\n\n  /**\n   * Converts color end tag to be valid for xml parsing\n   * For example,\n   * input: <c.yellow.bg_blue>Yellow text on blue bg</c>\n   * output: <c.yellow.bg_blue>Yellow text on blue bg</c.yellow.bg_blue>\n   *\n   * Returns original payload if invalid tag is found.\n   * Invalid tag example: <c.yellow><b>Example</c></b>\n   *\n   * @param {string} payload\n   * @return {string} processed payload\n   * @private\n   */\n  static replaceColorPayload_(payload) {\n    const names = [];\n    let nameStart = -1;\n    let newPayload = '';\n    for (let i = 0; i < payload.length; i++) {\n      if (payload[i] === '/' && i > 0 && payload[i - 1] === '<') {\n        const end = payload.indexOf('>', i);\n        if (end <= i) {\n          return payload;\n        }\n        const tagEnd = payload.substring(i + 1, end);\n        if (!tagEnd || tagEnd !== 'c') {\n          newPayload += payload[i];\n          continue;\n        }\n        const tagStart = names.pop();\n        if (!tagStart) {\n          newPayload += payload[i];\n        } else if (tagStart === tagEnd) {\n          newPayload += '/' + tagEnd + '>';\n          i += tagEnd.length + 1;\n        } else {\n          if (!tagStart.startsWith('c.')) {\n            newPayload += payload[i];\n            continue;\n          }\n          i += tagEnd.length + 1;\n          newPayload += '/' + tagStart + '>';\n        }\n      } else {\n        if (payload[i] === '<') {\n          nameStart = i + 1;\n          if (payload[nameStart] != 'c') {\n            nameStart = -1;\n          }\n        } else if (payload[i] === '>') {\n          if (nameStart > 0) {\n            names.push(payload.substr(nameStart, i - nameStart));\n            nameStart = -1;\n          }\n        }\n        newPayload += payload[i];\n      }\n    }\n    return newPayload;\n  }\n\n  /**\n   * @param {string} value\n   * @param {string} defaultValue\n   * @private\n   */\n  static getOrDefault_(value, defaultValue) {\n    if (value && value.length > 0) {\n      return value;\n    }\n    return defaultValue;\n  }\n\n  /**\n   * Merges values created in parseStyle_\n   * @param {!shaka.extern.Cue} cue\n   * @param {shaka.extern.Cue} refCue\n   * @private\n   */\n  static mergeStyle_(cue, refCue) {\n    if (!refCue) {\n      return;\n    }\n\n    const VttTextParser = shaka.text.VttTextParser;\n    // Overwrites if new value string length > 0\n    cue.backgroundColor = VttTextParser.getOrDefault_(\n        refCue.backgroundColor, cue.backgroundColor);\n    cue.color = VttTextParser.getOrDefault_(\n        refCue.color, cue.color);\n    cue.fontFamily = VttTextParser.getOrDefault_(\n        refCue.fontFamily, cue.fontFamily);\n    cue.fontSize = VttTextParser.getOrDefault_(\n        refCue.fontSize, cue.fontSize);\n\n    // Overwrite with new values as unable to determine\n    // if new value is set or not\n    cue.fontWeight = refCue.fontWeight;\n    cue.fontStyle = refCue.fontStyle;\n    cue.opacity = refCue.opacity;\n    cue.wrapLine = refCue.wrapLine;\n  }\n\n  /**\n   * @param {!Node} element\n   * @param {!shaka.text.Cue} rootCue\n   * @param {Array.<!shaka.extern.Cue>} cues\n   * @param {!Map.<string, shaka.text.Cue>} styles\n   * @private\n   */\n  static generateCueFromElement_(element, rootCue, cues, styles) {\n    const VttTextParser = shaka.text.VttTextParser;\n    const nestedCue = rootCue.clone();\n    if (element.nodeType === Node.ELEMENT_NODE && element.nodeName) {\n      const bold = shaka.text.Cue.fontWeight.BOLD;\n      const italic = shaka.text.Cue.fontStyle.ITALIC;\n      const underline = shaka.text.Cue.textDecoration.UNDERLINE;\n      const tags = element.nodeName.split(/(?=[ .])+/g);\n      for (const tag of tags) {\n        let styleTag = tag;\n        // White blanks at start indicate that the style is a voice\n        if (styleTag.startsWith('.voice-')) {\n          const voice = styleTag.split('-').pop();\n          styleTag = `v[voice=\"${voice}\"]`;\n          // The specification allows to have quotes and not, so we check to\n          // see which one is being used.\n          if (!styles.has(styleTag)) {\n            styleTag = `v[voice=${voice}]`;\n          }\n        }\n        if (styles.has(styleTag)) {\n          VttTextParser.mergeStyle_(nestedCue, styles.get(styleTag));\n        }\n        switch (tag) {\n          case 'br': {\n            const lineBreakCue = rootCue.clone();\n            lineBreakCue.lineBreak = true;\n            cues.push(lineBreakCue);\n            break;\n          }\n          case 'b':\n            nestedCue.fontWeight = bold;\n            break;\n          case 'i':\n            nestedCue.fontStyle = italic;\n            break;\n          case 'u':\n            nestedCue.textDecoration.push(underline);\n            break;\n          case 'div': {\n            const time = /** @type {!Element} */(element).getAttribute('time');\n            if (!time) {\n              break;\n            }\n            const parser = new shaka.util.TextParser(time);\n            const cueTime = shaka.text.VttTextParser.parseTime_(parser);\n            if (cueTime) {\n              nestedCue.startTime = cueTime;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n      }\n    }\n    const isTextNode = shaka.util.XmlUtils.isText(element);\n    if (isTextNode) {\n      // Trailing line breaks may lost when convert cue to HTML tag\n      // Need to insert line break cue to preserve line breaks\n      const textArr = element.textContent.split('\\n');\n      let isFirst = true;\n      for (const text of textArr) {\n        if (!isFirst) {\n          const lineBreakCue = rootCue.clone();\n          lineBreakCue.lineBreak = true;\n          cues.push(lineBreakCue);\n        }\n        if (text.length > 0) {\n          const textCue = nestedCue.clone();\n          textCue.payload = text;\n          cues.push(textCue);\n        }\n        isFirst = false;\n      }\n    } else {\n      for (const childNode of element.childNodes) {\n        VttTextParser.generateCueFromElement_(\n            childNode, nestedCue, cues, styles);\n      }\n    }\n  }\n\n  /**\n   * Parses a WebVTT setting from the given word.\n   *\n   * @param {!shaka.text.Cue} cue\n   * @param {string} word\n   * @param {!Array.<!shaka.text.CueRegion>} regions\n   * @return {boolean} True on success.\n   */\n  static parseCueSetting(cue, word, regions) {\n    const VttTextParser = shaka.text.VttTextParser;\n    let results = null;\n    if ((results = /^align:(start|middle|center|end|left|right)$/.exec(word))) {\n      VttTextParser.setTextAlign_(cue, results[1]);\n    } else if ((results = /^vertical:(lr|rl)$/.exec(word))) {\n      VttTextParser.setVerticalWritingMode_(cue, results[1]);\n    } else if ((results = /^size:([\\d.]+)%$/.exec(word))) {\n      cue.size = Number(results[1]);\n    } else if ((results =\n        /^position:([\\d.]+)%(?:,(line-left|line-right|center|start|end))?$/\n            .exec(word))) {\n      cue.position = Number(results[1]);\n      if (results[2]) {\n        VttTextParser.setPositionAlign_(cue, results[2]);\n      }\n    } else if ((results = /^region:(.*)$/.exec(word))) {\n      const region = VttTextParser.getRegionById_(regions, results[1]);\n      if (region) {\n        cue.region = region;\n      }\n    } else {\n      return VttTextParser.parsedLineValueAndInterpretation_(cue, word);\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Array.<!shaka.text.CueRegion>} regions\n   * @param {string} id\n   * @return {?shaka.text.CueRegion}\n   * @private\n   */\n  static getRegionById_(regions, id) {\n    const regionsWithId = regions.filter((region) => {\n      return region.id == id;\n    });\n    if (!regionsWithId.length) {\n      shaka.log.warning('VTT parser could not find a region with id: ',\n          id,\n          ' The region will be ignored.');\n      return null;\n    }\n    goog.asserts.assert(regionsWithId.length == 1,\n        'VTTRegion ids should be unique!');\n\n    return regionsWithId[0];\n  }\n\n  /**\n   * Parses a WebVTTRegion setting from the given word.\n   *\n   * @param {!shaka.text.CueRegion} region\n   * @param {string} word\n   * @return {boolean} True on success.\n   * @private\n   */\n  static parseRegionSetting_(region, word) {\n    let results = null;\n    if ((results = /^id=(.*)$/.exec(word))) {\n      region.id = results[1];\n    } else if ((results = /^width=(\\d{1,2}|100)%$/.exec(word))) {\n      region.width = Number(results[1]);\n    } else if ((results = /^lines=(\\d+)$/.exec(word))) {\n      region.height = Number(results[1]);\n      region.heightUnits = shaka.text.CueRegion.units.LINES;\n    } else if ((results = /^regionanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n        .exec(word))) {\n      region.regionAnchorX = Number(results[1]);\n      region.regionAnchorY = Number(results[2]);\n    } else if ((results = /^viewportanchor=(\\d{1,2}|100)%,(\\d{1,2}|100)%$/\n        .exec(word))) {\n      region.viewportAnchorX = Number(results[1]);\n      region.viewportAnchorY = Number(results[2]);\n    } else if ((results = /^scroll=up$/.exec(word))) {\n      region.scroll = shaka.text.CueRegion.scrollMode.UP;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} align\n   * @private\n   */\n  static setTextAlign_(cue, align) {\n    const Cue = shaka.text.Cue;\n    if (align == 'middle') {\n      cue.textAlign = Cue.textAlign.CENTER;\n    } else {\n      goog.asserts.assert(align.toUpperCase() in Cue.textAlign,\n          align.toUpperCase() +\n                          ' Should be in Cue.textAlign values!');\n\n      cue.textAlign = Cue.textAlign[align.toUpperCase()];\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} align\n   * @private\n   */\n  static setPositionAlign_(cue, align) {\n    const Cue = shaka.text.Cue;\n    if (align == 'line-left' || align == 'start') {\n      cue.positionAlign = Cue.positionAlign.LEFT;\n    } else if (align == 'line-right' || align == 'end') {\n      cue.positionAlign = Cue.positionAlign.RIGHT;\n    } else {\n      cue.positionAlign = Cue.positionAlign.CENTER;\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} value\n   * @private\n   */\n  static setVerticalWritingMode_(cue, value) {\n    const Cue = shaka.text.Cue;\n    if (value == 'lr') {\n      cue.writingMode = Cue.writingMode.VERTICAL_LEFT_TO_RIGHT;\n    } else {\n      cue.writingMode = Cue.writingMode.VERTICAL_RIGHT_TO_LEFT;\n    }\n  }\n\n  /**\n   * @param {!shaka.text.Cue} cue\n   * @param {string} word\n   * @return {boolean}\n   * @private\n   */\n  static parsedLineValueAndInterpretation_(cue, word) {\n    const Cue = shaka.text.Cue;\n    let results = null;\n    if ((results = /^line:([\\d.]+)%(?:,(start|end|center))?$/.exec(word))) {\n      cue.lineInterpretation = Cue.lineInterpretation.PERCENTAGE;\n      cue.line = Number(results[1]);\n      if (results[2]) {\n        goog.asserts.assert(\n            results[2].toUpperCase() in Cue.lineAlign,\n            results[2].toUpperCase() + ' Should be in Cue.lineAlign values!');\n        cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n      }\n    } else if ((results =\n                    /^line:(-?\\d+)(?:,(start|end|center))?$/.exec(word))) {\n      cue.lineInterpretation = Cue.lineInterpretation.LINE_NUMBER;\n      cue.line = Number(results[1]);\n      if (results[2]) {\n        goog.asserts.assert(\n            results[2].toUpperCase() in Cue.lineAlign,\n            results[2].toUpperCase() + ' Should be in Cue.lineAlign values!');\n        cue.lineAlign = Cue.lineAlign[results[2].toUpperCase()];\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Parses a WebVTT time from the given parser.\n   *\n   * @param {!shaka.util.TextParser} parser\n   * @return {?number}\n   * @private\n   */\n  static parseTime_(parser) {\n    const results = parser.readRegex(shaka.text.VttTextParser.timeFormat_);\n    if (results == null) {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]);\n    const seconds = Number(results[3]);\n    const milliseconds = Number(results[4]);\n    if (minutes > 59 || seconds > 59) {\n      return null;\n    }\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n\n  /**\n   * This method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;,\n   * &nbsp;, &lrm; and &rlm; in string to their corresponding characters.\n   *\n   * @param {!string} input\n   * @return {string}\n   * @private\n   */\n  static htmlUnescape_(input) {\n    // Used to map HTML entities to characters.\n    const htmlUnescapes = {\n      '&amp;': '&',\n      '&lt;': '<',\n      '&gt;': '>',\n      '&quot;': '\"',\n      '&#39;': '\\'',\n      '&nbsp;': '\\u{a0}',\n      '&lrm;': '\\u{200e}',\n      '&rlm;': '\\u{200f}',\n    };\n\n    // Used to match HTML entities and HTML characters.\n    const reEscapedHtml = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g;\n    const reHasEscapedHtml = RegExp(reEscapedHtml.source);\n    // This check is an optimization, since replace always makes a copy\n    if (input && reHasEscapedHtml.test(input)) {\n      return input.replace(reEscapedHtml, (entity) => {\n        // The only thing that might not match the dictionary above is the\n        // single quote, which can be matched by many strings in the regex, but\n        // only has a single entry in the dictionary.\n        return htmlUnescapes[entity] || '\\'';\n      });\n    }\n    return input || '';\n  }\n};\n\n/**\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.MPEG_TIMESCALE_ = 90000;\n\n/**\n * At this value, timestamps roll over in TS content.\n * @const {number}\n * @private\n */\nshaka.text.VttTextParser.TS_ROLLOVER_ = 0x200000000;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 00:00.000 or 00:00:00.000 or 0:00:00.000 or\n * 00:00.00 or 00:00:00.00 or 0:00:00.00\n */\nshaka.text.VttTextParser.timeFormat_ =\n    /(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{2,3})/g;\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt', () => new shaka.text.VttTextParser());\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"vtt\"', () => new shaka.text.VttTextParser());\n\nshaka.text.TextEngine.registerParser(\n    'text/vtt; codecs=\"wvtt\"', () => new shaka.text.VttTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.Mp4VttParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.VttTextParser');\ngoog.require('shaka.util.DataViewReader');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.Functional');\ngoog.require('shaka.util.Mp4Parser');\ngoog.require('shaka.util.Mp4BoxParsers');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.Mp4VttParser = class {\n  /** */\n  constructor() {\n    /**\n     * The current time scale used by the VTT parser.\n     *\n     * @type {?number}\n     * @private\n     */\n    this.timescale_ = null;\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let sawWVTT = false;\n\n    new Mp4Parser()\n        .box('moov', Mp4Parser.children)\n        .box('trak', Mp4Parser.children)\n        .box('mdia', Mp4Parser.children)\n        .fullBox('mdhd', (box) => {\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'MDHD version can only be 0 or 1');\n\n          const parsedMDHDBox = shaka.util.Mp4BoxParsers.parseMDHD(\n              box.reader, box.version);\n          this.timescale_ = parsedMDHDBox.timescale;\n        })\n        .box('minf', Mp4Parser.children)\n        .box('stbl', Mp4Parser.children)\n        .fullBox('stsd', Mp4Parser.sampleDescription)\n        .box('wvtt', (box) => {\n          // A valid vtt init segment, though we have no actual subtitles yet.\n          sawWVTT = true;\n        }).parse(data);\n\n    if (!this.timescale_) {\n      // Missing timescale for VTT content. It should be located in the MDHD.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    if (!sawWVTT) {\n      // A WVTT box should have been seen (a valid vtt init segment with no\n      // actual subtitles).\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    if (!this.timescale_) {\n      // Missing timescale for VTT content. We should have seen the init\n      // segment.\n      shaka.log.error('No init segment for MP4+VTT!');\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    const Mp4Parser = shaka.util.Mp4Parser;\n\n    let baseTime = 0;\n    /** @type {!Array.<shaka.util.ParsedTRUNSample>} */\n    let presentations = [];\n    /** @type {!Uint8Array} */\n    let rawPayload;\n    /** @type {!Array.<shaka.text.Cue>} */\n    const cues = [];\n\n    let sawTFDT = false;\n    let sawTRUN = false;\n    let sawMDAT = false;\n    let defaultDuration = null;\n\n    const parser = new Mp4Parser()\n        .box('moof', Mp4Parser.children)\n        .box('traf', Mp4Parser.children)\n        .fullBox('tfdt', (box) => {\n          sawTFDT = true;\n          goog.asserts.assert(\n              box.version == 0 || box.version == 1,\n              'TFDT version can only be 0 or 1');\n\n          const parsedTFDTBox = shaka.util.Mp4BoxParsers.parseTFDT(\n              box.reader, box.version);\n          baseTime = parsedTFDTBox.baseMediaDecodeTime;\n        })\n        .fullBox('tfhd', (box) => {\n          goog.asserts.assert(\n              box.flags != null,\n              'A TFHD box should have a valid flags value');\n          const parsedTFHDBox = shaka.util.Mp4BoxParsers.parseTFHD(\n              box.reader, box.flags);\n          defaultDuration = parsedTFHDBox.defaultSampleDuration;\n        })\n        .fullBox('trun', (box) => {\n          sawTRUN = true;\n          goog.asserts.assert(\n              box.version != null,\n              'A TRUN box should have a valid version value');\n          goog.asserts.assert(\n              box.flags != null,\n              'A TRUN box should have a valid flags value');\n\n          const parsedTRUNBox = shaka.util.Mp4BoxParsers.parseTRUN(\n              box.reader, box.version, box.flags);\n          presentations = parsedTRUNBox.sampleData;\n        })\n        .box('mdat', Mp4Parser.allData((data) => {\n          goog.asserts.assert(\n              !sawMDAT,\n              'VTT cues in mp4 with multiple MDAT are not currently supported');\n          sawMDAT = true;\n          rawPayload = data;\n        }));\n    parser.parse(data, /* partialOkay= */ false);\n\n    if (!sawMDAT && !sawTFDT && !sawTRUN) {\n      // A required box is missing.\n      throw new shaka.util.Error(\n          shaka.util.Error.Severity.CRITICAL,\n          shaka.util.Error.Category.TEXT,\n          shaka.util.Error.Code.INVALID_MP4_VTT);\n    }\n\n    let currentTime = baseTime;\n\n    /** @type {!shaka.util.DataViewReader} */\n    const reader = new shaka.util.DataViewReader(\n        rawPayload, shaka.util.DataViewReader.Endianness.BIG_ENDIAN);\n\n    for (const presentation of presentations) {\n      // If one presentation corresponds to multiple payloads, it is assumed\n      // that all of those payloads have the same start time and duration.\n      const duration = presentation.sampleDuration || defaultDuration;\n      const startTime = presentation.sampleCompositionTimeOffset ?\n                      baseTime + presentation.sampleCompositionTimeOffset :\n                      currentTime;\n      currentTime = startTime + (duration || 0);\n\n      // Read samples until it adds up to the given size.\n      let totalSize = 0;\n      do {\n        // Read the payload size.\n        const payloadSize = reader.readUint32();\n        totalSize += payloadSize;\n\n        // Skip the type.\n        const payloadType = reader.readUint32();\n        const payloadName = shaka.util.Mp4Parser.typeToString(payloadType);\n\n        // Read the data payload.\n        /** @type {Uint8Array} */\n        let payload = null;\n        if (payloadName == 'vttc') {\n          if (payloadSize > 8) {\n            payload = reader.readBytes(payloadSize - 8);\n          }\n        } else if (payloadName == 'vtte') {\n          // It's a vtte, which is a vtt cue that is empty. Ignore any data that\n          // does exist.\n          reader.skip(payloadSize - 8);\n        } else {\n          shaka.log.error('Unknown box ' + payloadName + '! Skipping!');\n          reader.skip(payloadSize - 8);\n        }\n\n        if (duration) {\n          if (payload) {\n            goog.asserts.assert(\n                this.timescale_ != null, 'Timescale should not be null!');\n            const cue = shaka.text.Mp4VttParser.parseVTTC_(\n                payload,\n                time.periodStart + startTime / this.timescale_,\n                time.periodStart + currentTime / this.timescale_);\n            cues.push(cue);\n          }\n        } else {\n          shaka.log.error(\n              'WVTT sample duration unknown, and no default found!');\n        }\n\n        goog.asserts.assert(\n            !presentation.sampleSize || totalSize <= presentation.sampleSize,\n            'The samples do not fit evenly into the sample sizes given in ' +\n            'the TRUN box!');\n\n        // If no sampleSize was specified, it's assumed that this presentation\n        // corresponds to only a single cue.\n      } while (presentation.sampleSize &&\n               (totalSize < presentation.sampleSize));\n    }\n\n    goog.asserts.assert(\n        !reader.hasMoreData(),\n        'MDAT which contain VTT cues and non-VTT data are not currently ' +\n        'supported!');\n\n    return /** @type {!Array.<!shaka.extern.Cue>} */ (\n      cues.filter(shaka.util.Functional.isNotNull));\n  }\n\n  /**\n   * Parses a vttc box into a cue.\n   *\n   * @param {!Uint8Array} data\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {shaka.text.Cue}\n   * @private\n   */\n  static parseVTTC_(data, startTime, endTime) {\n    let payload;\n    let id;\n    let settings;\n\n    new shaka.util.Mp4Parser()\n        .box('payl', shaka.util.Mp4Parser.allData((data) => {\n          payload = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .box('iden', shaka.util.Mp4Parser.allData((data) => {\n          id = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .box('sttg', shaka.util.Mp4Parser.allData((data) => {\n          settings = shaka.util.StringUtils.fromUTF8(data);\n        }))\n        .parse(data);\n\n    if (payload) {\n      return shaka.text.Mp4VttParser.assembleCue_(\n          payload, id, settings, startTime, endTime);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Take the individual components that make a cue and create a vttc cue.\n   *\n   * @param {string} payload\n   * @param {?string} id\n   * @param {?string} settings\n   * @param {number} startTime\n   * @param {number} endTime\n   * @return {!shaka.text.Cue}\n   * @private\n   */\n  static assembleCue_(payload, id, settings, startTime, endTime) {\n    const cue = new shaka.text.Cue(startTime, endTime, '');\n\n    /** @type {!Map.<string, shaka.text.Cue>} */\n    const styles = new Map();\n    shaka.text.VttTextParser.parseCueStyles(payload, cue, styles);\n\n    if (id) {\n      cue.id = id;\n    }\n\n    if (settings) {\n      const parser = new shaka.util.TextParser(settings);\n\n      let word = parser.readWord();\n\n      while (word) {\n        // TODO: Check WebVTTConfigurationBox for region info.\n        if (!shaka.text.VttTextParser.parseCueSetting(\n            cue, word, /* VTTRegions= */[])) {\n          shaka.log.warning(\n              'VTT parser encountered an invalid VTT setting: ', word,\n              ' The setting will be ignored.');\n        }\n\n        parser.skipWhitespace();\n        word = parser.readWord();\n      }\n    }\n\n    return cue;\n  }\n};\n\nshaka.text.TextEngine.registerParser(\n    'application/mp4; codecs=\"wvtt\"', () => new shaka.text.Mp4VttParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.SbvTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.Error');\ngoog.require('shaka.util.StringUtils');\ngoog.require('shaka.util.TextParser');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.SbvTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'SubViewer does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const SbvTextParser = shaka.text.SbvTextParser;\n    const StringUtils = shaka.util.StringUtils;\n\n    // Get the input as a string.\n    const strFromData = StringUtils.fromUTF8(data);\n    // remove dos newlines\n    let str = strFromData.replace(/\\r+/g, '');\n    // trim white space start and end\n    str = str.trim();\n\n    /** @type {!Array.<!shaka.extern.Cue>} */\n    const cues = [];\n\n    // Supports no cues\n    if (str == '') {\n      return cues;\n    }\n\n    // get cues\n    const blocklist = str.split('\\n\\n');\n    for (const block of blocklist) {\n      const lines = block.split('\\n');\n      // Parse the times.\n      const parser = new shaka.util.TextParser(lines[0]);\n      const start = SbvTextParser.parseTime_(parser);\n      const expect = parser.readRegex(/,/g);\n      const end = SbvTextParser.parseTime_(parser);\n\n      if (start == null || expect == null || end == null) {\n        throw new shaka.util.Error(\n            shaka.util.Error.Severity.CRITICAL,\n            shaka.util.Error.Category.TEXT,\n            shaka.util.Error.Code.INVALID_TEXT_CUE,\n            'Could not parse cue time range in SubViewer');\n      }\n\n      // Get the payload.\n      const payload = lines.slice(1).join('\\n').trim();\n\n      const cue = new shaka.text.Cue(start, end, payload);\n      cues.push(cue);\n    }\n\n    return cues;\n  }\n\n  /**\n   * Parses a SubViewer time from the given parser.\n   *\n   * @param {!shaka.util.TextParser} parser\n   * @return {?number}\n   * @private\n   */\n  static parseTime_(parser) {\n    // 00:00.000 or 00:00:00.000 or 0:00:00.000 or\n    // 00:00.00 or 00:00:00.00 or 0:00:00.00\n    const regexExpresion = /(?:(\\d{1,}):)?(\\d{2}):(\\d{2})\\.(\\d{2,3})/g;\n    const results = parser.readRegex(regexExpresion);\n    if (results == null) {\n      return null;\n    }\n    // This capture is optional, but will still be in the array as undefined,\n    // in which case it is 0.\n    const hours = Number(results[1]) || 0;\n    const minutes = Number(results[2]);\n    const seconds = Number(results[3]);\n    const milliseconds = Number(results[4]);\n    if (minutes > 59 || seconds > 59) {\n      return null;\n    }\n\n    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'text/x-subviewer', () => new shaka.text.SbvTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.SrtTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.text.VttTextParser');\ngoog.require('shaka.util.BufferUtils');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.SrtTextParser = class {\n  /** */\n  constructor() {\n    /**\n     * @type {!shaka.extern.TextParser}\n     * @private\n     */\n    this.parser_ = new shaka.text.VttTextParser();\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'SRT does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const SrtTextParser = shaka.text.SrtTextParser;\n    const BufferUtils = shaka.util.BufferUtils;\n    const StringUtils = shaka.util.StringUtils;\n\n    // Get the input as a string.\n    const str = StringUtils.fromUTF8(data);\n\n    const vvtText = SrtTextParser.srt2webvtt(str);\n\n    const newData = BufferUtils.toUint8(StringUtils.toUTF8(vvtText));\n\n    return this.parser_.parseMedia(newData, time);\n  }\n\n  /**\n   * Convert a SRT format to WebVTT\n   *\n   * @param {string} data\n   * @return {string}\n   * @export\n   */\n  static srt2webvtt(data) {\n    const SrtTextParser = shaka.text.SrtTextParser;\n    let result = 'WEBVTT\\n\\n';\n\n    // Supports no cues\n    if (data == '') {\n      return result;\n    }\n\n    // remove dos newlines\n    let srt = data.replace(/\\r+/g, '');\n    // trim white space start and end\n    srt = srt.trim();\n\n    // get cues\n    const cuelist = srt.split('\\n\\n');\n    for (const cue of cuelist) {\n      result += SrtTextParser.convertSrtCue_(cue);\n    }\n\n    return result;\n  }\n\n  /**\n   * Convert a SRT cue into WebVTT cue\n   *\n   * @param {string} caption\n   * @return {string}\n   * @private\n   */\n  static convertSrtCue_(caption) {\n    const lines = caption.split(/\\n/);\n\n    // detect and skip numeric identifier\n    if (lines[0].match(/\\d+/)) {\n      lines.shift();\n    }\n\n    // convert time codes\n    lines[0] = lines[0].replace(/,/g, '.');\n\n    return lines.join('\\n') + '\\n\\n';\n  }\n};\n\n\nshaka.text.TextEngine.registerParser(\n    'text/srt', () => new shaka.text.SrtTextParser());\n","/*! @license\n * Shaka Player\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.provide('shaka.text.SsaTextParser');\n\ngoog.require('goog.asserts');\ngoog.require('shaka.log');\ngoog.require('shaka.text.Cue');\ngoog.require('shaka.text.TextEngine');\ngoog.require('shaka.util.StringUtils');\n\n\n/**\n * Documentation: http://moodub.free.fr/video/ass-specs.doc\n * https://en.wikipedia.org/wiki/SubStation_Alpha\n * @implements {shaka.extern.TextParser}\n * @export\n */\nshaka.text.SsaTextParser = class {\n  /**\n   * @override\n   * @export\n   */\n  parseInit(data) {\n    goog.asserts.assert(false, 'SSA does not have init segments');\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  setSequenceMode(sequenceMode) {\n    // Unused.\n  }\n\n  /**\n   * @override\n   * @export\n   */\n  parseMedia(data, time) {\n    const StringUtils = shaka.util.StringUtils;\n    const SsaTextParser = shaka.text.SsaTextParser;\n\n    // Get the input as a string.\n    const str = StringUtils.fromUTF8(data);\n\n    const section = {\n      styles: '',\n      events: '',\n    };\n\n    const parts = str.split(/\\r?\\n\\s*\\r?\\n/);\n    for (const part of parts) {\n      // SSA content\n      const match = SsaTextParser.ssaContent_.exec(part);\n      if (match) {\n        const tag = match[1];\n        const lines = match[2];\n        if (tag == 'V4 Styles' || tag == 'V4+ Styles') {\n          section.styles = lines;\n          continue;\n        }\n        if (tag == 'Events') {\n          section.events = lines;\n          continue;\n        }\n      }\n      shaka.log.warning('SsaTextParser parser encountered an unknown part.',\n          part);\n    }\n\n    // Process styles\n    const styles = [];\n\n    // Used to be able to iterate over the style parameters.\n    let styleColumns = null;\n\n    const styleLines = section.styles.split(/\\r?\\n/);\n    for (const line of styleLines) {\n      if (/^\\s*;/.test(line)) {\n        // Skip comment\n        continue;\n      }\n      const lineParts = SsaTextParser.lineParts_.exec(line);\n      if (lineParts) {\n        const name = lineParts[1].trim();\n        const value = lineParts[2].trim();\n        if (name == 'Format') {\n          styleColumns = value.split(SsaTextParser.valuesFormat_);\n          continue;\n        }\n        if (name == 'Style') {\n          const values = value.split(SsaTextParser.valuesFormat_);\n          const style = {};\n          for (let c = 0; c < styleColumns.length && c < values.length; c++) {\n            style[styleColumns[c]] = values[c];\n          }\n          styles.push(style);\n          continue;\n        }\n      }\n    }\n\n    // Process cues\n    /** @type {!Array.<!shaka.extern.Cue>} */\n    const cues = [];\n\n    // Used to be able to iterate over the event parameters.\n    let eventColumns = null;\n\n    const eventLines = section.events.split(/\\r?\\n/);\n    for (const line of eventLines) {\n      if (/^\\s*;/.test(line)) {\n        // Skip comment\n        continue;\n      }\n      const lineParts = SsaTextParser.lineParts_.exec(line);\n      if (lineParts) {\n        const name = lineParts[1].trim();\n        const value = lineParts[2].trim();\n        if (name == 'Format') {\n          eventColumns = value.split(SsaTextParser.valuesFormat_);\n          continue;\n        }\n        if (name == 'Dialogue') {\n          const values = value.split(SsaTextParser.valuesFormat_);\n          const data = {};\n          for (let c = 0; c < eventColumns.length && c < values.length; c++) {\n            data[eventColumns[c]] = values[c];\n          }\n\n          const startTime = SsaTextParser.parseTime_(data['Start']);\n          const endTime = SsaTextParser.parseTime_(data['End']);\n\n          // Note: Normally, you should take the \"Text\" field, but if it\n          // has a comma, it fails.\n          const payload = values.slice(eventColumns.length - 1).join(',')\n              .replace(/\\\\N/g, '\\n') // '\\n' for new line\n              .replace(/\\{[^}]+\\}/g, ''); // {\\pos(400,570)}\n\n          const cue = new shaka.text.Cue(startTime, endTime, payload);\n\n          const styleName = data['Style'];\n          const styleData = styles.find((s) => s['Name'] == styleName);\n          if (styleData) {\n            SsaTextParser.addStyle_(cue, styleData);\n          }\n          cues.push(cue);\n          continue;\n        }\n      }\n    }\n\n    return cues;\n  }\n\n  /**\n   * Adds applicable style properties to a cue.\n   *\n   * @param {shaka.extern.Cue} cue\n   * @param {Object} style\n   * @private\n   */\n  static addStyle_(cue, style) {\n    const Cue = shaka.text.Cue;\n    const SsaTextParser = shaka.text.SsaTextParser;\n    const fontFamily = style['Fontname'];\n    if (fontFamily) {\n      cue.fontFamily = fontFamily;\n    }\n    const fontSize = style['Fontsize'];\n    if (fontSize) {\n      cue.fontSize = fontSize + 'px';\n    }\n    const color = style['PrimaryColour'];\n    if (color) {\n      const ccsColor = SsaTextParser.parseSsaColor_(color);\n      if (ccsColor) {\n        cue.color = ccsColor;\n      }\n    }\n    const backgroundColor = style['BackColour'];\n    if (backgroundColor) {\n      const cssBackgroundColor = SsaTextParser.parseSsaColor_(backgroundColor);\n      if (cssBackgroundColor) {\n        cue.backgroundColor = cssBackgroundColor;\n      }\n    }\n    const bold = style['Bold'];\n    if (bold) {\n      cue.fontWeight = Cue.fontWeight.BOLD;\n    }\n    const italic = style['Italic'];\n    if (italic) {\n      cue.fontStyle = Cue.fontStyle.ITALIC;\n    }\n    const underline = style['Underline'];\n    if (underline) {\n      cue.textDecoration.push(Cue.textDecoration.UNDERLINE);\n    }\n    const letterSpacing = style['Spacing'];\n    if (letterSpacing) {\n      cue.letterSpacing = letterSpacing + 'px';\n    }\n    const alignment = style['Alignment'];\n    if (alignment) {\n      const alignmentInt = parseInt(alignment, 10);\n      switch (alignmentInt) {\n        case 1:\n          cue.displayAlign = Cue.displayAlign.AFTER;\n          cue.textAlign = Cue.textAlign.START;\n          break;\n        case 2:\n          cue.displayAlign = Cue.displayAlign.AFTER;\n          cue.textAlign = Cue.textAlign.CENTER;\n          break;\n        case 3:\n          cue.displayAlign = Cue.displayAlign.AFTER;\n          cue.textAlign = Cue.textAlign.END;\n          break;\n        case 5:\n          cue.displayAlign = Cue.displayAlign.BEFORE;\n          cue.textAlign = Cue.textAlign.START;\n          break;\n        case 6:\n          cue.displayAlign = Cue.displayAlign.BEFORE;\n          cue.textAlign = Cue.textAlign.CENTER;\n          break;\n        case 7:\n          cue.displayAlign = Cue.displayAlign.BEFORE;\n          cue.textAlign = Cue.textAlign.END;\n          break;\n        case 9:\n          cue.displayAlign = Cue.displayAlign.CENTER;\n          cue.textAlign = Cue.textAlign.START;\n          break;\n        case 10:\n          cue.displayAlign = Cue.displayAlign.CENTER;\n          cue.textAlign = Cue.textAlign.CENTER;\n          break;\n        case 11:\n          cue.displayAlign = Cue.displayAlign.CENTER;\n          cue.textAlign = Cue.textAlign.END;\n          break;\n      }\n    }\n    const opacity = style['AlphaLevel'];\n    if (opacity) {\n      cue.opacity = parseFloat(opacity);\n    }\n  }\n\n  /**\n   * Parses a SSA color .\n   *\n   * @param {string} colorString\n   * @return {?string}\n   * @private\n   */\n  static parseSsaColor_(colorString) {\n    // The SSA V4+ color can be represented in hex (&HAABBGGRR) or in decimal\n    // format (byte order AABBGGRR) and in both cases the alpha channel's\n    // value needs to be inverted as in case of SSA the 0xFF alpha value means\n    // transparent and 0x00 means opaque\n    /** @type {number} */\n    const abgr = parseInt(colorString.replace('&H', ''), 16);\n    if (abgr >= 0) {\n      const a = ((abgr >> 24) & 0xFF) ^ 0xFF; // Flip alpha.\n      const alpha = a / 255;\n      const b = (abgr >> 16) & 0xFF;\n      const g = (abgr >> 8) & 0xFF;\n      const r = abgr & 0xff;\n      return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\n    }\n    return null;\n  }\n\n  /**\n   * Parses a SSA time from the given parser.\n   *\n   * @param {string} string\n   * @return {number}\n   * @private\n   */\n  static parseTime_(string) {\n    const SsaTextParser = shaka.text.SsaTextParser;\n    const match = SsaTextParser.timeFormat_.exec(string);\n    const hours = match[1] ? parseInt(match[1].replace(':', ''), 10) : 0;\n    const minutes = parseInt(match[2], 10);\n    const seconds = parseFloat(match[3]);\n    return hours * 3600 + minutes * 60 + seconds;\n  }\n};\n\n/**\n * @const\n * @private {!RegExp}\n * @example [V4 Styles]\\nFormat: Name\\nStyle: DefaultVCD\n */\nshaka.text.SsaTextParser.ssaContent_ =\n    /^\\s*\\[([^\\]]+)\\]\\r?\\n([\\s\\S]*)/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example Style: DefaultVCD,...\n */\nshaka.text.SsaTextParser.lineParts_ =\n    /^\\s*([^:]+):\\s*(.*)/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example Style: DefaultVCD,...\n */\nshaka.text.SsaTextParser.valuesFormat_ = /\\s*,\\s*/;\n\n/**\n * @const\n * @private {!RegExp}\n * @example 0:00:01.1 or 0:00:01.18 or 0:00:01.180\n */\nshaka.text.SsaTextParser.timeFormat_ =\n    /^(\\d+:)?(\\d{1,2}):(\\d{1,2}(?:[.]\\d{1,3})?)?$/;\n\nshaka.text.TextEngine.registerParser(\n    'text/x-ssa', () => new shaka.text.SsaTextParser());\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"d0e6e514\" + \".chunk.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","var inProgress = {};\nvar dataWebpackPrefix = \"tv:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function(url, done, key, chunkId) {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function(prev, event) {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach(function(fn) { return fn(event); });\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/tvt/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = function(chunkId, promises) {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = function(event) {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunktv\"] = self[\"webpackChunktv\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import React, { useState, useEffect, useRef } from \"react\";\r\nimport shaka from \"shaka-player\";\r\n\r\n// Rest of the code remains the same\r\n\r\nimport \"./Grid.css\";\r\nimport playlistData from \"./m3u/playlist.m3u\";\r\nimport \"shaka-player/dist/controls.css\";\r\n// import shaka from \"shaka-player/dist/shaka-player.ui\";\r\n\r\n// If you also need the CSS styles, import them as well\r\nimport \"shaka-player/dist/controls.css\";\r\n\r\n// import { useArrowKeys } from \"react-keyboard-navigation\";\r\n\r\nfunction Grid() {\r\n  const [playlist, setPlaylist] = useState([]);\r\n  const [selectedUrl, setSelectedUrl] = useState(\"\");\r\n  const [activeIndex, setActiveIndex] = useState(0);\r\n  const [showVideo, setShowVideo] = useState(true);\r\n  const gridRef = useRef(null);\r\n  const playerRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (event) => {\r\n      if (event.key === \"Escape\" || event.key === \"Backspace\") {\r\n        setShowVideo(false);\r\n      }\r\n    };\r\n\r\n    document.addEventListener(\"keydown\", handleKeyDown);\r\n\r\n    return () => {\r\n      document.removeEventListener(\"keydown\", handleKeyDown);\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!showVideo) {\r\n      // Clean up Shaka Player and reset the video source\r\n      const player = playerRef.current.shakaPlayer;\r\n      if (player) {\r\n        player.unload();\r\n      }\r\n      playerRef.current.src = \"\";\r\n    }\r\n  }, [showVideo]);\r\n\r\n  useEffect(() => {\r\n    if (showVideo) {\r\n      // Initialize Shaka Player\r\n      const player = new shaka.Player(playerRef.current);\r\n      player.configure({\r\n        streaming: {\r\n          retryParameters: {\r\n            maxAttempts: 3, // Maximum number of retries\r\n          },\r\n        },\r\n      });\r\n\r\n      // Load the HLS stream\r\n      const manifestUri =\r\n        \"https://d2q8p4pe5spbak.cloudfront.net/bpk-tv/9XM/9XM.isml/index.m3u8\";\r\n      player\r\n        .load(manifestUri)\r\n        .then(() => {\r\n          console.log(\"HLS stream loaded successfully\");\r\n        })\r\n        .catch((error) => {\r\n          console.error(\"Error loading HLS stream:\", error);\r\n        });\r\n\r\n      return () => {\r\n        // Clean up Shaka Player when the component unmounts or video is hidden\r\n        player.unload();\r\n      };\r\n    }\r\n  }, [showVideo]);\r\n\r\n  const handleFileChange = (event) => {\r\n    const file = event.target.files[0];\r\n    const reader = new FileReader();\r\n\r\n    // reader.onload = (e) => {\r\n    //   const contents = e.target.result;\r\n    //   const urls = parseM3U(contents);\r\n    //   setPlaylist(urls);\r\n    // };\r\n\r\n    // reader.readAsText(file);\r\n  };\r\n\r\n  useEffect(() => {\r\n    fetchPlaylist();\r\n  }, []);\r\n\r\n  const fetchPlaylist = () => {\r\n    // Fetch the M3U file and parse its contents\r\n    fetch(playlistData)\r\n      .then((response) => response.text())\r\n      .then((data) => {\r\n        const parsedPlaylist = parseM3U(data);\r\n        setPlaylist(parsedPlaylist);\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error fetching playlist:\", error);\r\n      });\r\n  };\r\n\r\n  const parseM3U = (contents) => {\r\n    const lines = contents.split(\"\\n\");\r\n    const urls = [];\r\n\r\n    let currentUrl = \"\";\r\n    let currentName = \"\";\r\n    let currentImage = \"\";\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n\r\n      if (line.startsWith(\"#EXTINF\")) {\r\n        const info = line.split(\",\");\r\n\r\n        // Extract the name from the line\r\n        currentName = info[1].trim();\r\n\r\n        // Extract the image URL from the line's tvg-logo attribute\r\n        currentImage = extractImageUrl(line);\r\n      } else if (line.startsWith(\"http\")) {\r\n        currentUrl = line.trim();\r\n\r\n        urls.push({\r\n          url: currentUrl,\r\n          name: currentName,\r\n          image: currentImage,\r\n        });\r\n\r\n        currentUrl = \"\";\r\n        currentName = \"\";\r\n        currentImage = \"\";\r\n      }\r\n    }\r\n\r\n    return urls;\r\n  };\r\n\r\n  const extractImageUrl = (line) => {\r\n    const regex = /tvg-logo=\"(.*?)\"/; // Regular expression pattern to match the tvg-logo attribute and capture the URL\r\n    const match = line.match(regex);\r\n\r\n    if (match && match[1]) {\r\n      return match[1]; // Extracted image URL\r\n    }\r\n\r\n    return process.env.PUBLIC_URL + \"/logo192.png\"; // Return default image URL if the attribute is not found or doesn't contain a valid URL\r\n  };\r\n\r\n  const handleItemClick = (url) => {\r\n    setSelectedUrl(url);\r\n    console.log(url);\r\n    playUrl(url);\r\n    // Play the URL\r\n    // Add your own logic here to play the media\r\n  };\r\n\r\n  const playUrl = (url) => {\r\n    // Initialize Shaka Player\r\n    const player = new shaka.Player(playerRef.current);\r\n    player.configure({\r\n      streaming: {\r\n        retryParameters: {\r\n          maxAttempts: 3, // Maximum number of retries\r\n        },\r\n      },\r\n    });\r\n\r\n    // Load the HLS stream\r\n    const manifestUri = url;\r\n    player\r\n      .load(manifestUri)\r\n      .then(() => {\r\n        console.log(\"HLS stream loaded successfully\");\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error loading HLS stream:\", error);\r\n      });\r\n\r\n    return () => {\r\n      // Clean up Shaka Player when the component unmounts\r\n      player.unload();\r\n    };\r\n  };\r\n\r\n  const handleArrowKeys = (event) => {\r\n    const { key } = event;\r\n\r\n    if (key === \"ArrowUp\") {\r\n      event.preventDefault(); // Prevent default scrolling behavior\r\n      setActiveIndex((prevIndex) =>\r\n        prevIndex > 0 ? prevIndex - 1 : prevIndex\r\n      );\r\n    } else if (key === \"ArrowDown\") {\r\n      event.preventDefault(); // Prevent default scrolling behavior\r\n      setActiveIndex((prevIndex) =>\r\n        prevIndex < playlist.length - 1 ? prevIndex + 1 : prevIndex\r\n      );\r\n    } else if (key === \"Enter\") {\r\n      handleItemClick(playlist[activeIndex].url);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (event) => {\r\n      if ([\"ArrowUp\", \"ArrowDown\", \"Enter\"].includes(event.key)) {\r\n        handleArrowKeys(event);\r\n      }\r\n    };\r\n\r\n    window.addEventListener(\"keydown\", handleKeyDown);\r\n    return () => {\r\n      window.removeEventListener(\"keydown\", handleKeyDown);\r\n    };\r\n  }, [playlist]);\r\n\r\n  useEffect(() => {\r\n    if (gridRef.current) {\r\n      const activeItem = gridRef.current.querySelector(\".grid-item.active\");\r\n      if (activeItem) {\r\n        activeItem.scrollIntoView({\r\n          behavior: \"smooth\",\r\n          block: \"nearest\",\r\n          inline: \"start\",\r\n        });\r\n      }\r\n    }\r\n  }, [activeIndex]);\r\n\r\n  return (\r\n    <div>\r\n      <video\r\n        ref={playerRef}\r\n        className=\"shaka-player-container\"\r\n        autoPlay\r\n        controls\r\n      />\r\n      <div className=\"grid\" ref={gridRef}>\r\n        {playlist.map((item, index) => (\r\n          <div\r\n            key={index}\r\n            className={`grid-item ${activeIndex === index ? \"active\" : \"\"}`}\r\n            onClick={() => handleItemClick(item.url)}\r\n            tabIndex={0}\r\n            autoFocus={activeIndex === index}\r\n          >\r\n            <div className=\"grid-item-content\">\r\n              <div className=\"grid-item-name\">{item.name}</div>\r\n              <img\r\n                src={item.image}\r\n                alt=\"Thumbnail\"\r\n                className=\"grid-item-image\"\r\n              />\r\n            </div>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"names":["aa","require","ca","p","a","b","c","arguments","length","encodeURIComponent","da","Set","ea","fa","ha","add","ia","window","document","createElement","ja","Object","prototype","hasOwnProperty","ka","la","ma","v","d","e","f","g","this","acceptsBooleans","attributeName","attributeNamespace","mustUseProperty","propertyName","type","sanitizeURL","removeEmptyString","z","split","forEach","toLowerCase","ra","sa","toUpperCase","ta","slice","pa","isNaN","qa","call","test","oa","removeAttribute","setAttribute","setAttributeNS","replace","xlinkHref","ua","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","va","Symbol","for","wa","ya","za","Aa","Ba","Ca","Da","Ea","Fa","Ga","Ha","Ia","Ja","iterator","Ka","La","A","assign","Ma","Error","stack","trim","match","Na","Oa","prepareStackTrace","defineProperty","set","Reflect","construct","l","h","k","displayName","includes","name","Pa","tag","render","Qa","$$typeof","_context","_payload","_init","Ra","Sa","Ta","nodeName","Va","_valueTracker","getOwnPropertyDescriptor","constructor","get","configurable","enumerable","getValue","setValue","stopTracking","Ua","Wa","checked","value","Xa","activeElement","body","Ya","defaultChecked","defaultValue","_wrapperState","initialChecked","Za","initialValue","controlled","ab","bb","cb","db","ownerDocument","eb","Array","isArray","fb","options","selected","defaultSelected","disabled","gb","dangerouslySetInnerHTML","children","hb","ib","jb","textContent","kb","lb","mb","nb","namespaceURI","innerHTML","valueOf","toString","firstChild","removeChild","appendChild","MSApp","execUnsafeLocalFunction","ob","lastChild","nodeType","nodeValue","pb","animationIterationCount","aspectRatio","borderImageOutset","borderImageSlice","borderImageWidth","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","columns","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridArea","gridRow","gridRowEnd","gridRowSpan","gridRowStart","gridColumn","gridColumnEnd","gridColumnSpan","gridColumnStart","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","floodOpacity","stopOpacity","strokeDasharray","strokeDashoffset","strokeMiterlimit","strokeOpacity","strokeWidth","qb","rb","sb","style","indexOf","setProperty","keys","charAt","substring","tb","menuitem","area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr","ub","vb","is","wb","xb","target","srcElement","correspondingUseElement","parentNode","yb","zb","Ab","Bb","Cb","stateNode","Db","Eb","push","Fb","Gb","Hb","Ib","Jb","Kb","Lb","Mb","addEventListener","removeEventListener","Nb","apply","m","onError","Ob","Pb","Qb","Rb","Sb","Tb","Vb","alternate","return","flags","Wb","memoizedState","dehydrated","Xb","Zb","child","sibling","current","Yb","$b","ac","unstable_scheduleCallback","bc","unstable_cancelCallback","cc","unstable_shouldYield","dc","unstable_requestPaint","B","unstable_now","ec","unstable_getCurrentPriorityLevel","fc","unstable_ImmediatePriority","gc","unstable_UserBlockingPriority","hc","unstable_NormalPriority","ic","unstable_LowPriority","jc","unstable_IdlePriority","kc","lc","oc","Math","clz32","pc","qc","log","LN2","rc","sc","tc","uc","pendingLanes","suspendedLanes","pingedLanes","entangledLanes","entanglements","vc","xc","yc","zc","Ac","eventTimes","Cc","C","Dc","Ec","Fc","Gc","Hc","Ic","Jc","Kc","Lc","Mc","Nc","Oc","Map","Pc","Qc","Rc","Sc","delete","pointerId","Tc","nativeEvent","blockedOn","domEventName","eventSystemFlags","targetContainers","Vc","Wc","priority","isDehydrated","containerInfo","Xc","Yc","dispatchEvent","shift","Zc","$c","ad","bd","cd","ReactCurrentBatchConfig","dd","ed","transition","fd","gd","hd","id","Uc","stopPropagation","jd","kd","ld","md","nd","od","keyCode","charCode","pd","qd","rd","_reactName","_targetInst","currentTarget","isDefaultPrevented","defaultPrevented","returnValue","isPropagationStopped","preventDefault","cancelBubble","persist","isPersistent","wd","xd","yd","sd","eventPhase","bubbles","cancelable","timeStamp","Date","now","isTrusted","td","ud","view","detail","vd","Ad","screenX","screenY","clientX","clientY","pageX","pageY","ctrlKey","shiftKey","altKey","metaKey","getModifierState","zd","button","buttons","relatedTarget","fromElement","toElement","movementX","movementY","Bd","Dd","dataTransfer","Fd","Hd","animationName","elapsedTime","pseudoElement","Id","clipboardData","Jd","Ld","data","Md","Esc","Spacebar","Left","Up","Right","Down","Del","Win","Menu","Apps","Scroll","MozPrintableKey","Nd","Od","Alt","Control","Meta","Shift","Pd","Qd","key","String","fromCharCode","code","location","repeat","locale","which","Rd","Td","width","height","pressure","tangentialPressure","tiltX","tiltY","twist","pointerType","isPrimary","Vd","touches","targetTouches","changedTouches","Xd","Yd","deltaX","wheelDeltaX","deltaY","wheelDeltaY","wheelDelta","deltaZ","deltaMode","Zd","$d","ae","be","documentMode","ce","de","ee","fe","ge","he","ie","le","color","date","datetime","email","month","number","password","range","search","tel","text","time","url","week","me","ne","oe","event","listeners","pe","qe","re","se","te","ue","ve","we","xe","ye","ze","oninput","Ae","detachEvent","Be","Ce","attachEvent","De","Ee","Fe","He","Ie","Je","Ke","node","offset","nextSibling","Le","contains","compareDocumentPosition","Me","HTMLIFrameElement","contentWindow","href","Ne","contentEditable","Oe","focusedElem","selectionRange","documentElement","start","end","selectionStart","selectionEnd","min","defaultView","getSelection","extend","rangeCount","anchorNode","anchorOffset","focusNode","focusOffset","createRange","setStart","removeAllRanges","addRange","setEnd","element","left","scrollLeft","top","scrollTop","focus","Pe","Qe","Re","Se","Te","Ue","Ve","We","animationend","animationiteration","animationstart","transitionend","Xe","Ye","Ze","animation","$e","af","bf","cf","df","ef","ff","gf","hf","lf","mf","concat","nf","Ub","instance","listener","D","of","has","pf","qf","rf","random","sf","bind","capture","passive","n","t","J","x","u","w","F","tf","uf","parentWindow","vf","wf","na","xa","$a","ba","je","char","ke","unshift","xf","yf","zf","Af","Bf","Cf","Df","Ef","__html","Ff","setTimeout","Gf","clearTimeout","Hf","Promise","Jf","queueMicrotask","resolve","then","catch","If","Kf","Lf","Mf","previousSibling","Nf","Of","Pf","Qf","Rf","Sf","Tf","Uf","E","G","Vf","H","Wf","Xf","Yf","contextTypes","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","Zf","childContextTypes","$f","ag","bg","getChildContext","cg","__reactInternalMemoizedMergedChildContext","dg","eg","fg","gg","hg","jg","kg","lg","mg","ng","og","pg","qg","rg","sg","tg","ug","vg","wg","xg","yg","I","zg","Ag","Bg","elementType","deletions","Cg","pendingProps","overflow","treeContext","retryLane","Dg","mode","Eg","Fg","Gg","memoizedProps","Hg","Ig","Jg","Kg","Lg","defaultProps","Mg","Ng","Og","Pg","Qg","Rg","_currentValue","Sg","childLanes","Tg","dependencies","firstContext","lanes","Ug","Vg","context","memoizedValue","next","Wg","Xg","Yg","interleaved","Zg","$g","ah","updateQueue","baseState","firstBaseUpdate","lastBaseUpdate","shared","pending","effects","bh","ch","eventTime","lane","payload","callback","dh","K","eh","fh","gh","q","r","y","hh","ih","jh","Component","refs","kh","nh","isMounted","_reactInternals","enqueueSetState","L","lh","mh","enqueueReplaceState","enqueueForceUpdate","oh","shouldComponentUpdate","isPureReactComponent","ph","contextType","state","updater","qh","componentWillReceiveProps","UNSAFE_componentWillReceiveProps","rh","props","getDerivedStateFromProps","getSnapshotBeforeUpdate","UNSAFE_componentWillMount","componentWillMount","componentDidMount","sh","ref","_owner","_stringRef","th","join","uh","vh","index","wh","xh","yh","implementation","zh","Ah","done","Bh","Ch","Dh","Eh","Fh","Gh","Hh","Ih","tagName","Jh","Kh","Lh","M","Mh","revealOrder","Nh","Oh","_workInProgressVersionPrimary","Ph","ReactCurrentDispatcher","Qh","Rh","N","O","P","Sh","Th","Uh","Vh","Q","Wh","Xh","Yh","Zh","$h","ai","bi","ci","baseQueue","queue","di","ei","fi","lastRenderedReducer","action","hasEagerState","eagerState","lastRenderedState","dispatch","gi","hi","ii","ji","ki","getSnapshot","li","mi","R","ni","lastEffect","stores","oi","pi","qi","ri","create","destroy","deps","si","ti","ui","vi","wi","xi","yi","zi","Ai","Bi","Ci","Di","Ei","Fi","Gi","Hi","Ii","Ji","readContext","useCallback","useContext","useEffect","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useReducer","useRef","useState","useDebugValue","useDeferredValue","useTransition","useMutableSource","useSyncExternalStore","useId","unstable_isNewReconciler","identifierPrefix","Ki","message","digest","Li","Mi","console","error","Ni","WeakMap","Oi","Pi","Qi","Ri","getDerivedStateFromError","componentDidCatch","Si","componentStack","Ti","pingCache","Ui","Vi","Wi","Xi","ReactCurrentOwner","Yi","Zi","$i","aj","bj","compare","cj","dj","ej","baseLanes","cachePool","transitions","fj","gj","hj","ij","jj","UNSAFE_componentWillUpdate","componentWillUpdate","componentDidUpdate","kj","lj","pendingContext","mj","Aj","Cj","Dj","nj","oj","pj","fallback","qj","rj","tj","dataset","dgst","uj","vj","_reactRetry","sj","subtreeFlags","wj","xj","isBackwards","rendering","renderingStartTime","last","tail","tailMode","yj","Ej","S","Fj","Gj","wasMultiple","multiple","suppressHydrationWarning","onClick","onclick","size","createElementNS","autoFocus","createTextNode","T","Hj","Ij","Jj","Kj","U","Lj","WeakSet","V","Mj","W","Nj","Oj","Qj","Rj","Sj","Tj","Uj","Vj","Wj","insertBefore","_reactRootContainer","Xj","X","Yj","Zj","ak","onCommitFiberUnmount","componentWillUnmount","bk","ck","dk","ek","fk","isHidden","gk","hk","display","ik","jk","kk","lk","__reactInternalSnapshotBeforeUpdate","src","Wk","mk","ceil","nk","ok","pk","Y","Z","qk","rk","sk","tk","uk","Infinity","vk","wk","xk","yk","zk","Ak","Bk","Ck","Dk","Ek","callbackNode","expirationTimes","expiredLanes","wc","callbackPriority","ig","Fk","Gk","Hk","Ik","Jk","Kk","Lk","Mk","Nk","Ok","Pk","finishedWork","finishedLanes","Qk","timeoutHandle","Rk","Sk","Tk","Uk","Vk","mutableReadLanes","Bc","Pj","onCommitFiberRoot","mc","onRecoverableError","Xk","onPostCommitFiberRoot","Yk","Zk","al","isReactComponent","pendingChildren","bl","mutableSourceEagerHydrationData","cl","cache","pendingSuspenseBoundaries","dl","el","fl","gl","hl","il","jl","zj","$k","ll","reportError","ml","_internalRoot","nl","ol","pl","ql","sl","rl","unmount","unstable_scheduleHydration","splice","querySelectorAll","JSON","stringify","form","tl","usingClientEntryPoint","Events","ul","findFiberByHostInstance","bundleType","version","rendererPackageName","vl","rendererConfig","overrideHookState","overrideHookStateDeletePath","overrideHookStateRenamePath","overrideProps","overridePropsDeletePath","overridePropsRenamePath","setErrorHandler","setSuspenseHandler","scheduleUpdate","currentDispatcherRef","findHostInstanceByFiber","findHostInstancesForRefresh","scheduleRefresh","scheduleRoot","setRefreshHandler","getCurrentFiber","reconcilerVersion","__REACT_DEVTOOLS_GLOBAL_HOOK__","wl","isDisabled","supportsFiber","inject","exports","createPortal","createRoot","unstable_strictMode","findDOMNode","flushSync","hydrate","hydrateRoot","hydratedSources","_getVersion","_source","unmountComponentAtNode","unstable_batchedUpdates","unstable_renderSubtreeIntoContainer","checkDCE","err","module","__self","__source","jsx","jsxs","setState","forceUpdate","escape","_status","_result","default","Children","map","count","toArray","only","Fragment","Profiler","PureComponent","StrictMode","Suspense","cloneElement","createContext","_currentValue2","_threadCount","Provider","Consumer","_defaultValue","_globalName","createFactory","createRef","forwardRef","isValidElement","lazy","memo","startTransition","unstable_act","pop","sortIndex","performance","setImmediate","startTime","expirationTime","priorityLevel","navigator","scheduling","isInputPending","MessageChannel","port2","port1","onmessage","postMessage","unstable_Profiling","unstable_continueExecution","unstable_forceFrameRate","floor","unstable_getFirstCallbackNode","unstable_next","unstable_pauseExecution","unstable_runWithPriority","delay","unstable_wrapCallback","globalThis","self","global","$jscomp.getGlobal","$jscomp.global","$jscomp.defineProperty","writable","$jscomp.arrayIteratorImpl","$jscomp.polyfill","TypeError","$jscomp.iteratorPrototype","$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.generator.Context","$jscomp.asyncExecutePromiseGenerator","$jscomp.generator.Generator_","$jscomp.generator.Engine_","Number","RegExp","reject","$jscomp.makeIterator","$jscomp.owns","list","head","$jscomp.findInternal","$jscomp.checkStringArgs","$jscomp.iteratorFromArray","$jscomp.assign","RangeError","publicPath","object","parts","part","cur","goog.global","execScript","undefined","halfLife","alpha_","exp","totalWeight_","estimate_","getEstimate","pow","fast_","shaka.abr.Ewma","slow_","bytesSampled_","minTotalBytes_","minBytes_","alwaysError","alwaysWarn","warnOnce","shaka.log.oneTimeWarningIssued_has","shaka.log.oneTimeWarningIssued_add","shaka.log.alwaysWarnapply","shaka.log","args","weight","adjAlpha","newEstimate","shaka.abr.EwmaBandwidthEstimator","config","minTotalBytes","minBytes","fastHalfLife","slowHalfLife","durationMs","numBytes","bandwidth","sample","defaultEstimate","shaka.log.logMap_","ERROR","WARNING","warn","INFO","info","DEBUG","V1","debug","V2","shaka.log.alwaysWarn","shaka.log.alwaysError","isTypeSupported","shaka.media.Capabilities.MediaSourceTypeSupportMaphas","shaka.media.Capabilities.MediaSourceTypeSupportMapget","currentSupport","MediaSource","shaka.media.Capabilities.MediaSourceTypeSupportMapset","defaultEquals","remove","array","hasSameElements","compareFn","shaka.util.ArrayUtils.defaultEquals","copy","item","idx","findIndex","other","equal","i","endTime","direction","shaka.text.Cue.direction.HORIZONTAL_LEFT_TO_RIGHT","region","shaka.text.CueRegion","position","positionAlign","shaka.text.Cue.positionAlign.AUTO","textAlign","shaka.text.Cue.textAlign.CENTER","writingMode","shaka.text.Cue.writingMode.HORIZONTAL_TOP_TO_BOTTOM","lineInterpretation","shaka.text.Cue.lineInterpretation.LINE_NUMBER","line","lineAlign","shaka.text.Cue.lineAlign.START","displayAlign","shaka.text.Cue.displayAlign.AFTER","fontSize","textStrokeWidth","textStrokeColor","textShadow","border","backgroundImage","backgroundColor","shaka.text.Cue.fontWeight.NORMAL","fontStyle","shaka.text.Cue.fontStyle.NORMAL","linePadding","letterSpacing","fontFamily","textDecoration","wrapLine","nestedCues","lineBreak","isContainer","cellResolution","rows","cue1","cue2","shaka.util.ArrayUtils.equal","shaka.text.Cue.equal","k2","shaka.text.Cue","clone","goog.exportSymbol","shaka.text.Cue.positionAlign","shaka.text.Cue.textAlign","LEFT","RIGHT","CENTER","START","END","shaka.text.Cue.displayAlign","BEFORE","AFTER","shaka.text.Cue.direction","shaka.text.Cue.writingMode","shaka.text.Cue.lineInterpretation","shaka.text.Cue.lineAlign","white","lime","cyan","red","yellow","magenta","blue","black","shaka.text.Cue.defaultTextColor","bg_white","bg_lime","bg_cyan","bg_red","bg_yellow","bg_magenta","bg_blue","bg_black","shaka.text.Cue.defaultTextBackgroundColor","shaka.text.Cue.fontWeight","shaka.text.Cue.fontStyle","NORMAL","ITALIC","OBLIQUE","regionAnchorY","regionAnchorX","viewportAnchorY","viewportAnchorX","viewportAnchorUnits","widthUnits","heightUnits","shaka.text.CueRegion.units.PERCENTAGE","scroll","shaka.text.CueRegion.scrollMode.NONE","shaka.text.Cue.textDecoration","shaka.text.CueRegion.units","arr1","arr2","byteLength","shaka.util.BufferUtils.unsafeGetArrayBuffer_","byteOffset","uint8A","shaka.util.BufferUtils.toUint8","uint8B","unsafeGetArrayBuffer_","ArrayBuffer","buffer","toArrayBuffer","Uint8Array","toUint8","shaka.util.BufferUtils.view_","toDataView","DataView","view_","Type","dataEnd","max","severity","category","varArgs","handled","shaka.text.CueRegion.scrollMode","shaka.util.BufferUtils","shaka.util.BufferUtils.toDataView","shaka.util.BufferUtils.toArrayBuffer","shaka.util.BufferUtils.equal","shaka.util.Error","shaka.util.Error.Severity","shaka.util.Error.Category","shaka.util.Error.Code","goog.Uri","uri","setScheme","scheme_","setUserInfo","userInfo_","setDomain","domain_","setPort","port_","setPath","path_","setQueryData","queryData_","setFragment","fragment_","goog.uri.utils.splitRe_","SCHEME","goog.Uri.decodeOrEmpty_","USER_INFO","DOMAIN","PORT","PATH","QUERY_DATA","FRAGMENT","goog.Uri.QueryData","goog.Uri.prototype.setScheme","newScheme","decode","goog.Uri.prototype.setPort","newPort","goog.Uri.prototype.setQueryData","queryData","goog.Uri.encodeSpecialChars_","goog.Uri.reDisallowedInQuery_","val","preserveReserved","decodeURI","decodeURIComponent","unescapedPart","extra","removeDoubleEncoding","encoded","encodeURI","goog.Uri.encodeChar_","charCodeAt","JSC$2279_scheme_","goog.Uri.prototype","goog.Uri.prototype.toString","out","scheme","getScheme","goog.Uri.reDisallowedInSchemeOrUserInfo_","domain","getDomain","userInfo","getUserInfo","port","getPort","path","getPath","hasDomain","goog.Uri.reDisallowedInAbsolutePath_","goog.Uri.reDisallowedInRelativePath_","query","getEncodedQuery","fragment","getFragment","goog.Uri.reDisallowedInFragment_","goog.Uri.prototype.resolve","relativeUri","absoluteUri","overridden","hasPath","lastSlashIndex","lastIndexOf","substr","leadingSlash","segments","pos","segment","goog.Uri.prototype.clone","encodedQuery_","goog.Uri.QueryData.prototype.ensureKeyMapInitialized_","keyMap_","count_","pairs","indexOfEquals","collapseArrays","all","noop","isNotNull","resolveUris","baseUris","relativeUris","relativeAsGoog","reduce","shaka.util.Functional.collapseArrays","createDrmInfo","keySystem","initData","licenseServerUri","distinctiveIdentifierRequired","persistentStateRequired","audioRobustness","videoRobustness","serverCertificate","serverCertificateUri","sessionType","keyIds","guessCodecs","contentType","codecs","shaka.util.ManifestParserUtils.guessCodecsSafe","shaka.util.Error.Severity.CRITICAL","shaka.util.Error.Category.MANIFEST","shaka.util.Error.Code.HLS_COULD_NOT_GUESS_CODECS","guessCodecsSafe","shaka.util.ManifestParserUtils.CODEC_REGEXPS_BY_CONTENT_TYPE_","format","codec","shaka.util.ManifestParserUtils.ContentType.TEXT","goog.Uri.QueryData.prototype","goog.Uri.QueryData.prototype.add","ensureKeyMapInitialized_","values","goog.Uri.QueryData.prototype.set","goog.Uri.QueryData.prototype.toString","encodedKey","j","goog.Uri.QueryData.prototype.clone","rv","cloneMap","TEXT","shaka.util.ManifestParserUtils.ContentType","VIDEO","AUDIO","IMAGE","APPLICATION","audio","shaka.util.ManifestParserUtils.AUDIO_CODEC_REGEXPS_","video","shaka.util.ManifestParserUtils.VIDEO_CODEC_REGEXPS_","shaka.util.ManifestParserUtils.TEXT_CODEC_REGEXPS_","resolvePromise","rejectPromise","publicPromise","promise","gen","gen_","value_","onTick","onTick_","cancelPending_","ticker_","supportsMediaSource","supportsMediaType","mimeType","shaka.util.Platform.anyMediaElement","canPlayType","isXboxOne","shaka.util.Platform.userAgentContains_","isTizen","isWebOS3","isApple","vendor","shaka.util.Platform.isTizen","shaka.util.Platform.isPS4","isPS4","safariVersion","shaka.util.Platform.isApple","userAgent","parseInt","userAgentContains_","anyMediaElement","shaka.util.Platform.cachedMediaElement_","shaka.util.Platform.cacheExpirationTimer_","shaka.util.Timer","getElementsByTagName","shaka.util.Platform.cacheExpirationTimer_tickAfter","tickAfter","shaka.util.PublicPromise","shaka.util.Lazy","shaka.util.DelayedTick","delayInSeconds","stop","alive","timeoutId","this.cancelPending_","seconds","goog.exportProperty","fromUTF8","uint8","subarray","TextDecoder","decoded","utf8decoder","codePoint","lowPart","baseCodePoint","fromUTF16","littleEndian","noThrow","shaka.util.Error.Category.TEXT","shaka.util.Error.Code.BAD_ENCODING","arr","Uint16Array","dataView","getUint16","shaka.util.StringUtils.fromCharCodeImpl_value","fromBytesAutoDetect","isAscii","shaka.util.StringUtils.fromUTF8","shaka.util.StringUtils.fromUTF16","shaka.util.Error.Code.UNABLE_TO_DETECT_ENCODING","toUTF8","str","TextEncoder","utf8Encoder","encode","utf8","unescape","result","toUTF16","setUint16","shaka.util.StringUtils","resetFromCharCode","shaka.util.StringUtils.fromCharCodeImpl_reset","shaka.util.StringUtils.toUTF16","shaka.util.StringUtils.toUTF8","shaka.util.StringUtils.fromBytesAutoDetect","supportsChunkSize","ret","toStandardBase64","btoa","bytes","toBase64","padding","base64","shaka.util.Uint8ArrayUtils.toStandardBase64","fromBase64","atob","fromHex","toHex","hex","totalLength","shaka.util.Uint8ArrayUtils","shaka.util.Uint8ArrayUtils.concat","shaka.util.Uint8ArrayUtils.toHex","shaka.util.Uint8ArrayUtils.fromHex","shaka.util.Uint8ArrayUtils.fromBase64","shaka.util.Uint8ArrayUtils.toBase64","shaka.dependencies","shaka.dependencies.dependencies_has","dep","shaka.dependencies.Allowed","shaka.dependencies.dependencies_set","muxjs","originalMimeType_","muxjs_","shaka.dependencies.dependencies_get","muxTransmuxer_","mp4","Transmuxer","keepOriginalTimestamps","transmuxPromise_","transmuxedData_","captions_","isTransmuxing_","on","onTransmuxed_","captions","initSegment","output","shaka.util.Uint8ArrayUtils.concatapply","onTransmuxDone_","isTs","shaka.media.Transmuxer.isTsContainer_","isAac","shaka.media.Capabilities.isTypeSupported","shaka.media.Transmuxer.convertTsCodecs_","audioMime","videoMime","isTsContainer_","convertCodecs","convertTsCodecs_","tsMimeType","mp4MimeType","exec","newCodecString","profile","level","getFullType","fullMimeType","getFullOrConvertedType","shaka.media.Transmuxer.isSupported","shaka.util.MimeUtils.getFullType","shaka.media.Transmuxer.convertCodecs","getNormalizedCodec","codecString","shaka.util.MimeUtils.getCodecParts_","getCodecs","pieces","find","piece","startsWith","getCodecParts_","displayer","parser_","displayer_","segmentRelativeVttTiming_","appendWindowStart_","timestampOffset_","appendWindowEnd_","bufferEnd_","bufferStart_","selectedClosedCaptionId_","closedCaptionsMap_","shaka.text.TextEngine.parserMap_","shaka.util.MimeUtils.CEA608_CLOSED_CAPTION_MIMETYPE","shaka.util.MimeUtils.CEA708_CLOSED_CAPTION_MIMETYPE","setSelectedClosedCaptionId","bufferEndTime","captionsMap","cues","filter","append","applyVideoTimestampOffsetRecursive_","cue","videoTimestampOffset","storeAndAppendClosedCaptions","closedCaptions","startAndEndTime","caption","stream","shaka.media.Transmuxer","dispose","shaka.util.MimeUtils","shaka.text.TextEngine","clear","findParser","unregisterParser","registerParser","plugin","areLanguageCompatible","locale1","locale2","shaka.util.LanguageUtils.normalize","isParentOf","possibleParent","possibleChild","possibleParentComponents","possibleChildComponents","isSiblingOf","localeA","localeB","localeAComponents","localeBComponents","normalize","components","language","shaka.util.LanguageUtils.isoMap_get","relatedness","candidate","shaka.util.LanguageUtils.isParentOf","shaka.util.LanguageUtils.isSiblingOf","getBase","lang","splitAt","major","getLocaleForVariant","variant","findClosestLocale","searchSpace","safeTarget","safeSearchSpace","option","shaka.util.LanguageUtils","shaka.util.LanguageUtils.findClosestLocale","shaka.util.LanguageUtils.getLocaleForVariant","getLocaleForText","shaka.util.LanguageUtils.getBase","shaka.util.LanguageUtils.relatedness","areSiblings","baseA","baseB","shaka.util.LanguageUtils.areLanguageCompatible","areLocaleCompatible","shaka.util.LanguageUtils.isoMap_","map_","chooseCodecsAndFilterManifest","manifest","preferredVideoCodecs","preferredAudioCodecs","preferredAudioChannelCount","preferredDecodingAttributes","variants","choosePreferredCodecs","videoCodec","filtered","subset","audioCodec","shaka.util.StreamUtils.choosePreferredCodecs","variantsByCodecs","getVariantsByCodecs_","shaka.util.MultiMap","variantCodecs","shaka.util.StreamUtils.getVariantCodecs_","shaka.util.StreamUtils.getVariantsByCodecs_","shaka.util.StreamUtils.filterVariantsByAudioChannelCount","filterVariantsByDensity_","maxDensity","codecGroupsByDensity","countCodecs","density","frameRate","group","shaka.util.StreamUtils.filterVariantsByDensity_","bestCodecs","chooseCodecsByDecodingAttributes_","attributes","attribute","shaka.util.StreamUtils.DecodingAttributes.SMOOTH","shaka.util.StreamUtils.DecodingAttributes.POWER","shaka.util.StreamUtils.chooseCodecsByMediaCapabilitiesInfo_","shaka.util.StreamUtils.DecodingAttributes.BANDWIDTH","findCodecsByLowestBandwidth_","lowestAverageBandwidth","sum","num","averageBandwidth","shaka.util.StreamUtils.findCodecsByLowestBandwidth_","shaka.util.StreamUtils.chooseCodecsByDecodingAttributes_","chooseCodecsByMediaCapabilitiesInfo_","highestScore","bestVariantsByCodecs","decodingInfos","averageScore","getVariantCodecs_","Cd","baseVideoCodec","shaka.util.MimeUtils.getNormalizedCodec","baseAudioCodec","meetsRestrictions","restrictions","maxHwRes","inRange","disabledUntilTime","minWidth","maxWidth","minHeight","maxHeight","minPixels","maxPixels","minFrameRate","maxFrameRate","minBandwidth","maxBandwidth","applyRestrictions","Kd","tracksChanged","originalAllowed","allowedByApplication","shaka.util.StreamUtils.meetsRestrictions","filterManifest","currentVariant","shaka.util.StreamUtils.filterManifestByMediaCapabilities","offlineSessionIds","shaka.util.StreamUtils.filterManifestByCurrentVariant","filterTextStreams_","textStreams","shaka.text.TextEngine.isTypeSupported","shaka.util.StreamUtils.filterTextStreams_","filterImageStreams_","imageStreams","minImage","res","shaka.util.StreamUtils.supportedImageMimeTypes_has","shaka.util.StreamUtils.minImage_get","shaka.util.StreamUtils.supportedImageMimeTypes_set","isImageSupported_","imageElement","Image","onload","onerror","imageElement.onerror","shaka.util.StreamUtils.isImageSupported_","shaka.util.StreamUtils.supportedImageMimeTypes_get","shaka.util.StreamUtils.filterImageStreams_","filterManifestByMediaCapabilities","usePersistentLicenses","shaka.util.StreamUtils.getDecodingInfosForVariants","videoCodecs","shaka.util.StreamUtils.getCorrectVideoCodecs_","allCodecs","shaka.util.ManifestParserUtils.guessCodecs","audioCodecs","shaka.util.StreamUtils.getCorrectAudioCodecs_","audioFullType","shaka.util.MimeUtils.getFullOrConvertedType","fullType","shaka.util.Platform.isXboxOne","shaka.util.StreamUtils.getVariantSummaryString_","supported","some","decodingInfo","getDecodingInfosForVariants","srcEquals","mediaCapabilities","operations","getVariantDecodingInfos","decodingConfigs","decodingConfig","shaka.util.StreamUtils.getDecodingConfigs_","getDecodingConfigs_","Ud","mediaDecodingConfig","channels","bitrate","samplerate","spatialRendering","framerate","hdr","transferFunction","channelsCount","audioSamplingRate","spatialAudio","allDrmInfos","drmInfos","configs","drmInfoByKeySystems","persistentState","sessionTypes","keySystemConfig","initDataType","distinctiveIdentifier","initDataTypes","robustness","keySystemConfiguration","getCorrectAudioCodecs_","Sd","getCorrectVideoCodecs_","avcdata","filterManifestByCurrentVariant","shaka.util.StreamUtils.areStreamsCompatible_","areStreamsCompatible_","s0","s1","variantToTrack","audioMimeType","videoMimeType","mimeTypes","kinds","kind","roles","active","label","pixelAspectRatio","primary","from","audioRoles","forced","videoId","audioId","tilesLayout","audioBandwidth","videoBandwidth","originalVideoId","originalAudioId","originalTextId","originalImageId","originalId","textStreamToTrack","imageStreamToTrack","reference","segmentIndex","layout","html5TrackId","html5Track","shaka.util.StreamUtils.nextTrackId_","html5TextTrackToTrack","textTrack","shaka.util.StreamUtils.html5TrackToGenericShakaTrack_","html5AudioTrackToTrack","audioTrack","enabled","html5TrackToGenericShakaTrack_","shaka.util.StreamUtils.html5TrackId","isPlayable","allowedByKeySystem","filterVariantsByAudioChannelCount","variantsWithChannelCounts","variantsByChannelCount","channelCounts","countLessThanOrEqualtoConfig","filterStreamsByLanguageAndRole","streams","preferredLanguage","preferredRole","preferredForced","chosen","firstLanguage","closestLocale","roleMatches","shaka.util.StreamUtils.filterTextStreamsByRole_","noRoleMatches","allRoles","filterTextStreamsByRole_","getVariantSummaryString_","summaries","shaka.util.StreamUtils.getStreamSummaryString_","getStreamSummaryString_","shaka.util.MultiMap.prototype","SMOOTH","POWER","BANDWIDTH","shaka.util.StreamUtils.supportedImageMimeTypes_","shaka.util.StreamUtils.minImage_","shaka.util.StreamUtils.minWebPImage_","shaka.util.StreamUtils.minAvifImage_","switch_","enabled_","bandwidthEstimator_","connection","config_","useNetworkInformation","configure","advanced","chosenVariant","chooseVariant","variants_","playbackRate_","startupComplete_","resizeObserver_","mediaElement_","lastTimeChosenMs_","resizeObserverTimer_","restrictToElementSize","getDefaultBandwidth_","defaultBandwidthEstimate","downlink","filterAndSortVariants_","sort","v1","v2","disconnect","shaka.abr.SimpleAbrManager.prototype","switchCallback","restrictToScreenSize","devicePixelRatio","ignoreDevicePixelRatio","screen","clientWidth","clientHeight","sortedVariants","shaka.abr.SimpleAbrManager.filterAndSortVariants_","currentBandwidth","getBandwidthEstimate","playbackRate","abs","bandwidthDowngradeTarget","bandwidthUpgradeTarget","segmentDownloaded","deltaTimeMs","suggestStreams_","switchInterval","rate","setMediaElement","mediaElement","ResizeObserver","shaka.abr.SimpleAbrManager.RESIZE_OBSERVER_BATCH_TIME","observe","shaka.abr.SimpleAbrManager","minor","major_","minor_","deprecateFeature","description","expiresAt","shaka.deprecate.Version","enforce","shaka.Deprecate.enforcer_","libraryVersion_","minorCheck","expiresOn","onPending_","onExpired_","libraryVersion","featureVersion","root","candidates","root_","shaka.media.AdaptationSet.canTransitionBetween_","shaka.media.AdaptationSet.areRolesEqual_","codecsA","codecsB","areRolesEqual_","aSet","bSet","mainRole","example","example_","fallback_","shaka.media.PreferenceBasedCriteria","role","channelCount","language_","role_","channelCount_","label_","previousState_","shaka.media.BufferingObserver.State.SATISFIED","thresholds_","thresholdWhenSatisfied","shaka.media.BufferingObserver.State.STARVING","thresholdWhenStarving","setThresholds","shaka.config.AutoShowText","NEVER","ALWAYS","IF_PREFERRED_TEXT_LANGUAGE","IF_SUBTITLES_MAY_BE_NEEDED","shaka.media.AdaptationSet","shaka.media.AdaptationSet.areAdaptable","canInclude","shaka.media.ExampleBasedCriteria","shortList","byLanguage","filterByLanguage_","preferredLocale","shaka.media.PreferenceBasedCriteria.filterByLanguage_","byPrimary","byRole","filterVariantsByRole_","shaka.media.PreferenceBasedCriteria.filterVariantsByRole_","byChannel","byLabel","filterVariantsByLabel_","preferredLabel","shaka.media.PreferenceBasedCriteria.filterVariantsByLabel_","STARVING","SATISFIED","parameters","autoReset","defaults","maxAttempts","baseDelay","backoffFactor","fuzzFactor","timeout","stallTimeout","connectionTimeout","maxAttempts_","baseDelay_","fuzzFactor_","backoffFactor_","numAttempts_","nextUnfuzzedDelay_","autoReset_","attempt","currentAttempt","fuzzedDelayMs","shaka.util.Error.Category.PLAYER","shaka.util.Error.Code.ATTEMPTS_EXHAUSTED","reset_","timer","onAbort","onAbort_","aborted_","failed","shaka.util.AbortableOperation","aborted","shaka.util.Error.Code.OPERATION_ABORTED","completed","notAbortable","op","abort","dict","stopped","fromRealEvent","fakeEvent","shaka.util.FakeEvent","onFinal","onSuccess","makeCallback","isSuccess","newPromise","abortError","exception","shaka.util.AbortableOperation.wrapChainCallback_","shaka.util.AbortableOperation.all","shaka.util.AbortableOperation.notAbortable","shaka.util.AbortableOperation.completed","shaka.util.AbortableOperation.aborted","shaka.util.AbortableOperation.failed","shaka.util.FakeEvent.EventName","AbrStatusChanged","Adaptation","Buffering","DownloadFailed","DownloadHeadersReceived","DrmSessionUpdate","Emsg","Prft","ExpirationUpdated","GapJumped","Loaded","Loading","ManifestParsed","MediaQualityChanged","Metadata","OnStateChange","OnStateIdle","RateChange","SegmentAppended","SessionDataEvent","StallDetected","Streaming","TextChanged","TextTrackVisibility","TimelineRegionAdded","TimelineRegionEnter","TimelineRegionExit","TracksChanged","Unloading","VariantChanged","listeners_","dispatchTarget","cloneObject","arg","seenObjects","shallowCloneObject","original","operations_","manage","operation","finally","shaka.util.ArrayUtils.remove","onProgressUpdated","onHeadersReceived","onDownloadFailed","shaka.util.FakeEventTargetcall","destroyed_","operationManager_","shaka.util.OperationManager","requestFilters_","responseFilters_","onProgressUpdated_","onHeadersReceived_","onDownloadFailed_","forceHTTPS_","registerScheme","progressSupport","shaka.net.NetworkingEngine.PluginPriority.APPLICATION","existing","shaka.net.NetworkingEngine.schemes_","uris","retryParams","streamDataCallback","method","headers","allowCrossSiteCredentials","retryParameters","licenseRequestType","sessionId","drmInfo","send_","request","backoff","lastError","numBytesRemainingObj","gotProgress","protocol","shaka.util.Error.Category.NETWORK","shaka.util.Error.Code.UNSUPPORTED_SCHEME","startTimeMs","connectionTimer","stallTimer","headersReceivedCalled","chain","requestPlugin","progressUpdated","numBytesRemaining","stallTimeoutMs","shaka.net.NetworkingEngine.RequestType.SEGMENT","bytesToLoad_","headersReceived","connectionTimeoutMs","response","timeMs","responseAndGotProgress","shakaError","httpResponseCode","shaka.util.Error.Code.BAD_HTTP_STATUS","shaka.util.Error.Severity.RECOVERABLE","shaka.util.Error.Code.TIMEOUT","shaka.util.AbortableOperationcall","bytesRemaining_","shaka.util.FakeEventTarget","universalListeners","shaka.util.FakeEventTarget.ALL_EVENTS_","handleEvent","release","cleanup","$jscomp.inherits","shaka.net.NetworkingEngine","FakeEventTarget","setForceHTTPS","shaka.net.NetworkingEngine.prototype","forceHTTPS","shaka.net.NetworkingEngine.NumBytesRemainingClass","shaka.net.NetworkingEngine.PendingRequest","shaka.util.ObjectUtils.cloneObject","requestFilterOperation","filterRequest_","filterOperation","requestFilter","shaka.util.Error.Code.REQUEST_FILTER_ERROR","requestOperation","makeRequestWithRetry_","shaka.net.Backoff","responseFilterOperation","filterResponse_","responseFilter","resp","shaka.util.Error.Code.RESPONSE_FILTER_ERROR","requestFilterStartTime","requestFilterMs","responseFilterStartTime","responseFilterMs","fromCache","pendingRequest","shaka.net.NetworkingEngine.makeRequest","defaultRetryParameters","unregisterScheme","shaka.net.NetworkingEngine.registerScheme","AbortableOperation","shaka.net.NetworkingEngine.RequestType","shaka.net.NetworkingEngine.PluginPriority","waitOnDestroy_","onDestroy_","ensureNotDestroyed","shaka.util.Error.Code.OBJECT_DESTROYED","bindingMap_","convertOptions_","ignored","doesSupportObject_","supports","shaka.util.EventManager.Binding_.supportsObject_","prop","shaka.util.EventManager.Binding_.doesSupportObject_","shaka.util.EventManager.Binding_.convertOptions_","shaka.util.Destroyer","shaka.util.EventManager.prototype","removeAll","binding","shaka.util.EventManager.Binding_","listen","shim","unlisten","shaka.util.EventManager","iterable","mapping","asMap","asObject","obj","map1","map2","val2","endianness","dataView_","littleEndian_","shaka.util.DataViewReader.Endianness.LITTLE_ENDIAN","position_","outOfBounds_","shaka.util.Error.Category.MEDIA","shaka.util.Error.Code.BUFFER_READ_OUT_OF_BOUNDS","hasMoreData","shaka.util.DataViewReader.prototype","getUint8","getUint32","readInt32","getInt32","high","shaka.util.Error.Code.JS_INTEGER_OVERFLOW","low","skip","shaka.util.DataViewReader","headers_","boxDefinitions_","done_","box","headerSize","shaka.util.Mp4Parser.headerSize","reader","parser","parseNext","partialOkay","sampleDescription","readUint32","visualSampleEntry","allData","readBytes","getPosition","typeFromString_","typeToString","basicHeaderSize","has64BitSize","versionAndFlagsSize","shaka.util.DataViewReader.Endianness","shaka.util.Mp4Parser.prototype","definition","typeCode","shaka.util.Mp4Parser.typeFromString_","shaka.util.Mp4Parser.BoxType_.BASIC_BOX","shaka.util.Mp4Parser.BoxType_.FULL_BOX","stopOnPartial","shaka.util.DataViewReader.Endianness.BIG_ENDIAN","absStart","shaka.util.Mp4Parser.typeToString","readUint64","boxDefinition","versionAndFlags","payloadSize","payloadReader","shaka.util.Mp4Parser","shaka.util.Mp4Parser.allData","shaka.util.Mp4Parser.visualSampleEntry","shaka.util.Mp4Parser.sampleDescription","shaka.util.Mp4Parser.children","BASIC_BOX","FULL_BOX","psshBox","systemIds","cencKeyIds","fullBox","pssh","parsePsshBox_","numKeyIds","keyId","parse","createPssh","systemId","dataLength","psshSize","psshData","byteCursor","setUint32","KID","findChild","elem","shaka.util.XmlUtils.findChildren","findChildNS","ns","shaka.util.XmlUtils.findChildrenNS","findChildren","found","childNodes","Element","findChildrenNS","localName","getAttributeNS","hasAttributeNS","getAttributeNSList","nsList","getContents","every","shaka.util.XmlUtils.isText","isText","Node","TEXT_NODE","CDATA_SECTION_NODE","parseAttr","parseFunction","parsedValue","getAttribute","parseDate","dateString","parseDuration","durationString","matches","isFinite","parseRange","rangeString","intString","parsePositiveInt","parseNonNegativeInt","parseFloat","floatString","evalDivision","exprString","parseXmlString","xmlString","expectedRootElemName","DOMParser","unsafeXmlString","shaka.util.XmlUtils.trustedHTMLFromString_value","unsafeXml","parseFromString","rootElem","createNodeIterator","NodeFilter","SHOW_ALL","currentNode","nextNode","HTMLElement","SVGElement","parseXml","shaka.util.XmlUtils.parseXmlString","trustedTypes","policy","createPolicy","createHTML","s","playerInterface","updateExpirationTime","playerInterface_","supportedTypes_","video_","mediaKeys_","initializedForStorage_","initialized_","licenseTimeSeconds_","currentDrmInfo_","eventManager_","activeSessions_","offlineSessionIds_","allSessionsLoaded_","onError_","this.onError_","keyStatusByKeyId_","announcedKeyStatusByKeyId_","keyStatusTimer_","processKeyStatusChanges_","privateMap","publicMap","status","statuses","shaka.util.Error.Category.DRM","shaka.util.Error.Code.EXPIRED","onKeyStatus","shaka.util.MapUtils.asObject","usePersistentLicenses_","mediaKeyMessageEvents_","initialRequestsSent_","expirationTimer_","pollExpiration_","metadata","session","oldTime","oldExpiration","newTime","expiration","onExpirationUpdated","tickEvery","destroyer_","destroyNow_","closeOpenSessions_","setMediaKeys","srcEquals_","mediaKeysAttached_","initForPlayback","init_","clearKeyDrmInfo","hadDrmInfo","servers","configureClearKey_","clearKeys","shaka.util.MapUtils.asMap","kid","keyObj","kty","license","jwkSet","initDataStr","kids","initDatas","replaceDrmInfo_","keySystems","shaka.media.DrmEngine.replaceDrmInfo_","getVariantDrmInfos_","shaka.media.DrmEngine.fillInDrmInfoDefaults_","keySystemsMapping","queryMediaKeys_","configsByKeySystem","attachMediaKeys_","mediaKeys","shaka.util.Error.Code.FAILED_TO_ATTACH_TO_VIDEO","setServerCertificate","netEngine","shaka.net.NetworkingEngine.RequestType.SERVER_CERTIFICATE","shaka.util.Error.Code.SERVER_CERTIFICATE_REQUEST_FAILED","shaka.util.Error.Code.INVALID_SERVER_CERTIFICATE","createOrLoad","newInitData","initDataOverride","loadOfflineSession_","metadatas","areAllSessionsLoaded_","createSession","shaka.util.Error.Code.FAILED_TO_CREATE_SESSION","onSessionMessage_","delayLicenseRequestUntilPlayed","paused","sendLicenseRequest_","onKeyStatusesChange_","loaded","updatePromise","initDataTransform","shaka.util.Error.Code.INIT_DATA_TRANSFORM_ERROR","logLicenseExchange","generateRequest","errorCode","systemCode","extended","shaka.util.Error.Code.FAILED_TO_GENERATE_LICENSE_REQUEST","isPlayReadyKeySystem","getSessionIds","ids","shaka.util.Iterables.map","sessions","drmInfosByKeySystem","mediaKeySystemAccess","realConfig","audioCaps","videoCaps","cap","getKeySystemAccessFromVariants_","shaka.util.Error.Code.NO_RECOGNIZED_KEY_SYSTEMS","preferredKeySystems","preferredKeySystem","keySystemAccess","shouldHaveLicenseServer","getKeySystemAccessByConfigs_","hasLicenseServer","audioCapabilities","videoCapabilities","requestMediaKeySystemAccess","shaka.util.Error.Code.REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE","getConfiguration","licenseServers","serverCertificateUris","serverCerts","shaka.media.DrmEngine.processDrmInfos_","defaultSessionType","shaka.util.Error.Code.NO_LICENSE_SERVER_GIVEN","createMediaKeys","shaka.util.Error.Code.FAILED_TO_CREATE_CDM","present","load","shaka.util.Error.Code.OFFLINE_SESSION_REMOVED","advancedConfig","startTimeRequest","shakaErr","updateEvent","$jscomp.asyncExecutePromiseGeneratorProgram","messageType","individualizationServer","shaka.media.DrmEngine.isPlayReadyKeySystem","unpackPlayReadyRequest_","xml","dom","header","shaka.net.NetworkingEngine.RequestType.LICENSE","shaka.util.Error.Code.LICENSE_REQUEST_FAILED","update","shaka.util.Error.Code.LICENSE_RESPONSE_REJECTED","onEvent","shaka.media.DrmEngine.SESSION_LOAD_TIMEOUT_","hasExpiredKeys","keyStatuses","tmp","part0","part1","part2","keyIdHex","msUntilExpiration","close","shaka.media.DrmEngine.KEY_STATUS_BATCH_TIME","openSessions","entries","closeSession_","shaka.media.DrmEngine.CLOSE_TIMEOUT_","race","closed","getCommonDrmInfos","drms1","drms2","commonDrms","drm1","drm2","d2","mergedDrm","shaka.util.Iterables.every","processDrmInfos_","cert","fillInDrmInfoDefaults_","advancedConfigs","originalKeySystem","server","cast","__platform__","shaka.media.DrmEngine.prototype","manifestInitData","listenOnce","onPlay_","shaka.util.Error.Code.ENCRYPTED_CONTENT_WITHOUT_DRM_INFO","parseInbandPsshEnabled","onEncryptedEvent_","shaka.media.DrmEngine.DUMMY_KEY_ID","getFactory","factory","extension","shaka.media.ManifestParser.parsersByMime","shaka.media.ManifestParser.getExtension","shaka.media.ManifestParser.parsersByExtension","shaka.media.ManifestParser.getMimeType","shaka.util.Error.Code.UNABLE_TO_GUESS_MANIFEST_TYPE","getMimeType","shaka.net.NetworkingEngine.RequestType.MANIFEST","getExtension","filenamePieces","uriObj","shaka.media.ManifestParser","unregisterParserByMime","registerParserByMime","parserFactory","registerParserByExtension","insertEncryptionMetadata_","stsdBox","sourceBox","ancestorBoxes","metadataBoxType","sinfBoxArray","shaka.media.ContentWorkarounds.CANNED_SINF_BOX_value","sourceBoxArray","sourceBoxView","metadataBoxArray","metadataBoxView","shaka.media.ContentWorkarounds.BOX_TYPE_OFFSET_","sourceBoxType","shaka.media.ContentWorkarounds.CANNED_SINF_BOX_FORMAT_OFFSET_","shaka.media.ContentWorkarounds.updateBoxSize_","newInitSegment","cutPoint","afterData","stsdBoxView","stsdBoxHeaderSize","numEntries","updateBoxSize_","dataArray","boxStart","newBoxSize","sizeField","boxView","shaka.media.ContentWorkarounds.BOX_SIZE_OFFSET_","shaka.media.ContentWorkarounds.BOX_SIZE_64_OFFSET_","getParsedCaption","topLevelCue","memory","firstNonEmptyRow","lastNonEmptyRow","character_","currentItalics","currentUnderline","currentTextColor","shaka.cea.CeaUtils.DEFAULT_TXT_COLOR","currentBackgroundColor","shaka.cea.CeaUtils.DEFAULT_BG_COLOR","currentCue","shaka.cea.CeaUtils.createStyledCue","row","firstNonEmptyCol","lastNonEmptyCol","linebreakCue","shaka.cea.CeaUtils.createLineBreakCue","styledChar","underline","underline_","italics","italics_","textColor","textColor_","backgroundColor_","createStyledCue","txtColor","bgColor","shaka.text.Cue.textDecoration.UNDERLINE","shaka.text.Cue.fontStyle.ITALIC","createLineBreakCue","character","fieldNum","channelNum","rows_","row_","scrollRows_","fieldNum_","channelNum_","reset","forceEmit","shaka.cea.CeaUtils.getParsedCaption","resetRows","resetAllRows","shaka.cea.Cea608Memory.CC_ROWS","addChar","shaka.cea.Cea608Memory.CharSet.BASIC_NORTH_AMERICAN","shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanCharshas","shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanCharsget","shaka.cea.Cea608Memory.CharSet.SPECIAL_NORTH_AMERICAN","shaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanCharsget","shaka.cea.Cea608Memory.CharSet.SPANISH_FRENCH","eraseChar","shaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrenchget","shaka.cea.Cea608Memory.CharSet.PORTUGUESE_GERMAN","shaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGermanget","shaka.cea.CeaUtils.StyledChar","moveRows","dst","BASIC_NORTH_AMERICAN","SPECIAL_NORTH_AMERICAN","SPANISH_FRENCH","PORTUGUESE_GERMAN","shaka.cea.Cea608Memory.CharSet.BasicNorthAmericanChars","shaka.cea.Cea608Memory.CharSet.SpecialNorthAmericanChars","shaka.cea.Cea608Memory.CharSet.ExtendedSpanishFrench","shaka.cea.Cea608Memory.CharSet.ExtendedPortugueseGerman","type_","shaka.cea.Cea608DataChannel.CaptionType.NONE","text_","shaka.cea.Cea608Memory","displayedMemory_","nonDisplayedMemory_","curbuf_","prevEndTime_","lastcp_","controlRu_","scrollSize","pts","buf","parsedClosedCaption","shaka.cea.Cea608DataChannel.CaptionType.ROLLUP","shaka.cea.Cea608DataChannel.CaptionType.TEXT","controlRcl_","shaka.cea.Cea608DataChannel.CaptionType.POPON","scrollRows","controlRtd_","shaka.log.warnOnce","NONE","POPON","ROLLUP","shaka.cea.Cea608DataChannel.BG_COLORS","shaka.cea.Cea608DataChannel.TEXT_COLORS","visible_","colCount_","rowCount_","justification_","shaka.cea.Cea708Window.TextJustification.CENTER","memory_","col_","startTime_","resetMemory","shaka.cea.Cea708Window.MAX_ROWS","createNewRow_","shaka.cea.Cea708Window.MAX_COLS","setCharacter","isPenInBounds_","cea708Char","inColBounds","serviceNumber","shaka.cea.Cea708Window.TextJustification.LEFT","shaka.text.Cue.textAlign.LEFT","shaka.cea.Cea708Window.TextJustification.RIGHT","shaka.text.Cue.textAlign.RIGHT","setStartTime","shaka.cea.Cea708Window","builtPackets_","currentPacketBeingBuilt_","bytesLeftToAddInCurrentPacket_","addByte","cea708Byte","shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_START","packet","shaka.cea.DtvccPacket","packetData","pos_","packetData_","readByte","serviceNumber_","windows_","currentWindow_","handleC1_","dtvccPacket","captionCommand","windowNum","setCurrentWindow_","bitmap","getSpecifiedWindowIds_","clearWindows_","isVisible","displayWindows_","hideWindows_","toggleWindows_","deleteWindows_","allWindowsBitmap","attrByte2","setPenAttributes_","foregroundByte","backgroundByte","setPenColor_","rgbColorToHex_","locationByte1","locationByte2","setPenLocation_","b3","setWindowAttributes_","windowAlreadyExists","defineWindow_","b1","b4","b5","b6","resetPen","defineWindow","windowsBitmap","windowId","green","colorMapping","shaka.cea.Cea708Service.Colors","numBlocks","cea608DataArray_","cea708DataArray_","dtvccPacketBuilder_","shaka.cea.DtvccPacketBuilder","badFrames_","cea608ModeToStream_","shaka.cea.Cea608DataChannel","currentField2Channel_","currentField1Channel_","serviceNumberToService_","PAINTON","decodeCea608_","ccPacket","ccData1","selectedStream","ccData2","isOddParity_","b2","ccrowtab","attr","newTopRow","RCL","BS","RU2","RU3","RU4","FON","RDC","TR","RTD","EDM","CR","toprow","ENM","EOC","decodeCea708_","parsedClosedCaptions","serviceBlockHeader","blockSize","service","shaka.cea.Cea708Service","startPos","blockData","controlCode","shaka.cea.Cea708Service.EXT_CEA708_CTRL_CODE_BYTE1","shaka.cea.Cea708Service.ASCII_BACKSPACE","shaka.cea.Cea708Service.ASCII_CARRIAGE_RETURN","shaka.cea.Cea708Service.ASCII_HOR_CARRIAGE_RETURN","shaka.cea.Cea708Service.ASCII_FORM_FEED","shaka.cea.Cea708Service.G2Charsethas","shaka.cea.Cea708Service.G2Charsetget","closedCaption","byte","parity","parseTFHD","defaultSampleDuration","defaultSampleSize","baseDataOffset","trackId","parseTFDT","baseMediaDecodeTime","parseMDHD","timescale","parseTRUN","sampleCount","sampleData","dataOffset","sampleDuration","sampleSize","sampleCompositionTimeOffset","trackIdToTimescale_","defaultSampleSize_","defaultSampleDuration_","bitstreamFormat_","shaka.cea.Mp4CeaParser.BitstreamFormat.UNKNOWN","shaka.cea.DummyCeaParser","shaka.cea.Mp4CeaParser","codecBoxParser","shaka.cea.Mp4CeaParser.CodecBitstreamMap_","setBitstreamFormat_","trackIds","timescales","parsedMDHDBox","shaka.util.Mp4BoxParsers.parseMDHD","fourcc","shaka.util.Error.Code.INVALID_MP4_CEA","mediaSegment","captionPackets","moofOffset","trunOffset","shaka.cea.ICeaParser.DEFAULT_TIMESCALE_VALUE","parsedTRUN","shaka.util.Mp4BoxParsers.parseTRUN","parsedTFHD","shaka.util.Mp4BoxParsers.parseTFHD","shaka.util.Mp4BoxParsers.parseTFDT","sampleIndex","naluSize","naluHeader","readUint8","parseMdat_","shaka.cea.Mp4CeaParser.BitstreamFormat.H264","isSeiMessage","shaka.cea.ICeaParser.H264_NALU_TYPE_SEI","shaka.cea.Mp4CeaParser.BitstreamFormat.H265","shaka.cea.ICeaParser.H265_PREFIX_NALU_TYPE_SEI","naluType","shaka.cea.ICeaParser.H265_SUFFIX_NALU_TYPE_SEI","timeOffset","naluClone","seiPayloads","zeroCount","newArr","payloadType","UNKNOWN","H264","H265","avc1","avc3","hev1","hvc1","dvh1","dvhe","ceaParser_","ceaDecoder_","shaka.cea.CeaDecoder","parseFrom","mediaFragment","captionPacket","uint8ArrayData","shaka.cea.CeaDecoder.USA_COUNTRY_CODE","shaka.cea.CeaDecoder.ATSC_PROVIDER_CODE","readUint16","shaka.cea.CeaDecoder.ATSC1_USER_IDENTIFIER","captionData","ccValid","shaka.cea.CeaDecoder.NTSC_CC_FIELD_1","shaka.cea.CeaDecoder.NTSC_CC_FIELD_2","ccType","shaka.cea.DtvccPacketBuilder.DTVCC_PACKET_DATA","stableComparator","p1","p2","startByte","endByte","mediaQuality","getUris","initSegmentReference","timestampOffset","appendWindowStart","appendWindowEnd","partialReferences","tileDuration","syncTime","hlsAes128Key","shaka.media.SegmentReference.Status.AVAILABLE","trueEndTime","getUrisInner","thumbnailSprite","discontinuitySequence","shaka.media.ClosedCaptionParser","init","shaka.media.InitSegmentReference","shaka.media.SegmentReference.prototype","getStartByte","shaka.media.SegmentReference.Status.UNAVAILABLE","partial","syncAgainst","lowestSyncTime","shaka.media.SegmentReference","AVAILABLE","UNAVAILABLE","bufferStart","bufferEnd","isBuffered","bufferedAheadOf","shaka.media.TimeRangesUtils.getBufferedInfo","getBufferedInfo","readSize_","decodeFrame_","frame","metadataFrame","shaka.util.Id3Utils.UTF8_encoding","descriptionEndIndex","textEndIndex","getID3Frames","id3Data","frames","shaka.util.Id3Utils.readSize_","shaka.util.Id3Utils.decodeFrame_","frameData","pmtId_","pmtParsed_","videoPid_","videoStartTime_","videoData_","audioPid_","audioStartTime_","audioData_","id3Pid_","id3Data_","pes","packetLength","dts","ptsDtsFlags","syncOffset","scanwindow","shaka.util.TsParser.PacketLength_","media","canvas","dilConfig","dil_","variantId_","media_","canvas_","dilConfig_","libDPIModule","LcevcDil","SupportObject","SupportStatus","SupportError","create_","HTMLCanvasElement","webGLSupport","classList","updateVariant","containerFormat","shaka.lcevc.Dil.ContainerFormat.MPEG2_TS","shaka.lcevc.Dil.ContainerFormat.WEBM","shaka.lcevc.Dil.ContainerFormat.MP4","setLevelSwitching","setContainerFormat","shaka.media.SegmentReference.Status","MISSING","shaka.util.Id3Utils","shaka.util.Id3Utils.getID3Frames","shaka.util.TsParser","shaka.util.TsParser.syncOffset","unknownPIDs","payloadUnitStartIndicator","pid","id3","tableEnd","parsedPIDs","videoData","parsePES","shaka.util.TsParser.Timescale_","audioData","shaka.lcevc.Dil","MPEG2_TS","WEBM","MP4","textDisplayer","onMetadata","lcevcDil","textDisplayer_","sourceBuffers_","sourceBufferTypes_","expectedEncryption_","textEngine_","onMetadata_","onMetadataNoOp","lcevcDil_","queues_","transmuxers_","captionParser_","mediaSourceOpen_","mediaSource_","createMediaSource","mediaSource","URL","revokeObjectURL","onSourceOpen_","url_","shaka.media.MediaSourceEngine.createObjectURL","doDestroy_","inProgress","shaka.util.Functional.noop","sequenceMode_","textSequenceModeOffset_","reinitText","sequenceMode","setSequenceMode","segmentRelativeVttTiming","ended","readyState","shaka.media.TimeRangesUtils.bufferStart","getBuffered_","shaka.media.TimeRangesUtils.bufferEnd","buffered","appendBuffer","hasClosedCaptions","seeked","adaptation","ContentType","tsParser","videoOffset","transmuxedData","sourceBuffer","SEQUENCE","duration","originalRange","originalOffset","mediaStartTime","textOffset","vttOffset","allCues","cuesToAppend","parseInit","periodStart","segmentStart","segmentEnd","parseMedia","shaka.media.MediaSourceEngine.RAW_FORMATSincludes","cueTime","getStartTime","getMetadata","prevId3Data","resetCaptions","transmux","flush","shaka.util.Error.Code.TRANSMUXING_FAILED","convertMuxjsCaptionsToShakaCaptions","workAroundBrokenPlatforms_","encryptionExpected","fakeEncryption","initSegmentBuffer","onEncryptionMetadataBox","isEncrypted","onSimpleAncestorBox","boxesToModify","newType","shaka.media.ContentWorkarounds.BOX_TYPE_ENCV_","shaka.media.ContentWorkarounds.BOX_TYPE_ENCA_","shaka.util.Error.Code.CONTENT_TRANSFORMATION_FAILED","reverse","workItem","shaka.media.ContentWorkarounds.insertEncryptionMetadata_","shaka.media.ContentWorkarounds.fakeEncryption","shaka.media.MediaSourceEngine.SourceBufferMode_.SEQUENCE","enqueueOperation_","append_","abort_","remove_","flush_","currentTime","onUpdateEnd_","setDuration","setTimestampOffset_","popFromQueue_","startOperation_","enqueueBlockingOperation_","run","allWaiters","ready","shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_THREW","shaka.util.Error.Code.QUOTA_EXCEEDED_ERROR","shaka.media.MediaSourceEngine.prototype","streamsByType","forceTransmux","sourceBufferExtraFeatures","addSourceBuffer","shaka.util.Error.Code.MEDIA_SOURCE_OPERATION_FAILED","total","reason","endOfStream","dummyOperation","createObjectURL","shaka.media.MediaSourceEngine.RAW_FORMATS","presentationStartTime","presentationDelay","autoCorrectDrift","presentationStartTime_","presentationDelay_","segmentAvailabilityDuration_","duration_","maxSegmentDuration_","maxSegmentEndTime_","minSegmentStartTime_","clockOffset_","static_","userSeekStart_","autoCorrectDrift_","availabilityTimeOffset_","startTimeLocked_","stallThresholdSeconds","onEvent_","implementation_","wasMakingProgress_","shouldBeMakingProgress","lastUpdateSeconds_","didJump_","stallsDetected_","stallThresholdSeconds_","onStall_","this.onStall_","timeInSeconds","timeline","stallDetector","timeline_","seekingEventReceived_","prevReadyState_","gapsJumped_","stallDetector_","hadSegmentAppended_","onPollGapJump_","gapJumpTimer_","seeking","autoplay","impl","wallTimeSeconds","triggerCallback","stallSeconds","gapIndex","getGapIndex","threshold","shaka.media.TimeRangesUtils.getGapIndex","gapDetectionThreshold","jumpTo","getSeekRangeEnd","shaka.media.GapJumpingController.BROWSER_GAP_TOLERANCE","waitForReadyState","eventManager","HTMLMediaElement","HAVE_NOTHING","eventName","shaka.util.MediaReadyState.READY_STATES_TO_EVENT_NAMES_value","getDuration","shaka.media.PresentationTimeline.prototype","isStatic","segmentAvailabilityDuration","notifySegments","references","firstReferenceStartTime","lastReferenceEndTime","notifyMinSegmentStartTime","maxSegmentDuration","getSegmentAvailabilityEnd","isLive","isInProgress","getLiveEdge_","getSafeSeekRangeStart","earliestSegmentTime","shaka.media.PresentationTimeline","shaka.media.StallDetector","shaka.media.GapJumpingController","HAVE_METADATA","HAVE_CURRENT_DATA","HAVE_FUTURE_DATA","HAVE_ENOUGH_DATA","onSeek","onSeek_","started_","mover_","shaka.media.VideoWrapper.PlayheadMover","shaka.util.MediaReadyState.waitForReadyState","setStartTime_","getTime","setTime","moveTo","startListeningToSeeks_","targetTime_","originTime_","remainingAttempts_","timer_","presentationTimeline","minBufferTime_","minBufferTime","lastCorrectiveSeek_","createStallDetector_","stallEnabled","stallSkip","detector","shaka.media.StallDetector.MediaElementImplementation","stallThreshold","onStall","doThis","pause","play","gapController_","videoWrapper_","shaka.media.VideoWrapper","onSeeking_","targetTime","reposition_","getStartTime_","getSeekRangeStart","clampSeekToDuration_","clampTime_","checkWindowTimer_","onPollWindow_","seekStart","seekEnd","minSeekRange_","durationBackoff","rebufferingGoal","safeSeekOffset","safe","seekSafe","shaka.media.TimeRangesUtils.isBuffered","numEvicted","immutable_","forEachTopLevelReference","fn","shaka.media.SegmentIndex","partialSegmentIndex","segmentIndex_","currentPosition_","currentPartialPosition_","shaka.media.SegmentIndexcall","indexes_","harness","harness_","isBuffering_","rate_","getRate","movePlayhead","pollRate_","apply_","calculateCurrentRate_","applyRate_","setRate","newRate","observers_","pollingLoop_","pollAllObservers_","poll","contentTypeStates_","getBufferedInfo_","getSeekRange","regions_","getSeekRange_","filterTimer_","seekRange","filterBySeekRange_","shaka.media.RegionTimeline.REGION_FILTER_INTERVAL","oldPosition_","rules_","weWere","weAre","shaka.media.RegionObserver.RelativePosition_.IN_THE_REGION","invoke","shaka.media.RegionObserver.RelativePosition_.BEFORE_THE_REGION","shaka.media.RegionObserver.RelativePosition_.AFTER_THE_REGION","eventType","this.onSeek_","shaka.media.SrcEqualsPlayhead.prototype","JSC$2582_getGapsJumped","shaka.media.MediaSourcePlayhead.prototype","onSegmentAppended","shaka.media.SegmentIndex.prototype","lastReferenceIndex","firstStartTime","round","mergeAndEvict","windowStart","merge","evict","oldSize","fit","windowEnd","isNew","lastReference","updateEvery","interval","updateCallback","getIteratorForTime","shaka.media.SegmentIterator","shaka.media.SegmentIndex.forSingleSegment","shaka.media.MetaSegmentIndex","SegmentIndex","shaka.media.MetaSegmentIndex.prototype","numPassedInEarlierIndexes","shaka.media.PlayRateController","getDefaultRate","shaka.media.PlayheadObserverManager","shaka.media.QualityObserver","positionInSeconds","changePositions","contentTypeState","qualityChangePositions","qualityChange","mq1","bufferedRanges","currentQuality","qualityAtPosition","shaka.media.RegionTimeline","shaka.media.RegionObserver","wasSeeking","previousPosition","currentPosition","rule","BEFORE_THE_REGION","IN_THE_REGION","AFTER_THE_REGION","createSegmentRequest","manifest_","bufferingGoalScale_","currentTextStream_","currentVariant_","parsedPrftEventRaised_","mediaStates_","failureCallbackBackoff_","fatalError_","aborts","cancelUpdate_","abortOperations_","setTrickPlay","mediaState","trickModeVideo","restoreStreamAfterTrickPlay","switchInternal_","normalVideo","switchVariant","clearBuffer","safeMargin","force","switchTextStream","textStream","mediaSourceEngine","closeSegmentIndex","segmentIterator","clearingBuffer","waitingToFlushBuffer","performingUpdate","waitingToClearBuffer","clearBufferSafeMargin","clearBuffer_","makeAbortDecision_","originalStream","originalOperation","createSegmentIndex","presentationTime","shouldAbortCurrentRequest_","getPresentationTime","lastSegmentReference","newSegment","newSegmentSize","bandwidthEstimate","loadNewTextStream_","isTextVisible","alwaysStreamText","createMediaState_","scheduleUpdate_","forceClearBuffer_","updateTimer","lastInitSegmentReference","lastTimestampOffset","lastAppendWindowStart","lastAppendWindowEnd","needsResync","recovering","hasError","onUpdate_","thisStream","mediaStates","update_","shaka.media.StreamingEngine.isEmbeddedText_","videoBufferEndTime","clearSelectedClosedCaptionId","timeNeeded","bufferedAhead","shaka.media.TimeRangesUtils.bufferedAheadOf","scaledBufferingGoal","bufferingGoal","timeUntilEnd","oneMicrosecond","textState","updateIntervalSeconds","getSegmentReferenceNeeded_","inaccurateTolerance","inaccurateManifestTolerance","lookupTime","otherState","minTimeNeeded","maxRunAhead","fetchAndAppend_","iter","isMP4","isReadableStreamSupported","remaining","processingResult","callbackCalled","getStatus","shaka.util.Error.Code.SEGMENT_MISSING","initSourceBuffer_","setProperties","fetchInit","lastDiscontinuitySequence","shaka.media.StreamingEngine.APPEND_WINDOW_START_FUDGE_","shaka.media.StreamingEngine.APPEND_WINDOW_END_FUDGE_","setStreamProperties","setAppendWindow","setAppendWindow_","reference1","reference2","getEndByte","shaka.media.InitSegmentReference.equal","fetch_","beforeAppendSegment","onInitSegmentAppended","resync","ReadableStream","lowLatencyMode","sawMDAT","dataToAppend","concatArray_","aes128Decrypt_","rawResult","iv","sequence","cryptoKey","fetchKey","firstMediaSequenceNumber","crypto","subtle","decrypt","ignoreTextStreamFailures","handleStreamingError_","handleQuotaExceeded_","ms","percentBefore","hasEmsg","shouldParsePrftBox","emsgSchemeIdUris","dispatchAllEmsgBoxes","parsePrftBox","readTerminatedString","presentationTimeDelta","eventDuration","schemeId","messageData","parseEMSG_","onManifestUpdate","emsg","schemeIdUri","parsePrft_","ntpTimestampSec","ntpTimestamp","mediaTime","wallClockTime","UTC","prftInfo","programStartDate","evict_","bufferBehind","isEmbeddedText_","requestType","shaka.util.Networking.createSegmentRequest","modifySegmentRequest","failureCallback","startingAt","startingWith","shaka.Player.createEmptyPayload_","currentlyAt_","currentlyWith_","waitForWork_","requests_","currentStep_","currentRoute_","mainLoopPromise_","mainLoop_","tryNewRoute_","interruptible","onCancel","newRoute","onStart","onSkip","takeNextStep_","getNext","enterNode","onEnd","handleError","onIdle","unblockMainLoop_","startNewRoute","onEnter","flattenPayload_","openStyleTags","bold","shaka.text.Cue.fontWeight.BOLD","prefixStyleTags","acc","suffixStyleTags","reduceRight","shaka.text.Utils.flattenPayload_","getCuesToFlatten","shaka.text.Utils.getCuesToFlatten","flatCue","textTrack_","textTracks","shaka.Player.TextTrackLabel","addTextTrack","shakaCue","vttCue","VTTCue","align","shaka.text.Cue.writingMode.VERTICAL_LEFT_TO_RIGHT","vertical","shaka.text.Cue.writingMode.VERTICAL_RIGHT_TO_LEFT","shaka.text.Cue.lineInterpretation.PERCENTAGE","snapToLines","removeWhere_","predicate","oldState","tempState","removeCue","removeAllChildren","videoContainer","isTextVisible_","cues_","videoContainer_","textContainer_","flexDirection","alignItems","justifyContent","captionsTimer_","updateCaptions_","updatePeriod","currentCuesMap_","regionElements_","isElementUnderTextContainer_","elemToCheck","parentElement","updateCuesRecursive_","container","parents","updateDOM","toUproot","toPlant","cueRegistry","shouldBeDisplayed","wrapper","cueElement","regionElement","createCue_","shaka.util.Dom.removeAllChildren","previousCuesMap","isNested","needWrapper","setCaptionStyles_","hasWrapper","isLeaf","whiteSpace","nonBreakingSpace","webkitTextStrokeColor","webkitTextStrokeWidth","paddingLeft","shaka.text.UITextDisplayer.convertLengthValue_","paddingRight","backgroundRepeat","backgroundSize","backgroundPosition","inheritProperty_","shaka.text.UITextDisplayer.inheritProperty_","shaka.text.Cue.displayAlign.BEFORE","shaka.text.Cue.displayAlign.CENTER","margin","shaka.text.Cue.lineAlign.END","bottom","right","paddingTop","shaka.text.Cue.positionAlign.LEFT","cssFloat","shaka.text.Cue.positionAlign.RIGHT","webkitWritingMode","regionId","getRegionElement_","heightUnit","widthUnit","viewportAnchorUnit","convertLengthValue_","lengthValue","unit","lengthValueInfo","sid_","sf_","playbackStarted_","buffering_","starved_","applySegmentData","segmentInfo","st","getStreamType_","shaka.util.CmcdManager.StreamType.LIVE","shaka.util.CmcdManager.StreamType.VOD","ot","getObjectType_","shaka.util.CmcdManager.ObjectType.INIT","shaka.util.CmcdManager.ObjectType.MUXED","shaka.util.CmcdManager.ObjectType.VIDEO","shaka.util.CmcdManager.ObjectType.AUDIO","shaka.util.CmcdManager.ObjectType.TIMED_TEXT","shaka.util.CmcdManager.ObjectType.CAPTION","isMedia","getBufferLength_","ranges","NaN","getCurrentTime","getTopBandwidth_","getVariantTracks","createData_","randomUUID","shaka.util.CmcdManager.Version","sid","cid","contentId","mtp","useHeaders","pr","getPlaybackRate","isVideo","bs","su","toHeaders","headerNames","headerGroups","headerMap","nor","nrr","rtp","shaka.util.CmcdManager.serialize","shaka.util.CmcdManager.toHeaders","shaka.util.CmcdManager.appendQueryToUri","serialize","toHundred","toRounded","results","formatters","toUrlSafe","formatter","appendQueryToUri","shaka.media.StreamingEngine.prototype","failureRetryParams","initStreams_","shaka.util.Error.Category.STREAMING","shaka.util.Error.Code.STREAMING_ENGINE_STARTUP_INVALID_STATE","updateDuration","shaka.routing.Walker","shaka.text.SimpleTextDisplayer.prototype","shaka.text.SimpleTextDisplayer.removeWhere_","removeInRange","flattenedCues","textTrackCues","cuesInTextTrack","inCue","cueInTextTrack","shaka.text.SimpleTextDisplayer.convertToTextTrackCue_","sortedCues","addCue","removeIt","shaka.text.SimpleTextDisplayer","shaka.util.Dom","shaka.text.UITextDisplayer.prototype","cuesList","cueInList","oldNumCues","shaka.text.UITextDisplayer","shaka.text.WebVttGenerator","MANIFEST","MUXED","INIT","CAPTION","TIMED_TEXT","VOD","LIVE","mergeConfigObjects","destination","template","overrides","ignoreKeys","isValid","subPath","subTemplate","subMergeValid","shaka.util.ConfigUtils.mergeConfigObjects","convertToConfigObject","xl","fieldName","configObject","searchIndex","nameStart","referenceParametersAndReturn","yl","defaultGetContentId","Al","uriString","Bl","appendWithLength","rebuiltInitData","shaka.util.Error.Code.SERVER_CERTIFICATE_REQUIRED","contentIdArray","utf16","sdkUri","createDefault","Dl","abrMaxHeight","saveData","drm","shaka.util.FairPlayUtils.initDataTransform","shaka.util.FairPlayUtils.defaultGetContentId","availabilityWindowOverride","disableAudio","disableVideo","disableText","disableThumbnails","defaultPresentationDelay","dash","clockSyncUri","ignoreDrmInfo","disableXlinkProcessing","xlinkFailGracefully","ignoreMinBufferTime","initialSegmentLimit","ignoreSuggestedPresentationDelay","ignoreEmptyAdaptationSet","ignoreMaxSegmentDuration","keySystemsByURI","manifestPreprocessor","shaka.util.ConfigUtils.referenceParametersAndReturn","hls","ignoreImageStreamFailures","defaultAudioCodec","defaultVideoCodec","ignoreManifestProgramDateTime","mediaPlaylistFullMimeType","useSafariBehaviorForLive","liveSegmentsDelay","streaming","startAtSegmentBoundary","useNativeHlsOnSafari","autoLowLatencyMode","preferNativeHls","observeQualityChanges","maxDisabledTime","offline","trackSelectionCallback","tracks","downloadSizeCallback","sizeEstimate","estimate","storage","usage","quota","progressCallback","content","progress","usePersistentLicense","numberOfParallelDownloads","abrFactory","abr","autoShowText","shaka.config.AutoShowText.IF_SUBTITLES_MAY_BE_NEEDED","preferredAudioLanguage","preferredTextLanguage","preferredVariantRole","preferredTextRole","preferForcedSubs","playRangeStart","playRangeEnd","textDisplayFactory","cmcd","lcevc","dynamicPerformanceScaling","logLevel","drawLogo","offline.trackSelectionCallback","defaultTrackSelect","allVariants","selectedVariants","tracksByHeight","selectedTracks","middleIndex","shaka.util.PlayerConfiguration.defaultTrackSelect","Fl","updates","shaka.util.PlayerConfiguration.createDefault","open_","closed_","start_","timestamp","currentTimeSeconds","getTimeSpentIn","entry","currentText_","history_","updateCurrentText","newText","fromAdaptation","bandwidthEstimate_","currentStreamBandwidth_","maxSegmentDurationSeconds_","liveLatencySeconds_","drmTimeSeconds_","manifestTimeSeconds_","loadLatencySeconds_","completionPercent_","totalGapsJumped_","totalStallsDetected_","totalCorruptedFrames_","totalDecodedFrames_","totalDroppedFrames_","height_","width_","stateHistory_","shaka.util.StateHistory","switchHistory_","shaka.util.SwitchHistory","dependencyInjector","loadMode_","shaka.Player.LoadMode.NOT_LOADED","globalEventManager_","attachEventManager_","loadEventManager_","assetUri_","parserFactory_","streamingEngine_","qualityObserver_","lcevcCanvas_","cmcdManager_","regionTimeline_","bufferObserver_","bufferPoller_","playRateController_","playheadObservers_","playhead_","mediaSourceEngine_","drmEngine_","networkingEngine_","fullyLoaded_","abrManagerFactory_","abrManager_","nextExternalStreamId_","defaultConfig_","maxHwRes_","stats_","currentAdaptationSetCriteria_","currentTextLanguage_","currentTextRole_","currentTextForced_","cleanupOnUnload_","updatedStartTime_","createNetworkingEngine","bytesDownloaded","makeEvent_","adManager_","shaka.Player.adManagerFactory_","retryStreaming","detachNode_","attachNode_","unloadNode_","parserNode_","manifestNode_","mediaSourceNode_","drmNode_","loadNode_","srcEqualsDrmNode_","srcEqualsNode_","actions","wants","onAttach_","videoErrorToShakaError_","onVideoError_","onDetach_","onUnload_","onInitializeMediaSourceEngine_","textDisplayerFactory","lastTextFactory_","createMediaSourceEngine","shaka.media.MediaSourceEngine","processTimedMetadataMediaSrc_","onInitializeParser_","assetUri","networkingEngine","manifestConfig","shaka.media.ManifestParser.getFactory","onParseManifest_","onRegionEvent_","onDashTimedMetadata","mediaQualityInfo","onMediaQualityChange_","modifyManifestRequest","manifestInfo","shaka.util.CmcdManager.ObjectType.MANIFEST","filterManifest_","makeTextStreamsForClosedCaptions","makeTextStreamsForClosedCaptions_","closedCaptionsSet","CLOSED_CAPTION","encrypted","onTimelineRegionAdded","findSimilarRegion_","similarRegion","isLowLatencyMode","isLowLatencyMode_","isAutoLowLatencyMode","isAutoLowLatencyMode_","enableLowLatencyMode","newDrmInfo","currentDrmInfo","delta","shaka.util.Error.Code.NO_VARIANTS","filterForAVVariants_","isAVVariant","shaka.Player.filterForAVVariants_","onInitializeDrm_","firstEvent","createDrmEngine","onKeyStatus_","onExpirationUpdated_","attach","onLoad_","updateStateHistory","onRateChange","initialVariant","activeVariant","createSegmentIndexPromises","toLazyLoad","rebufferThreshold","adjustedTime","initialTextStream","defaultPlaybackRate","updateStateHistory_","onRateChange_","setupLcevc_","shaka.Player.SRC_EQUAL_EXTENSIONS_TO_MIME_TYPES_","closeLcevcDil_","createLcevcDil_","shaka.Deprecate.deprecateFeature","this.abrManager_.setMediaElement","shaka.Player.applyPlayRange_","switchVariant_","shaka.util.StreamUtils.chooseCodecsAndFilterManifest","createStreamingEngine","shaka.media.StreamingEngine","onManifestUpdate_","onSegmentAppended_","notifyOfBufferingChange","pollBufferState_","addMediaQualityChange","getContentTypeState_","purgeQualityChangePositions_","oldChangePositions","newChangePosition","insertBeforeIndex","shaka.util.Pssh","combinedData","shaka.Player.LoadMode.MEDIA_SOURCE","activateChaptersTrack_","chooseVariant_","createPlayhead","shaka.media.MediaSourcePlayhead","createPlayheadObserversForMSE_","regionObserver","manager","startBufferManagement_","adjustStartTime_","activeAudio","activeVideo","getAdjustedTime","audioStartTime","videoStartTime","refTime","onAdaptation_","shaka.util.StreamUtils.variantToTrack","getTextTracks","shaka.util.StreamUtils.filterStreamsByLanguageAndRole","chooseTextStream_","addTextStreamToSwitchHistory_","shouldInitiallyShowText_","audioStream","shaka.config.AutoShowText.NEVER","shaka.config.AutoShowText.ALWAYS","preferredTextLocale","textLocale","shaka.config.AutoShowText.IF_PREFERRED_TEXT_LANGUAGE","audioLocale","setInitialTextState_","setTextVisibility","onTextTrackVisibility_","shouldStreamText_","isTextTrackVisible","enable","onAbrStatusChanged_","filterManifestByCurrentVariant_","checkPlayableVariants_","onTracksChanged_","updateAbrManagerVariants_","startTimeOfLoad","onInitializeSrcEqualsDrm_","shaka.util.MimeUtils.getCodecs","onSrcEquals_","shaka.media.SrcEqualsPlayhead","unloaded","preload","audioTracks","processTimedMetadataSrcEqls_","activeCues","dispatchMetadataEvent_","onCueMetadataChange","getMetadataTracks_","tickNow","appendSrcData","shaka.Player.LoadMode.SRC_EQUALS","fullyLoaded","setupPreferredAudioOnSrc_","selectAudioLanguage","getFilteredTextTracks_","setupPreferredTextOnSrc_","selectTextLanguage","abortedError","walker_","walkerImplementation","at","goingTo","getNextStep_","getNextMatchingAllDependencies_","checkVariantsTimer_","shaka.util.StreamUtils.applyRestrictions","checkVariants_","cleanupTasks","shaka.Player.LoadMode.DESTROYED","onAssetUnload","shaka.util.Stats","updateBufferState_","segmentEndTime","metadataType","onHlsTimedMetadata","shaka.media.DrmEngine","shaka.media.BufferingObserver","updateBufferingSettings_","shaka.Player.TYPICAL_BUFFERING_THRESHOLD_","isBufferedToEndSrc_","fudge","isBufferedToEndMS_","liveEdge","bufferedToEnd","bufferLead","newState","Xm","applyConfig_","filterManifestWithRestrictions_","chooseVariantAndSwitch_","oldTextDisplayer","disable","Sm","getChaptersTracks_","getTextMimetype_","shaka.Player.TEXT_EXTENSIONS_TO_MIME_TYPES_","shaka.util.Error.Code.TEXT_COULD_NOT_GUESS_MIME_TYPE","addSrcTrackElement_","adCuePoints","vvtText","blob","trackElement","getTextData_","convertToWebVTT_","Blob","srclang","convert","webvttTimeString","adCuePoint","hours","minutes","milliseconds","webvttString","webvttSettings","settings","shaka.text.Cue.textAlign.START","shaka.text.Cue.textAlign.END","shaka.text.WebVttGenerator.convert","shaka.util.Error.Code.MISSING_TEXT_PLUGIN","Ol","config.streaming.failureCallback","defaultStreamingFailureCallback_","retryDelaySeconds","shaka.util.Error.Code.HTTP_ERROR","config.textDisplayFactory","filterManifestWithStreamUtils_","shaka.util.StreamUtils.filterManifest","checkRestrictedVariants_","isBuffering","history","playableVariants","shaka.util.StreamUtils.isPlayable","adaptationSet","setVariants","addVariantToSwitchHistory_","oldTrack","newTrack","onVariantChanged_","switchHtml5Track_","currentTrack","shaka.util.StreamUtils.html5AudioTrackToTrack","to","delayDispatchEvent_","onTextChanged_","tryToRecoverFromError_","onLine","activeVariantTrack","eventElement","msExtendedCode","shaka.util.Error.Code.VIDEO_ERROR","keyStatusMap","isGlobalStatus","keyStatus","shaka.Player.restrictedStatuses_includes","variantsUpdated","applyPlayRange_","zm","setUserSeekStart","fullDuration","getKeyStatuses","hasPlayable","hasAppRestrictions","missingKeys","badKeyStatuses","shaka.util.Error.Code.RESTRICTIONS_CANNOT_BE_MET","restrictedKeyStatuses","shaka.util.Error.Code.CONTENT_UNSUPPORTED_BY_BROWSER","getLanguagesFrom_","cn","languages","getLanguageAndRolesFrom_","bn","languageToRoles","languageRoleToLabel","pairings","createAbortLoadError_","shaka.util.Error.Code.LOAD_INTERRUPTED","destinationNode","resetNode","createEmptyPayload_","wrapWalkerListenersWithPromise_","listeners.onCancel","listeners.onEnd","listeners.onError","listeners.onSkip","shaka.util.CmcdManager.StreamingFormat","DASH","HLS","OTHER","shaka.util.ConfigUtils","shaka.util.ConfigUtils.convertToConfigObject","commonFairPlayResponse","licenseProcessing","responseText","responseObject","shaka.util.FairPlayUtils","conaxFairPlayRequest","ezdrmFairPlayRequest","verimatrixFairPlayRequest","base64Payload","originalPayload","conaxInitDataTransform","skdValue","string","strLen","ezdrmInitDataTransform","verimatrixInitDataTransform","isFairPlaySupported","shaka.util.PlayerConfiguration","shaka.util.PlayerConfiguration.mergeConfigObjects","shaka.Player","events","events.onStart","events.onEnd","events.onCancel","events.onError","events.onSkip","shaka.Player.prototype","initializeMediaSource","shaka.util.Platform.supportsMediaSource","detach","currentPayload","shouldUseSrcEquals_","useSrcEquals","createCmcd_","shaka.util.CmcdManager","shaka.util.Error.Code.NO_VIDEO_ELEMENT","getBufferFullness","bufferedLength","bufferedEnd","lengthToBeBuffered","getAdManager","videoTracks","videoHeight","seekable","getExpiration","playbackRateChanged","activeTracks","currentTextStream","shaka.util.StreamUtils.textStreamToTrack","shaka.util.StreamUtils.html5TextTrackToTrack","image","shaka.util.StreamUtils.imageStreamToTrack","getThumbnails","imageStream","referencePosition","fullImageWidth","fullImageHeight","totalImages","segmentDuration","thumbnailDuration","thumbnailTime","positionX","positionY","thumbnailPosition","sprite","imageHeight","imageWidth","selectTextTrack","selectVariantTrack","shaka.Player.getLanguageAndRolesFrom_","shaka.Player.getLanguagesFrom_","diff","bestVariant","curVariant","languageAndRoleMatch","languageMatch","selectedLanguage","chosenText","selectVariantsByLabel","firstVariantWithLabel","expected","getChapters","inputlanguage","chaptersTracksWithLanguage","chaptersTracks","chapters","uniqueChapters","chaptersTrack","chapter","title","newVisibility","unloadTextStream","getPlayheadTimeAsDate","walkerPayload","getStartDate","startDate","getPresentationStartTimeAsDate","getStats","streamBandwidth","decodedFrames","droppedFrames","corruptedFrames","stallsDetected","gapsJumped","estimatedBandwidth","completionPercent","loadLatency","manifestTimeSeconds","drmTimeSeconds","playTime","pauseTime","bufferingTime","licenseTime","liveLatency","switchHistory","stateHistory","completionRatio","percent","getGapsJumped","getStallsDetected","getVideoPlaybackQuality","totalVideoFrames","droppedVideoFrames","corruptedVideoFrames","licenseSeconds","videoWidth","getCopy","addTextTrackAsync","srcTrack","shaka.util.Error.Code.CONTENT_NOT_LOADED","getServerSideCuePoints","shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS","shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM","addThumbnailsTrack","TextParser","spriteInfo","shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_SRC_EQUALS","shaka.util.Error.Code.UNSUPPORTED_EXTERNAL_THUMBNAILS_URI","shaka.util.Error.Code.CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_LIVE_STREAM","imageUri","shaka.util.ManifestParserUtils.resolveUris","setThumbnailSprite","addChaptersTrack","getChaptersTracks","shaka.util.Error.Code.CHAPTERS_TRACK_FAILED","delaySeconds","getManifest","probeSupport","promptsOkay","plugins","testKeySystems","basicVideoCapabilities","support","testSystem","tests","access","shaka.util.Platform.safariVersion","shaka.media.DrmEngine.probeSupport","testExtensions","testMimeTypes","shaka.util.Platform.supportsMediaType","basicType","shaka.Player.supportPlugins_","isBrowserSupported","MediaKeys","MediaKeySystemAccess","setAdManagerFactory","registerSupportPlugin","Nl","Cm","Qm","shaka.Player.LoadMode","shaka.Player.version","shaka.Deprecate.onPending_","shaka.Deprecate.onExpired_","shaka.Player.restrictedStatuses_","m4v","m4a","webm","weba","mkv","ts","ogv","ogg","mpg","mpeg","m3u8","mpd","mp3","aac","flac","wav","sbv","srt","vtt","webvtt","ttml","lrc","ssa","ass","loadTimes_","skipped_","playedCompletely_","imaAd","imaAdManager","ad_","manager_","isPaused_","volume_","getVolume","google","ima","AdEvent","PAUSED","RESUMED","adContainer","adContainer_","requestAdsStartTime_","setLocale","adDisplayContainer","AdDisplayContainer","initialize","adsLoader_","AdsLoader","getSettings","setPlayerType","setPlayerVersion","imaAdsManager_","AdsManagerLoadedEvent","ADS_MANAGER_LOADED","onAdsManagerLoaded_","shaka.ads.AdManager.ADS_LOADED","getAdsManager","shaka.ads.AdManager.IMA_AD_MANAGER_LOADED","cuePointStarts","getCuePoints","cuePoints","shakaCuePoint","shaka.ads.AdManager.CUEPOINTS_CHANGED","addImaEventListeners_","convertEventAndSend","AdErrorEvent","AD_ERROR","onAdError_","CONTENT_PAUSE_REQUESTED","onAdStart_","STARTED","FIRST_QUARTILE","shaka.ads.AdManager.AD_FIRST_QUARTILE","MIDPOINT","shaka.ads.AdManager.AD_MIDPOINT","THIRD_QUARTILE","shaka.ads.AdManager.AD_THIRD_QUARTILE","COMPLETE","shaka.ads.AdManager.AD_COMPLETE","CONTENT_RESUME_REQUESTED","onAdComplete_","ALL_ADS_COMPLETED","SKIPPED","shaka.ads.AdManager.AD_SKIPPED","VOLUME_CHANGED","shaka.ads.AdManager.AD_VOLUME_CHANGED","VOLUME_MUTED","shaka.ads.AdManager.AD_MUTED","shaka.ads.AdManager.AD_PAUSED","shaka.ads.AdManager.AD_RESUMED","SKIPPABLE_STATE_CHANGED","shaka.ads.AdManager.AD_SKIP_STATE_CHANGED","CLICK","shaka.ads.AdManager.AD_CLICKED","AD_PROGRESS","shaka.ads.AdManager.AD_PROGRESS","AD_BUFFERING","shaka.ads.AdManager.AD_BUFFERING","IMPRESSION","shaka.ads.AdManager.AD_IMPRESSION","DURATION_CHANGE","shaka.ads.AdManager.AD_DURATION_CHANGED","USER_CLOSE","shaka.ads.AdManager.AD_CLOSED","LOADED","shaka.ads.AdManager.AD_LOADED","shaka.ads.AdManager.ALL_ADS_COMPLETED","LINEAR_CHANGED","shaka.ads.AdManager.AD_LINEAR_CHANGED","AD_METADATA","shaka.ads.AdManager.AD_METADATA","LOG","shaka.ads.AdManager.AD_RECOVERABLE_ERROR","AD_BREAK_READY","shaka.ads.AdManager.AD_BREAK_READY","INTERACTION","shaka.ads.AdManager.AD_INTERACTION","offsetWidth","offsetHeight","isFullScreenEnabled_","ViewMode","FULLSCREEN","resize","once","adError","onended","this.video_.onended","contentComplete","getError","fullscreenEnabled","fullscreenElement","webkitSupportsFullscreen","webkitDisplayingFullscreen","getAd","shaka.ads.ClientSideAd","shaka.ads.AdManager.AD_STARTED","isLinear","shaka.ads.AdManager.AD_STOPPED","adProgressData_","streamPromise_","streamRequestStartTime_","isLiveContent_","snapForwardTime_","backupUrl_","currentCuePoints_","uiSettings","dai","api","UiSettings","streamManager_","StreamManager","shaka.ads.AdManager.IMA_STREAM_MANAGER_LOADED","StreamEvent","onLoaded_","getStreamData","checkForSnapback_","streamTimeForContentTime","previousCuePoint","previousCuePointForStreamTime","played","AD_BREAK_STARTED","shaka.ads.ServerSideAd","AD_BREAK_ENDED","onAdBreakEnded_","onAdProgress_","adProgressData","CUEPOINTS_CHANGED","streamData","cuepoints","point","onCuePointsChanged_","ssAdManager_","csAdManager_","shaka.ads.AdsStats","locale_","Cn","thing","Event","simpleEvent","eventKey","eventValue","properties","getOwnPropertyNames","contents","__type__","deserialize","Dn","simulateTimeRanges_","shaka.ads.ClientSideAd.prototype","getMinSuggestedDuration","getRemainingTime","isSkippable","getSkipTimeOffset","skipOffset","canSkipIn","getAdSkippableState","resume","volume","setVolume","isInFullscreen","muted","podInfo","getAdPodInfo","getTotalAds","getPositionInSequence","getAdPosition","getTitle","getDescription","shaka.ads.ClientSideAdManager","shaka.ads.ServerSideAd.prototype","canSkipNow","getTimeUntilSkippable","getSequenceLength","shaka.ads.ServerSideAdManager","onTimedMetadata","shaka.ads.AdManager","shaka.ads.AdManager.prototype","shaka.util.Error.Category.ADS","shaka.util.Error.Code.CS_IMA_SDK_MISSING","loadTime","imaRequest","shaka.util.Error.Code.CS_AD_MANAGER_NOT_INITIALIZED","requestAds","initServerSide","shaka.util.Error.Code.SS_IMA_SDK_MISSING","requestServerSideStream","backupUrl","shaka.util.Error.Code.SS_AD_MANAGER_NOT_INITIALIZED","adTagParameters","adTagParams","shaka.util.Error.Code.CURRENT_DAI_REQUEST_NOT_FINISHED","LiveStreamRequest","requestStream","replaceAdTagParameters","loadTimes","started","playedCompletely","skipped","processMetadata","shaka.cast.CastUtils.VideoAttributes","shaka.cast.CastUtils.VideoInitStateAttributes","shaka.cast.CastUtils.VideoVoidMethods","shaka.cast.CastUtils.PlayerGetterMethods","getAssetUri","getAudioLanguages","getAudioLanguagesAndRoles","getTextLanguages","getTextLanguagesAndRoles","getImageTracks","isAudioOnly","getLoadMode","shaka.cast.CastUtils.LargePlayerGetterMethods","shaka.cast.CastUtils.PlayerGetterMethodsThatRequireLive","shaka.cast.CastUtils.PlayerInitState","shaka.cast.CastUtils.PlayerInitAfterLoadState","shaka.cast.CastUtils.PlayerVoidMethods","shaka.cast.CastUtils.PlayerPromiseMethods","receiverAppId","onStatusChanged","onFirstCastStateUpdate","onRemoteEvent","onResumeLocal","onInitStateRequired","androidReceiverCompatible","receiverAppId_","androidReceiverCompatible_","statusChangeTimer_","onFirstCastStateUpdate_","hasJoinedExistingSession_","onRemoteEvent_","onResumeLocal_","onInitStateRequired_","isCasting_","apiReady_","receiverName_","appData_","onConnectionStatusChangedBound_","this.onConnectionStatusChangedBound_","onConnectionStatusChanged_","onMessageReceivedBound_","this.onMessageReceivedBound_","namespace","serialized","shaka.cast.CastUtils.deserialize","targetName","shaka.util.FakeEvent.fromRealEvent","onMessageReceived_","property","cachedProperties_","asyncCallPromises_","reconstructedError","player","nextAsyncCallId_","castPromise_","shaka.cast.CastSender.instances_add","onSessionInitiated_","initState","shaka.cast.CastSender.session_","addUpdateListener","onSessionCreated_","addMessageListener","shaka.cast.CastUtils.SHAKA_MESSAGE_NAMESPACE","sendMessage_","appData","onConnectionError_","shaka.util.Error.Code.UNEXPECTED_CAST_ERROR","shaka.util.Error.Code.CAST_CANCELED_BY_USER","shaka.util.Error.Code.CAST_CONNECTION_TIMED_OUT","shaka.util.Error.Code.CAST_RECEIVER_APP_UNAVAILABLE","shaka.util.Error.Category.CAST","onExistingSessionJoined_","removeListeners_","removeUpdateListener","removeMessageListener","connected","shaka.cast.CastSender.session_status","rejectAllPromises_","shaka.cast.CastSender.session_receiverfriendlyName","receiver","friendlyName","shaka.cast.CastUtils.serialize","sendMessage","shaka.log.error","forceDisconnect","shaka.cast.CastSender.prototype","shaka.cast.CastSender.instances_delete","chrome","isAvailable","sessionRequest","SessionRequest","apiConfig","ApiConfig","shaka.cast.CastSender.instances_","availability","shaka.cast.CastSender.hasReceivers_","shaka.cast.CastSender.STATUS_DELAY","oldSession","SessionStatus","STOPPED","__onGCastApiAvailable","shaka.cast.CastSender.onGCastApiAvailable_","shaka.cast.CastSender.__onGCastApiAvailable_","shaka.util.Error.Code.CAST_API_UNAVAILABLE","shaka.util.Error.Code.NO_CAST_RECEIVERS","shaka.util.Error.Code.ALREADY_CASTING","requestSession","shaka.cast.CastSender.session_stop","shaka.cast.CastUtils.VideoVoidMethodsincludes","remoteCall_","shaka.cast.CastUtils.PlayerVoidMethodsincludes","shaka.cast.CastUtils.PlayerPromiseMethodsincludes","remoteAsyncCall_","propertyGetter_","methodName","$jscomp.getRestArgumentsapply","$n","available","localVideo_","localPlayer_","playerEventTarget_","videoEventTarget_","playerProxy_","videoProxy_","compiledToExternNames_","sender_","shaka.cast.CastSender","onCastStatusChanged_","getInitState_","shaka.cast.CastUtils.VideoEvents","videoProxyLocalEvent_","isCasting","playerProxyLocalEvent_","videoProxyGet_","videoProxySet_","iterateOverPlayerMethods_","playerProxyGet_","getNetworkingEngine","setVideoContainer","mapCompiledToUncompiledPlayerMethodNames_","methodsToNames","name2","shouldAddToTheMap","seenNames","proto","getPrototypeOf","objProto","playerAfterLoad","pair","setter","manifestReady","videoState","appDataCallback","contentIdCallback","player_","targets_","appDataCallback_","contentIdCallback_","metadata_","isConnected_","isIdle_","updateNumber_","startUpdatingUpdateNumber_","initialStatusUpdatePending_","genericBus_","shakaBus_","pollTimer_","pollAttributes_","CastReceiverManager","getInstance","onSenderConnected","manager.onSenderConnected","onSendersChanged_","onSenderDisconnected","manager.onSenderDisconnected","onSystemVolumeChanged","manager.onSystemVolumeChanged","systemVolume","getSystemVolume","fakeVolumeChangeEvent_","getCastMessageBus","shaka.cast.CastUtils.GENERIC_MESSAGE_NAMESPACE","onMessage","this.genericBus_.onMessage","onGenericMessage_","sendMediaStatus_","resumeState","unload","sendMediaInfoMessage_","volumeObject","oldVolumeLevel","oldVolumeMuted","mediaInfo","requestId","this.shakaBus_.onMessage","onShakaMessage_","initState_","setSystemVolumeLevel","setSystemVolumeMuted","senderId","sendAsyncComplete_","proxyEvent_","canDisplayType","setMaxHardwareResolution","shaka.cast.CastReceiver.IDLE_INTERVAL","getSenders","maybeSendMediaInfoMessage_","shaka.cast.CastReceiver.POLL_INTERVAL","streamType","bus","getCastChannel","send","broadcast","mediaStatus","mediaSessionId","playerState","getPlayState_","shaka.cast.CastReceiver.PLAY_STATE.IDLE","shaka.cast.CastReceiver.PLAY_STATE.BUFFERING","shaka.cast.CastReceiver.PLAY_STATE.PAUSED","shaka.cast.CastReceiver.PLAY_STATE.PLAYING","supportedMediaCommands","shaka.cast.CastProxy","waitFor","shaka.cast.CastProxy.prototype","receiverName","setAppData","showDisconnectDialog","changeReceiverId","newAppId","newCastAndroidReceiver","shaka.cast.CastReceiver","isConnected","shaka.cast.CastReceiver.prototype","setContentTitle","MetadataType","GENERIC","imageUrl","artist","MUSIC_TRACK","IDLE","PLAYING","BUFFERING","parseFromAdaptationSet","Lo","elems","parsed","parseElements_","shaka.dash.ContentProtection.parseElement_","shaka.dash.ContentProtection.parseElements_","defaultInit","parsedNonCenc","shaka.util.Error.Code.DASH_CONFLICTING_KEY_IDS","shaka.dash.ContentProtection.MP4Protection_","schemeUri","convertElements_","elements","proNode","shaka.util.XmlUtils.findChildNS","shaka.util.Pssh.createPssh","psshVersion","clearKeyInitData","shaka.dash.ContentProtection.ClearKeySchemeUri_","shaka.util.ManifestParserUtils.createDrmInfo","proInitData","licenseParser","shaka.dash.ContentProtection.licenseUrlParsers_get","shaka.dash.ContentProtection.convertElements_","defaultKeyId","firstRepresentation","getPlayReadyLicenseUrl","Ro","record","parseMsPro_","records","recordValue","shaka.dash.ContentProtection.parseMsPro_","shaka.dash.ContentProtection.PLAYREADY_RECORD_TYPES.RIGHTS_MANAGEMENT","rootElement","getLaurl_","shaka.dash.ContentProtection.getLaurl_","parseElement_","Uo","shaka.util.XmlUtils.getAttributeNS","shaka.dash.ContentProtection.CencNamespaceUri_","psshs","shaka.util.XmlUtils.getContents","shaka.util.Error.Code.DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED","shaka.util.Error.Code.DASH_PSSH_BAD_ENCODING","RIGHTS_MANAGEMENT","shaka.dash.ContentProtection.licenseUrlParsers_","getWidevineLicenseUrl","mslaurlNode","shaka.dash.ContentProtection.getPlayReadyLicenseUrl","getClearKeyLicenseUrl","clearKeyLaurlNode","shaka.dash.ContentProtection.ClearKeyNamespaceUri_","fillUriTemplate","Vo","uriTemplate","representationId","valueTable","RepresentationID","Bandwidth","Time","widthStr","valueString","parseSegmentInfo","Wo","timescaleStr","shaka.dash.MpdUtils.inheritAttribute","shaka.util.XmlUtils.parsePositiveInt","durationStr","representation","shaka.util.XmlUtils.parseFloat","startNumberStr","unscaledPresentationTimeOffset","startNumber","shaka.util.XmlUtils.parseNonNegativeInt","timelineNode","shaka.dash.MpdUtils.inheritChild","periodInfo","timePoints","lastEndTime","timePoint","shaka.util.XmlUtils.parseAttr","shaka.util.XmlUtils.parseInt","nextStartTime","periodDuration","unscaledStart","scaledPresentationTimeOffset","inheritAttribute","Xo","period","shaka.util.Functional.isNotNull","inheritChild","Yo","shaka.util.XmlUtils.findChild","processXlinks","$o","failGracefully","baseUri","linkDepth","shaka.dash.MpdUtils.XlinkNamespaceUri_","handleXlinkInElement_","xlinkActuate","removeAttributeNS","shaka.util.Error.Code.DASH_XLINK_DEPTH_LIMIT","shaka.util.Error.Code.DASH_UNSUPPORTED_XLINK_ACTUATE","shaka.util.XmlUtils.parseXml","shaka.util.Error.Code.DASH_INVALID_XML","setAttributeNode","cloneNode","shaka.dash.MpdUtils.processXlinks","shaka.dash.MpdUtils.handleXlinkInElement_","childOperations","resolveToZeroString","ap","sidxData","sidxOffset","parseSIDX_","shaka.util.Error.Code.MP4_SIDX_INVALID_TIMESCALE","earliestPresentationTime","referenceCount","firstOffset","chunk","referenceType","subsegmentDuration","shaka.util.Error.Code.MP4_SIDX_TYPE_NOT_SUPPORTED","unscaledStartTime","referenceSize","shaka.media.Mp4SegmentIndexParser.parseSIDX_","shaka.util.Error.Code.MP4_SIDX_WRONG_BOX_TYPE","reader_","dp","parseElement","vint","parseVint_","parseId_","shaka.util.Error.Code.EBML_OVERFLOW","shaka.util.EbmlParser.DYNAMIC_SIZES","elementSize","shaka.util.EbmlElement","firstByte","log2","shaka.util.EbmlParser","getUint","parseCuePoint_","jp","cuePointElement","shaka.media.WebmSegmentIndexParser.CUE_TIME_ID","cueTimeElement","shaka.util.Error.Code.WEBM_CUE_TIME_ELEMENT_MISSING","unscaledTime","shaka.media.WebmSegmentIndexParser.CUE_TRACK_POSITIONS_ID","cueTrackPositionsElement","shaka.util.Error.Code.WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING","cueTrackParser","relativeOffset","shaka.media.WebmSegmentIndexParser.CUE_CLUSTER_POSITION","createInitSegment","kp","initialization","resolvedUris","shaka.util.XmlUtils.parseRange","shaka.dash.SegmentBase.createQualityInfo","createStreamInfo","mp","requestInitSegment","shaka.dash.SegmentBase.fromInheritance_","shaka.dash.SegmentBase.createInitSegment","checkSegmentIndexRangeSupport_","shaka.dash.SegmentBase.checkSegmentIndexSupport","shaka.dash.SegmentBase.computeIndexRange_","shaka.util.Error.Code.DASH_NO_SEGMENT_INFO","shaka.dash.SegmentBase.checkSegmentIndexRangeSupport_","shallowCopyOfContext","shaka.util.ObjectUtils.shallowCloneObject","generateSegmentIndex","representationIndex","indexUris","representationUri","indexRange","shaka.dash.SegmentBase.generateSegmentIndexFromUris","generateSegmentIndexFromUris","fitLast","containerType","localRequest","responses","indexData","dynamic","isLastPeriod","shaka.media.WebmSegmentIndexParser.EBML_ID","shaka.util.Error.Code.WEBM_EBML_HEADER_ELEMENT_MISSING","segmentElement","shaka.media.WebmSegmentIndexParser.SEGMENT_ID","shaka.util.Error.Code.WEBM_SEGMENT_ELEMENT_MISSING","segmentOffset","infoElement","shaka.media.WebmSegmentIndexParser.INFO_ID","shaka.util.Error.Code.WEBM_INFO_ELEMENT_MISSING","timecodeScaleNanoseconds","durationScale","shaka.media.WebmSegmentIndexParser.TIMECODE_SCALE_ID","shaka.media.WebmSegmentIndexParser.DURATION_ID","getFloat32","shaka.util.Error.Code.EBML_BAD_FLOATING_POINT_SIZE","getFloat64","shaka.util.Error.Code.WEBM_DURATION_ELEMENT_MISSING","timecodeScale","shaka.media.WebmSegmentIndexParser.CUES_ID","cuesElement","cuesData","shaka.util.Error.Code.WEBM_CUES_ELEMENT_MISSING","parseCues_","lastTime","lastOffset","shaka.media.WebmSegmentIndexParser.CUE_POINT_ID","tuple","shaka.media.WebmSegmentIndexParser.parseCuePoint_","currentOffset","shaka.media.WebmSegmentIndexParser.parseCues_","fromInheritance_","np","segmentBase","computeIndexRange_","pp","indexRangeElem","checkSegmentIndexSupport","rp","shaka.util.Error.Code.DASH_UNSUPPORTED_CONTAINER","shaka.util.Error.Code.DASH_WEBM_MISSING_INIT","createQualityInfo","lp","numChannels","sp","streamMap","shaka.dash.SegmentList.fromInheritance_","parseSegmentListInfo_","mediaSegments","parseMediaSegments_","segmentList","urlNode","indexRangeWarningGiven","mediaUri","shaka.dash.SegmentList.parseMediaSegments_","shaka.dash.MpdUtils.parseSegmentInfo","shaka.dash.SegmentList.parseSegmentListInfo_","createSegmentReferences_","prevEndTime","shaka.dash.SegmentList.createSegmentReferences_","getSegmentAvailabilityStart","tp","xp","isUpdate","segmentLimit","periodDurationMap","createInitSegment_","shaka.dash.SegmentTemplate.fromInheritance_","repId","filledTemplate","shaka.dash.MpdUtils.fillUriTemplate","shaka.dash.SegmentTemplate.createInitSegment_","parseSegmentTemplateInfo_","mediaTemplate","indexTemplate","shaka.dash.SegmentTemplate.parseSegmentTemplateInfo_","checkSegmentTemplateInfo_","shaka.dash.SegmentTemplate.checkSegmentTemplateInfo_","notifyMaxSegmentDuration","generateSegmentIndexFromDuration_","createReference","segmentPeriodTime","segmentMediaTime","trueSegmentEnd","getPeriodEnd","computeAvailablePositionRange","availablePeriodTimes","availablePresentationTimes","availablePeriodPositions","periodId","initialPeriodDuration","minPosition","maxPosition","willNeedToAddReferences","willNeedToEvictReferences","nextPosition","availabilityStartTime","shaka.dash.SegmentTemplate.generateSegmentIndexFromDuration_","createFromTimeline_","segmentReplacement","timeReplacement","createUris","shaka.dash.SegmentTemplate.createFromTimeline_","periodEnd","shouldFit","Dp","segmentTemplate","audioStreams_","videoStreams_","textStreams_","imageStreams_","usedPeriodIds_","Fp","combinePeriods","periods","isDynamic","firstPeriod","firstNewPeriodIndex","audioStreamsPerPeriod","videoStreamsPerPeriod","textStreamsPerPeriod","imageStreamsPerPeriod","nextVariantId","commonDrmInfos","filterOutAudioStreamDuplicates_","filteredAudios","audioStreams","a1","duplicate","a2","shaka.util.ArrayUtils.hasSameElements","shaka.util.PeriodCombiner.filterOutAudioStreamDuplicates_","filterOutVideoStreamDuplicates_","filteredVideos","videoStreams","shaka.util.MapUtils.hasSameElements","shaka.util.PeriodCombiner.filterOutVideoStreamDuplicates_","filterOutTextStreamDuplicates_","filteredTexts","t1","t2","shaka.util.PeriodCombiner.filterOutTextStreamDuplicates_","filterOutImageStreamDuplicates_","filteredImages","i1","i2","shaka.util.PeriodCombiner.filterOutImageStreamDuplicates_","shaka.util.PeriodCombiner.dummyStream_","shaka.util.PeriodCombiner.combine_","shaka.util.PeriodCombiner.cloneStream_","shaka.util.PeriodCombiner.concatenateStreams_","shaka.media.DrmEngine.getCommonDrmInfos","combineDbStreams","streamDbsPerPeriod","audioStreamDbsPerPeriod","videoStreamDbsPerPeriod","textStreamDbsPerPeriod","imageStreamDbsPerPeriod","combinedAudioStreamDbs","combinedVideoStreamDbs","combinedTextStreamDbs","combinedImageStreamDbs","combinedStreamDbs","shaka.util.PeriodCombiner.dummyStreamDB_","shaka.util.PeriodCombiner.cloneStreamDB_","shaka.util.PeriodCombiner.concatenateStreamDBs_","variantIds","combine_","outputStreams","streamsPerPeriod","unusedStreamsPerPeriod","unusedStreams","outputStream","isDummyText","isDummyImage","extendExistingOutputStream_","shaka.util.PeriodCombiner.findMatchesInAllPeriods_","matchedStreams","shaka.util.PeriodCombiner.extendOutputSegmentIndex_","shaka.util.PeriodCombiner.extendOutputStream_","shaka.util.PeriodCombiner.extendExistingOutputStream_","shaka.util.Error.Code.PERIOD_FLATTENING_FAILED","shaka.util.PeriodCombiner.createNewOutputStream_","extendOutputSegmentIndex_","createNewOutputStream_","Tp","outputStream.createSegmentIndex","extendOutputStream_","Wp","used","cloneStream_","Mp","clone.createSegmentIndex","clone.closeSegmentIndex","cloneStreamDB_","Qp","streamDb","concatenateStreams_","Np","combineSets","shaka.util.Error.Code.INCONSISTENT_DRM_ACROSS_PERIODS","output.trickModeVideo.createSegmentIndex","concatenateStreamDBs_","Rp","findMatchesInAllPeriods_","areCompatible","shaka.util.PeriodCombiner.areAVStreamsCompatible_","shaka.util.PeriodCombiner.areTextStreamsCompatible_","shaka.util.PeriodCombiner.areImageStreamsCompatible_","isBetterMatch","shaka.util.PeriodCombiner.isAudioStreamBetterMatch_","shaka.util.PeriodCombiner.isVideoStreamBetterMatch_","shaka.util.PeriodCombiner.isTextStreamBetterMatch_","shaka.util.PeriodCombiner.isImageStreamBetterMatch_","best","areAVStreamsCompatible_","Xp","areTextStreamsCompatible_","Yp","areImageStreamsCompatible_","Zp","isAudioStreamBetterMatch_","$p","bestRelatedness","candidateRelatedness","bestRoleMatches","candidateRoleMatches","shaka.util.PeriodCombiner.compareClosestPreferLower","shaka.util.PeriodCombiner.BetterOrWorse.BETTER","channelsBetterOrWorse","shaka.util.PeriodCombiner.BetterOrWorse.WORSE","sampleRateBetterOrWorse","shaka.util.PeriodCombiner.compareClosestPreferMinimalAbsDiff_","isVideoStreamBetterMatch_","aq","resolutionBetterOrWorse","frameRateBetterOrWorse","isTextStreamBetterMatch_","bq","isImageStreamBetterMatch_","cq","dummyStreamDB_","Pp","dummyStream_","Kp","compareClosestPreferLower","dq","outputValue","bestValue","candidateValue","shaka.util.PeriodCombiner.BetterOrWorse.EQUAL","compareClosestPreferMinimalAbsDiff_","gq","absDiffBest","absDiffCandidate","shaka.util.PeriodCombiner","BETTER","EQUAL","WORSE","manifestUris_","globalId_","streamMap_","periodDurations_","periodCombiner_","updatePeriod_","averageUpdateDuration_","updateTimer_","updateDelay","requestManifest_","setUpdateTimer_","largestPeriodStartTime_","lastManifestUpdatePeriodIds_","minTotalAvailabilityTimeOffset_","lowLatencyMode_","kq","parseManifest_","finalManifestUri","xlinkOperation","finalMpd","processManifest_","manifestBaseUris","locations","absoluteLocations","uriObjs","availabilityTimeOffset","suggestedPresentationDelay","mpdType","profiles","periodsAndDuration","timingElements","shaka.util.XmlUtils.parseDuration","shaka.util.XmlUtils.parseDate","setStatic","setSegmentAvailabilityDuration","parsePeriods_","presentationDuration","prevEnd","periodNodes","givenDuration","nextStart","parsePeriod_","durationDerivedFromPeriods","setAvailabilityTimeOffset","usingPresentationStartTime","parseUtcTiming_","schemesAndValues","sv","requestForTiming_","setClockOffset","lockStartTime","createFrame_","eventStreamNodes","availabilityStart","parseEventStream_","adaptationSets","parseAdaptationSet_","getVideoRangeFromTransferCharacteristicCICP","cicp","videoRange","main","roleElements","roleValues","SUBTITLE","roleElement","essentialProperties","trickModeFor","unrecognizedEssentialProperty","videoRangeScheme","supplementalProperties","accessibilities","channelId","channelAssignments","captionStr","channel","channelAndLanguage","serviceAndLanguage","contentProtectionElems","contentProtection","shaka.dash.ContentProtection.parseFromAdaptationSet","labelElements","firstLabelElement","representations","parsedRepresentation","parseRepresentation_","verifyRepresentation_","isImage","requestInitSegment_","shaka.dash.SegmentBase.createStreamInfo","streamInfo","shaka.dash.SegmentList.createStreamInfo","shaka.dash.SegmentTemplate.createStreamInfo","parseFromRepresentation","repContext","asUnknown","repUnencrypted","asInfo","repInfo","shaka.util.Error.Code.DASH_NO_COMMON_KEY_SYSTEM","shaka.dash.ContentProtection.parseFromRepresentation","expectedUri","expectedValue","thumbnailTileElem","expectedUris","hevcHDR","contextId","currentStream","shaka.util.Error.Code.DASH_EMPTY_ADAPTATION_SET","shaka.dash.DashParser.guessContentType_","repIds","representationIds","uniqueIds","shaka.util.Error.Code.DASH_DUPLICATE_REPRESENTATION_ID","normalAdaptationSets","as","trickModeAdaptationSets","targetIds","trickModeSet","normalSet","trickStream","audioSets","getSetsOfType_","videoSets","textSets","imageSets","shaka.util.Error.Code.DASH_EMPTY_PERIOD","shaka.dash.DashParser.MIN_UPDATE_PERIOD_","parent","shaka.util.XmlUtils.evalDivision","schemeIdUris","inBandEventStreams","parseAudioChannels_","audioChannelConfigs","intValue","hexValue","numBits","channelCountMapping","noValue","segmentBaseAto","segmentTemplateAto","baseUriAto","requestUris","shaka.net.NetworkingEngine.RequestType.TIMING","eventNode","guessContentType_","wq","tags","getAttributeValue","getRequiredAttrValue","shaka.util.Error.Code.HLS_REQUIRED_ATTRIBUTE_MISSING","partialSegments","filterTagsByName","Gq","filterTagsByType","Hq","tagType","getFirstTagWithName","Iq","tagsWithName","shaka.hls.Utils.filterTagsByName","getFirstTagWithNameAsNumber","Jq","shaka.hls.Utils.getFirstTagWithName","constructAbsoluteUri","Kq","parentAbsoluteUri","data_","skipWhitespace","readRegex","regex","lastIndex","indexOf_","atEnd","readRegexReturnCapture_","parsePlaylist","absolutePlaylistUri","lines","shaka.util.Error.Code.HLS_PLAYLIST_HEADER_MISSING","playlistType","MASTER","parseTag_","MEDIA","shaka.hls.ManifestTextParser.SEGMENT_TAGSincludes","shaka.util.Error.Code.HLS_INVALID_PLAYLIST_HIERARCHY","segmentsData","segmentTags","partialSegmentTags","currentMapTag","shaka.hls.ManifestTextParser.MEDIA_PLAYLIST_TAGSincludes","absoluteSegmentUri","shaka.hls.Utils.constructAbsoluteUri","absoluteMediaPlaylistUri","shaka.hls.Segment","shaka.hls.Playlist","tagUri","shaka.hls.Attribute","word","blocks","shaka.util.Error.Code.INVALID_HLS_TAG","blockAttrs","blockValue","shaka.util.TextParser","valueRegex","attributeRegex","shaka.hls.Tag","shaka.dash.DashParser.prototype","shaka.dash.DashParser","tagStr","appendages","attrToStr","shaka.hls.ManifestTextParser.SEGMENT_TAGS","Vq","shaka.net.DataUriPlugin.parseRaw","originalUri","parseRaw","Wq","shaka.util.Error.Code.MALFORMED_DATA_URI","infoAndData","dataStr","typeInfoList","base64Encoded","globalVariables_","groupIdToStreamInfosMap_","mediaSequenceToStartTimeByType_","variantUriSet_","uriToStreamInfosMap_","presentationTimeline_","masterPlaylistUri_","manifestTextParser_","shaka.hls.ManifestTextParser","updatePlaylistDelay_","minSequenceNumber_","lowestSyncTime_","streamsFinalized_","updatePlaylistTimer_","isLive_","presentationType_","shaka.hls.HlsParser.PresentationType_.VOD","maxTargetDuration_","minTargetDuration_","lowLatencyPresentationDelay_","partialTargetDuration_","groupIdToClosedCaptionsMap_","groupIdToCodecsMap_","mapTagToInitSegmentRefMap_","gr","getMediaSequenceToStartTimeFor_","mediaSequenceToStartTime","updateStream_","manifestUri","playlist","variablesTags","mediaVariables","mediaSequenceNumber","playlistStartTime","newestSegment","canSkipSegments","parseMediaVariables_","parseDrmInfo_","keysAreEqual","createSegments_","shaka.hls.Utils.getFirstTagWithNameAsNumber","hasEndList","maxTimestamp","offsetStreamInfo_","determineDuration_","shaka.hls.HlsParser.PresentationType_.LIVE","getMinDuration_","variableTag","mediaImport","globalValue","getCodecsForVariantTag_","defaultCodecsArray","codecsString","seen","shortCodec","getLanguage_","languageValue","createStreamInfoFromMediaTag_","groupId","verbatimMediaPlaylistUri","variableSubstitution_","defaultAttrValue","createStreamInfo_","forcedAttrValue","characteristics","downloadSegmentIndex","abortSignal","wasLive","realStreamInfo","realStream","otherStreamInfo","streamInfos","activeStreamInfos","convertParsedPlaylistIntoStreamInfo_","changePresentationTimelineToLive_","loadedOnce","hasEnoughInfoToFinalizeStreams_","videos","audios","finalizeStreams_","initialMediaPlaylistUri","makeStreamObject_","firstSequenceNumber","creationPromise","abortController","AbortController","safeCreateSegmentIndex","signal","stream.closeSegmentIndex","minDuration","notifySegmentsForStreams_","syncStreamsWithSequenceNumber_","updateMinSequenceNumber","segment0","segmentN","streamOffset","syncStreamsWithProgramDateTime_","aesEncrypted","prevLowLatencyMode","serverControlTag","determinePresentationType_","guessMimeType_","variables","middleSegmentIdx","middleSegmentUri","parsedUri","headRequest","contentMimeType","trunc","shaka.hls.HlsParser.EXTENSION_MAP_BY_CONTENT_TYPE_","shaka.hls.HlsParser.RAW_FORMATS_TO_MIME_TYPES_","guessMimeTypeBeforeLoading_","makeNetworkRequest_","guessMimeTypeFallback_","shaka.util.Error.Code.HLS_KEYFORMATS_NOT_SUPPORTED","drmTags","segmentKeyTags","drmTag","keyFormat","drmParser","shaka.hls.HlsParser.KEYFORMATS_TO_DRM_PARSERS_","parseAES128DrmTag_","shaka.util.Error.Code.NO_WEB_CRYPTO_API","ivHex","shaka.util.Error.Code.HLS_AES_128_INVALID_IV_LENGTH","keyUri","keyInfo","keyInfo.fetchKey","keyResponse","algorithm","shaka.net.NetworkingEngine.RequestType.KEY","shaka.util.Error.Code.HLS_AES_128_INVALID_KEY_LENGTH","importKey","presentationTypeTag","endListTag","isVod","isEvent","setPresentationType_","shaka.hls.HlsParser.PresentationType_.EVENT","shaka.util.Error.Code.HLS_REQUIRED_TAG_MISSING","targetDuration","partialTargetDurationTag","setPresentationStartTime","setDelay","getInitSegmentReference_","playlistUri","mapTag","mapTagKey","absoluteInitSegmentUri","initSegmentRef","createInitSegmentReference_","byterange","createSegmentReference_","previousReference","hlsSegment","extinfTag","dateTimeTag","partialSegmentRefs","pAbsoluteUri","pPreviousReference","pStartTime","pDuration","pEndTime","pStartByte","pEndByte","pByterangeStart","parseByteRange_","pByterange","pUri","partialStatus","byterangeTag","tilesTag","hlsSegments","skipTag","skippedSegments","someSyncTime","forwardI","forwardAdd","backwardI","backwardAdd","lookForward","lookBackward","uriVariables","newUri","variableName","variable","replaceValue","shaka.util.Error.Code.HLS_VARIABLE_NOT_FOUND","shaka.net.DataUriPlugin","shaka.net.DataUriPlugin.parse","shaka.hls.HlsParser.prototype","mediaTags","variantTags","imageTags","sessionKeyTags","sesionDataTags","parseMasterVariables_","shaka.hls.HlsParser.AUDIO_EXTENSIONS_TO_MIME_TYPES_","shaka.hls.HlsParser.VIDEO_EXTENSIONS_TO_MIME_TYPES_","variantTag","audioGroupId","videoGroupId","subGroupId","parseCodecs_","textCodecs","createStreamInfosFromMediaTags_","closedCaptionsTags","shaka.hls.Utils.filterTagsByType","instreamId","parseClosedCaptions_","createVariantsForTags_","resolution","createStreamInfosForVariantTag_","ignoreStream","streamURI","hasSameUri","createStreamInfoFromVariantTag_","closedCaptionsAttr","getClosedCaptions_","createVariants_","audioInfos","videoInfos","audioInfo","videoInfo","videoStream","audioDrmInfos","videoDrmInfos","variantUriKey","parseTexts_","subtitleTags","textStreamInfos","textStreamInfo","parseImages_","imageStreamPromises","createStreamInfoFromImageTag_","verbatimImagePlaylistUri","stillLive","maxTimestamps","shaka.hls.HlsParser.PresentationType_","ac3","ec3","mp4a","m4s","m4i","m4f","cmfa","mp4v","cmfv","shaka.hls.HlsParser.TEXT_EXTENSIONS_TO_MIME_TYPES_","cmft","shaka.hls.HlsParser.IMAGE_EXTENSIONS_TO_MIME_TYPES_","jpg","png","svg","webp","avif","fairplayDrmParser_","shaka.util.Error.Code.HLS_MSE_ENCRYPTED_MP2T_NOT_SUPPORTED","shakaMediaKeysPolyfill","shaka.util.Error.Code.HLS_MSE_ENCRYPTED_LEGACY_APPLE_MEDIA_KEYS_NOT_SUPPORTED","widevineDrmParser_","VALID_METHODS","parsedData","playreadyDrmParser_","identity","identityDrmParser_","EVENT","Zq","Rr","Ar","makeResponse","Xr","responseURL","Zr","shaka.net.HttpFetchPlugin.Headers_","controller","shaka.net.HttpFetchPlugin.AbortController_","abortStatus","canceled","timedOut","request_","fetch","arrayBuffer","lastLoaded","contentLengthRaw","contentLength","shaka.net.HttpFetchPlugin.fetch_","shaka.net.HttpFetchPlugin.ReadableStream_","shaka.net.HttpFetchPlugin.headersToGenericObject_","getReader","readObj","read","enqueue","shaka.net.HttpPluginUtils.makeResponse","shaka.net.HttpFetchPlugin.request_","credentials","timeoutMs","headersToGenericObject_","es","headersObj","isSupported","fs","shaka.util.Platform.isWebOS3","shaka.hls.HlsParser","shaka.net.HttpFetchPlugin","shaka.net.HttpFetchPlugin.isSupported","shaka.net.HttpFetchPlugin.parse","Headers","hs","xhr","shaka.net.HttpXHRPlugin.Xhr_","open","responseType","withCredentials","onabort","xhr.onabort","calledHeadersReceived","onreadystatechange","xhr.onreadystatechange","shaka.net.HttpXHRPlugin.headersToGenericObject_","xhr.onload","xhrResponse","xhr.onerror","ontimeout","xhr.ontimeout","onprogress","xhr.onprogress","lengthComputable","setRequestHeader","js","headerLines","getAllResponseHeaders","shaka.net.NetworkingEngine.PluginPriority.PREFERRED","shaka.net.HttpXHRPlugin","shaka.net.HttpXHRPlugin.parse","XMLHttpRequest","estimateId","isInitSegment","idForSegmentRef","ls","makeSegmentRequest","actualDownloaded_","estimatedDownloaded_","estimatedTotal_","pending_","nextId_","groups_","abortAll","abortCallbacks_","onProgress_","this.onProgress_","onInitData_","this.onInitData_","estimator_","shaka.offline.DownloadProgressEstimator","promises","onDownloaded","segmentBytes","fetchSegment_","abortCallback","shaka.util.Error.Category.STORAGE","transaction","storeName","transaction_","store_","objectStore","promise_","transaction.onabort","transaction.onerror","oncomplete","transaction.oncomplete","ws","forEachEntry","req","openCursor","onsuccess","req.onsuccess","cursor","continue","connection_","startReadWriteOperation","store","shaka.offline.indexeddb.DBOperation","stopTracking_","segmentStore","manifestStore","shaka.offline.indexeddb.DBConnection","segmentStore_","manifestStore_","Bs","shaka.util.Error.Code.NEW_KEY_OPERATION_NOT_SUPPORTED","Cs","onRemove","get_","missing","request.onsuccess","shaka.util.Error.Code.KEY_NOT_FOUND","mechanisms_","Is","getActive","handle","mechanism","mechanismName","getCells","cell","cellName","hasFixedKeySpace","shaka.util.Error.Code.MISSING_STORAGE_CELL","getCell","register","Os","shaka.offline.StorageMuxer.registry_set","shaka.net.NetworkingEngine.PluginPriority.FALLBACK","actual","shaka.offline.DownloadManager","shaka.offline.indexeddb.BaseStorageCell.prototype","rejectAdd","rawSegments","convertSegmentData","updateManifest","shaka.util.Error.Code.MODIFY_OPERATION_NOT_SUPPORTED","newExpiration","put","getManifests","rawManifests","convertManifest","old","shaka.offline.indexeddb.EmeSessionStorageCell","shaka.offline.indexeddb.StorageMechanism.SESSION_ID_STORE","sessionIds","shaka.offline.StorageMuxer","destroys","shaka.offline.StorageMuxer.registry_","mech","initPromises","unregister","shaka.offline.StorageMuxer.registry_delete","shaka.offline.StorageMuxer.register","shaka.offline.indexeddb.BaseStorageCellapply","Qs","fillMissingVariants_","nextId","variantId","shaka.offline.indexeddb.V1StorageCell.fillMissingVariants_","convertStream_","initSegmentKey","initSegmentUri","shaka.offline.indexeddb.V1StorageCell.getKeyFromSegmentUri_","presentationTimeOffset","dataKey","shaka.offline.indexeddb.V1StorageCell.convertStream_","getKeyFromSegmentUri_","Ts","shaka.util.Error.Code.MALFORMED_OFFLINE_URI","Vs","sessions_","v5_","v3_","v2_","v1_","db_","mechanism_","cell_","key_","asString_","$s","shaka.offline.OfflineUri","fromManifestDB","manifestDB","streamDB","createVariants","variantMap","fromStreamDB_","fromSegmentDB_","segmentDB","fromInitSegmentDB_","uri_","it","offlineUri","shaka.offline.OfflineUri.parse","getSegment_","muxer","getSegments","deleted","bucket","shaka.offline.SessionDeleter.isCompatible_","doDelete_","drmEngine","initForRemoval","licenseUri","removeSession","tasks","isCompatible_","lt","comp","pt","converter","shaka.offline.ManifestConverter","appMetadata","shaka.offline.StoredContentUtils.getTracks_","originalManifestUri","isIncomplete","getTracks_","getPlayableVariants","shaka.util.StreamUtils.getPlayableVariants","estimateByStreamId_","addVariant","setBitrate_","audioBitRate","shaka.offline.StreamBandwidthEstimator.DEFAULT_AUDIO_BITRATE_","videoBitRate","addImage","shaka.offline.StreamBandwidthEstimator.DEFAULT_IMAGE_BITRATE_","getEstimate_","bitRate","shaka.util.Error.Code.LOCAL_PLAYER_INSTANCE_REQUIRED","openOperations_","openDownloadManagers_","destroyNetworkingEngine","awaits","vt","cleanStoredManifest","manifestId","activeHandle","shaka.offline.Storage","assignSegmentsToManifest","manifestUpdates","dataSizeUpdate","throwIfAbortedFn","manifestUpdated","complete","dataKeys","pendingSegmentRefId","pendingInitSegmentRefId","shaka.offline.Storage.cleanStoredManifest","removeSegments","getManifestIsEncrypted_","audioEncrypted","getManifestIncludesInitData_","getCapabilities_","Rt","manifestDb","removeFromDRM_","deleteLicenseFor_","net","drmConfig","sessionIdCell","deletedSessionIds","getEmeSessionCell","mechanisms","shaka.util.Error.Code.STORAGE_NOT_SUPPORTED","shaka.offline.Storage.getCapabilities_","shaka.offline.Storage.deleteLicenseFor_","removeFromStorage_","segmentIds","getAllSegmentIds_","shaka.offline.Storage.getAllSegmentIds_","shaka.offline.StoredContentUtils.fromManifestDB","removeManifests","createStream_","downloader","estimator","toDownload","forEachSegment_","shaka.offline.Storage.forEachSegment_","shaka.offline.DownloadInfo.idForSegmentRef","estimatedByteLength","segmentDownload","shaka.offline.DownloadInfo","initDownload","ensureNotDestroyed_","requireSupport_","shaka.offline.Storage.support","getAllStreamsFromManifest_","Wt","shaka.offline.indexeddb.V1StorageCell","BaseStorageCell","shaka.offline.indexeddb.V1StorageCell.convertPeriod_","shaka.util.PeriodCombiner.combineDbStreams","creationTime","shaka.offline.indexeddb.V2StorageCell","shaka.offline.indexeddb.V5StorageCell","shaka.offline.indexeddb.V5StorageCell.prototype","manifests","updateManifestImplementation","timeOutTimer","shaka.util.Error.Code.INDEXED_DB_INIT_TIMED_OUT","indexedDB","shaka.offline.indexeddb.StorageMechanism.DB_NAME","shaka.offline.indexeddb.StorageMechanism.VERSION","open.onsuccess","objectStoreNames","shaka.offline.indexeddb.StorageMechanism.V1_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V1_SEGMENT_STORE","shaka.offline.indexeddb.StorageMechanism.V2_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V2_SEGMENT_STORE","shaka.offline.indexeddb.StorageMechanism.V3_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V3_SEGMENT_STORE","shaka.offline.indexeddb.StorageMechanism.V5_MANIFEST_STORE","shaka.offline.indexeddb.StorageMechanism.V5_SEGMENT_STORE","onupgradeneeded","open.onupgradeneeded","storeNames","createObjectStore","autoIncrement","open.onerror","shaka.util.Error.Code.INDEXED_DB_ERROR","shaka.offline.indexeddb.StorageMechanism.prototype","erase","del","deleteDatabase","onblocked","del.onblocked","del.onsuccess","del.onerror","shaka.offline.indexeddb.StorageMechanism.deleteAll_","shaka.offline.indexeddb.StorageMechanism","shaka.offline.OfflineManifestParser.prototype","finalManifest","foundSession","updateManifestExpiration","shaka.offline.OfflineManifestParser","shaka.offline.OfflineScheme","shaka.offline.OfflineScheme.plugin","shaka.offline.Storage.prototype","storeOp","getParser","drmError","parseManifest","shaka.offline.Storage.getAllStreamsFromManifest_","shaka.util.Error.Code.CANNOT_STORE_LIVE_OFFLINE","initForStorage","allTracks","chosenTracks","trackSize","textIds","imageIds","filterByRestrictions","maxHwResolution","shaka.util.StreamUtils.filterByRestrictions","shaka.util.Error.Code.STORAGE_LIMIT_REACHED","shaka.util.Error.Code.DOWNLOAD_SIZE_CALLBACK_ERROR","validateManifest_","texts","shaka.offline.Storage.validateManifest_","makeManifestDB_","pendingContent","fromManifest","shaka.offline.StoredContentUtils.fromManifest","setCallbacks","onProgress","onInitData","needsInitData","currentSystemId","shaka.offline.Storage.defaultSystemIds_get","shaka.offline.StreamBandwidthEstimator","shaka.offline.StreamBandwidthEstimator.DEFAULT_TEXT_BITRATE_","createStreams_","streamSet","streamDBs","addManifests","downloadSegments_","pendingManifestUpdates","pendingDataSize","download","usingBgFetch","dataSize","updateDRM","addSegments","waitToFinish","setManifestDrmFields_","shaka.util.Error.Code.NO_INIT_DATA_FOR_OFFLINE","shaka.offline.Storage.assignSegmentsToManifest","abortableStoreOp","startAbortableOperation_","contentUri","nullableUri","removeEmeSessions_","hasRemaining","cells","forEachEmeSessionCell","getAll","list_","forEachCell","getAllManifests","deleteAll","alreadyInitialized","shaka.offline.Storage.defaultSystemIds_","$t","polyfill","newItem","shaka.polyfill.polyfills_length","shaka.polyfill.polyfills_","shaka.polyfill.polyfills_splice","shaka.polyfill.polyfills_push","shaka.polyfill","shaka.polyfill.register","installAll","signal_","shaka.polyfill.AbortController.AbortSignal","install","du","shaka.polyfill.AbortController","AbortSignal","cu","reason_","fu","shaka.polyfill.Aria.addARIAMixinAttribute_","addARIAMixinAttribute_","gu","snakeCaseName","iu","EncryptionSchemePolyfills.install","lu","Document","requestFullscreen","mozRequestFullScreen","msRequestFullscreen","webkitRequestFullscreen","exitFullscreen","mozCancelFullScreen","msExitFullscreen","webkitCancelFullScreen","mozFullScreenElement","msFullscreenElement","webkitCurrentFullScreenElement","webkitFullscreenElement","mozFullScreenEnabled","msFullscreenEnabled","webkitFullscreenEnabled","shaka.polyfill.Fullscreen.proxyEvent_","mu","newEvent","createEvent","initEvent","ou","canUseNativeMCap","shaka.polyfill.MediaCapabilities.originalMcap","shaka.polyfill.MediaCapabilities.decodingInfo_","decodingInfo_","videoConfig","audioConfig","mediaCapkeySystemConfig","capability","mediaKeySystemConfig","powerEfficient","smooth","configuration","displayType","DOMException","$jscomp.globalObjectdefineProperties","shaka.polyfill.AbortController.install","shaka.polyfill.Aria","shaka.polyfill.Aria.install","shaka.polyfill.EncryptionScheme","shaka.polyfill.EncryptionScheme.install","shaka.polyfill.Fullscreen","shaka.polyfill.Fullscreen.install","shaka.polyfill.MediaCapabilities","shaka.polyfill.MediaCapabilities.install","patchCastIsTypeSupported_","originalIsTypeSupported","MediaSource.isTypeSupported","shaka.polyfill.MediaSource.patchCastIsTypeSupported_","shaka.polyfill.MediaSource.stubAbort_","patchRemovalRange_","originalRemove","SourceBuffer","SourceBuffer.prototype.remove","shaka.polyfill.MediaSource.patchRemovalRange_","rejectCodec_","shaka.polyfill.MediaSource.rejectCodec_","patchVp09_","codecsIndex","vp09Index","codecName","shaka.polyfill.MediaSource.patchVp09_","stubAbort_","uu","MediaSource.prototype.addSourceBuffer","sourceBuffer.abort","zu","orientation","installBasedOnWindowMethods_","setValues","angle","shaka.polyfill.Orientation.FakeOrientation","shaka.polyfill.Orientation.installBasedOnWindowMethods_","Ju","supportedConfigurations","shaka.polyfill.PatchedMediaKeysApple.MediaKeySystemAccess","Lu","oldMediaKeys","setMedia","onWebkitNeedKey_","Nu","event2","Ku","cfg","newCfg","ranAnyTests","success","WebKitMediaKeys","checkConfig_","configuration_","unsupportedKeySystemError","NOT_SUPPORTED_ERR","nativeMediaKeys_","Mu","shaka.polyfill.PatchedMediaKeysApple.onWebkitNeedKey_","webkitSetMediaKeys","nativeMediaKeys","nativeMediaKeySession_","updatePromise_","generateRequestPromise_","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap","updateKeyStatus_","status_","Tu","HTMLVideoElement","shaka.polyfill.PatchedMediaKeysNop.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysNop.setMediaKeys","shaka.polyfill.PatchedMediaKeysNop.MediaKeys","shaka.polyfill.PatchedMediaKeysNop.MediaKeySystemAccess","Uu","Vu","Zu","webkitGenerateKeyRequest","shaka.polyfill.PatchedMediaKeysWebkit.prefix_","generateKeyRequest","shaka.polyfill.PatchedMediaKeysWebkit.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysWebkit.setMediaKeys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeys","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySystemAccess","prefixApi_","ev","av","bv","dv","internalKeySystem_","allowPersistentState","tmpVideo","unsupportedError","keySystem_","newSessions_","sessionMap_","prefix","CustomEvent","findSession_","onWebkitKeyMessage_","generatePromise_","onWebkitKeyAdded_","onWebkitKeyError_","gv","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap","kv","generate_","offlineSessionId","mangledInitData","generateKeyRequestName","shaka.polyfill.PatchedMediaKeysWebkit.prefixApi_","exception2","licenseString","addKeyName","shaka.polyfill.MediaSource","shaka.polyfill.MediaSource.install","shaka.polyfill.Orientation","shaka.polyfill.Orientation.install","lock","lockOrientation","mozLockOrientation","msLockOrientation","unlock","unlockOrientation","mozUnlockOrientation","msUnlockOrientation","shaka.polyfill.PatchedMediaKeysApple","uninstall","shaka.polyfill.PatchedMediaKeysApple.enableUninstall","shaka.polyfill.PatchedMediaKeysApple.originalHTMLMediaElementPrototypeMediaKeys","shaka.polyfill.PatchedMediaKeysApple.originalHTMLMediaElementPrototypeSetMediaKeys","shaka.polyfill.PatchedMediaKeysApple.originalWindowMediaKeys","shaka.polyfill.PatchedMediaKeysApple.originalWindowMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysApple.originalNavigatorRequestMediaKeySystemAccess","enableUninstall","shaka.polyfill.PatchedMediaKeysApple.setMediaKeys","shaka.polyfill.PatchedMediaKeysApple.MediaKeys","shaka.polyfill.PatchedMediaKeysApple.requestMediaKeySystemAccess","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession","WebKitMediaKeyError","MEDIA_KEYERR_OUTPUT","MEDIA_KEYERR_HARDWARECHANGE","shaka.polyfill.PatchedMediaKeysApple.MediaKeySession.prototype","shaka.polyfill.PatchedMediaKeysApple.MediaKeyStatusMap.prototype","shaka.media.DrmEngine.DUMMY_KEY_IDvalue","fakeKeyId","shaka.polyfill.PatchedMediaKeysNop","shaka.polyfill.PatchedMediaKeysNop.install","shaka.polyfill.PatchedMediaKeysWebkit","shaka.polyfill.PatchedMediaKeysWebkit.install","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession","MediaKeyError","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeySession.prototype","nextUpdatePromise","cancelKeyRequestName","shaka.polyfill.PatchedMediaKeysWebkit.MediaKeyStatusMap.prototype","nv","requestPictureInPicture","exitPictureInPicture","webkitSupportsPresentationMode","pictureInPictureEnabled","pictureInPictureElement","shaka.polyfill.PiPWebkit.requestPictureInPicture_","shaka.polyfill.PiPWebkit.getDisablePictureInPicture_","shaka.polyfill.PiPWebkit.setDisablePictureInPicture_","shaka.polyfill.PiPWebkit.exitPictureInPicture_","shaka.polyfill.PiPWebkit.proxyEvent_","shaka.polyfill.PiPWebkit.PIP_MODE_","webkitPresentationMode","requestPictureInPicture_","ov","webkitSetPresentationMode","exitPictureInPicture_","pipElement","shaka.polyfill.PiPWebkit.INLINE_MODE_","getDisablePictureInPicture_","pv","hasAttribute","setDisablePictureInPicture_","qv","uv","shaka.polyfill.RandomUUID.randomUUID_","randomUUID_","vv","uuid","xv","webkitTemporaryStorage","queryUsageAndQuota","shaka.polyfill.StorageEstimate.storageEstimate_","storageEstimate_","yv","Av","shaka.polyfill.Symbol.getSymbolDescription_","getSymbolDescription_","Bv","Dv","originalPlay","HTMLMediaElement.prototype.play","Fv","shaka.polyfill.VideoPlaybackQuality.webkit_","webkit_","Gv","webkitDroppedFrameCount","webkitDecodedFrameCount","totalFrameDelay","Iv","TextTrackCue","replacement","constructorLength","shaka.polyfill.VTTCue.from3ArgsTextTrackCue_","shaka.polyfill.VTTCue.from6ArgsTextTrackCue_","from3ArgsTextTrackCue_","Jv","from6ArgsTextTrackCue_","Kv","shaka.polyfill.PiPWebkit","shaka.polyfill.PiPWebkit.install","shaka.polyfill.RandomUUID","shaka.polyfill.RandomUUID.install","shaka.polyfill.StorageEstimate","shaka.polyfill.StorageEstimate.install","shaka.polyfill.Symbol","shaka.polyfill.Symbol.install","shaka.polyfill.VideoPlayPromise","shaka.polyfill.VideoPlayPromise.install","shaka.polyfill.VideoPlaybackQuality","shaka.polyfill.VideoPlaybackQuality.install","shaka.polyfill.VTTCue","shaka.polyfill.VTTCue.install","shaka.text.LrcTextParser","prevCue","shaka.text.LrcTextParser.lyricLine_exec","shaka.text.LrcTextParser.timeFormat_exec","shaka.text.LrcTextParser.timeFormat_","Vv","cueNode","timeContext","rateInfo","metadataElements","styles","regionElements","cueRegions","whitespaceTrim","parentCueElement","isContent","COMMENT_NODE","span","shaka.text.TtmlTextParser.smpteNsList_","shaka.text.TtmlTextParser.getElementsFromCollection_","parentIsContent","localWhitespaceTrim","isLeafNode","isTextNode","nestedCue","shaka.text.TtmlTextParser.parseCue_","hasTextContent","hasTimeAttributes","shaka.text.TtmlTextParser.parseTime_","ELEMENT_NODE","shaka.text.TtmlTextParser.resolveTime_","regionElementForStyle","addStyle_","shouldInheritRegionStyles","shaka.text.TtmlTextParser.getStyleAttribute_","shaka.text.Cue.direction.HORIZONTAL_RIGHT_TO_LEFT","shaka.text.TtmlTextParser.textAlignToPositionAlign_","shaka.text.TtmlTextParser.textAlignToLineAlign_","wrapOption","shaka.text.TtmlTextParser.unitValues_","shaka.text.TtmlTextParser.percentValue_","backgroundImageType","backgroundImageEncoding","backgroundImageData","textOutline","textDecorationRegion","shaka.text.TtmlTextParser.getStyleAttributeFromRegion_","shaka.text.TtmlTextParser.addTextDecoration_","textDecorationElement","shaka.text.TtmlTextParser.getStyleAttributeFromElement_","shaka.text.TtmlTextParser.addStyle_","addTextDecoration_","fw","decoration","shaka.text.Cue.textDecoration.LINE_THROUGH","shaka.text.Cue.textDecoration.OVERLINE","getStyleAttribute_","aw","getStyleAttributeFromRegion_","Uv","shaka.util.XmlUtils.getAttributeNSList","shaka.text.TtmlTextParser.styleNs_","shaka.text.TtmlTextParser.getInheritedStyleAttribute_","getStyleAttributeFromElement_","gw","elementAttribute","getInheritedStyleAttribute_","hw","inheritedStyles","styleValue","styleAttributeValue","shaka.text.TtmlTextParser.styleEbuttsNs_","getElementsFromCollection_","Xv","collection","prefixName","nsName","items","attributeValue","resolveTime_","Zv","parentTime","parseTime_","Yv","shaka.text.TtmlTextParser.parseTimeAttribute_","parseTimeAttribute_","iw","shaka.text.TtmlTextParser.timeColonFormatFrames_test","shaka.text.TtmlTextParser.timeColonFormatFrames_exec","subFrameRate","shaka.text.TtmlTextParser.timeColonFormat_test","shaka.text.TtmlTextParser.parseTimeFromRegex_","shaka.text.TtmlTextParser.timeColonFormat_","shaka.text.TtmlTextParser.timeColonFormatMilliseconds_test","shaka.text.TtmlTextParser.timeColonFormatMilliseconds_","shaka.text.TtmlTextParser.timeFramesFormat_test","shaka.text.TtmlTextParser.timeFramesFormat_exec","shaka.text.TtmlTextParser.timeTickFormat_test","shaka.text.TtmlTextParser.timeTickFormat_exec","tickRate","shaka.text.TtmlTextParser.timeHMSFormat_test","shaka.text.TtmlTextParser.timeHMSFormat_","shaka.util.Error.Code.INVALID_TEXT_CUE","parseTimeFromRegex_","lw","Rv","frameRateMultiplier","multiplierResults","shaka.text.TtmlTextParser","tt","shaka.util.Error.Code.INVALID_XML","shaka.text.TtmlTextParser.parameterNs_","spaceStyle","extent","shaka.text.TtmlTextParser.RateInfo_","getChildren","shaka.util.XmlUtils.getChildren","percentage","globalResults","shaka.text.TtmlTextParser.percentValues_exec","shaka.text.TtmlTextParser.pixelValues_exec","globalWidth","globalHeight","shaka.text.CueRegion.units.PX","origin","cueRegion","cellResolutionInfo","shaka.text.TtmlTextParser.pixelValues_","shaka.text.TtmlTextParser.timeColonFormatFrames_","shaka.text.TtmlTextParser.timeFramesFormat_","shaka.text.TtmlTextParser.timeTickFormat_","center","shaka.text.Cue.lineAlign.CENTER","shaka.text.Cue.positionAlign.CENTER","tw","parseCueStyles","vw","rootCue","shaka.text.VttTextParser.addDefaultTextColor_","names","newPayload","tagEnd","tagStart","shaka.text.VttTextParser.timeFormat_","endTag","hasVoiceEndTag","voiceTag","newName","childNode","shaka.text.VttTextParser.generateCueFromElement_","getOrDefault_","zw","generateCueFromElement_","yw","styleTag","voice","shaka.text.VttTextParser.getOrDefault_","refCue","lineBreakCue","shaka.text.VttTextParser.parseTime_","isFirst","textCue","parseCueSetting","ww","regions","getRegionById_","regionsWithId","shaka.text.VttTextParser.getRegionById_","sw","htmlUnescape_","uw","htmlUnescapes","reEscapedHtml","reHasEscapedHtml","entity","shaka.text.Mp4TtmlParser","sawSTPP","shaka.util.Error.Code.INVALID_MP4_TTML","shaka.text.VttTextParser","shaka.util.Error.Code.INVALID_TEXT_HEADER","cueTimeMatch","mpegTimeMatch","mpegTime","rolloverSeconds","shaka.text.VttTextParser.TS_ROLLOVER_","shaka.text.VttTextParser.MPEG_TIMESCALE_","shaka.text.CueRegion.units.LINES","shaka.text.CueRegion.scrollMode.UP","styleBlocks","lastBlockIndex","styleBlock","styleSelector","selector","propertyLines","validStyle","lineParts","shaka.text.Cue.fontStyle.OBLIQUE","expect","shaka.text.VttTextParser.htmlUnescape_","shaka.text.VttTextParser.parseCueStyles","shaka.text.VttTextParser.parseCueSetting","timescale_","parseVTTC_","Cw","assembleCue_","shaka.text.Mp4VttParser.assembleCue_","Fw","regexExpresion","srt2webvtt","Hw","Nw","ccsColor","shaka.text.SsaTextParser.parseSsaColor_","cssBackgroundColor","alignment","parseSsaColor_","Ow","colorString","abgr","Mw","shaka.text.SsaTextParser.timeFormat_exec","shaka.text.Mp4VttParser","sawWVTT","shaka.util.Error.Code.INVALID_MP4_VTT","rawPayload","baseTime","presentations","sawTFDT","sawTRUN","defaultDuration","presentation","totalSize","shaka.text.Mp4VttParser.parseVTTC_","shaka.text.SbvTextParser","shaka.text.SbvTextParser.parseTime_","shaka.text.SrtTextParser","newData","shaka.text.SrtTextParser.srt2webvtt","shaka.text.SsaTextParser","shaka.text.SsaTextParser.ssaContent_exec","styleColumns","shaka.text.SsaTextParser.lineParts_exec","shaka.text.SsaTextParser.valuesFormat_","eventColumns","styleName","shaka.text.SsaTextParser.parseTime_","styleData","shaka.text.SsaTextParser.addStyle_","shaka.text.SsaTextParser.ssaContent_","shaka.text.SsaTextParser.lineParts_","shaka.text.SsaTextParser.timeFormat_","EmeEncryptionSchemePolyfill","Sw","EmeEncryptionSchemePolyfill.originalRMKSA_","EmeEncryptionSchemePolyfill.probeRMKSA_","probeRMKSA_","assert","EmeEncryptionSchemePolyfill.originalRMKSA_call","hasEncryptionScheme","EmeEncryptionSchemePolyfill.polyfillRMKSA_","EmeEncryptionSchemePolyfill.polyfillRMKSA_call","polyfillRMKSA_","supportedScheme","filteredSupportedConfigurations","filteredVideoCapabilities","filteredAudioCapabilities","clonedConfiguration","guessSupportedScheme","EmeEncryptionSchemePolyfill.filterCapabilities_","EmeEncryptionSchemePolyfillMediaKeySystemAccess","filterCapabilities_","Xw","capabilities","McEncryptionSchemePolyfill","ax","McEncryptionSchemePolyfill.originalDecodingInfo_","McEncryptionSchemePolyfill.probeDecodingInfo_","probeDecodingInfo_","requestedConfiguration","McEncryptionSchemePolyfill.originalDecodingInfo_call","McEncryptionSchemePolyfill.polyfillDecodingInfo_","McEncryptionSchemePolyfill.getMediaKeySystemAccess_","McEncryptionSchemePolyfill.polyfillDecodingInfo_call","polyfillDecodingInfo_","audioScheme","videoScheme","notSupportedResult","encryptionScheme","getMediaKeySystemAccess_","mediaCapKeySystemConfig","mksa","mksa_","firstAudioCapability","firstCapability","EncryptionSchemePolyfills","ju","EmeEncryptionSchemePolyfill.install","McEncryptionSchemePolyfill.install","Yw","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","o","chunkId","miniCssF","Function","script","needAttach","scripts","charset","nc","onScriptComplete","prev","doneFns","toStringTag","installedChunks","installedChunkData","errorType","realSrc","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","chunkLoadingGlobal","_arrayLikeToArray","len","_slicedToArray","_i","_s","_e","_x","_r","_arr","_n","_d","minLen","setPlaylist","setSelectedUrl","activeIndex","setActiveIndex","showVideo","setShowVideo","gridRef","playerRef","handleKeyDown","shakaPlayer","shaka","fetchPlaylist","playlistData","parsedPlaylist","parseM3U","urls","currentUrl","currentName","currentImage","extractImageUrl","process","handleItemClick","playUrl","prevIndex","handleArrowKeys","activeItem","querySelector","scrollIntoView","behavior","block","inline","className","autoPlay","controls","tabIndex","alt","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","getElementById","App","reportWebVitals"],"sourceRoot":""}